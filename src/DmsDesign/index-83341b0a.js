var Ci = Object.defineProperty;
var Si = (_n, nr, Cn) => nr in _n ? Ci(_n, nr, { enumerable: !0, configurable: !0, writable: !0, value: Cn }) : _n[nr] = Cn;
var Ra = (_n, nr, Cn) => (Si(_n, typeof nr != "symbol" ? nr + "" : nr, Cn), Cn);
import { computed, openBlock, createElementBlock, createElementVNode, ref, nextTick, toRaw, defineComponent, defineAsyncComponent, toRefs, inject, reactive, resolveComponent, Fragment, createVNode as createVNode$1, unref, toDisplayString, withCtx, normalizeClass, createTextVNode, createBlock, createCommentVNode, isRef, resolveDirective, withDirectives, renderList, useCssVars, onMounted, watch, renderSlot, normalizeStyle as normalizeStyle$1, vShow, mergeProps, withModifiers, onUnmounted, provide, shallowRef, resolveDynamicComponent, toHandlers, watchEffect, Teleport, getCurrentInstance, readonly, getCurrentScope, onScopeDispose, useSlots, vModelText, pushScopeId, popScopeId, withAsyncContext, Suspense } from "vue";
import { createRouter, createWebHashHistory, useRoute, useRouter } from "vue-router";
import { defineStore, createPinia } from "pinia";
import { ElMessageBox, ElMessage, ElLoading, ClickOutside } from "element-plus";
import { cloneDeep, debounce as debounce$1, omit, throttle as throttle$2, merge as merge$3, isObject as isObject$8 } from "lodash";
var ThemeEnum = /* @__PURE__ */ ((_n) => (_n.DARK = "dark", _n.LIGHT = "light", _n))(ThemeEnum || {}), LangEnum = /* @__PURE__ */ ((_n) => (_n.ZH = "ZH", _n.EN = "EN", _n))(LangEnum || {}), PreviewScaleEnum = /* @__PURE__ */ ((_n) => (_n.FIT = "fit", _n.SCROLL_Y = "scrollY", _n.SCROLL_X = "scrollX", _n.HIDE_Y = "hideY", _n.HIDE_X = "hideX", _n.FULL = "full", _n.AUTO = "auto", _n))(PreviewScaleEnum || {});
const bgFitOptions = [
  // 背景图片填充方式
  { value: "100% 100%", label: "拉伸填充" },
  { value: "contain", label: "自适应" },
  { value: "cover", label: "覆盖" }
], objectFitOptions = [
  // 背景图片填充方式
  { value: "fill", label: "拉伸填充" },
  { value: "contain", label: "自适应" },
  { value: "cover", label: "覆盖" },
  { value: "none", label: "原始尺寸" },
  { value: "scale-down", label: "按比例缩小" }
];
var ResultEnum = /* @__PURE__ */ ((_n) => (_n[_n.DATA_SUCCESS = 0] = "DATA_SUCCESS", _n[_n.SUCCESS = 200] = "SUCCESS", _n[_n.SERVER_ERROR = 500] = "SERVER_ERROR", _n[_n.SERVER_FORBIDDEN = 403] = "SERVER_FORBIDDEN", _n[_n.NOT_FOUND = 404] = "NOT_FOUND", _n[_n.TIMEOUT = 6e5] = "TIMEOUT", _n))(ResultEnum || {}), RequestDataTypeEnum = /* @__PURE__ */ ((_n) => (_n[_n.STATIC = 0] = "STATIC", _n[_n.AJAX = 1] = "AJAX", _n[_n.Pond = 2] = "Pond", _n))(RequestDataTypeEnum || {}), RequestContentTypeEnum = /* @__PURE__ */ ((_n) => (_n[_n.DEFAULT = 0] = "DEFAULT", _n[_n.SQL = 1] = "SQL", _n))(RequestContentTypeEnum || {}), RequestHttpEnum = /* @__PURE__ */ ((_n) => (_n.GET = "get", _n.POST = "post", _n.PATCH = "patch", _n.PUT = "put", _n.DELETE = "delete", _n))(RequestHttpEnum || {}), ValueTypeEnum = /* @__PURE__ */ ((_n) => (_n.COUSTOM = "custom", _n.NUMBER = "number", _n.BOOLEAN = "boolean", _n.OBJECT = "object", _n.GLOBAL = "global", _n.FORM = "form", _n.LINK = "link", _n.QUERY = "query", _n.FILE = "file", _n.CURRENT = "CURRENT", _n))(ValueTypeEnum || {});
const SelectValueTypeObj = {
  custom: "文本类型",
  number: "数字类型",
  boolean: "布尔类型",
  global: "全局变量",
  form: "表单字段",
  link: "联动组件",
  query: "地址参数",
  CURRENT: "当前组件",
  object: "自定义"
}, GlobalField = [
  {
    // 全局变量字段
    label: "token",
    desc: "当前大屏登录用户token",
    value: "token"
  },
  {
    label: "角色",
    desc: "当前大屏登录用户角色",
    value: "roles"
  },
  {
    label: "部门",
    desc: "当前大屏登录用户部门",
    value: "groups"
  },
  {
    label: "用户编号",
    desc: "当前大屏登录用户编号",
    value: "userId"
  },
  {
    label: "项目编号",
    desc: "当前大屏所属项目编号",
    value: "projectId"
  }
], fileUpload = {
  custom: "自定义",
  global: "全局变量",
  link: "联动组件",
  file: "文件"
};
var RequestHttpIntervalEnum = /* @__PURE__ */ ((_n) => (_n.SECOND = "second", _n.MINUTE = "minute", _n.HOUR = "hour", _n.DAY = "day", _n))(RequestHttpIntervalEnum || {});
const SelectHttpTimeNameObj = {
  second: "秒",
  minute: "分",
  hour: "时",
  day: "天"
};
var RequestBodyEnum = /* @__PURE__ */ ((_n) => (_n.NONE = "none", _n.FORM_DATA = "form-data", _n.X_WWW_FORM_URLENCODED = "x-www-form-urlencoded", _n.JSON = "json", _n.XML = "xml", _n))(RequestBodyEnum || {});
const RequestBodyEnumList = [
  "none",
  "form-data",
  "x-www-form-urlencoded",
  "json"
  /* JSON */
  // RequestBodyEnum.XML
];
var RequestParamsTypeEnum = /* @__PURE__ */ ((_n) => (_n.PARAMS = "Params", _n.BODY = "Body", _n.HEADER = "Header", _n))(RequestParamsTypeEnum || {}), ContentTypeEnum = /* @__PURE__ */ ((_n) => (_n.JSON = "application/json;charset=UTF-8", _n.TEXT = "text/plain;charset=UTF-8", _n.XML = "application/xml;charset=UTF-8", _n.FORM_URLENCODED = "application/x-www-form-urlencoded;charset=UTF-8", _n.FORM_DATA = "multipart/form-data;charset=UTF-8", _n))(ContentTypeEnum || {});
LangEnum.ZH;
const groupTitle = "分组", theme$1 = {
  // 默认是否开启深色主题
  darkTheme: !1,
  //默认主题色
  appTheme: "#376AF5",
  appThemeDetail: null
}, chartInitConfig = {
  x: 0,
  y: 0,
  w: 500,
  h: 300,
  // 不建议动 offset
  offsetX: 0,
  offsetY: 0
}, asideCollapsedWidth = 60, previewScaleType = PreviewScaleEnum.FIT;
RequestHttpIntervalEnum.SECOND;
const editHistoryMax = 100, SCALE_KEY = "scale-value";
function bind$2(_n, nr) {
  return function() {
    return _n.apply(nr, arguments);
  };
}
const { toString: toString$2 } = Object.prototype, { getPrototypeOf } = Object, { iterator: iterator$1, toStringTag } = Symbol, kindOf = ((_n) => (nr) => {
  const Cn = toString$2.call(nr);
  return _n[Cn] || (_n[Cn] = Cn.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = (_n) => (_n = _n.toLowerCase(), (nr) => kindOf(nr) === _n), typeOfTest = (_n) => (nr) => typeof nr === _n, { isArray: isArray$5 } = Array, isUndefined = typeOfTest("undefined");
function isBuffer$2(_n) {
  return _n !== null && !isUndefined(_n) && _n.constructor !== null && !isUndefined(_n.constructor) && isFunction$2(_n.constructor.isBuffer) && _n.constructor.isBuffer(_n);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(_n) {
  let nr;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? nr = ArrayBuffer.isView(_n) : nr = _n && _n.buffer && isArrayBuffer(_n.buffer), nr;
}
const isString$2 = typeOfTest("string"), isFunction$2 = typeOfTest("function"), isNumber$1 = typeOfTest("number"), isObject$7 = (_n) => _n !== null && typeof _n == "object", isBoolean = (_n) => _n === !0 || _n === !1, isPlainObject$2 = (_n) => {
  if (kindOf(_n) !== "object")
    return !1;
  const nr = getPrototypeOf(_n);
  return (nr === null || nr === Object.prototype || Object.getPrototypeOf(nr) === null) && !(toStringTag in _n) && !(iterator$1 in _n);
}, isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = (_n) => isObject$7(_n) && isFunction$2(_n.pipe), isFormData = (_n) => {
  let nr;
  return _n && (typeof FormData == "function" && _n instanceof FormData || isFunction$2(_n.append) && ((nr = kindOf(_n)) === "formdata" || // detect form-data instance
  nr === "object" && isFunction$2(_n.toString) && _n.toString() === "[object FormData]"));
}, isURLSearchParams = kindOfTest("URLSearchParams"), [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest), trim$2 = (_n) => _n.trim ? _n.trim() : _n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(_n, nr, { allOwnKeys: Cn = !1 } = {}) {
  if (_n === null || typeof _n > "u")
    return;
  let Bn, In;
  if (typeof _n != "object" && (_n = [_n]), isArray$5(_n))
    for (Bn = 0, In = _n.length; Bn < In; Bn++)
      nr.call(null, _n[Bn], Bn, _n);
  else {
    const Dn = Cn ? Object.getOwnPropertyNames(_n) : Object.keys(_n), Ln = Dn.length;
    let $n;
    for (Bn = 0; Bn < Ln; Bn++)
      $n = Dn[Bn], nr.call(null, _n[$n], $n, _n);
  }
}
function findKey(_n, nr) {
  nr = nr.toLowerCase();
  const Cn = Object.keys(_n);
  let Bn = Cn.length, In;
  for (; Bn-- > 0; )
    if (In = Cn[Bn], nr === In.toLowerCase())
      return In;
  return null;
}
const _global$1 = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), isContextDefined = (_n) => !isUndefined(_n) && _n !== _global$1;
function merge$2() {
  const { caseless: _n } = isContextDefined(this) && this || {}, nr = {}, Cn = (Bn, In) => {
    const Dn = _n && findKey(nr, In) || In;
    isPlainObject$2(nr[Dn]) && isPlainObject$2(Bn) ? nr[Dn] = merge$2(nr[Dn], Bn) : isPlainObject$2(Bn) ? nr[Dn] = merge$2({}, Bn) : isArray$5(Bn) ? nr[Dn] = Bn.slice() : nr[Dn] = Bn;
  };
  for (let Bn = 0, In = arguments.length; Bn < In; Bn++)
    arguments[Bn] && forEach(arguments[Bn], Cn);
  return nr;
}
const extend$1 = (_n, nr, Cn, { allOwnKeys: Bn } = {}) => (forEach(nr, (In, Dn) => {
  Cn && isFunction$2(In) ? _n[Dn] = bind$2(In, Cn) : _n[Dn] = In;
}, { allOwnKeys: Bn }), _n), stripBOM = (_n) => (_n.charCodeAt(0) === 65279 && (_n = _n.slice(1)), _n), inherits$1 = (_n, nr, Cn, Bn) => {
  _n.prototype = Object.create(nr.prototype, Bn), _n.prototype.constructor = _n, Object.defineProperty(_n, "super", {
    value: nr.prototype
  }), Cn && Object.assign(_n.prototype, Cn);
}, toFlatObject = (_n, nr, Cn, Bn) => {
  let In, Dn, Ln;
  const $n = {};
  if (nr = nr || {}, _n == null)
    return nr;
  do {
    for (In = Object.getOwnPropertyNames(_n), Dn = In.length; Dn-- > 0; )
      Ln = In[Dn], (!Bn || Bn(Ln, _n, nr)) && !$n[Ln] && (nr[Ln] = _n[Ln], $n[Ln] = !0);
    _n = Cn !== !1 && getPrototypeOf(_n);
  } while (_n && (!Cn || Cn(_n, nr)) && _n !== Object.prototype);
  return nr;
}, endsWith = (_n, nr, Cn) => {
  _n = String(_n), (Cn === void 0 || Cn > _n.length) && (Cn = _n.length), Cn -= nr.length;
  const Bn = _n.indexOf(nr, Cn);
  return Bn !== -1 && Bn === Cn;
}, toArray = (_n) => {
  if (!_n)
    return null;
  if (isArray$5(_n))
    return _n;
  let nr = _n.length;
  if (!isNumber$1(nr))
    return null;
  const Cn = new Array(nr);
  for (; nr-- > 0; )
    Cn[nr] = _n[nr];
  return Cn;
}, isTypedArray$3 = ((_n) => (nr) => _n && nr instanceof _n)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (_n, nr) => {
  const Bn = (_n && _n[iterator$1]).call(_n);
  let In;
  for (; (In = Bn.next()) && !In.done; ) {
    const Dn = In.value;
    nr.call(_n, Dn[0], Dn[1]);
  }
}, matchAll = (_n, nr) => {
  let Cn;
  const Bn = [];
  for (; (Cn = _n.exec(nr)) !== null; )
    Bn.push(Cn);
  return Bn;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase$1 = (_n) => _n.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(Cn, Bn, In) {
    return Bn.toUpperCase() + In;
  }
), hasOwnProperty$9 = (({ hasOwnProperty: _n }) => (nr, Cn) => _n.call(nr, Cn))(Object.prototype), isRegExp$1 = kindOfTest("RegExp"), reduceDescriptors = (_n, nr) => {
  const Cn = Object.getOwnPropertyDescriptors(_n), Bn = {};
  forEach(Cn, (In, Dn) => {
    let Ln;
    (Ln = nr(In, Dn, _n)) !== !1 && (Bn[Dn] = Ln || In);
  }), Object.defineProperties(_n, Bn);
}, freezeMethods = (_n) => {
  reduceDescriptors(_n, (nr, Cn) => {
    if (isFunction$2(_n) && ["arguments", "caller", "callee"].indexOf(Cn) !== -1)
      return !1;
    const Bn = _n[Cn];
    if (isFunction$2(Bn)) {
      if (nr.enumerable = !1, "writable" in nr) {
        nr.writable = !1;
        return;
      }
      nr.set || (nr.set = () => {
        throw Error("Can not rewrite read-only method '" + Cn + "'");
      });
    }
  });
}, toObjectSet = (_n, nr) => {
  const Cn = {}, Bn = (In) => {
    In.forEach((Dn) => {
      Cn[Dn] = !0;
    });
  };
  return isArray$5(_n) ? Bn(_n) : Bn(String(_n).split(nr)), Cn;
}, noop$2 = () => {
}, toFiniteNumber = (_n, nr) => _n != null && Number.isFinite(_n = +_n) ? _n : nr;
function isSpecCompliantForm(_n) {
  return !!(_n && isFunction$2(_n.append) && _n[toStringTag] === "FormData" && _n[iterator$1]);
}
const toJSONObject = (_n) => {
  const nr = new Array(10), Cn = (Bn, In) => {
    if (isObject$7(Bn)) {
      if (nr.indexOf(Bn) >= 0)
        return;
      if (!("toJSON" in Bn)) {
        nr[In] = Bn;
        const Dn = isArray$5(Bn) ? [] : {};
        return forEach(Bn, (Ln, $n) => {
          const Nn = Cn(Ln, In + 1);
          !isUndefined(Nn) && (Dn[$n] = Nn);
        }), nr[In] = void 0, Dn;
      }
    }
    return Bn;
  };
  return Cn(_n, 0);
}, isAsyncFn = kindOfTest("AsyncFunction"), isThenable = (_n) => _n && (isObject$7(_n) || isFunction$2(_n)) && isFunction$2(_n.then) && isFunction$2(_n.catch), _setImmediate = ((_n, nr) => _n ? setImmediate : nr ? ((Cn, Bn) => (_global$1.addEventListener("message", ({ source: In, data: Dn }) => {
  In === _global$1 && Dn === Cn && Bn.length && Bn.shift()();
}, !1), (In) => {
  Bn.push(In), _global$1.postMessage(Cn, "*");
}))(`axios@${Math.random()}`, []) : (Cn) => setTimeout(Cn))(
  typeof setImmediate == "function",
  isFunction$2(_global$1.postMessage)
), asap = typeof queueMicrotask < "u" ? queueMicrotask.bind(_global$1) : typeof process < "u" && process.nextTick || _setImmediate, isIterable = (_n) => _n != null && isFunction$2(_n[iterator$1]), utils$1 = {
  isArray: isArray$5,
  isArrayBuffer,
  isBuffer: isBuffer$2,
  isFormData,
  isArrayBufferView,
  isString: isString$2,
  isNumber: isNumber$1,
  isBoolean,
  isObject: isObject$7,
  isPlainObject: isPlainObject$2,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp: isRegExp$1,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray$3,
  isFileList,
  forEach,
  merge: merge$2,
  extend: extend$1,
  trim: trim$2,
  stripBOM,
  inherits: inherits$1,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$9,
  hasOwnProp: hasOwnProperty$9,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase: toCamelCase$1,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global$1,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError(_n, nr, Cn, Bn, In) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = _n, this.name = "AxiosError", nr && (this.code = nr), Cn && (this.config = Cn), Bn && (this.request = Bn), In && (this.response = In, this.status = In.status ? In.status : null);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((_n) => {
  descriptors[_n] = { value: _n };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError.from = (_n, nr, Cn, Bn, In, Dn) => {
  const Ln = Object.create(prototype$1);
  return utils$1.toFlatObject(_n, Ln, function(Nn) {
    return Nn !== Error.prototype;
  }, ($n) => $n !== "isAxiosError"), AxiosError.call(Ln, _n.message, nr, Cn, Bn, In), Ln.cause = _n, Ln.name = _n.name, Dn && Object.assign(Ln, Dn), Ln;
};
const httpAdapter = null;
function isVisitable(_n) {
  return utils$1.isPlainObject(_n) || utils$1.isArray(_n);
}
function removeBrackets(_n) {
  return utils$1.endsWith(_n, "[]") ? _n.slice(0, -2) : _n;
}
function renderKey(_n, nr, Cn) {
  return _n ? _n.concat(nr).map(function(In, Dn) {
    return In = removeBrackets(In), !Cn && Dn ? "[" + In + "]" : In;
  }).join(Cn ? "." : "") : nr;
}
function isFlatArray(_n) {
  return utils$1.isArray(_n) && !_n.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function(nr) {
  return /^is[A-Z]/.test(nr);
});
function toFormData(_n, nr, Cn) {
  if (!utils$1.isObject(_n))
    throw new TypeError("target must be an object");
  nr = nr || new FormData(), Cn = utils$1.toFlatObject(Cn, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(Gn, Yn) {
    return !utils$1.isUndefined(Yn[Gn]);
  });
  const Bn = Cn.metaTokens, In = Cn.visitor || Fn, Dn = Cn.dots, Ln = Cn.indexes, Nn = (Cn.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(nr);
  if (!utils$1.isFunction(In))
    throw new TypeError("visitor must be a function");
  function Rn(zn) {
    if (zn === null)
      return "";
    if (utils$1.isDate(zn))
      return zn.toISOString();
    if (!Nn && utils$1.isBlob(zn))
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    return utils$1.isArrayBuffer(zn) || utils$1.isTypedArray(zn) ? Nn && typeof Blob == "function" ? new Blob([zn]) : Buffer.from(zn) : zn;
  }
  function Fn(zn, Gn, Yn) {
    let Wn = zn;
    if (zn && !Yn && typeof zn == "object") {
      if (utils$1.endsWith(Gn, "{}"))
        Gn = Bn ? Gn : Gn.slice(0, -2), zn = JSON.stringify(zn);
      else if (utils$1.isArray(zn) && isFlatArray(zn) || (utils$1.isFileList(zn) || utils$1.endsWith(Gn, "[]")) && (Wn = utils$1.toArray(zn)))
        return Gn = removeBrackets(Gn), Wn.forEach(function(ea, ta) {
          !(utils$1.isUndefined(ea) || ea === null) && nr.append(
            // eslint-disable-next-line no-nested-ternary
            Ln === !0 ? renderKey([Gn], ta, Dn) : Ln === null ? Gn : Gn + "[]",
            Rn(ea)
          );
        }), !1;
    }
    return isVisitable(zn) ? !0 : (nr.append(renderKey(Yn, Gn, Dn), Rn(zn)), !1);
  }
  const Pn = [], Un = Object.assign(predicates, {
    defaultVisitor: Fn,
    convertValue: Rn,
    isVisitable
  });
  function Hn(zn, Gn) {
    if (!utils$1.isUndefined(zn)) {
      if (Pn.indexOf(zn) !== -1)
        throw Error("Circular reference detected in " + Gn.join("."));
      Pn.push(zn), utils$1.forEach(zn, function(Wn, Xn) {
        (!(utils$1.isUndefined(Wn) || Wn === null) && In.call(
          nr,
          Wn,
          utils$1.isString(Xn) ? Xn.trim() : Xn,
          Gn,
          Un
        )) === !0 && Hn(Wn, Gn ? Gn.concat(Xn) : [Xn]);
      }), Pn.pop();
    }
  }
  if (!utils$1.isObject(_n))
    throw new TypeError("data must be an object");
  return Hn(_n), nr;
}
function encode$2(_n) {
  const nr = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(_n).replace(/[!'()~]|%20|%00/g, function(Bn) {
    return nr[Bn];
  });
}
function AxiosURLSearchParams(_n, nr) {
  this._pairs = [], _n && toFormData(_n, this, nr);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function(nr, Cn) {
  this._pairs.push([nr, Cn]);
};
prototype.toString = function(nr) {
  const Cn = nr ? function(Bn) {
    return nr.call(this, Bn, encode$2);
  } : encode$2;
  return this._pairs.map(function(In) {
    return Cn(In[0]) + "=" + Cn(In[1]);
  }, "").join("&");
};
function encode$1(_n) {
  return encodeURIComponent(_n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(_n, nr, Cn) {
  if (!nr)
    return _n;
  const Bn = Cn && Cn.encode || encode$1;
  utils$1.isFunction(Cn) && (Cn = {
    serialize: Cn
  });
  const In = Cn && Cn.serialize;
  let Dn;
  if (In ? Dn = In(nr, Cn) : Dn = utils$1.isURLSearchParams(nr) ? nr.toString() : new AxiosURLSearchParams(nr, Cn).toString(Bn), Dn) {
    const Ln = _n.indexOf("#");
    Ln !== -1 && (_n = _n.slice(0, Ln)), _n += (_n.indexOf("?") === -1 ? "?" : "&") + Dn;
  }
  return _n;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(nr, Cn, Bn) {
    return this.handlers.push({
      fulfilled: nr,
      rejected: Cn,
      synchronous: Bn ? Bn.synchronous : !1,
      runWhen: Bn ? Bn.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(nr) {
    this.handlers[nr] && (this.handlers[nr] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(nr) {
    utils$1.forEach(this.handlers, function(Bn) {
      Bn !== null && nr(Bn);
    });
  }
}
const InterceptorManager$1 = InterceptorManager, transitionalDefaults = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams, FormData$1 = typeof FormData < "u" ? FormData : null, Blob$1 = typeof Blob < "u" ? Blob : null, platform$2 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, hasBrowserEnv = typeof window < "u" && typeof document < "u", _navigator = typeof navigator == "object" && navigator || void 0, hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0), hasStandardBrowserWebWorkerEnv = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), origin = hasBrowserEnv && window.location.href || "http://localhost", utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" })), platform$1 = {
  ...utils,
  ...platform$2
};
function toURLEncodedForm(_n, nr) {
  return toFormData(_n, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(Cn, Bn, In, Dn) {
      return platform$1.isNode && utils$1.isBuffer(Cn) ? (this.append(Bn, Cn.toString("base64")), !1) : Dn.defaultVisitor.apply(this, arguments);
    }
  }, nr));
}
function parsePropPath(_n) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, _n).map((nr) => nr[0] === "[]" ? "" : nr[1] || nr[0]);
}
function arrayToObject(_n) {
  const nr = {}, Cn = Object.keys(_n);
  let Bn;
  const In = Cn.length;
  let Dn;
  for (Bn = 0; Bn < In; Bn++)
    Dn = Cn[Bn], nr[Dn] = _n[Dn];
  return nr;
}
function formDataToJSON(_n) {
  function nr(Cn, Bn, In, Dn) {
    let Ln = Cn[Dn++];
    if (Ln === "__proto__")
      return !0;
    const $n = Number.isFinite(+Ln), Nn = Dn >= Cn.length;
    return Ln = !Ln && utils$1.isArray(In) ? In.length : Ln, Nn ? (utils$1.hasOwnProp(In, Ln) ? In[Ln] = [In[Ln], Bn] : In[Ln] = Bn, !$n) : ((!In[Ln] || !utils$1.isObject(In[Ln])) && (In[Ln] = []), nr(Cn, Bn, In[Ln], Dn) && utils$1.isArray(In[Ln]) && (In[Ln] = arrayToObject(In[Ln])), !$n);
  }
  if (utils$1.isFormData(_n) && utils$1.isFunction(_n.entries)) {
    const Cn = {};
    return utils$1.forEachEntry(_n, (Bn, In) => {
      nr(parsePropPath(Bn), In, Cn, 0);
    }), Cn;
  }
  return null;
}
function stringifySafely(_n, nr, Cn) {
  if (utils$1.isString(_n))
    try {
      return (nr || JSON.parse)(_n), utils$1.trim(_n);
    } catch (Bn) {
      if (Bn.name !== "SyntaxError")
        throw Bn;
    }
  return (Cn || JSON.stringify)(_n);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(nr, Cn) {
    const Bn = Cn.getContentType() || "", In = Bn.indexOf("application/json") > -1, Dn = utils$1.isObject(nr);
    if (Dn && utils$1.isHTMLForm(nr) && (nr = new FormData(nr)), utils$1.isFormData(nr))
      return In ? JSON.stringify(formDataToJSON(nr)) : nr;
    if (utils$1.isArrayBuffer(nr) || utils$1.isBuffer(nr) || utils$1.isStream(nr) || utils$1.isFile(nr) || utils$1.isBlob(nr) || utils$1.isReadableStream(nr))
      return nr;
    if (utils$1.isArrayBufferView(nr))
      return nr.buffer;
    if (utils$1.isURLSearchParams(nr))
      return Cn.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), nr.toString();
    let $n;
    if (Dn) {
      if (Bn.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(nr, this.formSerializer).toString();
      if (($n = utils$1.isFileList(nr)) || Bn.indexOf("multipart/form-data") > -1) {
        const Nn = this.env && this.env.FormData;
        return toFormData(
          $n ? { "files[]": nr } : nr,
          Nn && new Nn(),
          this.formSerializer
        );
      }
    }
    return Dn || In ? (Cn.setContentType("application/json", !1), stringifySafely(nr)) : nr;
  }],
  transformResponse: [function(nr) {
    const Cn = this.transitional || defaults$1.transitional, Bn = Cn && Cn.forcedJSONParsing, In = this.responseType === "json";
    if (utils$1.isResponse(nr) || utils$1.isReadableStream(nr))
      return nr;
    if (nr && utils$1.isString(nr) && (Bn && !this.responseType || In)) {
      const Ln = !(Cn && Cn.silentJSONParsing) && In;
      try {
        return JSON.parse(nr);
      } catch ($n) {
        if (Ln)
          throw $n.name === "SyntaxError" ? AxiosError.from($n, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : $n;
      }
    }
    return nr;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform$1.classes.FormData,
    Blob: platform$1.classes.Blob
  },
  validateStatus: function(nr) {
    return nr >= 200 && nr < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (_n) => {
  defaults$1.headers[_n] = {};
});
const defaults$2 = defaults$1, ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders = (_n) => {
  const nr = {};
  let Cn, Bn, In;
  return _n && _n.split(`
`).forEach(function(Ln) {
    In = Ln.indexOf(":"), Cn = Ln.substring(0, In).trim().toLowerCase(), Bn = Ln.substring(In + 1).trim(), !(!Cn || nr[Cn] && ignoreDuplicateOf[Cn]) && (Cn === "set-cookie" ? nr[Cn] ? nr[Cn].push(Bn) : nr[Cn] = [Bn] : nr[Cn] = nr[Cn] ? nr[Cn] + ", " + Bn : Bn);
  }), nr;
}, $internals = Symbol("internals");
function normalizeHeader(_n) {
  return _n && String(_n).trim().toLowerCase();
}
function normalizeValue(_n) {
  return _n === !1 || _n == null ? _n : utils$1.isArray(_n) ? _n.map(normalizeValue) : String(_n);
}
function parseTokens(_n) {
  const nr = /* @__PURE__ */ Object.create(null), Cn = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let Bn;
  for (; Bn = Cn.exec(_n); )
    nr[Bn[1]] = Bn[2];
  return nr;
}
const isValidHeaderName = (_n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(_n.trim());
function matchHeaderValue(_n, nr, Cn, Bn, In) {
  if (utils$1.isFunction(Bn))
    return Bn.call(this, nr, Cn);
  if (In && (nr = Cn), !!utils$1.isString(nr)) {
    if (utils$1.isString(Bn))
      return nr.indexOf(Bn) !== -1;
    if (utils$1.isRegExp(Bn))
      return Bn.test(nr);
  }
}
function formatHeader(_n) {
  return _n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (nr, Cn, Bn) => Cn.toUpperCase() + Bn);
}
function buildAccessors(_n, nr) {
  const Cn = utils$1.toCamelCase(" " + nr);
  ["get", "set", "has"].forEach((Bn) => {
    Object.defineProperty(_n, Bn + Cn, {
      value: function(In, Dn, Ln) {
        return this[Bn].call(this, nr, In, Dn, Ln);
      },
      configurable: !0
    });
  });
}
class AxiosHeaders {
  constructor(nr) {
    nr && this.set(nr);
  }
  set(nr, Cn, Bn) {
    const In = this;
    function Dn($n, Nn, Rn) {
      const Fn = normalizeHeader(Nn);
      if (!Fn)
        throw new Error("header name must be a non-empty string");
      const Pn = utils$1.findKey(In, Fn);
      (!Pn || In[Pn] === void 0 || Rn === !0 || Rn === void 0 && In[Pn] !== !1) && (In[Pn || Nn] = normalizeValue($n));
    }
    const Ln = ($n, Nn) => utils$1.forEach($n, (Rn, Fn) => Dn(Rn, Fn, Nn));
    if (utils$1.isPlainObject(nr) || nr instanceof this.constructor)
      Ln(nr, Cn);
    else if (utils$1.isString(nr) && (nr = nr.trim()) && !isValidHeaderName(nr))
      Ln(parseHeaders(nr), Cn);
    else if (utils$1.isObject(nr) && utils$1.isIterable(nr)) {
      let $n = {}, Nn, Rn;
      for (const Fn of nr) {
        if (!utils$1.isArray(Fn))
          throw TypeError("Object iterator must return a key-value pair");
        $n[Rn = Fn[0]] = (Nn = $n[Rn]) ? utils$1.isArray(Nn) ? [...Nn, Fn[1]] : [Nn, Fn[1]] : Fn[1];
      }
      Ln($n, Cn);
    } else
      nr != null && Dn(Cn, nr, Bn);
    return this;
  }
  get(nr, Cn) {
    if (nr = normalizeHeader(nr), nr) {
      const Bn = utils$1.findKey(this, nr);
      if (Bn) {
        const In = this[Bn];
        if (!Cn)
          return In;
        if (Cn === !0)
          return parseTokens(In);
        if (utils$1.isFunction(Cn))
          return Cn.call(this, In, Bn);
        if (utils$1.isRegExp(Cn))
          return Cn.exec(In);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(nr, Cn) {
    if (nr = normalizeHeader(nr), nr) {
      const Bn = utils$1.findKey(this, nr);
      return !!(Bn && this[Bn] !== void 0 && (!Cn || matchHeaderValue(this, this[Bn], Bn, Cn)));
    }
    return !1;
  }
  delete(nr, Cn) {
    const Bn = this;
    let In = !1;
    function Dn(Ln) {
      if (Ln = normalizeHeader(Ln), Ln) {
        const $n = utils$1.findKey(Bn, Ln);
        $n && (!Cn || matchHeaderValue(Bn, Bn[$n], $n, Cn)) && (delete Bn[$n], In = !0);
      }
    }
    return utils$1.isArray(nr) ? nr.forEach(Dn) : Dn(nr), In;
  }
  clear(nr) {
    const Cn = Object.keys(this);
    let Bn = Cn.length, In = !1;
    for (; Bn--; ) {
      const Dn = Cn[Bn];
      (!nr || matchHeaderValue(this, this[Dn], Dn, nr, !0)) && (delete this[Dn], In = !0);
    }
    return In;
  }
  normalize(nr) {
    const Cn = this, Bn = {};
    return utils$1.forEach(this, (In, Dn) => {
      const Ln = utils$1.findKey(Bn, Dn);
      if (Ln) {
        Cn[Ln] = normalizeValue(In), delete Cn[Dn];
        return;
      }
      const $n = nr ? formatHeader(Dn) : String(Dn).trim();
      $n !== Dn && delete Cn[Dn], Cn[$n] = normalizeValue(In), Bn[$n] = !0;
    }), this;
  }
  concat(...nr) {
    return this.constructor.concat(this, ...nr);
  }
  toJSON(nr) {
    const Cn = /* @__PURE__ */ Object.create(null);
    return utils$1.forEach(this, (Bn, In) => {
      Bn != null && Bn !== !1 && (Cn[In] = nr && utils$1.isArray(Bn) ? Bn.join(", ") : Bn);
    }), Cn;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([nr, Cn]) => nr + ": " + Cn).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(nr) {
    return nr instanceof this ? nr : new this(nr);
  }
  static concat(nr, ...Cn) {
    const Bn = new this(nr);
    return Cn.forEach((In) => Bn.set(In)), Bn;
  }
  static accessor(nr) {
    const Bn = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, In = this.prototype;
    function Dn(Ln) {
      const $n = normalizeHeader(Ln);
      Bn[$n] || (buildAccessors(In, Ln), Bn[$n] = !0);
    }
    return utils$1.isArray(nr) ? nr.forEach(Dn) : Dn(nr), this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value: _n }, nr) => {
  let Cn = nr[0].toUpperCase() + nr.slice(1);
  return {
    get: () => _n,
    set(Bn) {
      this[Cn] = Bn;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(_n, nr) {
  const Cn = this || defaults$2, Bn = nr || Cn, In = AxiosHeaders$1.from(Bn.headers);
  let Dn = Bn.data;
  return utils$1.forEach(_n, function($n) {
    Dn = $n.call(Cn, Dn, In.normalize(), nr ? nr.status : void 0);
  }), In.normalize(), Dn;
}
function isCancel(_n) {
  return !!(_n && _n.__CANCEL__);
}
function CanceledError(_n, nr, Cn) {
  AxiosError.call(this, _n ?? "canceled", AxiosError.ERR_CANCELED, nr, Cn), this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: !0
});
function settle(_n, nr, Cn) {
  const Bn = Cn.config.validateStatus;
  !Cn.status || !Bn || Bn(Cn.status) ? _n(Cn) : nr(new AxiosError(
    "Request failed with status code " + Cn.status,
    [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(Cn.status / 100) - 4],
    Cn.config,
    Cn.request,
    Cn
  ));
}
function parseProtocol(_n) {
  const nr = /^([-+\w]{1,25})(:?\/\/|:)/.exec(_n);
  return nr && nr[1] || "";
}
function speedometer(_n, nr) {
  _n = _n || 10;
  const Cn = new Array(_n), Bn = new Array(_n);
  let In = 0, Dn = 0, Ln;
  return nr = nr !== void 0 ? nr : 1e3, function(Nn) {
    const Rn = Date.now(), Fn = Bn[Dn];
    Ln || (Ln = Rn), Cn[In] = Nn, Bn[In] = Rn;
    let Pn = Dn, Un = 0;
    for (; Pn !== In; )
      Un += Cn[Pn++], Pn = Pn % _n;
    if (In = (In + 1) % _n, In === Dn && (Dn = (Dn + 1) % _n), Rn - Ln < nr)
      return;
    const Hn = Fn && Rn - Fn;
    return Hn ? Math.round(Un * 1e3 / Hn) : void 0;
  };
}
function throttle$1(_n, nr) {
  let Cn = 0, Bn = 1e3 / nr, In, Dn;
  const Ln = (Rn, Fn = Date.now()) => {
    Cn = Fn, In = null, Dn && (clearTimeout(Dn), Dn = null), _n.apply(null, Rn);
  };
  return [(...Rn) => {
    const Fn = Date.now(), Pn = Fn - Cn;
    Pn >= Bn ? Ln(Rn, Fn) : (In = Rn, Dn || (Dn = setTimeout(() => {
      Dn = null, Ln(In);
    }, Bn - Pn)));
  }, () => In && Ln(In)];
}
const progressEventReducer = (_n, nr, Cn = 3) => {
  let Bn = 0;
  const In = speedometer(50, 250);
  return throttle$1((Dn) => {
    const Ln = Dn.loaded, $n = Dn.lengthComputable ? Dn.total : void 0, Nn = Ln - Bn, Rn = In(Nn), Fn = Ln <= $n;
    Bn = Ln;
    const Pn = {
      loaded: Ln,
      total: $n,
      progress: $n ? Ln / $n : void 0,
      bytes: Nn,
      rate: Rn || void 0,
      estimated: Rn && $n && Fn ? ($n - Ln) / Rn : void 0,
      event: Dn,
      lengthComputable: $n != null,
      [nr ? "download" : "upload"]: !0
    };
    _n(Pn);
  }, Cn);
}, progressEventDecorator = (_n, nr) => {
  const Cn = _n != null;
  return [(Bn) => nr[0]({
    lengthComputable: Cn,
    total: _n,
    loaded: Bn
  }), nr[1]];
}, asyncDecorator = (_n) => (...nr) => utils$1.asap(() => _n(...nr)), isURLSameOrigin = platform$1.hasStandardBrowserEnv ? ((_n, nr) => (Cn) => (Cn = new URL(Cn, platform$1.origin), _n.protocol === Cn.protocol && _n.host === Cn.host && (nr || _n.port === Cn.port)))(
  new URL(platform$1.origin),
  platform$1.navigator && /(msie|trident)/i.test(platform$1.navigator.userAgent)
) : () => !0, cookies = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(_n, nr, Cn, Bn, In, Dn) {
      const Ln = [_n + "=" + encodeURIComponent(nr)];
      utils$1.isNumber(Cn) && Ln.push("expires=" + new Date(Cn).toGMTString()), utils$1.isString(Bn) && Ln.push("path=" + Bn), utils$1.isString(In) && Ln.push("domain=" + In), Dn === !0 && Ln.push("secure"), document.cookie = Ln.join("; ");
    },
    read(_n) {
      const nr = document.cookie.match(new RegExp("(^|;\\s*)(" + _n + ")=([^;]*)"));
      return nr ? decodeURIComponent(nr[3]) : null;
    },
    remove(_n) {
      this.write(_n, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(_n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(_n);
}
function combineURLs(_n, nr) {
  return nr ? _n.replace(/\/?\/$/, "") + "/" + nr.replace(/^\/+/, "") : _n;
}
function buildFullPath(_n, nr, Cn) {
  let Bn = !isAbsoluteURL(nr);
  return _n && (Bn || Cn == !1) ? combineURLs(_n, nr) : nr;
}
const headersToObject = (_n) => _n instanceof AxiosHeaders$1 ? { ..._n } : _n;
function mergeConfig(_n, nr) {
  nr = nr || {};
  const Cn = {};
  function Bn(Rn, Fn, Pn, Un) {
    return utils$1.isPlainObject(Rn) && utils$1.isPlainObject(Fn) ? utils$1.merge.call({ caseless: Un }, Rn, Fn) : utils$1.isPlainObject(Fn) ? utils$1.merge({}, Fn) : utils$1.isArray(Fn) ? Fn.slice() : Fn;
  }
  function In(Rn, Fn, Pn, Un) {
    if (utils$1.isUndefined(Fn)) {
      if (!utils$1.isUndefined(Rn))
        return Bn(void 0, Rn, Pn, Un);
    } else
      return Bn(Rn, Fn, Pn, Un);
  }
  function Dn(Rn, Fn) {
    if (!utils$1.isUndefined(Fn))
      return Bn(void 0, Fn);
  }
  function Ln(Rn, Fn) {
    if (utils$1.isUndefined(Fn)) {
      if (!utils$1.isUndefined(Rn))
        return Bn(void 0, Rn);
    } else
      return Bn(void 0, Fn);
  }
  function $n(Rn, Fn, Pn) {
    if (Pn in nr)
      return Bn(Rn, Fn);
    if (Pn in _n)
      return Bn(void 0, Rn);
  }
  const Nn = {
    url: Dn,
    method: Dn,
    data: Dn,
    baseURL: Ln,
    transformRequest: Ln,
    transformResponse: Ln,
    paramsSerializer: Ln,
    timeout: Ln,
    timeoutMessage: Ln,
    withCredentials: Ln,
    withXSRFToken: Ln,
    adapter: Ln,
    responseType: Ln,
    xsrfCookieName: Ln,
    xsrfHeaderName: Ln,
    onUploadProgress: Ln,
    onDownloadProgress: Ln,
    decompress: Ln,
    maxContentLength: Ln,
    maxBodyLength: Ln,
    beforeRedirect: Ln,
    transport: Ln,
    httpAgent: Ln,
    httpsAgent: Ln,
    cancelToken: Ln,
    socketPath: Ln,
    responseEncoding: Ln,
    validateStatus: $n,
    headers: (Rn, Fn, Pn) => In(headersToObject(Rn), headersToObject(Fn), Pn, !0)
  };
  return utils$1.forEach(Object.keys(Object.assign({}, _n, nr)), function(Fn) {
    const Pn = Nn[Fn] || In, Un = Pn(_n[Fn], nr[Fn], Fn);
    utils$1.isUndefined(Un) && Pn !== $n || (Cn[Fn] = Un);
  }), Cn;
}
const resolveConfig = (_n) => {
  const nr = mergeConfig({}, _n);
  let { data: Cn, withXSRFToken: Bn, xsrfHeaderName: In, xsrfCookieName: Dn, headers: Ln, auth: $n } = nr;
  nr.headers = Ln = AxiosHeaders$1.from(Ln), nr.url = buildURL(buildFullPath(nr.baseURL, nr.url, nr.allowAbsoluteUrls), _n.params, _n.paramsSerializer), $n && Ln.set(
    "Authorization",
    "Basic " + btoa(($n.username || "") + ":" + ($n.password ? unescape(encodeURIComponent($n.password)) : ""))
  );
  let Nn;
  if (utils$1.isFormData(Cn)) {
    if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv)
      Ln.setContentType(void 0);
    else if ((Nn = Ln.getContentType()) !== !1) {
      const [Rn, ...Fn] = Nn ? Nn.split(";").map((Pn) => Pn.trim()).filter(Boolean) : [];
      Ln.setContentType([Rn || "multipart/form-data", ...Fn].join("; "));
    }
  }
  if (platform$1.hasStandardBrowserEnv && (Bn && utils$1.isFunction(Bn) && (Bn = Bn(nr)), Bn || Bn !== !1 && isURLSameOrigin(nr.url))) {
    const Rn = In && Dn && cookies.read(Dn);
    Rn && Ln.set(In, Rn);
  }
  return nr;
}, isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported && function(_n) {
  return new Promise(function(Cn, Bn) {
    const In = resolveConfig(_n);
    let Dn = In.data;
    const Ln = AxiosHeaders$1.from(In.headers).normalize();
    let { responseType: $n, onUploadProgress: Nn, onDownloadProgress: Rn } = In, Fn, Pn, Un, Hn, zn;
    function Gn() {
      Hn && Hn(), zn && zn(), In.cancelToken && In.cancelToken.unsubscribe(Fn), In.signal && In.signal.removeEventListener("abort", Fn);
    }
    let Yn = new XMLHttpRequest();
    Yn.open(In.method.toUpperCase(), In.url, !0), Yn.timeout = In.timeout;
    function Wn() {
      if (!Yn)
        return;
      const ea = AxiosHeaders$1.from(
        "getAllResponseHeaders" in Yn && Yn.getAllResponseHeaders()
      ), na = {
        data: !$n || $n === "text" || $n === "json" ? Yn.responseText : Yn.response,
        status: Yn.status,
        statusText: Yn.statusText,
        headers: ea,
        config: _n,
        request: Yn
      };
      settle(function(aa) {
        Cn(aa), Gn();
      }, function(aa) {
        Bn(aa), Gn();
      }, na), Yn = null;
    }
    "onloadend" in Yn ? Yn.onloadend = Wn : Yn.onreadystatechange = function() {
      !Yn || Yn.readyState !== 4 || Yn.status === 0 && !(Yn.responseURL && Yn.responseURL.indexOf("file:") === 0) || setTimeout(Wn);
    }, Yn.onabort = function() {
      Yn && (Bn(new AxiosError("Request aborted", AxiosError.ECONNABORTED, _n, Yn)), Yn = null);
    }, Yn.onerror = function() {
      Bn(new AxiosError("Network Error", AxiosError.ERR_NETWORK, _n, Yn)), Yn = null;
    }, Yn.ontimeout = function() {
      let ta = In.timeout ? "timeout of " + In.timeout + "ms exceeded" : "timeout exceeded";
      const na = In.transitional || transitionalDefaults;
      In.timeoutErrorMessage && (ta = In.timeoutErrorMessage), Bn(new AxiosError(
        ta,
        na.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        _n,
        Yn
      )), Yn = null;
    }, Dn === void 0 && Ln.setContentType(null), "setRequestHeader" in Yn && utils$1.forEach(Ln.toJSON(), function(ta, na) {
      Yn.setRequestHeader(na, ta);
    }), utils$1.isUndefined(In.withCredentials) || (Yn.withCredentials = !!In.withCredentials), $n && $n !== "json" && (Yn.responseType = In.responseType), Rn && ([Un, zn] = progressEventReducer(Rn, !0), Yn.addEventListener("progress", Un)), Nn && Yn.upload && ([Pn, Hn] = progressEventReducer(Nn), Yn.upload.addEventListener("progress", Pn), Yn.upload.addEventListener("loadend", Hn)), (In.cancelToken || In.signal) && (Fn = (ea) => {
      Yn && (Bn(!ea || ea.type ? new CanceledError(null, _n, Yn) : ea), Yn.abort(), Yn = null);
    }, In.cancelToken && In.cancelToken.subscribe(Fn), In.signal && (In.signal.aborted ? Fn() : In.signal.addEventListener("abort", Fn)));
    const Xn = parseProtocol(In.url);
    if (Xn && platform$1.protocols.indexOf(Xn) === -1) {
      Bn(new AxiosError("Unsupported protocol " + Xn + ":", AxiosError.ERR_BAD_REQUEST, _n));
      return;
    }
    Yn.send(Dn || null);
  });
}, composeSignals = (_n, nr) => {
  const { length: Cn } = _n = _n ? _n.filter(Boolean) : [];
  if (nr || Cn) {
    let Bn = new AbortController(), In;
    const Dn = function(Rn) {
      if (!In) {
        In = !0, $n();
        const Fn = Rn instanceof Error ? Rn : this.reason;
        Bn.abort(Fn instanceof AxiosError ? Fn : new CanceledError(Fn instanceof Error ? Fn.message : Fn));
      }
    };
    let Ln = nr && setTimeout(() => {
      Ln = null, Dn(new AxiosError(`timeout ${nr} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, nr);
    const $n = () => {
      _n && (Ln && clearTimeout(Ln), Ln = null, _n.forEach((Rn) => {
        Rn.unsubscribe ? Rn.unsubscribe(Dn) : Rn.removeEventListener("abort", Dn);
      }), _n = null);
    };
    _n.forEach((Rn) => Rn.addEventListener("abort", Dn));
    const { signal: Nn } = Bn;
    return Nn.unsubscribe = () => utils$1.asap($n), Nn;
  }
}, composeSignals$1 = composeSignals, streamChunk = function* (_n, nr) {
  let Cn = _n.byteLength;
  if (!nr || Cn < nr) {
    yield _n;
    return;
  }
  let Bn = 0, In;
  for (; Bn < Cn; )
    In = Bn + nr, yield _n.slice(Bn, In), Bn = In;
}, readBytes = async function* (_n, nr) {
  for await (const Cn of readStream(_n))
    yield* streamChunk(Cn, nr);
}, readStream = async function* (_n) {
  if (_n[Symbol.asyncIterator]) {
    yield* _n;
    return;
  }
  const nr = _n.getReader();
  try {
    for (; ; ) {
      const { done: Cn, value: Bn } = await nr.read();
      if (Cn)
        break;
      yield Bn;
    }
  } finally {
    await nr.cancel();
  }
}, trackStream = (_n, nr, Cn, Bn) => {
  const In = readBytes(_n, nr);
  let Dn = 0, Ln, $n = (Nn) => {
    Ln || (Ln = !0, Bn && Bn(Nn));
  };
  return new ReadableStream({
    async pull(Nn) {
      try {
        const { done: Rn, value: Fn } = await In.next();
        if (Rn) {
          $n(), Nn.close();
          return;
        }
        let Pn = Fn.byteLength;
        if (Cn) {
          let Un = Dn += Pn;
          Cn(Un);
        }
        Nn.enqueue(new Uint8Array(Fn));
      } catch (Rn) {
        throw $n(Rn), Rn;
      }
    },
    cancel(Nn) {
      return $n(Nn), In.return();
    }
  }, {
    highWaterMark: 2
  });
}, isFetchSupported = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", isReadableStreamSupported = isFetchSupported && typeof ReadableStream == "function", encodeText = isFetchSupported && (typeof TextEncoder == "function" ? ((_n) => (nr) => _n.encode(nr))(new TextEncoder()) : async (_n) => new Uint8Array(await new Response(_n).arrayBuffer())), test = (_n, ...nr) => {
  try {
    return !!_n(...nr);
  } catch {
    return !1;
  }
}, supportsRequestStream = isReadableStreamSupported && test(() => {
  let _n = !1;
  const nr = new Request(platform$1.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return _n = !0, "half";
    }
  }).headers.has("Content-Type");
  return _n && !nr;
}), DEFAULT_CHUNK_SIZE = 64 * 1024, supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body)), resolvers = {
  stream: supportsResponseStream && ((_n) => _n.body)
};
isFetchSupported && ((_n) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((nr) => {
    !resolvers[nr] && (resolvers[nr] = utils$1.isFunction(_n[nr]) ? (Cn) => Cn[nr]() : (Cn, Bn) => {
      throw new AxiosError(`Response type '${nr}' is not supported`, AxiosError.ERR_NOT_SUPPORT, Bn);
    });
  });
})(new Response());
const getBodyLength = async (_n) => {
  if (_n == null)
    return 0;
  if (utils$1.isBlob(_n))
    return _n.size;
  if (utils$1.isSpecCompliantForm(_n))
    return (await new Request(platform$1.origin, {
      method: "POST",
      body: _n
    }).arrayBuffer()).byteLength;
  if (utils$1.isArrayBufferView(_n) || utils$1.isArrayBuffer(_n))
    return _n.byteLength;
  if (utils$1.isURLSearchParams(_n) && (_n = _n + ""), utils$1.isString(_n))
    return (await encodeText(_n)).byteLength;
}, resolveBodyLength = async (_n, nr) => {
  const Cn = utils$1.toFiniteNumber(_n.getContentLength());
  return Cn ?? getBodyLength(nr);
}, fetchAdapter = isFetchSupported && (async (_n) => {
  let {
    url: nr,
    method: Cn,
    data: Bn,
    signal: In,
    cancelToken: Dn,
    timeout: Ln,
    onDownloadProgress: $n,
    onUploadProgress: Nn,
    responseType: Rn,
    headers: Fn,
    withCredentials: Pn = "same-origin",
    fetchOptions: Un
  } = resolveConfig(_n);
  Rn = Rn ? (Rn + "").toLowerCase() : "text";
  let Hn = composeSignals$1([In, Dn && Dn.toAbortSignal()], Ln), zn;
  const Gn = Hn && Hn.unsubscribe && (() => {
    Hn.unsubscribe();
  });
  let Yn;
  try {
    if (Nn && supportsRequestStream && Cn !== "get" && Cn !== "head" && (Yn = await resolveBodyLength(Fn, Bn)) !== 0) {
      let na = new Request(nr, {
        method: "POST",
        body: Bn,
        duplex: "half"
      }), ra;
      if (utils$1.isFormData(Bn) && (ra = na.headers.get("content-type")) && Fn.setContentType(ra), na.body) {
        const [aa, ia] = progressEventDecorator(
          Yn,
          progressEventReducer(asyncDecorator(Nn))
        );
        Bn = trackStream(na.body, DEFAULT_CHUNK_SIZE, aa, ia);
      }
    }
    utils$1.isString(Pn) || (Pn = Pn ? "include" : "omit");
    const Wn = "credentials" in Request.prototype;
    zn = new Request(nr, {
      ...Un,
      signal: Hn,
      method: Cn.toUpperCase(),
      headers: Fn.normalize().toJSON(),
      body: Bn,
      duplex: "half",
      credentials: Wn ? Pn : void 0
    });
    let Xn = await fetch(zn);
    const ea = supportsResponseStream && (Rn === "stream" || Rn === "response");
    if (supportsResponseStream && ($n || ea && Gn)) {
      const na = {};
      ["status", "statusText", "headers"].forEach((Aa) => {
        na[Aa] = Xn[Aa];
      });
      const ra = utils$1.toFiniteNumber(Xn.headers.get("content-length")), [aa, ia] = $n && progressEventDecorator(
        ra,
        progressEventReducer(asyncDecorator($n), !0)
      ) || [];
      Xn = new Response(
        trackStream(Xn.body, DEFAULT_CHUNK_SIZE, aa, () => {
          ia && ia(), Gn && Gn();
        }),
        na
      );
    }
    Rn = Rn || "text";
    let ta = await resolvers[utils$1.findKey(resolvers, Rn) || "text"](Xn, _n);
    return !ea && Gn && Gn(), await new Promise((na, ra) => {
      settle(na, ra, {
        data: ta,
        headers: AxiosHeaders$1.from(Xn.headers),
        status: Xn.status,
        statusText: Xn.statusText,
        config: _n,
        request: zn
      });
    });
  } catch (Wn) {
    throw Gn && Gn(), Wn && Wn.name === "TypeError" && /Load failed|fetch/i.test(Wn.message) ? Object.assign(
      new AxiosError("Network Error", AxiosError.ERR_NETWORK, _n, zn),
      {
        cause: Wn.cause || Wn
      }
    ) : AxiosError.from(Wn, Wn && Wn.code, _n, zn);
  }
}), knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (_n, nr) => {
  if (_n) {
    try {
      Object.defineProperty(_n, "name", { value: nr });
    } catch {
    }
    Object.defineProperty(_n, "adapterName", { value: nr });
  }
});
const renderReason = (_n) => `- ${_n}`, isResolvedHandle = (_n) => utils$1.isFunction(_n) || _n === null || _n === !1, adapters = {
  getAdapter: (_n) => {
    _n = utils$1.isArray(_n) ? _n : [_n];
    const { length: nr } = _n;
    let Cn, Bn;
    const In = {};
    for (let Dn = 0; Dn < nr; Dn++) {
      Cn = _n[Dn];
      let Ln;
      if (Bn = Cn, !isResolvedHandle(Cn) && (Bn = knownAdapters[(Ln = String(Cn)).toLowerCase()], Bn === void 0))
        throw new AxiosError(`Unknown adapter '${Ln}'`);
      if (Bn)
        break;
      In[Ln || "#" + Dn] = Bn;
    }
    if (!Bn) {
      const Dn = Object.entries(In).map(
        ([$n, Nn]) => `adapter ${$n} ` + (Nn === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let Ln = nr ? Dn.length > 1 ? `since :
` + Dn.map(renderReason).join(`
`) : " " + renderReason(Dn[0]) : "as no adapter specified";
      throw new AxiosError(
        "There is no suitable adapter to dispatch the request " + Ln,
        "ERR_NOT_SUPPORT"
      );
    }
    return Bn;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(_n) {
  if (_n.cancelToken && _n.cancelToken.throwIfRequested(), _n.signal && _n.signal.aborted)
    throw new CanceledError(null, _n);
}
function dispatchRequest(_n) {
  return throwIfCancellationRequested(_n), _n.headers = AxiosHeaders$1.from(_n.headers), _n.data = transformData.call(
    _n,
    _n.transformRequest
  ), ["post", "put", "patch"].indexOf(_n.method) !== -1 && _n.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(_n.adapter || defaults$2.adapter)(_n).then(function(Bn) {
    return throwIfCancellationRequested(_n), Bn.data = transformData.call(
      _n,
      _n.transformResponse,
      Bn
    ), Bn.headers = AxiosHeaders$1.from(Bn.headers), Bn;
  }, function(Bn) {
    return isCancel(Bn) || (throwIfCancellationRequested(_n), Bn && Bn.response && (Bn.response.data = transformData.call(
      _n,
      _n.transformResponse,
      Bn.response
    ), Bn.response.headers = AxiosHeaders$1.from(Bn.response.headers))), Promise.reject(Bn);
  });
}
const VERSION$1 = "1.9.0", validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((_n, nr) => {
  validators$1[_n] = function(Bn) {
    return typeof Bn === _n || "a" + (nr < 1 ? "n " : " ") + _n;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function(nr, Cn, Bn) {
  function In(Dn, Ln) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + Dn + "'" + Ln + (Bn ? ". " + Bn : "");
  }
  return (Dn, Ln, $n) => {
    if (nr === !1)
      throw new AxiosError(
        In(Ln, " has been removed" + (Cn ? " in " + Cn : "")),
        AxiosError.ERR_DEPRECATED
      );
    return Cn && !deprecatedWarnings[Ln] && (deprecatedWarnings[Ln] = !0, console.warn(
      In(
        Ln,
        " has been deprecated since v" + Cn + " and will be removed in the near future"
      )
    )), nr ? nr(Dn, Ln, $n) : !0;
  };
};
validators$1.spelling = function(nr) {
  return (Cn, Bn) => (console.warn(`${Bn} is likely a misspelling of ${nr}`), !0);
};
function assertOptions(_n, nr, Cn) {
  if (typeof _n != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  const Bn = Object.keys(_n);
  let In = Bn.length;
  for (; In-- > 0; ) {
    const Dn = Bn[In], Ln = nr[Dn];
    if (Ln) {
      const $n = _n[Dn], Nn = $n === void 0 || Ln($n, Dn, _n);
      if (Nn !== !0)
        throw new AxiosError("option " + Dn + " must be " + Nn, AxiosError.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (Cn !== !0)
      throw new AxiosError("Unknown option " + Dn, AxiosError.ERR_BAD_OPTION);
  }
}
const validator = {
  assertOptions,
  validators: validators$1
}, validators = validator.validators;
class Axios {
  constructor(nr) {
    this.defaults = nr || {}, this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(nr, Cn) {
    try {
      return await this._request(nr, Cn);
    } catch (Bn) {
      if (Bn instanceof Error) {
        let In = {};
        Error.captureStackTrace ? Error.captureStackTrace(In) : In = new Error();
        const Dn = In.stack ? In.stack.replace(/^.+\n/, "") : "";
        try {
          Bn.stack ? Dn && !String(Bn.stack).endsWith(Dn.replace(/^.+\n.+\n/, "")) && (Bn.stack += `
` + Dn) : Bn.stack = Dn;
        } catch {
        }
      }
      throw Bn;
    }
  }
  _request(nr, Cn) {
    typeof nr == "string" ? (Cn = Cn || {}, Cn.url = nr) : Cn = nr || {}, Cn = mergeConfig(this.defaults, Cn);
    const { transitional: Bn, paramsSerializer: In, headers: Dn } = Cn;
    Bn !== void 0 && validator.assertOptions(Bn, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, !1), In != null && (utils$1.isFunction(In) ? Cn.paramsSerializer = {
      serialize: In
    } : validator.assertOptions(In, {
      encode: validators.function,
      serialize: validators.function
    }, !0)), Cn.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? Cn.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : Cn.allowAbsoluteUrls = !0), validator.assertOptions(Cn, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, !0), Cn.method = (Cn.method || this.defaults.method || "get").toLowerCase();
    let Ln = Dn && utils$1.merge(
      Dn.common,
      Dn[Cn.method]
    );
    Dn && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (zn) => {
        delete Dn[zn];
      }
    ), Cn.headers = AxiosHeaders$1.concat(Ln, Dn);
    const $n = [];
    let Nn = !0;
    this.interceptors.request.forEach(function(Gn) {
      typeof Gn.runWhen == "function" && Gn.runWhen(Cn) === !1 || (Nn = Nn && Gn.synchronous, $n.unshift(Gn.fulfilled, Gn.rejected));
    });
    const Rn = [];
    this.interceptors.response.forEach(function(Gn) {
      Rn.push(Gn.fulfilled, Gn.rejected);
    });
    let Fn, Pn = 0, Un;
    if (!Nn) {
      const zn = [dispatchRequest.bind(this), void 0];
      for (zn.unshift.apply(zn, $n), zn.push.apply(zn, Rn), Un = zn.length, Fn = Promise.resolve(Cn); Pn < Un; )
        Fn = Fn.then(zn[Pn++], zn[Pn++]);
      return Fn;
    }
    Un = $n.length;
    let Hn = Cn;
    for (Pn = 0; Pn < Un; ) {
      const zn = $n[Pn++], Gn = $n[Pn++];
      try {
        Hn = zn(Hn);
      } catch (Yn) {
        Gn.call(this, Yn);
        break;
      }
    }
    try {
      Fn = dispatchRequest.call(this, Hn);
    } catch (zn) {
      return Promise.reject(zn);
    }
    for (Pn = 0, Un = Rn.length; Pn < Un; )
      Fn = Fn.then(Rn[Pn++], Rn[Pn++]);
    return Fn;
  }
  getUri(nr) {
    nr = mergeConfig(this.defaults, nr);
    const Cn = buildFullPath(nr.baseURL, nr.url, nr.allowAbsoluteUrls);
    return buildURL(Cn, nr.params, nr.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function(nr) {
  Axios.prototype[nr] = function(Cn, Bn) {
    return this.request(mergeConfig(Bn || {}, {
      method: nr,
      url: Cn,
      data: (Bn || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function(nr) {
  function Cn(Bn) {
    return function(Dn, Ln, $n) {
      return this.request(mergeConfig($n || {}, {
        method: nr,
        headers: Bn ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: Dn,
        data: Ln
      }));
    };
  }
  Axios.prototype[nr] = Cn(), Axios.prototype[nr + "Form"] = Cn(!0);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(nr) {
    if (typeof nr != "function")
      throw new TypeError("executor must be a function.");
    let Cn;
    this.promise = new Promise(function(Dn) {
      Cn = Dn;
    });
    const Bn = this;
    this.promise.then((In) => {
      if (!Bn._listeners)
        return;
      let Dn = Bn._listeners.length;
      for (; Dn-- > 0; )
        Bn._listeners[Dn](In);
      Bn._listeners = null;
    }), this.promise.then = (In) => {
      let Dn;
      const Ln = new Promise(($n) => {
        Bn.subscribe($n), Dn = $n;
      }).then(In);
      return Ln.cancel = function() {
        Bn.unsubscribe(Dn);
      }, Ln;
    }, nr(function(Dn, Ln, $n) {
      Bn.reason || (Bn.reason = new CanceledError(Dn, Ln, $n), Cn(Bn.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(nr) {
    if (this.reason) {
      nr(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(nr) : this._listeners = [nr];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(nr) {
    if (!this._listeners)
      return;
    const Cn = this._listeners.indexOf(nr);
    Cn !== -1 && this._listeners.splice(Cn, 1);
  }
  toAbortSignal() {
    const nr = new AbortController(), Cn = (Bn) => {
      nr.abort(Bn);
    };
    return this.subscribe(Cn), nr.signal.unsubscribe = () => this.unsubscribe(Cn), nr.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let nr;
    return {
      token: new CancelToken(function(In) {
        nr = In;
      }),
      cancel: nr
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(_n) {
  return function(Cn) {
    return _n.apply(null, Cn);
  };
}
function isAxiosError(_n) {
  return utils$1.isObject(_n) && _n.isAxiosError === !0;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([_n, nr]) => {
  HttpStatusCode[nr] = _n;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(_n) {
  const nr = new Axios$1(_n), Cn = bind$2(Axios$1.prototype.request, nr);
  return utils$1.extend(Cn, Axios$1.prototype, nr, { allOwnKeys: !0 }), utils$1.extend(Cn, nr, null, { allOwnKeys: !0 }), Cn.create = function(In) {
    return createInstance(mergeConfig(_n, In));
  }, Cn;
}
const axios = createInstance(defaults$2);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function(nr) {
  return Promise.all(nr);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (_n) => formDataToJSON(utils$1.isHTMLForm(_n) ? new FormData(_n) : _n);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios, excludeParseEventKeyList = ["vnodeMounted", "vnodeBeforeMount", "click", "dblclick", "mousemove", "mouseenter", "mouseleave", "filter"], excludeParseEventValueList = [
  // 请求里的函数语句
  "javascript:"
], JSONStringify = (_n) => JSON.stringify(
  _n,
  (nr, Cn) => typeof Cn == "function" ? `${Cn}` : typeof Cn > "u" ? null : Cn,
  2
), JSONParse = (data) => JSON.parse(data, (k, v) => {
  if (excludeParseEventKeyList.includes(k) || typeof v == "string" && excludeParseEventValueList.some((nr) => v.indexOf(nr) > -1))
    return v;
  if (typeof v == "string" && v.indexOf && (v.indexOf("function") > -1 || v.indexOf("=>") > -1))
    try {
      return eval(`(function(){return ${v}})()`);
    } catch {
      return v;
    }
  else if (typeof v == "string" && v.indexOf && v.indexOf("return ") > -1) {
    const baseLeftIndex = v.indexOf("(");
    if (baseLeftIndex > -1 && baseLeftIndex === 7) {
      const newFn = `function ${v.substring(baseLeftIndex)}`;
      return eval(`(function(){return ${newFn}})()`);
    }
  }
  return v;
}), setLocalStorage = (_n, nr) => {
  try {
    window.localStorage.setItem(_n, JSONStringify(nr));
  } catch {
    return !1;
  }
}, getLocalStorage = (_n) => {
  const nr = window.localStorage.getItem(_n);
  try {
    return nr && JSONParse(nr);
  } catch {
    return nr;
  }
}, clearLocalStorage = (_n) => {
  window.localStorage.removeItem(_n);
}, setSessionStorage = (_n, nr) => {
  try {
    window.sessionStorage.setItem(_n, JSONStringify(nr));
  } catch {
    return !1;
  }
}, getSessionStorage = (_n) => {
  const nr = window.sessionStorage.getItem(_n);
  try {
    return nr && JSONParse(nr);
  } catch {
    return nr;
  }
};
function getCookie(_n) {
  if (document.cookie.length > 0) {
    let nr = document.cookie.indexOf(_n + "=");
    if (nr !== -1) {
      nr = nr + _n.length + 1;
      let Cn = document.cookie.indexOf(";", nr);
      return Cn === -1 && (Cn = document.cookie.length), unescape(document.cookie.substring(nr, Cn));
    }
  }
  return "";
}
function setCookie(_n, nr, Cn) {
  const Bn = /* @__PURE__ */ new Date();
  Cn ? Bn.setDate(Bn.getDate() + Cn) : Bn.setDate(Bn.getDate()), document.cookie = _n + "=" + decodeURIComponent(nr) + (Cn == null ? "" : ";expires=" + Bn.toUTCString());
}
const TokenKey = "token";
function getToken() {
  return getLocalStorage(TokenKey);
}
const axiosInstance = axios$1.create({
  baseURL: "/",
  timeout: 6e5,
  withCredentials: !0
});
axiosInstance.interceptors.request.use(
  (_n) => (_n.headers.Authorization || (_n.headers.Authorization = getToken()), _n),
  (_n) => {
    Promise.reject(_n);
  }
);
axiosInstance.interceptors.response.use(
  (_n) => {
    const { code: nr } = _n.data;
    return nr == null ? Promise.resolve(_n) : Promise.resolve(_n.data);
  },
  (_n) => Promise.reject(_n)
);
function getScreenList(_n) {
  return axiosInstance({
    url: "/dms/screen/list",
    method: "post",
    data: _n
  });
}
function getScreenInfo$1(_n) {
  return axiosInstance({
    url: `/dms/screen/info/${_n}`,
    method: "get"
  });
}
function uploadDesign(_n, nr) {
  const Cn = new FormData();
  return Cn.set("file", nr), axiosInstance({
    url: `/dms/screen/uploadDesign/id/${_n}`,
    method: "post",
    data: Cn,
    headers: {
      "Content-Type": "x-www-form-urlencoded"
    }
  });
}
function getWidgetAll() {
  return axiosInstance({
    url: "/dms/widget/all",
    method: "get"
  });
}
function screenValidate(_n) {
  return axiosInstance({
    url: "/dms/screen/validate",
    method: "post",
    data: _n
  });
}
const index_vue_vue_type_style_index_0_scoped_abaf7765_lang = "", _export_sfc = (_n, nr) => {
  const Cn = _n.__vccOpts || _n;
  for (const [Bn, In] of nr)
    Cn[Bn] = In;
  return Cn;
}, _hoisted_1$i = ["width", "height"], _hoisted_2$9 = ["xlink:href"], _sfc_main$n = {
  __name: "index",
  props: {
    prefix: {
      type: String,
      default: "icon"
    },
    iconClass: {
      type: String,
      required: !0
    },
    color: {
      type: String,
      default: "#333"
    },
    size: {
      type: String,
      default: "1em"
    }
  },
  setup(_n) {
    const nr = _n, Cn = computed(() => `#${nr.prefix}-${nr.iconClass}`);
    return (Bn, In) => (openBlock(), createElementBlock("svg", {
      "aria-hidden": "true",
      class: "svg-icon",
      width: nr.size,
      height: nr.size
    }, [
      createElementVNode("use", { "xlink:href": Cn.value }, null, 8, _hoisted_2$9)
    ], 8, _hoisted_1$i));
  }
}, __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-abaf7765"]]);
var HistoryStackItemEnum = /* @__PURE__ */ ((_n) => (_n.ID = "id", _n.TARGET_TYPE = "targetType", _n.ACTION_TYPE = "actionType", _n.HISTORY_DATA = "historyData", _n))(HistoryStackItemEnum || {}), HistoryTargetTypeEnum = /* @__PURE__ */ ((_n) => (_n.CANVAS = "canvas", _n.CHART = "chart", _n))(HistoryTargetTypeEnum || {}), HistoryActionTypeEnum = /* @__PURE__ */ ((_n) => (_n.ADD = "add", _n.DELETE = "delete", _n.UPDATE = "update", _n.MOVE = "move", _n.COPY = "copy", _n.CUT = "cut", _n.PASTE = "paste", _n.TOP = "top", _n.BOTTOM = "bottom", _n.UP = "up", _n.DOWN = "down", _n.GROUP = "group", _n.UN_GROUP = "unGroup", _n.REMOVE_GROUP = "removeGroup", _n.LOCK = "lock", _n.UNLOCK = "unLock", _n.HIDE = "hide", _n.SHOW = "show", _n))(HistoryActionTypeEnum || {});
const useHistoryStore = defineStore("historyStore", {
  state: () => ({
    // 后退栈
    backStack: [],
    // 前进栈
    forwardStack: []
  }),
  getters: {
    getBackStack() {
      return this.backStack;
    },
    getForwardStack() {
      return this.forwardStack;
    }
  },
  actions: {
    /**
    * * 新增记录并插入栈
    * @param item 图表实例
    * @param actionType 动作类型
    * @param targetType 对象类型（默认图表）
    */
    createStackItem(_n, nr, Cn = HistoryTargetTypeEnum.CHART) {
      this.pushBackStackItem(
        Object.freeze({
          [HistoryStackItemEnum.ID]: (/* @__PURE__ */ new Date()).getTime().toString(),
          [HistoryStackItemEnum.HISTORY_DATA]: _n,
          [HistoryStackItemEnum.ACTION_TYPE]: nr,
          [HistoryStackItemEnum.TARGET_TYPE]: Cn
        })
      );
    },
    // * 画布初始化
    canvasInit(_n) {
      this.createStackItem([_n], HistoryActionTypeEnum.ADD, HistoryTargetTypeEnum.CANVAS);
    },
    // * 推入后退栈
    pushBackStackItem(_n, nr = !1) {
      _n instanceof Array ? this.backStack = [...this.backStack, ..._n] : this.backStack.push(_n), this.backStack.splice(0, this.backStack.length - editHistoryMax), !nr && this.clearForwardStack();
    },
    // * 推入前进栈
    pushForwardStack(_n) {
      _n instanceof Array ? this.forwardStack = [...this.forwardStack, ..._n] : this.forwardStack.push(_n);
    },
    // * 移出后退栈
    popBackStackItem() {
      if (this.backStack.length > 0)
        return this.backStack.pop();
    },
    // * 移出前进栈
    popForwardStack() {
      if (this.forwardStack.length > 0)
        return this.forwardStack.pop();
    },
    // * 清空前进栈
    clearForwardStack() {
      this.forwardStack = [];
    },
    // * 清空后退栈(保留初始化)
    clearBackStack() {
      const _n = this.getBackStack[0];
      this.backStack = [_n];
    },
    // * 撤回
    backAction() {
      try {
        if (this.getBackStack.length > 1) {
          const _n = this.popBackStackItem();
          return _n ? (this.pushForwardStack(_n), _n) : void 0;
        }
      } catch (_n) {
        console.log("历史记录撤回", _n);
      }
    },
    // * 前进
    forwardAction() {
      try {
        if (this.getForwardStack.length) {
          const _n = this.popForwardStack();
          return _n ? (this.pushBackStackItem(_n, !0), _n) : void 0;
        }
      } catch (_n) {
        console.log("历史记录前进", _n);
      }
    },
    // * 新增组件记录
    createAddHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.ADD, HistoryTargetTypeEnum.CHART);
    },
    // * 更新属性记录（大小、图表属性）
    createUpdateHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.UPDATE, HistoryTargetTypeEnum.CHART);
    },
    // * 删除组件记录
    createDeleteHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.DELETE, HistoryTargetTypeEnum.CHART);
    },
    // * 移动组件记录
    createMoveHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.MOVE, HistoryTargetTypeEnum.CHART);
    },
    // * 改变层级组件记录
    createLayerHistory(_n, nr) {
      this.createStackItem(_n, nr, HistoryTargetTypeEnum.CHART);
    },
    // * 剪切组件记录
    createPasteHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.CUT, HistoryTargetTypeEnum.CHART);
    },
    // * 创建分组
    createGroupHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.GROUP, HistoryTargetTypeEnum.CHART);
    },
    // * 解除分组
    createUnGroupHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.UN_GROUP, HistoryTargetTypeEnum.CHART);
    },
    // * 移出分组
    createRemoveGroupHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.REMOVE_GROUP, HistoryTargetTypeEnum.CHART);
    },
    // * 锁定记录
    createLockHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.LOCK, HistoryTargetTypeEnum.CHART);
    },
    // * 解锁记录
    createUnLockHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.UNLOCK, HistoryTargetTypeEnum.CHART);
    },
    // * 隐藏记录
    createHideHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.HIDE, HistoryTargetTypeEnum.CHART);
    },
    // * 展示记录
    createShowHistory(_n) {
      this.createStackItem(_n, HistoryActionTypeEnum.SHOW, HistoryTargetTypeEnum.CHART);
    }
  }
});
var StorageEnum = /* @__PURE__ */ ((_n) => (_n.DMS_SYSTEM_SETTING_STORE = "DMS_SYSTEM_SETTING", _n.DMS_ACCESS_TOKEN_STORE = "DMS_ACCESS_TOKEN", _n.DMS_LOGIN_INFO_STORE = "DMS_LOGIN_INFO", _n.DMS_LANG_STORE = "DMS_LANG", _n.DMS_DESIGN_STORE = "DMS_DESIGN", _n.DMS_CHART_LAYOUT_STORE = "DMS_CHART_LAYOUT", _n.DMS_CHART_STORAGE_LIST = "DMS_CHART_STORAGE_LIST", _n))(StorageEnum || {});
const { DMS_DESIGN_STORE } = StorageEnum, { darkTheme: darkTheme$1, appTheme, appThemeDetail } = theme$1, storageDesign = getLocalStorage(DMS_DESIGN_STORE);
defineStore("useDesignStore", {
  state: () => storageDesign || {
    // 是否暗黑
    darkTheme: darkTheme$1,
    // 主题名称
    themeName: darkTheme$1 && ThemeEnum.DARK || ThemeEnum.LIGHT,
    // 颜色色号
    appTheme,
    appThemeDetail
  },
  getters: {
    getDarkTheme(_n) {
      return this.darkTheme;
    },
    getAppTheme() {
      return this.appTheme;
    },
    getAppThemeDetail() {
      return this.appThemeDetail;
    }
  },
  actions: {
    // 切换主题
    changeTheme() {
      this.darkTheme = !this.darkTheme, this.themeName = this.darkTheme ? ThemeEnum.DARK : ThemeEnum.LIGHT, setLocalStorage(DMS_DESIGN_STORE, this.$state);
    },
    // 设置颜色
    setAppColor(_n) {
      this.appTheme = _n.hex, this.appThemeDetail = _n, setLocalStorage(DMS_DESIGN_STORE, this.$state);
    }
  }
});
const useLayoutStore = defineStore("layoutStore", {
  persist: !0,
  state: () => ({
    currentType: "",
    // 当前点击的按钮类型
    sidebar: !0,
    config: !0,
    resource: !1,
    appPage: !1,
    // 是否重置当前画布位置
    rePositionCanvas: !1,
    filterConfig: !1
    // 滤镜设置
  }),
  getters: {
    getSidebar: (_n) => _n.sidebar,
    getConfig: (_n) => _n.config,
    getResource: (_n) => _n.resource,
    getAppPage: (_n) => _n.appPage,
    getRePositionCanvas: (_n) => _n.rePositionCanvas,
    getFilterConfig: (_n) => _n.filterConfig
  },
  actions: {
    setItem(_n, nr) {
      this.$patch((Cn) => {
        Cn[_n] = nr;
      }), this.rePositionCanvas = !0;
    },
    setItemUnHandle(_n, nr) {
      this.$patch((Cn) => {
        Cn[_n] = nr;
      });
    },
    setSidebar(_n) {
      this.sidebar = _n;
    },
    setConfig(_n) {
      this.config = _n;
    },
    setResource(_n) {
      this.resource = _n;
    },
    setAppPage(_n) {
      this.appPage = _n, this.appPage && (this.config || this.setConfig(!0), this.filterConfig && this.setFilterConfig(!1));
    },
    setRePositionCanvas(_n) {
      this.rePositionCanvas = _n;
    },
    setFilterConfig(_n) {
      this.filterConfig = _n, this.filterConfig && (this.config || this.setConfig(!0), this.appPage && this.setAppPage(!1));
    }
  }
});
var FileTypeEnum = /* @__PURE__ */ ((_n) => (_n.TXT = "text/plain", _n.JSON = "application/json", _n.PNG = "image/png", _n.JPEG = "image/jpeg", _n.GIF = "image/gif", _n))(FileTypeEnum || {});
const readFile = (_n) => new Promise((nr) => {
  try {
    const Cn = new FileReader();
    Cn.onload = (Bn) => {
      Bn.target && nr(Bn.target.result);
    }, Cn.readAsText(_n);
  } catch {
    window.$message.error("文件读取失败！");
  }
}), downloadByA = (_n, nr = (/* @__PURE__ */ new Date()).getTime() + "", Cn) => {
  const Bn = document.createElement("a");
  Bn.download = `${nr}.${Cn}`, Bn.style.display = "none", Bn.href = _n, document.body.appendChild(Bn), Bn.click(), document.body.removeChild(Bn);
}, downloadTextFile = (_n, nr = (/* @__PURE__ */ new Date()).getTime() + "", Cn) => {
  const Bn = new Blob([_n]);
  downloadByA(URL.createObjectURL(Bn), nr, Cn);
}, base64Tofile = (_n, nr = "file") => {
  let Cn = _n.split(","), Bn = Cn[0].match(/:(.*?);/)[1], In = Bn.split("/")[1], Dn = window.atob(Cn[1]), Ln = Dn.length, $n = new Uint8Array(Ln);
  for (; Ln--; )
    $n[Ln] = Dn.charCodeAt(Ln);
  return new File([$n], `${nr}.${In}`, {
    type: Bn
  });
}, useImportJson = () => {
  const _n = ref();
  return {
    importJsonFileList: _n,
    importJsonRequest: (Bn) => {
      const { file: In } = Bn;
      nextTick(() => {
        In ? readFile(In).then((Dn) => {
          ElMessageBox.confirm(
            "请选择导入方式：",
            "提示",
            {
              distinguishCancelAndClose: !0,
              confirmButtonText: "新增（可撤回）",
              cancelButtonText: "覆盖（不可撤回）"
            }
          ).then(() => {
            try {
              Dn = JSONParse(Dn), ElMessage.success("导入成功！");
            } catch (Ln) {
              console.log(Ln), ElMessage.error("组件导入失败，请检查文件完整性!");
            }
          }).catch(() => {
            try {
              Dn = JSONParse(Dn), ElMessage.success("导入成功！");
            } catch (Ln) {
              console.log(Ln), ElMessage.error("组件导入失败，请检查文件完整性!");
            }
          });
        }) : ElMessage.error("导入失败，请检查数据或联系管理员！");
      });
    },
    importJsonBeforeUpload: (Bn) => {
      _n.value = [];
      const In = Bn.type;
      return In !== FileTypeEnum.JSON && In !== FileTypeEnum.TXT ? (ElMessage.warning("仅支持上传 【JSON】 格式文件，请重新上传！"), !1) : !0;
    }
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(_n, nr) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Cn, Bn) {
    Cn.__proto__ = Bn;
  } || function(Cn, Bn) {
    for (var In in Bn)
      Object.prototype.hasOwnProperty.call(Bn, In) && (Cn[In] = Bn[In]);
  }, extendStatics$1(_n, nr);
};
function __extends$2(_n, nr) {
  if (typeof nr != "function" && nr !== null)
    throw new TypeError("Class extends value " + String(nr) + " is not a constructor or null");
  extendStatics$1(_n, nr);
  function Cn() {
    this.constructor = _n;
  }
  _n.prototype = nr === null ? Object.create(nr) : (Cn.prototype = nr.prototype, new Cn());
}
var Browser = function() {
  function _n() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return _n;
}(), Env = function() {
  function _n() {
    this.browser = new Browser(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return _n;
}(), env = new Env();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (env.wxa = !0, env.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? env.worker = !0 : !env.hasGlobalWindow || "Deno" in window ? (env.node = !0, env.svgSupported = !0) : detect(navigator.userAgent, env);
function detect(_n, nr) {
  var Cn = nr.browser, Bn = _n.match(/Firefox\/([\d.]+)/), In = _n.match(/MSIE\s([\d.]+)/) || _n.match(/Trident\/.+?rv:(([\d.]+))/), Dn = _n.match(/Edge?\/([\d.]+)/), Ln = /micromessenger/i.test(_n);
  Bn && (Cn.firefox = !0, Cn.version = Bn[1]), In && (Cn.ie = !0, Cn.version = In[1]), Dn && (Cn.edge = !0, Cn.version = Dn[1], Cn.newEdge = +Dn[1].split(".")[0] > 18), Ln && (Cn.weChat = !0), nr.svgSupported = typeof SVGRect < "u", nr.touchEventsSupported = "ontouchstart" in window && !Cn.ie && !Cn.edge, nr.pointerEventsSupported = "onpointerdown" in window && (Cn.edge || Cn.ie && +Cn.version >= 11), nr.domSupported = typeof document < "u";
  var $n = document.documentElement.style;
  nr.transform3dSupported = (Cn.ie && "transition" in $n || Cn.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in $n) && !("OTransition" in $n), nr.transformSupported = nr.transform3dSupported || Cn.ie && +Cn.version >= 9;
}
const env$1 = env;
var DEFAULT_FONT_SIZE = 12, DEFAULT_FONT_FAMILY = "sans-serif", DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY, OFFSET = 20, SCALE = 100, defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(_n) {
  var nr = {};
  if (typeof JSON > "u")
    return nr;
  for (var Cn = 0; Cn < _n.length; Cn++) {
    var Bn = String.fromCharCode(Cn + 32), In = (_n.charCodeAt(Cn) - OFFSET) / SCALE;
    nr[Bn] = In;
  }
  return nr;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr), platformApi = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: function() {
    var _n, nr;
    return function(Cn, Bn) {
      if (!_n) {
        var In = platformApi.createCanvas();
        _n = In && In.getContext("2d");
      }
      if (_n)
        return nr !== Bn && (nr = _n.font = Bn || DEFAULT_FONT), _n.measureText(Cn);
      Cn = Cn || "", Bn = Bn || DEFAULT_FONT;
      var Dn = /((?:\d+)?\.?\d*)px/.exec(Bn), Ln = Dn && +Dn[1] || DEFAULT_FONT_SIZE, $n = 0;
      if (Bn.indexOf("mono") >= 0)
        $n = Ln * Cn.length;
      else
        for (var Nn = 0; Nn < Cn.length; Nn++) {
          var Rn = DEFAULT_TEXT_WIDTH_MAP[Cn[Nn]];
          $n += Rn == null ? Ln : Rn * Ln;
        }
      return { width: $n };
    };
  }(),
  loadImage: function(_n, nr, Cn) {
    var Bn = new Image();
    return Bn.onload = nr, Bn.onerror = Cn, Bn.src = _n, Bn;
  }
};
function setPlatformAPI(_n) {
  for (var nr in platformApi)
    _n[nr] && (platformApi[nr] = _n[nr]);
}
var BUILTIN_OBJECT = reduce([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(_n, nr) {
  return _n["[object " + nr + "]"] = !0, _n;
}, {}), TYPED_ARRAY = reduce([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(_n, nr) {
  return _n["[object " + nr + "Array]"] = !0, _n;
}, {}), objToString = Object.prototype.toString, arrayProto$1 = Array.prototype, nativeForEach = arrayProto$1.forEach, nativeFilter = arrayProto$1.filter, nativeSlice = arrayProto$1.slice, nativeMap = arrayProto$1.map, ctorFunction = (function() {
}).constructor, protoFunction = ctorFunction ? ctorFunction.prototype : null, protoKey = "__proto__", idStart = 2311;
function guid() {
  return idStart++;
}
function logError() {
  for (var _n = [], nr = 0; nr < arguments.length; nr++)
    _n[nr] = arguments[nr];
  typeof console < "u" && console.error.apply(console, _n);
}
function clone$4(_n) {
  if (_n == null || typeof _n != "object")
    return _n;
  var nr = _n, Cn = objToString.call(_n);
  if (Cn === "[object Array]") {
    if (!isPrimitive(_n)) {
      nr = [];
      for (var Bn = 0, In = _n.length; Bn < In; Bn++)
        nr[Bn] = clone$4(_n[Bn]);
    }
  } else if (TYPED_ARRAY[Cn]) {
    if (!isPrimitive(_n)) {
      var Dn = _n.constructor;
      if (Dn.from)
        nr = Dn.from(_n);
      else {
        nr = new Dn(_n.length);
        for (var Bn = 0, In = _n.length; Bn < In; Bn++)
          nr[Bn] = _n[Bn];
      }
    }
  } else if (!BUILTIN_OBJECT[Cn] && !isPrimitive(_n) && !isDom(_n)) {
    nr = {};
    for (var Ln in _n)
      _n.hasOwnProperty(Ln) && Ln !== protoKey && (nr[Ln] = clone$4(_n[Ln]));
  }
  return nr;
}
function merge$1(_n, nr, Cn) {
  if (!isObject$6(nr) || !isObject$6(_n))
    return Cn ? clone$4(nr) : _n;
  for (var Bn in nr)
    if (nr.hasOwnProperty(Bn) && Bn !== protoKey) {
      var In = _n[Bn], Dn = nr[Bn];
      isObject$6(Dn) && isObject$6(In) && !isArray$4(Dn) && !isArray$4(In) && !isDom(Dn) && !isDom(In) && !isBuiltInObject(Dn) && !isBuiltInObject(In) && !isPrimitive(Dn) && !isPrimitive(In) ? merge$1(In, Dn, Cn) : (Cn || !(Bn in _n)) && (_n[Bn] = clone$4(nr[Bn]));
    }
  return _n;
}
function mergeAll(_n, nr) {
  for (var Cn = _n[0], Bn = 1, In = _n.length; Bn < In; Bn++)
    Cn = merge$1(Cn, _n[Bn], nr);
  return Cn;
}
function extend(_n, nr) {
  if (Object.assign)
    Object.assign(_n, nr);
  else
    for (var Cn in nr)
      nr.hasOwnProperty(Cn) && Cn !== protoKey && (_n[Cn] = nr[Cn]);
  return _n;
}
function defaults(_n, nr, Cn) {
  for (var Bn = keys(nr), In = 0, Dn = Bn.length; In < Dn; In++) {
    var Ln = Bn[In];
    (Cn ? nr[Ln] != null : _n[Ln] == null) && (_n[Ln] = nr[Ln]);
  }
  return _n;
}
var createCanvas = platformApi.createCanvas;
function indexOf(_n, nr) {
  if (_n) {
    if (_n.indexOf)
      return _n.indexOf(nr);
    for (var Cn = 0, Bn = _n.length; Cn < Bn; Cn++)
      if (_n[Cn] === nr)
        return Cn;
  }
  return -1;
}
function inherits(_n, nr) {
  var Cn = _n.prototype;
  function Bn() {
  }
  Bn.prototype = nr.prototype, _n.prototype = new Bn();
  for (var In in Cn)
    Cn.hasOwnProperty(In) && (_n.prototype[In] = Cn[In]);
  _n.prototype.constructor = _n, _n.superClass = nr;
}
function mixin(_n, nr, Cn) {
  if (_n = "prototype" in _n ? _n.prototype : _n, nr = "prototype" in nr ? nr.prototype : nr, Object.getOwnPropertyNames)
    for (var Bn = Object.getOwnPropertyNames(nr), In = 0; In < Bn.length; In++) {
      var Dn = Bn[In];
      Dn !== "constructor" && (Cn ? nr[Dn] != null : _n[Dn] == null) && (_n[Dn] = nr[Dn]);
    }
  else
    defaults(_n, nr, Cn);
}
function isArrayLike$1(_n) {
  return !_n || typeof _n == "string" ? !1 : typeof _n.length == "number";
}
function each$f(_n, nr, Cn) {
  if (_n && nr)
    if (_n.forEach && _n.forEach === nativeForEach)
      _n.forEach(nr, Cn);
    else if (_n.length === +_n.length)
      for (var Bn = 0, In = _n.length; Bn < In; Bn++)
        nr.call(Cn, _n[Bn], Bn, _n);
    else
      for (var Dn in _n)
        _n.hasOwnProperty(Dn) && nr.call(Cn, _n[Dn], Dn, _n);
}
function map$1(_n, nr, Cn) {
  if (!_n)
    return [];
  if (!nr)
    return slice(_n);
  if (_n.map && _n.map === nativeMap)
    return _n.map(nr, Cn);
  for (var Bn = [], In = 0, Dn = _n.length; In < Dn; In++)
    Bn.push(nr.call(Cn, _n[In], In, _n));
  return Bn;
}
function reduce(_n, nr, Cn, Bn) {
  if (_n && nr) {
    for (var In = 0, Dn = _n.length; In < Dn; In++)
      Cn = nr.call(Bn, Cn, _n[In], In, _n);
    return Cn;
  }
}
function filter(_n, nr, Cn) {
  if (!_n)
    return [];
  if (!nr)
    return slice(_n);
  if (_n.filter && _n.filter === nativeFilter)
    return _n.filter(nr, Cn);
  for (var Bn = [], In = 0, Dn = _n.length; In < Dn; In++)
    nr.call(Cn, _n[In], In, _n) && Bn.push(_n[In]);
  return Bn;
}
function find(_n, nr, Cn) {
  if (_n && nr) {
    for (var Bn = 0, In = _n.length; Bn < In; Bn++)
      if (nr.call(Cn, _n[Bn], Bn, _n))
        return _n[Bn];
  }
}
function keys(_n) {
  if (!_n)
    return [];
  if (Object.keys)
    return Object.keys(_n);
  var nr = [];
  for (var Cn in _n)
    _n.hasOwnProperty(Cn) && nr.push(Cn);
  return nr;
}
function bindPolyfill(_n, nr) {
  for (var Cn = [], Bn = 2; Bn < arguments.length; Bn++)
    Cn[Bn - 2] = arguments[Bn];
  return function() {
    return _n.apply(nr, Cn.concat(nativeSlice.call(arguments)));
  };
}
var bind$1 = protoFunction && isFunction$1(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry$1(_n) {
  for (var nr = [], Cn = 1; Cn < arguments.length; Cn++)
    nr[Cn - 1] = arguments[Cn];
  return function() {
    return _n.apply(this, nr.concat(nativeSlice.call(arguments)));
  };
}
function isArray$4(_n) {
  return Array.isArray ? Array.isArray(_n) : objToString.call(_n) === "[object Array]";
}
function isFunction$1(_n) {
  return typeof _n == "function";
}
function isString$1(_n) {
  return typeof _n == "string";
}
function isStringSafe(_n) {
  return objToString.call(_n) === "[object String]";
}
function isNumber(_n) {
  return typeof _n == "number";
}
function isObject$6(_n) {
  var nr = typeof _n;
  return nr === "function" || !!_n && nr === "object";
}
function isBuiltInObject(_n) {
  return !!BUILTIN_OBJECT[objToString.call(_n)];
}
function isTypedArray$2(_n) {
  return !!TYPED_ARRAY[objToString.call(_n)];
}
function isDom(_n) {
  return typeof _n == "object" && typeof _n.nodeType == "number" && typeof _n.ownerDocument == "object";
}
function isGradientObject(_n) {
  return _n.colorStops != null;
}
function isImagePatternObject(_n) {
  return _n.image != null;
}
function isRegExp(_n) {
  return objToString.call(_n) === "[object RegExp]";
}
function eqNaN(_n) {
  return _n !== _n;
}
function retrieve() {
  for (var _n = [], nr = 0; nr < arguments.length; nr++)
    _n[nr] = arguments[nr];
  for (var Cn = 0, Bn = _n.length; Cn < Bn; Cn++)
    if (_n[Cn] != null)
      return _n[Cn];
}
function retrieve2(_n, nr) {
  return _n ?? nr;
}
function retrieve3(_n, nr, Cn) {
  return _n ?? nr ?? Cn;
}
function slice(_n) {
  for (var nr = [], Cn = 1; Cn < arguments.length; Cn++)
    nr[Cn - 1] = arguments[Cn];
  return nativeSlice.apply(_n, nr);
}
function normalizeCssArray$1(_n) {
  if (typeof _n == "number")
    return [_n, _n, _n, _n];
  var nr = _n.length;
  return nr === 2 ? [_n[0], _n[1], _n[0], _n[1]] : nr === 3 ? [_n[0], _n[1], _n[2], _n[1]] : _n;
}
function assert(_n, nr) {
  if (!_n)
    throw new Error(nr);
}
function trim$1(_n) {
  return _n == null ? null : typeof _n.trim == "function" ? _n.trim() : _n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(_n) {
  _n[primitiveKey] = !0;
}
function isPrimitive(_n) {
  return _n[primitiveKey];
}
var MapPolyfill = function() {
  function _n() {
    this.data = {};
  }
  return _n.prototype.delete = function(nr) {
    var Cn = this.has(nr);
    return Cn && delete this.data[nr], Cn;
  }, _n.prototype.has = function(nr) {
    return this.data.hasOwnProperty(nr);
  }, _n.prototype.get = function(nr) {
    return this.data[nr];
  }, _n.prototype.set = function(nr, Cn) {
    return this.data[nr] = Cn, this;
  }, _n.prototype.keys = function() {
    return keys(this.data);
  }, _n.prototype.forEach = function(nr) {
    var Cn = this.data;
    for (var Bn in Cn)
      Cn.hasOwnProperty(Bn) && nr(Cn[Bn], Bn);
  }, _n;
}(), isNativeMapSupported = typeof Map == "function";
function maybeNativeMap() {
  return isNativeMapSupported ? /* @__PURE__ */ new Map() : new MapPolyfill();
}
var HashMap = function() {
  function _n(nr) {
    var Cn = isArray$4(nr);
    this.data = maybeNativeMap();
    var Bn = this;
    nr instanceof _n ? nr.each(In) : nr && each$f(nr, In);
    function In(Dn, Ln) {
      Cn ? Bn.set(Dn, Ln) : Bn.set(Ln, Dn);
    }
  }
  return _n.prototype.hasKey = function(nr) {
    return this.data.has(nr);
  }, _n.prototype.get = function(nr) {
    return this.data.get(nr);
  }, _n.prototype.set = function(nr, Cn) {
    return this.data.set(nr, Cn), Cn;
  }, _n.prototype.each = function(nr, Cn) {
    this.data.forEach(function(Bn, In) {
      nr.call(Cn, Bn, In);
    });
  }, _n.prototype.keys = function() {
    var nr = this.data.keys();
    return isNativeMapSupported ? Array.from(nr) : nr;
  }, _n.prototype.removeKey = function(nr) {
    this.data.delete(nr);
  }, _n;
}();
function createHashMap(_n) {
  return new HashMap(_n);
}
function concatArray(_n, nr) {
  for (var Cn = new _n.constructor(_n.length + nr.length), Bn = 0; Bn < _n.length; Bn++)
    Cn[Bn] = _n[Bn];
  for (var In = _n.length, Bn = 0; Bn < nr.length; Bn++)
    Cn[Bn + In] = nr[Bn];
  return Cn;
}
function createObject(_n, nr) {
  var Cn;
  if (Object.create)
    Cn = Object.create(_n);
  else {
    var Bn = function() {
    };
    Bn.prototype = _n, Cn = new Bn();
  }
  return nr && extend(Cn, nr), Cn;
}
function disableUserSelect(_n) {
  var nr = _n.style;
  nr.webkitUserSelect = "none", nr.userSelect = "none", nr.webkitTapHighlightColor = "rgba(0,0,0,0)", nr["-webkit-touch-callout"] = "none";
}
function hasOwn(_n, nr) {
  return _n.hasOwnProperty(nr);
}
function noop$1() {
}
var RADIAN_TO_DEGREE = 180 / Math.PI;
const util$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HashMap,
  RADIAN_TO_DEGREE,
  assert,
  bind: bind$1,
  clone: clone$4,
  concatArray,
  createCanvas,
  createHashMap,
  createObject,
  curry: curry$1,
  defaults,
  disableUserSelect,
  each: each$f,
  eqNaN,
  extend,
  filter,
  find,
  guid,
  hasOwn,
  indexOf,
  inherits,
  isArray: isArray$4,
  isArrayLike: isArrayLike$1,
  isBuiltInObject,
  isDom,
  isFunction: isFunction$1,
  isGradientObject,
  isImagePatternObject,
  isNumber,
  isObject: isObject$6,
  isPrimitive,
  isRegExp,
  isString: isString$1,
  isStringSafe,
  isTypedArray: isTypedArray$2,
  keys,
  logError,
  map: map$1,
  merge: merge$1,
  mergeAll,
  mixin,
  noop: noop$1,
  normalizeCssArray: normalizeCssArray$1,
  reduce,
  retrieve,
  retrieve2,
  retrieve3,
  setAsPrimitive,
  slice,
  trim: trim$1
}, Symbol.toStringTag, { value: "Module" }));
function create$2(_n, nr) {
  return _n == null && (_n = 0), nr == null && (nr = 0), [_n, nr];
}
function copy$1(_n, nr) {
  return _n[0] = nr[0], _n[1] = nr[1], _n;
}
function clone$3(_n) {
  return [_n[0], _n[1]];
}
function set$2(_n, nr, Cn) {
  return _n[0] = nr, _n[1] = Cn, _n;
}
function add(_n, nr, Cn) {
  return _n[0] = nr[0] + Cn[0], _n[1] = nr[1] + Cn[1], _n;
}
function scaleAndAdd$1(_n, nr, Cn, Bn) {
  return _n[0] = nr[0] + Cn[0] * Bn, _n[1] = nr[1] + Cn[1] * Bn, _n;
}
function sub(_n, nr, Cn) {
  return _n[0] = nr[0] - Cn[0], _n[1] = nr[1] - Cn[1], _n;
}
function len(_n) {
  return Math.sqrt(lenSquare(_n));
}
var length = len;
function lenSquare(_n) {
  return _n[0] * _n[0] + _n[1] * _n[1];
}
var lengthSquare = lenSquare;
function mul$1(_n, nr, Cn) {
  return _n[0] = nr[0] * Cn[0], _n[1] = nr[1] * Cn[1], _n;
}
function div(_n, nr, Cn) {
  return _n[0] = nr[0] / Cn[0], _n[1] = nr[1] / Cn[1], _n;
}
function dot(_n, nr) {
  return _n[0] * nr[0] + _n[1] * nr[1];
}
function scale$2(_n, nr, Cn) {
  return _n[0] = nr[0] * Cn, _n[1] = nr[1] * Cn, _n;
}
function normalize$3(_n, nr) {
  var Cn = len(nr);
  return Cn === 0 ? (_n[0] = 0, _n[1] = 0) : (_n[0] = nr[0] / Cn, _n[1] = nr[1] / Cn), _n;
}
function distance$1(_n, nr) {
  return Math.sqrt((_n[0] - nr[0]) * (_n[0] - nr[0]) + (_n[1] - nr[1]) * (_n[1] - nr[1]));
}
var dist$1 = distance$1;
function distanceSquare(_n, nr) {
  return (_n[0] - nr[0]) * (_n[0] - nr[0]) + (_n[1] - nr[1]) * (_n[1] - nr[1]);
}
var distSquare = distanceSquare;
function negate(_n, nr) {
  return _n[0] = -nr[0], _n[1] = -nr[1], _n;
}
function lerp$2(_n, nr, Cn, Bn) {
  return _n[0] = nr[0] + Bn * (Cn[0] - nr[0]), _n[1] = nr[1] + Bn * (Cn[1] - nr[1]), _n;
}
function applyTransform$1(_n, nr, Cn) {
  var Bn = nr[0], In = nr[1];
  return _n[0] = Cn[0] * Bn + Cn[2] * In + Cn[4], _n[1] = Cn[1] * Bn + Cn[3] * In + Cn[5], _n;
}
function min$2(_n, nr, Cn) {
  return _n[0] = Math.min(nr[0], Cn[0]), _n[1] = Math.min(nr[1], Cn[1]), _n;
}
function max$3(_n, nr, Cn) {
  return _n[0] = Math.max(nr[0], Cn[0]), _n[1] = Math.max(nr[1], Cn[1]), _n;
}
const vector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add,
  applyTransform: applyTransform$1,
  clone: clone$3,
  copy: copy$1,
  create: create$2,
  dist: dist$1,
  distSquare,
  distance: distance$1,
  distanceSquare,
  div,
  dot,
  len,
  lenSquare,
  length,
  lengthSquare,
  lerp: lerp$2,
  max: max$3,
  min: min$2,
  mul: mul$1,
  negate,
  normalize: normalize$3,
  scale: scale$2,
  scaleAndAdd: scaleAndAdd$1,
  set: set$2,
  sub
}, Symbol.toStringTag, { value: "Module" }));
var Param = function() {
  function _n(nr, Cn) {
    this.target = nr, this.topTarget = Cn && Cn.topTarget;
  }
  return _n;
}(), Draggable = function() {
  function _n(nr) {
    this.handler = nr, nr.on("mousedown", this._dragStart, this), nr.on("mousemove", this._drag, this), nr.on("mouseup", this._dragEnd, this);
  }
  return _n.prototype._dragStart = function(nr) {
    for (var Cn = nr.target; Cn && !Cn.draggable; )
      Cn = Cn.parent || Cn.__hostTarget;
    Cn && (this._draggingTarget = Cn, Cn.dragging = !0, this._x = nr.offsetX, this._y = nr.offsetY, this.handler.dispatchToElement(new Param(Cn, nr), "dragstart", nr.event));
  }, _n.prototype._drag = function(nr) {
    var Cn = this._draggingTarget;
    if (Cn) {
      var Bn = nr.offsetX, In = nr.offsetY, Dn = Bn - this._x, Ln = In - this._y;
      this._x = Bn, this._y = In, Cn.drift(Dn, Ln, nr), this.handler.dispatchToElement(new Param(Cn, nr), "drag", nr.event);
      var $n = this.handler.findHover(Bn, In, Cn).target, Nn = this._dropTarget;
      this._dropTarget = $n, Cn !== $n && (Nn && $n !== Nn && this.handler.dispatchToElement(new Param(Nn, nr), "dragleave", nr.event), $n && $n !== Nn && this.handler.dispatchToElement(new Param($n, nr), "dragenter", nr.event));
    }
  }, _n.prototype._dragEnd = function(nr) {
    var Cn = this._draggingTarget;
    Cn && (Cn.dragging = !1), this.handler.dispatchToElement(new Param(Cn, nr), "dragend", nr.event), this._dropTarget && this.handler.dispatchToElement(new Param(this._dropTarget, nr), "drop", nr.event), this._draggingTarget = null, this._dropTarget = null;
  }, _n;
}();
const Draggable$1 = Draggable;
var Eventful = function() {
  function _n(nr) {
    nr && (this._$eventProcessor = nr);
  }
  return _n.prototype.on = function(nr, Cn, Bn, In) {
    this._$handlers || (this._$handlers = {});
    var Dn = this._$handlers;
    if (typeof Cn == "function" && (In = Bn, Bn = Cn, Cn = null), !Bn || !nr)
      return this;
    var Ln = this._$eventProcessor;
    Cn != null && Ln && Ln.normalizeQuery && (Cn = Ln.normalizeQuery(Cn)), Dn[nr] || (Dn[nr] = []);
    for (var $n = 0; $n < Dn[nr].length; $n++)
      if (Dn[nr][$n].h === Bn)
        return this;
    var Nn = {
      h: Bn,
      query: Cn,
      ctx: In || this,
      callAtLast: Bn.zrEventfulCallAtLast
    }, Rn = Dn[nr].length - 1, Fn = Dn[nr][Rn];
    return Fn && Fn.callAtLast ? Dn[nr].splice(Rn, 0, Nn) : Dn[nr].push(Nn), this;
  }, _n.prototype.isSilent = function(nr) {
    var Cn = this._$handlers;
    return !Cn || !Cn[nr] || !Cn[nr].length;
  }, _n.prototype.off = function(nr, Cn) {
    var Bn = this._$handlers;
    if (!Bn)
      return this;
    if (!nr)
      return this._$handlers = {}, this;
    if (Cn) {
      if (Bn[nr]) {
        for (var In = [], Dn = 0, Ln = Bn[nr].length; Dn < Ln; Dn++)
          Bn[nr][Dn].h !== Cn && In.push(Bn[nr][Dn]);
        Bn[nr] = In;
      }
      Bn[nr] && Bn[nr].length === 0 && delete Bn[nr];
    } else
      delete Bn[nr];
    return this;
  }, _n.prototype.trigger = function(nr) {
    for (var Cn = [], Bn = 1; Bn < arguments.length; Bn++)
      Cn[Bn - 1] = arguments[Bn];
    if (!this._$handlers)
      return this;
    var In = this._$handlers[nr], Dn = this._$eventProcessor;
    if (In)
      for (var Ln = Cn.length, $n = In.length, Nn = 0; Nn < $n; Nn++) {
        var Rn = In[Nn];
        if (!(Dn && Dn.filter && Rn.query != null && !Dn.filter(nr, Rn.query)))
          switch (Ln) {
            case 0:
              Rn.h.call(Rn.ctx);
              break;
            case 1:
              Rn.h.call(Rn.ctx, Cn[0]);
              break;
            case 2:
              Rn.h.call(Rn.ctx, Cn[0], Cn[1]);
              break;
            default:
              Rn.h.apply(Rn.ctx, Cn);
              break;
          }
      }
    return Dn && Dn.afterTrigger && Dn.afterTrigger(nr), this;
  }, _n.prototype.triggerWithContext = function(nr) {
    for (var Cn = [], Bn = 1; Bn < arguments.length; Bn++)
      Cn[Bn - 1] = arguments[Bn];
    if (!this._$handlers)
      return this;
    var In = this._$handlers[nr], Dn = this._$eventProcessor;
    if (In)
      for (var Ln = Cn.length, $n = Cn[Ln - 1], Nn = In.length, Rn = 0; Rn < Nn; Rn++) {
        var Fn = In[Rn];
        if (!(Dn && Dn.filter && Fn.query != null && !Dn.filter(nr, Fn.query)))
          switch (Ln) {
            case 0:
              Fn.h.call($n);
              break;
            case 1:
              Fn.h.call($n, Cn[0]);
              break;
            case 2:
              Fn.h.call($n, Cn[0], Cn[1]);
              break;
            default:
              Fn.h.apply($n, Cn.slice(1, Ln - 1));
              break;
          }
      }
    return Dn && Dn.afterTrigger && Dn.afterTrigger(nr), this;
  }, _n;
}();
const Eventful$1 = Eventful;
var LN2 = Math.log(2);
function determinant(_n, nr, Cn, Bn, In, Dn) {
  var Ln = Bn + "-" + In, $n = _n.length;
  if (Dn.hasOwnProperty(Ln))
    return Dn[Ln];
  if (nr === 1) {
    var Nn = Math.round(Math.log((1 << $n) - 1 & ~In) / LN2);
    return _n[Cn][Nn];
  }
  for (var Rn = Bn | 1 << Cn, Fn = Cn + 1; Bn & 1 << Fn; )
    Fn++;
  for (var Pn = 0, Un = 0, Hn = 0; Un < $n; Un++) {
    var zn = 1 << Un;
    zn & In || (Pn += (Hn % 2 ? -1 : 1) * _n[Cn][Un] * determinant(_n, nr - 1, Fn, Rn, In | zn, Dn), Hn++);
  }
  return Dn[Ln] = Pn, Pn;
}
function buildTransformer(_n, nr) {
  var Cn = [
    [_n[0], _n[1], 1, 0, 0, 0, -nr[0] * _n[0], -nr[0] * _n[1]],
    [0, 0, 0, _n[0], _n[1], 1, -nr[1] * _n[0], -nr[1] * _n[1]],
    [_n[2], _n[3], 1, 0, 0, 0, -nr[2] * _n[2], -nr[2] * _n[3]],
    [0, 0, 0, _n[2], _n[3], 1, -nr[3] * _n[2], -nr[3] * _n[3]],
    [_n[4], _n[5], 1, 0, 0, 0, -nr[4] * _n[4], -nr[4] * _n[5]],
    [0, 0, 0, _n[4], _n[5], 1, -nr[5] * _n[4], -nr[5] * _n[5]],
    [_n[6], _n[7], 1, 0, 0, 0, -nr[6] * _n[6], -nr[6] * _n[7]],
    [0, 0, 0, _n[6], _n[7], 1, -nr[7] * _n[6], -nr[7] * _n[7]]
  ], Bn = {}, In = determinant(Cn, 8, 0, 0, 0, Bn);
  if (In !== 0) {
    for (var Dn = [], Ln = 0; Ln < 8; Ln++)
      for (var $n = 0; $n < 8; $n++)
        Dn[$n] == null && (Dn[$n] = 0), Dn[$n] += ((Ln + $n) % 2 ? -1 : 1) * determinant(Cn, 7, Ln === 0 ? 1 : 0, 1 << Ln, 1 << $n, Bn) / In * nr[Ln];
    return function(Nn, Rn, Fn) {
      var Pn = Rn * Dn[6] + Fn * Dn[7] + 1;
      Nn[0] = (Rn * Dn[0] + Fn * Dn[1] + Dn[2]) / Pn, Nn[1] = (Rn * Dn[3] + Fn * Dn[4] + Dn[5]) / Pn;
    };
  }
}
var EVENT_SAVED_PROP = "___zrEVENTSAVED", _calcOut$1 = [];
function transformLocalCoord(_n, nr, Cn, Bn, In) {
  return transformCoordWithViewport(_calcOut$1, nr, Bn, In, !0) && transformCoordWithViewport(_n, Cn, _calcOut$1[0], _calcOut$1[1]);
}
function transformCoordWithViewport(_n, nr, Cn, Bn, In) {
  if (nr.getBoundingClientRect && env$1.domSupported && !isCanvasEl(nr)) {
    var Dn = nr[EVENT_SAVED_PROP] || (nr[EVENT_SAVED_PROP] = {}), Ln = prepareCoordMarkers(nr, Dn), $n = preparePointerTransformer(Ln, Dn, In);
    if ($n)
      return $n(_n, Cn, Bn), !0;
  }
  return !1;
}
function prepareCoordMarkers(_n, nr) {
  var Cn = nr.markers;
  if (Cn)
    return Cn;
  Cn = nr.markers = [];
  for (var Bn = ["left", "right"], In = ["top", "bottom"], Dn = 0; Dn < 4; Dn++) {
    var Ln = document.createElement("div"), $n = Ln.style, Nn = Dn % 2, Rn = (Dn >> 1) % 2;
    $n.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      Bn[Nn] + ":0",
      In[Rn] + ":0",
      Bn[1 - Nn] + ":auto",
      In[1 - Rn] + ":auto",
      ""
    ].join("!important;"), _n.appendChild(Ln), Cn.push(Ln);
  }
  return Cn;
}
function preparePointerTransformer(_n, nr, Cn) {
  for (var Bn = Cn ? "invTrans" : "trans", In = nr[Bn], Dn = nr.srcCoords, Ln = [], $n = [], Nn = !0, Rn = 0; Rn < 4; Rn++) {
    var Fn = _n[Rn].getBoundingClientRect(), Pn = 2 * Rn, Un = Fn.left, Hn = Fn.top;
    Ln.push(Un, Hn), Nn = Nn && Dn && Un === Dn[Pn] && Hn === Dn[Pn + 1], $n.push(_n[Rn].offsetLeft, _n[Rn].offsetTop);
  }
  return Nn && In ? In : (nr.srcCoords = Ln, nr[Bn] = Cn ? buildTransformer($n, Ln) : buildTransformer(Ln, $n));
}
function isCanvasEl(_n) {
  return _n.nodeName.toUpperCase() === "CANVAS";
}
var replaceReg = /([&<>"'])/g, replaceMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function encodeHTML(_n) {
  return _n == null ? "" : (_n + "").replace(replaceReg, function(nr, Cn) {
    return replaceMap[Cn];
  });
}
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, _calcOut = [], firefoxNotSupportOffsetXY = env$1.browser.firefox && +env$1.browser.version.split(".")[0] < 39;
function clientToLocal(_n, nr, Cn, Bn) {
  return Cn = Cn || {}, Bn ? calculateZrXY(_n, nr, Cn) : firefoxNotSupportOffsetXY && nr.layerX != null && nr.layerX !== nr.offsetX ? (Cn.zrX = nr.layerX, Cn.zrY = nr.layerY) : nr.offsetX != null ? (Cn.zrX = nr.offsetX, Cn.zrY = nr.offsetY) : calculateZrXY(_n, nr, Cn), Cn;
}
function calculateZrXY(_n, nr, Cn) {
  if (env$1.domSupported && _n.getBoundingClientRect) {
    var Bn = nr.clientX, In = nr.clientY;
    if (isCanvasEl(_n)) {
      var Dn = _n.getBoundingClientRect();
      Cn.zrX = Bn - Dn.left, Cn.zrY = In - Dn.top;
      return;
    } else if (transformCoordWithViewport(_calcOut, _n, Bn, In)) {
      Cn.zrX = _calcOut[0], Cn.zrY = _calcOut[1];
      return;
    }
  }
  Cn.zrX = Cn.zrY = 0;
}
function getNativeEvent(_n) {
  return _n || window.event;
}
function normalizeEvent(_n, nr, Cn) {
  if (nr = getNativeEvent(nr), nr.zrX != null)
    return nr;
  var Bn = nr.type, In = Bn && Bn.indexOf("touch") >= 0;
  if (In) {
    var Ln = Bn !== "touchend" ? nr.targetTouches[0] : nr.changedTouches[0];
    Ln && clientToLocal(_n, Ln, nr, Cn);
  } else {
    clientToLocal(_n, nr, nr, Cn);
    var Dn = getWheelDeltaMayPolyfill(nr);
    nr.zrDelta = Dn ? Dn / 120 : -(nr.detail || 0) / 3;
  }
  var $n = nr.button;
  return nr.which == null && $n !== void 0 && MOUSE_EVENT_REG.test(nr.type) && (nr.which = $n & 1 ? 1 : $n & 2 ? 3 : $n & 4 ? 2 : 0), nr;
}
function getWheelDeltaMayPolyfill(_n) {
  var nr = _n.wheelDelta;
  if (nr)
    return nr;
  var Cn = _n.deltaX, Bn = _n.deltaY;
  if (Cn == null || Bn == null)
    return nr;
  var In = Math.abs(Bn !== 0 ? Bn : Cn), Dn = Bn > 0 ? -1 : Bn < 0 ? 1 : Cn > 0 ? -1 : 1;
  return 3 * In * Dn;
}
function addEventListener(_n, nr, Cn, Bn) {
  _n.addEventListener(nr, Cn, Bn);
}
function removeEventListener(_n, nr, Cn, Bn) {
  _n.removeEventListener(nr, Cn, Bn);
}
var stop = function(_n) {
  _n.preventDefault(), _n.stopPropagation(), _n.cancelBubble = !0;
};
function isMiddleOrRightButtonOnMouseUpDown(_n) {
  return _n.which === 2 || _n.which === 3;
}
var GestureMgr = function() {
  function _n() {
    this._track = [];
  }
  return _n.prototype.recognize = function(nr, Cn, Bn) {
    return this._doTrack(nr, Cn, Bn), this._recognize(nr);
  }, _n.prototype.clear = function() {
    return this._track.length = 0, this;
  }, _n.prototype._doTrack = function(nr, Cn, Bn) {
    var In = nr.touches;
    if (In) {
      for (var Dn = {
        points: [],
        touches: [],
        target: Cn,
        event: nr
      }, Ln = 0, $n = In.length; Ln < $n; Ln++) {
        var Nn = In[Ln], Rn = clientToLocal(Bn, Nn, {});
        Dn.points.push([Rn.zrX, Rn.zrY]), Dn.touches.push(Nn);
      }
      this._track.push(Dn);
    }
  }, _n.prototype._recognize = function(nr) {
    for (var Cn in recognizers)
      if (recognizers.hasOwnProperty(Cn)) {
        var Bn = recognizers[Cn](this._track, nr);
        if (Bn)
          return Bn;
      }
  }, _n;
}();
function dist(_n) {
  var nr = _n[1][0] - _n[0][0], Cn = _n[1][1] - _n[0][1];
  return Math.sqrt(nr * nr + Cn * Cn);
}
function center$1(_n) {
  return [
    (_n[0][0] + _n[1][0]) / 2,
    (_n[0][1] + _n[1][1]) / 2
  ];
}
var recognizers = {
  pinch: function(_n, nr) {
    var Cn = _n.length;
    if (Cn) {
      var Bn = (_n[Cn - 1] || {}).points, In = (_n[Cn - 2] || {}).points || Bn;
      if (In && In.length > 1 && Bn && Bn.length > 1) {
        var Dn = dist(Bn) / dist(In);
        !isFinite(Dn) && (Dn = 1), nr.pinchScale = Dn;
        var Ln = center$1(Bn);
        return nr.pinchX = Ln[0], nr.pinchY = Ln[1], {
          type: "pinch",
          target: _n[0].target,
          event: nr
        };
      }
    }
  }
};
function create$1() {
  return [1, 0, 0, 1, 0, 0];
}
function identity$1(_n) {
  return _n[0] = 1, _n[1] = 0, _n[2] = 0, _n[3] = 1, _n[4] = 0, _n[5] = 0, _n;
}
function copy(_n, nr) {
  return _n[0] = nr[0], _n[1] = nr[1], _n[2] = nr[2], _n[3] = nr[3], _n[4] = nr[4], _n[5] = nr[5], _n;
}
function mul(_n, nr, Cn) {
  var Bn = nr[0] * Cn[0] + nr[2] * Cn[1], In = nr[1] * Cn[0] + nr[3] * Cn[1], Dn = nr[0] * Cn[2] + nr[2] * Cn[3], Ln = nr[1] * Cn[2] + nr[3] * Cn[3], $n = nr[0] * Cn[4] + nr[2] * Cn[5] + nr[4], Nn = nr[1] * Cn[4] + nr[3] * Cn[5] + nr[5];
  return _n[0] = Bn, _n[1] = In, _n[2] = Dn, _n[3] = Ln, _n[4] = $n, _n[5] = Nn, _n;
}
function translate(_n, nr, Cn) {
  return _n[0] = nr[0], _n[1] = nr[1], _n[2] = nr[2], _n[3] = nr[3], _n[4] = nr[4] + Cn[0], _n[5] = nr[5] + Cn[1], _n;
}
function rotate(_n, nr, Cn, Bn) {
  Bn === void 0 && (Bn = [0, 0]);
  var In = nr[0], Dn = nr[2], Ln = nr[4], $n = nr[1], Nn = nr[3], Rn = nr[5], Fn = Math.sin(Cn), Pn = Math.cos(Cn);
  return _n[0] = In * Pn + $n * Fn, _n[1] = -In * Fn + $n * Pn, _n[2] = Dn * Pn + Nn * Fn, _n[3] = -Dn * Fn + Pn * Nn, _n[4] = Pn * (Ln - Bn[0]) + Fn * (Rn - Bn[1]) + Bn[0], _n[5] = Pn * (Rn - Bn[1]) - Fn * (Ln - Bn[0]) + Bn[1], _n;
}
function scale$1(_n, nr, Cn) {
  var Bn = Cn[0], In = Cn[1];
  return _n[0] = nr[0] * Bn, _n[1] = nr[1] * In, _n[2] = nr[2] * Bn, _n[3] = nr[3] * In, _n[4] = nr[4] * Bn, _n[5] = nr[5] * In, _n;
}
function invert(_n, nr) {
  var Cn = nr[0], Bn = nr[2], In = nr[4], Dn = nr[1], Ln = nr[3], $n = nr[5], Nn = Cn * Ln - Dn * Bn;
  return Nn ? (Nn = 1 / Nn, _n[0] = Ln * Nn, _n[1] = -Dn * Nn, _n[2] = -Bn * Nn, _n[3] = Cn * Nn, _n[4] = (Bn * $n - Ln * In) * Nn, _n[5] = (Dn * In - Cn * $n) * Nn, _n) : null;
}
function clone$2(_n) {
  var nr = create$1();
  return copy(nr, _n), nr;
}
const matrix$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clone: clone$2,
  copy,
  create: create$1,
  identity: identity$1,
  invert,
  mul,
  rotate,
  scale: scale$1,
  translate
}, Symbol.toStringTag, { value: "Module" }));
var Point = function() {
  function _n(nr, Cn) {
    this.x = nr || 0, this.y = Cn || 0;
  }
  return _n.prototype.copy = function(nr) {
    return this.x = nr.x, this.y = nr.y, this;
  }, _n.prototype.clone = function() {
    return new _n(this.x, this.y);
  }, _n.prototype.set = function(nr, Cn) {
    return this.x = nr, this.y = Cn, this;
  }, _n.prototype.equal = function(nr) {
    return nr.x === this.x && nr.y === this.y;
  }, _n.prototype.add = function(nr) {
    return this.x += nr.x, this.y += nr.y, this;
  }, _n.prototype.scale = function(nr) {
    this.x *= nr, this.y *= nr;
  }, _n.prototype.scaleAndAdd = function(nr, Cn) {
    this.x += nr.x * Cn, this.y += nr.y * Cn;
  }, _n.prototype.sub = function(nr) {
    return this.x -= nr.x, this.y -= nr.y, this;
  }, _n.prototype.dot = function(nr) {
    return this.x * nr.x + this.y * nr.y;
  }, _n.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, _n.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, _n.prototype.normalize = function() {
    var nr = this.len();
    return this.x /= nr, this.y /= nr, this;
  }, _n.prototype.distance = function(nr) {
    var Cn = this.x - nr.x, Bn = this.y - nr.y;
    return Math.sqrt(Cn * Cn + Bn * Bn);
  }, _n.prototype.distanceSquare = function(nr) {
    var Cn = this.x - nr.x, Bn = this.y - nr.y;
    return Cn * Cn + Bn * Bn;
  }, _n.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, _n.prototype.transform = function(nr) {
    if (nr) {
      var Cn = this.x, Bn = this.y;
      return this.x = nr[0] * Cn + nr[2] * Bn + nr[4], this.y = nr[1] * Cn + nr[3] * Bn + nr[5], this;
    }
  }, _n.prototype.toArray = function(nr) {
    return nr[0] = this.x, nr[1] = this.y, nr;
  }, _n.prototype.fromArray = function(nr) {
    this.x = nr[0], this.y = nr[1];
  }, _n.set = function(nr, Cn, Bn) {
    nr.x = Cn, nr.y = Bn;
  }, _n.copy = function(nr, Cn) {
    nr.x = Cn.x, nr.y = Cn.y;
  }, _n.len = function(nr) {
    return Math.sqrt(nr.x * nr.x + nr.y * nr.y);
  }, _n.lenSquare = function(nr) {
    return nr.x * nr.x + nr.y * nr.y;
  }, _n.dot = function(nr, Cn) {
    return nr.x * Cn.x + nr.y * Cn.y;
  }, _n.add = function(nr, Cn, Bn) {
    nr.x = Cn.x + Bn.x, nr.y = Cn.y + Bn.y;
  }, _n.sub = function(nr, Cn, Bn) {
    nr.x = Cn.x - Bn.x, nr.y = Cn.y - Bn.y;
  }, _n.scale = function(nr, Cn, Bn) {
    nr.x = Cn.x * Bn, nr.y = Cn.y * Bn;
  }, _n.scaleAndAdd = function(nr, Cn, Bn, In) {
    nr.x = Cn.x + Bn.x * In, nr.y = Cn.y + Bn.y * In;
  }, _n.lerp = function(nr, Cn, Bn, In) {
    var Dn = 1 - In;
    nr.x = Dn * Cn.x + In * Bn.x, nr.y = Dn * Cn.y + In * Bn.y;
  }, _n;
}();
const Point$1 = Point;
var mathMin$a = Math.min, mathMax$a = Math.max, lt$3 = new Point$1(), rb = new Point$1(), lb = new Point$1(), rt$2 = new Point$1(), minTv$1 = new Point$1(), maxTv$1 = new Point$1(), BoundingRect = function() {
  function _n(nr, Cn, Bn, In) {
    Bn < 0 && (nr = nr + Bn, Bn = -Bn), In < 0 && (Cn = Cn + In, In = -In), this.x = nr, this.y = Cn, this.width = Bn, this.height = In;
  }
  return _n.prototype.union = function(nr) {
    var Cn = mathMin$a(nr.x, this.x), Bn = mathMin$a(nr.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = mathMax$a(nr.x + nr.width, this.x + this.width) - Cn : this.width = nr.width, isFinite(this.y) && isFinite(this.height) ? this.height = mathMax$a(nr.y + nr.height, this.y + this.height) - Bn : this.height = nr.height, this.x = Cn, this.y = Bn;
  }, _n.prototype.applyTransform = function(nr) {
    _n.applyTransform(this, this, nr);
  }, _n.prototype.calculateTransform = function(nr) {
    var Cn = this, Bn = nr.width / Cn.width, In = nr.height / Cn.height, Dn = create$1();
    return translate(Dn, Dn, [-Cn.x, -Cn.y]), scale$1(Dn, Dn, [Bn, In]), translate(Dn, Dn, [nr.x, nr.y]), Dn;
  }, _n.prototype.intersect = function(nr, Cn) {
    if (!nr)
      return !1;
    nr instanceof _n || (nr = _n.create(nr));
    var Bn = this, In = Bn.x, Dn = Bn.x + Bn.width, Ln = Bn.y, $n = Bn.y + Bn.height, Nn = nr.x, Rn = nr.x + nr.width, Fn = nr.y, Pn = nr.y + nr.height, Un = !(Dn < Nn || Rn < In || $n < Fn || Pn < Ln);
    if (Cn) {
      var Hn = 1 / 0, zn = 0, Gn = Math.abs(Dn - Nn), Yn = Math.abs(Rn - In), Wn = Math.abs($n - Fn), Xn = Math.abs(Pn - Ln), ea = Math.min(Gn, Yn), ta = Math.min(Wn, Xn);
      Dn < Nn || Rn < In ? ea > zn && (zn = ea, Gn < Yn ? Point$1.set(maxTv$1, -Gn, 0) : Point$1.set(maxTv$1, Yn, 0)) : ea < Hn && (Hn = ea, Gn < Yn ? Point$1.set(minTv$1, Gn, 0) : Point$1.set(minTv$1, -Yn, 0)), $n < Fn || Pn < Ln ? ta > zn && (zn = ta, Wn < Xn ? Point$1.set(maxTv$1, 0, -Wn) : Point$1.set(maxTv$1, 0, Xn)) : ea < Hn && (Hn = ea, Wn < Xn ? Point$1.set(minTv$1, 0, Wn) : Point$1.set(minTv$1, 0, -Xn));
    }
    return Cn && Point$1.copy(Cn, Un ? minTv$1 : maxTv$1), Un;
  }, _n.prototype.contain = function(nr, Cn) {
    var Bn = this;
    return nr >= Bn.x && nr <= Bn.x + Bn.width && Cn >= Bn.y && Cn <= Bn.y + Bn.height;
  }, _n.prototype.clone = function() {
    return new _n(this.x, this.y, this.width, this.height);
  }, _n.prototype.copy = function(nr) {
    _n.copy(this, nr);
  }, _n.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, _n.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, _n.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, _n.create = function(nr) {
    return new _n(nr.x, nr.y, nr.width, nr.height);
  }, _n.copy = function(nr, Cn) {
    nr.x = Cn.x, nr.y = Cn.y, nr.width = Cn.width, nr.height = Cn.height;
  }, _n.applyTransform = function(nr, Cn, Bn) {
    if (!Bn) {
      nr !== Cn && _n.copy(nr, Cn);
      return;
    }
    if (Bn[1] < 1e-5 && Bn[1] > -1e-5 && Bn[2] < 1e-5 && Bn[2] > -1e-5) {
      var In = Bn[0], Dn = Bn[3], Ln = Bn[4], $n = Bn[5];
      nr.x = Cn.x * In + Ln, nr.y = Cn.y * Dn + $n, nr.width = Cn.width * In, nr.height = Cn.height * Dn, nr.width < 0 && (nr.x += nr.width, nr.width = -nr.width), nr.height < 0 && (nr.y += nr.height, nr.height = -nr.height);
      return;
    }
    lt$3.x = lb.x = Cn.x, lt$3.y = rt$2.y = Cn.y, rb.x = rt$2.x = Cn.x + Cn.width, rb.y = lb.y = Cn.y + Cn.height, lt$3.transform(Bn), rt$2.transform(Bn), rb.transform(Bn), lb.transform(Bn), nr.x = mathMin$a(lt$3.x, rb.x, lb.x, rt$2.x), nr.y = mathMin$a(lt$3.y, rb.y, lb.y, rt$2.y);
    var Nn = mathMax$a(lt$3.x, rb.x, lb.x, rt$2.x), Rn = mathMax$a(lt$3.y, rb.y, lb.y, rt$2.y);
    nr.width = Nn - nr.x, nr.height = Rn - nr.y;
  }, _n;
}();
const BoundingRect$1 = BoundingRect;
var SILENT = "silent";
function makeEventPacket(_n, nr, Cn) {
  return {
    type: _n,
    event: Cn,
    target: nr.target,
    topTarget: nr.topTarget,
    cancelBubble: !1,
    offsetX: Cn.zrX,
    offsetY: Cn.zrY,
    gestureEvent: Cn.gestureEvent,
    pinchX: Cn.pinchX,
    pinchY: Cn.pinchY,
    pinchScale: Cn.pinchScale,
    wheelDelta: Cn.zrDelta,
    zrByTouch: Cn.zrByTouch,
    which: Cn.which,
    stop: stopEvent
  };
}
function stopEvent() {
  stop(this.event);
}
var EmptyProxy = function(_n) {
  __extends$2(nr, _n);
  function nr() {
    var Cn = _n !== null && _n.apply(this, arguments) || this;
    return Cn.handler = null, Cn;
  }
  return nr.prototype.dispose = function() {
  }, nr.prototype.setCursor = function() {
  }, nr;
}(Eventful$1), HoveredResult = function() {
  function _n(nr, Cn) {
    this.x = nr, this.y = Cn;
  }
  return _n;
}(), handlerNames = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], tmpRect$1 = new BoundingRect$1(0, 0, 0, 0), Handler = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn, Bn, In, Dn, Ln) {
    var $n = _n.call(this) || this;
    return $n._hovered = new HoveredResult(0, 0), $n.storage = Cn, $n.painter = Bn, $n.painterRoot = Dn, $n._pointerSize = Ln, In = In || new EmptyProxy(), $n.proxy = null, $n.setHandlerProxy(In), $n._draggingMgr = new Draggable$1($n), $n;
  }
  return nr.prototype.setHandlerProxy = function(Cn) {
    this.proxy && this.proxy.dispose(), Cn && (each$f(handlerNames, function(Bn) {
      Cn.on && Cn.on(Bn, this[Bn], this);
    }, this), Cn.handler = this), this.proxy = Cn;
  }, nr.prototype.mousemove = function(Cn) {
    var Bn = Cn.zrX, In = Cn.zrY, Dn = isOutsideBoundary(this, Bn, In), Ln = this._hovered, $n = Ln.target;
    $n && !$n.__zr && (Ln = this.findHover(Ln.x, Ln.y), $n = Ln.target);
    var Nn = this._hovered = Dn ? new HoveredResult(Bn, In) : this.findHover(Bn, In), Rn = Nn.target, Fn = this.proxy;
    Fn.setCursor && Fn.setCursor(Rn ? Rn.cursor : "default"), $n && Rn !== $n && this.dispatchToElement(Ln, "mouseout", Cn), this.dispatchToElement(Nn, "mousemove", Cn), Rn && Rn !== $n && this.dispatchToElement(Nn, "mouseover", Cn);
  }, nr.prototype.mouseout = function(Cn) {
    var Bn = Cn.zrEventControl;
    Bn !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", Cn), Bn !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: Cn });
  }, nr.prototype.resize = function() {
    this._hovered = new HoveredResult(0, 0);
  }, nr.prototype.dispatch = function(Cn, Bn) {
    var In = this[Cn];
    In && In.call(this, Bn);
  }, nr.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, nr.prototype.setCursorStyle = function(Cn) {
    var Bn = this.proxy;
    Bn.setCursor && Bn.setCursor(Cn);
  }, nr.prototype.dispatchToElement = function(Cn, Bn, In) {
    Cn = Cn || {};
    var Dn = Cn.target;
    if (!(Dn && Dn.silent)) {
      for (var Ln = "on" + Bn, $n = makeEventPacket(Bn, Cn, In); Dn && (Dn[Ln] && ($n.cancelBubble = !!Dn[Ln].call(Dn, $n)), Dn.trigger(Bn, $n), Dn = Dn.__hostTarget ? Dn.__hostTarget : Dn.parent, !$n.cancelBubble); )
        ;
      $n.cancelBubble || (this.trigger(Bn, $n), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(Nn) {
        typeof Nn[Ln] == "function" && Nn[Ln].call(Nn, $n), Nn.trigger && Nn.trigger(Bn, $n);
      }));
    }
  }, nr.prototype.findHover = function(Cn, Bn, In) {
    var Dn = this.storage.getDisplayList(), Ln = new HoveredResult(Cn, Bn);
    if (setHoverTarget(Dn, Ln, Cn, Bn, In), this._pointerSize && !Ln.target) {
      for (var $n = [], Nn = this._pointerSize, Rn = Nn / 2, Fn = new BoundingRect$1(Cn - Rn, Bn - Rn, Nn, Nn), Pn = Dn.length - 1; Pn >= 0; Pn--) {
        var Un = Dn[Pn];
        Un !== In && !Un.ignore && !Un.ignoreCoarsePointer && (!Un.parent || !Un.parent.ignoreCoarsePointer) && (tmpRect$1.copy(Un.getBoundingRect()), Un.transform && tmpRect$1.applyTransform(Un.transform), tmpRect$1.intersect(Fn) && $n.push(Un));
      }
      if ($n.length)
        for (var Hn = 4, zn = Math.PI / 12, Gn = Math.PI * 2, Yn = 0; Yn < Rn; Yn += Hn)
          for (var Wn = 0; Wn < Gn; Wn += zn) {
            var Xn = Cn + Yn * Math.cos(Wn), ea = Bn + Yn * Math.sin(Wn);
            if (setHoverTarget($n, Ln, Xn, ea, In), Ln.target)
              return Ln;
          }
    }
    return Ln;
  }, nr.prototype.processGesture = function(Cn, Bn) {
    this._gestureMgr || (this._gestureMgr = new GestureMgr());
    var In = this._gestureMgr;
    Bn === "start" && In.clear();
    var Dn = In.recognize(Cn, this.findHover(Cn.zrX, Cn.zrY, null).target, this.proxy.dom);
    if (Bn === "end" && In.clear(), Dn) {
      var Ln = Dn.type;
      Cn.gestureEvent = Ln;
      var $n = new HoveredResult();
      $n.target = Dn.target, this.dispatchToElement($n, Ln, Dn.event);
    }
  }, nr;
}(Eventful$1);
each$f(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(_n) {
  Handler.prototype[_n] = function(nr) {
    var Cn = nr.zrX, Bn = nr.zrY, In = isOutsideBoundary(this, Cn, Bn), Dn, Ln;
    if ((_n !== "mouseup" || !In) && (Dn = this.findHover(Cn, Bn), Ln = Dn.target), _n === "mousedown")
      this._downEl = Ln, this._downPoint = [nr.zrX, nr.zrY], this._upEl = Ln;
    else if (_n === "mouseup")
      this._upEl = Ln;
    else if (_n === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [nr.zrX, nr.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(Dn, _n, nr);
  };
});
function isHover(_n, nr, Cn) {
  if (_n[_n.rectHover ? "rectContain" : "contain"](nr, Cn)) {
    for (var Bn = _n, In = void 0, Dn = !1; Bn; ) {
      if (Bn.ignoreClip && (Dn = !0), !Dn) {
        var Ln = Bn.getClipPath();
        if (Ln && !Ln.contain(nr, Cn))
          return !1;
      }
      Bn.silent && (In = !0);
      var $n = Bn.__hostTarget;
      Bn = $n || Bn.parent;
    }
    return In ? SILENT : !0;
  }
  return !1;
}
function setHoverTarget(_n, nr, Cn, Bn, In) {
  for (var Dn = _n.length - 1; Dn >= 0; Dn--) {
    var Ln = _n[Dn], $n = void 0;
    if (Ln !== In && !Ln.ignore && ($n = isHover(Ln, Cn, Bn)) && (!nr.topTarget && (nr.topTarget = Ln), $n !== SILENT)) {
      nr.target = Ln;
      break;
    }
  }
}
function isOutsideBoundary(_n, nr, Cn) {
  var Bn = _n.painter;
  return nr < 0 || nr > Bn.getWidth() || Cn < 0 || Cn > Bn.getHeight();
}
const Handler$1 = Handler;
var DEFAULT_MIN_MERGE = 32, DEFAULT_MIN_GALLOPING = 7;
function minRunLength(_n) {
  for (var nr = 0; _n >= DEFAULT_MIN_MERGE; )
    nr |= _n & 1, _n >>= 1;
  return _n + nr;
}
function makeAscendingRun(_n, nr, Cn, Bn) {
  var In = nr + 1;
  if (In === Cn)
    return 1;
  if (Bn(_n[In++], _n[nr]) < 0) {
    for (; In < Cn && Bn(_n[In], _n[In - 1]) < 0; )
      In++;
    reverseRun(_n, nr, In);
  } else
    for (; In < Cn && Bn(_n[In], _n[In - 1]) >= 0; )
      In++;
  return In - nr;
}
function reverseRun(_n, nr, Cn) {
  for (Cn--; nr < Cn; ) {
    var Bn = _n[nr];
    _n[nr++] = _n[Cn], _n[Cn--] = Bn;
  }
}
function binaryInsertionSort(_n, nr, Cn, Bn, In) {
  for (Bn === nr && Bn++; Bn < Cn; Bn++) {
    for (var Dn = _n[Bn], Ln = nr, $n = Bn, Nn; Ln < $n; )
      Nn = Ln + $n >>> 1, In(Dn, _n[Nn]) < 0 ? $n = Nn : Ln = Nn + 1;
    var Rn = Bn - Ln;
    switch (Rn) {
      case 3:
        _n[Ln + 3] = _n[Ln + 2];
      case 2:
        _n[Ln + 2] = _n[Ln + 1];
      case 1:
        _n[Ln + 1] = _n[Ln];
        break;
      default:
        for (; Rn > 0; )
          _n[Ln + Rn] = _n[Ln + Rn - 1], Rn--;
    }
    _n[Ln] = Dn;
  }
}
function gallopLeft(_n, nr, Cn, Bn, In, Dn) {
  var Ln = 0, $n = 0, Nn = 1;
  if (Dn(_n, nr[Cn + In]) > 0) {
    for ($n = Bn - In; Nn < $n && Dn(_n, nr[Cn + In + Nn]) > 0; )
      Ln = Nn, Nn = (Nn << 1) + 1, Nn <= 0 && (Nn = $n);
    Nn > $n && (Nn = $n), Ln += In, Nn += In;
  } else {
    for ($n = In + 1; Nn < $n && Dn(_n, nr[Cn + In - Nn]) <= 0; )
      Ln = Nn, Nn = (Nn << 1) + 1, Nn <= 0 && (Nn = $n);
    Nn > $n && (Nn = $n);
    var Rn = Ln;
    Ln = In - Nn, Nn = In - Rn;
  }
  for (Ln++; Ln < Nn; ) {
    var Fn = Ln + (Nn - Ln >>> 1);
    Dn(_n, nr[Cn + Fn]) > 0 ? Ln = Fn + 1 : Nn = Fn;
  }
  return Nn;
}
function gallopRight(_n, nr, Cn, Bn, In, Dn) {
  var Ln = 0, $n = 0, Nn = 1;
  if (Dn(_n, nr[Cn + In]) < 0) {
    for ($n = In + 1; Nn < $n && Dn(_n, nr[Cn + In - Nn]) < 0; )
      Ln = Nn, Nn = (Nn << 1) + 1, Nn <= 0 && (Nn = $n);
    Nn > $n && (Nn = $n);
    var Rn = Ln;
    Ln = In - Nn, Nn = In - Rn;
  } else {
    for ($n = Bn - In; Nn < $n && Dn(_n, nr[Cn + In + Nn]) >= 0; )
      Ln = Nn, Nn = (Nn << 1) + 1, Nn <= 0 && (Nn = $n);
    Nn > $n && (Nn = $n), Ln += In, Nn += In;
  }
  for (Ln++; Ln < Nn; ) {
    var Fn = Ln + (Nn - Ln >>> 1);
    Dn(_n, nr[Cn + Fn]) < 0 ? Nn = Fn : Ln = Fn + 1;
  }
  return Nn;
}
function TimSort(_n, nr) {
  var Cn = DEFAULT_MIN_GALLOPING, Bn, In, Dn = 0, Ln = [];
  Bn = [], In = [];
  function $n(Hn, zn) {
    Bn[Dn] = Hn, In[Dn] = zn, Dn += 1;
  }
  function Nn() {
    for (; Dn > 1; ) {
      var Hn = Dn - 2;
      if (Hn >= 1 && In[Hn - 1] <= In[Hn] + In[Hn + 1] || Hn >= 2 && In[Hn - 2] <= In[Hn] + In[Hn - 1])
        In[Hn - 1] < In[Hn + 1] && Hn--;
      else if (In[Hn] > In[Hn + 1])
        break;
      Fn(Hn);
    }
  }
  function Rn() {
    for (; Dn > 1; ) {
      var Hn = Dn - 2;
      Hn > 0 && In[Hn - 1] < In[Hn + 1] && Hn--, Fn(Hn);
    }
  }
  function Fn(Hn) {
    var zn = Bn[Hn], Gn = In[Hn], Yn = Bn[Hn + 1], Wn = In[Hn + 1];
    In[Hn] = Gn + Wn, Hn === Dn - 3 && (Bn[Hn + 1] = Bn[Hn + 2], In[Hn + 1] = In[Hn + 2]), Dn--;
    var Xn = gallopRight(_n[Yn], _n, zn, Gn, 0, nr);
    zn += Xn, Gn -= Xn, Gn !== 0 && (Wn = gallopLeft(_n[zn + Gn - 1], _n, Yn, Wn, Wn - 1, nr), Wn !== 0 && (Gn <= Wn ? Pn(zn, Gn, Yn, Wn) : Un(zn, Gn, Yn, Wn)));
  }
  function Pn(Hn, zn, Gn, Yn) {
    var Wn = 0;
    for (Wn = 0; Wn < zn; Wn++)
      Ln[Wn] = _n[Hn + Wn];
    var Xn = 0, ea = Gn, ta = Hn;
    if (_n[ta++] = _n[ea++], --Yn === 0) {
      for (Wn = 0; Wn < zn; Wn++)
        _n[ta + Wn] = Ln[Xn + Wn];
      return;
    }
    if (zn === 1) {
      for (Wn = 0; Wn < Yn; Wn++)
        _n[ta + Wn] = _n[ea + Wn];
      _n[ta + Yn] = Ln[Xn];
      return;
    }
    for (var na = Cn, ra, aa, ia; ; ) {
      ra = 0, aa = 0, ia = !1;
      do
        if (nr(_n[ea], Ln[Xn]) < 0) {
          if (_n[ta++] = _n[ea++], aa++, ra = 0, --Yn === 0) {
            ia = !0;
            break;
          }
        } else if (_n[ta++] = Ln[Xn++], ra++, aa = 0, --zn === 1) {
          ia = !0;
          break;
        }
      while ((ra | aa) < na);
      if (ia)
        break;
      do {
        if (ra = gallopRight(_n[ea], Ln, Xn, zn, 0, nr), ra !== 0) {
          for (Wn = 0; Wn < ra; Wn++)
            _n[ta + Wn] = Ln[Xn + Wn];
          if (ta += ra, Xn += ra, zn -= ra, zn <= 1) {
            ia = !0;
            break;
          }
        }
        if (_n[ta++] = _n[ea++], --Yn === 0) {
          ia = !0;
          break;
        }
        if (aa = gallopLeft(Ln[Xn], _n, ea, Yn, 0, nr), aa !== 0) {
          for (Wn = 0; Wn < aa; Wn++)
            _n[ta + Wn] = _n[ea + Wn];
          if (ta += aa, ea += aa, Yn -= aa, Yn === 0) {
            ia = !0;
            break;
          }
        }
        if (_n[ta++] = Ln[Xn++], --zn === 1) {
          ia = !0;
          break;
        }
        na--;
      } while (ra >= DEFAULT_MIN_GALLOPING || aa >= DEFAULT_MIN_GALLOPING);
      if (ia)
        break;
      na < 0 && (na = 0), na += 2;
    }
    if (Cn = na, Cn < 1 && (Cn = 1), zn === 1) {
      for (Wn = 0; Wn < Yn; Wn++)
        _n[ta + Wn] = _n[ea + Wn];
      _n[ta + Yn] = Ln[Xn];
    } else {
      if (zn === 0)
        throw new Error();
      for (Wn = 0; Wn < zn; Wn++)
        _n[ta + Wn] = Ln[Xn + Wn];
    }
  }
  function Un(Hn, zn, Gn, Yn) {
    var Wn = 0;
    for (Wn = 0; Wn < Yn; Wn++)
      Ln[Wn] = _n[Gn + Wn];
    var Xn = Hn + zn - 1, ea = Yn - 1, ta = Gn + Yn - 1, na = 0, ra = 0;
    if (_n[ta--] = _n[Xn--], --zn === 0) {
      for (na = ta - (Yn - 1), Wn = 0; Wn < Yn; Wn++)
        _n[na + Wn] = Ln[Wn];
      return;
    }
    if (Yn === 1) {
      for (ta -= zn, Xn -= zn, ra = ta + 1, na = Xn + 1, Wn = zn - 1; Wn >= 0; Wn--)
        _n[ra + Wn] = _n[na + Wn];
      _n[ta] = Ln[ea];
      return;
    }
    for (var aa = Cn; ; ) {
      var ia = 0, Aa = 0, sa = !1;
      do
        if (nr(Ln[ea], _n[Xn]) < 0) {
          if (_n[ta--] = _n[Xn--], ia++, Aa = 0, --zn === 0) {
            sa = !0;
            break;
          }
        } else if (_n[ta--] = Ln[ea--], Aa++, ia = 0, --Yn === 1) {
          sa = !0;
          break;
        }
      while ((ia | Aa) < aa);
      if (sa)
        break;
      do {
        if (ia = zn - gallopRight(Ln[ea], _n, Hn, zn, zn - 1, nr), ia !== 0) {
          for (ta -= ia, Xn -= ia, zn -= ia, ra = ta + 1, na = Xn + 1, Wn = ia - 1; Wn >= 0; Wn--)
            _n[ra + Wn] = _n[na + Wn];
          if (zn === 0) {
            sa = !0;
            break;
          }
        }
        if (_n[ta--] = Ln[ea--], --Yn === 1) {
          sa = !0;
          break;
        }
        if (Aa = Yn - gallopLeft(_n[Xn], Ln, 0, Yn, Yn - 1, nr), Aa !== 0) {
          for (ta -= Aa, ea -= Aa, Yn -= Aa, ra = ta + 1, na = ea + 1, Wn = 0; Wn < Aa; Wn++)
            _n[ra + Wn] = Ln[na + Wn];
          if (Yn <= 1) {
            sa = !0;
            break;
          }
        }
        if (_n[ta--] = _n[Xn--], --zn === 0) {
          sa = !0;
          break;
        }
        aa--;
      } while (ia >= DEFAULT_MIN_GALLOPING || Aa >= DEFAULT_MIN_GALLOPING);
      if (sa)
        break;
      aa < 0 && (aa = 0), aa += 2;
    }
    if (Cn = aa, Cn < 1 && (Cn = 1), Yn === 1) {
      for (ta -= zn, Xn -= zn, ra = ta + 1, na = Xn + 1, Wn = zn - 1; Wn >= 0; Wn--)
        _n[ra + Wn] = _n[na + Wn];
      _n[ta] = Ln[ea];
    } else {
      if (Yn === 0)
        throw new Error();
      for (na = ta - (Yn - 1), Wn = 0; Wn < Yn; Wn++)
        _n[na + Wn] = Ln[Wn];
    }
  }
  return {
    mergeRuns: Nn,
    forceMergeRuns: Rn,
    pushRun: $n
  };
}
function sort$2(_n, nr, Cn, Bn) {
  Cn || (Cn = 0), Bn || (Bn = _n.length);
  var In = Bn - Cn;
  if (!(In < 2)) {
    var Dn = 0;
    if (In < DEFAULT_MIN_MERGE) {
      Dn = makeAscendingRun(_n, Cn, Bn, nr), binaryInsertionSort(_n, Cn, Bn, Cn + Dn, nr);
      return;
    }
    var Ln = TimSort(_n, nr), $n = minRunLength(In);
    do {
      if (Dn = makeAscendingRun(_n, Cn, Bn, nr), Dn < $n) {
        var Nn = In;
        Nn > $n && (Nn = $n), binaryInsertionSort(_n, Cn, Cn + Nn, Cn + Dn, nr), Dn = Nn;
      }
      Ln.pushRun(Cn, Dn), Ln.mergeRuns(), In -= Dn, Cn += Dn;
    } while (In !== 0);
    Ln.forceMergeRuns();
  }
}
var REDRAW_BIT = 1, STYLE_CHANGED_BIT = 2, SHAPE_CHANGED_BIT = 4, invalidZErrorLogged = !1;
function logInvalidZError() {
  invalidZErrorLogged || (invalidZErrorLogged = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function shapeCompareFunc(_n, nr) {
  return _n.zlevel === nr.zlevel ? _n.z === nr.z ? _n.z2 - nr.z2 : _n.z - nr.z : _n.zlevel - nr.zlevel;
}
var Storage = function() {
  function _n() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = shapeCompareFunc;
  }
  return _n.prototype.traverse = function(nr, Cn) {
    for (var Bn = 0; Bn < this._roots.length; Bn++)
      this._roots[Bn].traverse(nr, Cn);
  }, _n.prototype.getDisplayList = function(nr, Cn) {
    Cn = Cn || !1;
    var Bn = this._displayList;
    return (nr || !Bn.length) && this.updateDisplayList(Cn), Bn;
  }, _n.prototype.updateDisplayList = function(nr) {
    this._displayListLen = 0;
    for (var Cn = this._roots, Bn = this._displayList, In = 0, Dn = Cn.length; In < Dn; In++)
      this._updateAndAddDisplayable(Cn[In], null, nr);
    Bn.length = this._displayListLen, sort$2(Bn, shapeCompareFunc);
  }, _n.prototype._updateAndAddDisplayable = function(nr, Cn, Bn) {
    if (!(nr.ignore && !Bn)) {
      nr.beforeUpdate(), nr.update(), nr.afterUpdate();
      var In = nr.getClipPath();
      if (nr.ignoreClip)
        Cn = null;
      else if (In) {
        Cn ? Cn = Cn.slice() : Cn = [];
        for (var Dn = In, Ln = nr; Dn; )
          Dn.parent = Ln, Dn.updateTransform(), Cn.push(Dn), Ln = Dn, Dn = Dn.getClipPath();
      }
      if (nr.childrenRef) {
        for (var $n = nr.childrenRef(), Nn = 0; Nn < $n.length; Nn++) {
          var Rn = $n[Nn];
          nr.__dirty && (Rn.__dirty |= REDRAW_BIT), this._updateAndAddDisplayable(Rn, Cn, Bn);
        }
        nr.__dirty = 0;
      } else {
        var Fn = nr;
        Cn && Cn.length ? Fn.__clipPaths = Cn : Fn.__clipPaths && Fn.__clipPaths.length > 0 && (Fn.__clipPaths = []), isNaN(Fn.z) && (logInvalidZError(), Fn.z = 0), isNaN(Fn.z2) && (logInvalidZError(), Fn.z2 = 0), isNaN(Fn.zlevel) && (logInvalidZError(), Fn.zlevel = 0), this._displayList[this._displayListLen++] = Fn;
      }
      var Pn = nr.getDecalElement && nr.getDecalElement();
      Pn && this._updateAndAddDisplayable(Pn, Cn, Bn);
      var Un = nr.getTextGuideLine();
      Un && this._updateAndAddDisplayable(Un, Cn, Bn);
      var Hn = nr.getTextContent();
      Hn && this._updateAndAddDisplayable(Hn, Cn, Bn);
    }
  }, _n.prototype.addRoot = function(nr) {
    nr.__zr && nr.__zr.storage === this || this._roots.push(nr);
  }, _n.prototype.delRoot = function(nr) {
    if (nr instanceof Array) {
      for (var Cn = 0, Bn = nr.length; Cn < Bn; Cn++)
        this.delRoot(nr[Cn]);
      return;
    }
    var In = indexOf(this._roots, nr);
    In >= 0 && this._roots.splice(In, 1);
  }, _n.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, _n.prototype.getRoots = function() {
    return this._roots;
  }, _n.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, _n;
}();
const Storage$1 = Storage;
var requestAnimationFrame$1;
requestAnimationFrame$1 = env$1.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(_n) {
  return setTimeout(_n, 16);
};
const requestAnimationFrame$2 = requestAnimationFrame$1;
var easingFuncs = {
  linear: function(_n) {
    return _n;
  },
  quadraticIn: function(_n) {
    return _n * _n;
  },
  quadraticOut: function(_n) {
    return _n * (2 - _n);
  },
  quadraticInOut: function(_n) {
    return (_n *= 2) < 1 ? 0.5 * _n * _n : -0.5 * (--_n * (_n - 2) - 1);
  },
  cubicIn: function(_n) {
    return _n * _n * _n;
  },
  cubicOut: function(_n) {
    return --_n * _n * _n + 1;
  },
  cubicInOut: function(_n) {
    return (_n *= 2) < 1 ? 0.5 * _n * _n * _n : 0.5 * ((_n -= 2) * _n * _n + 2);
  },
  quarticIn: function(_n) {
    return _n * _n * _n * _n;
  },
  quarticOut: function(_n) {
    return 1 - --_n * _n * _n * _n;
  },
  quarticInOut: function(_n) {
    return (_n *= 2) < 1 ? 0.5 * _n * _n * _n * _n : -0.5 * ((_n -= 2) * _n * _n * _n - 2);
  },
  quinticIn: function(_n) {
    return _n * _n * _n * _n * _n;
  },
  quinticOut: function(_n) {
    return --_n * _n * _n * _n * _n + 1;
  },
  quinticInOut: function(_n) {
    return (_n *= 2) < 1 ? 0.5 * _n * _n * _n * _n * _n : 0.5 * ((_n -= 2) * _n * _n * _n * _n + 2);
  },
  sinusoidalIn: function(_n) {
    return 1 - Math.cos(_n * Math.PI / 2);
  },
  sinusoidalOut: function(_n) {
    return Math.sin(_n * Math.PI / 2);
  },
  sinusoidalInOut: function(_n) {
    return 0.5 * (1 - Math.cos(Math.PI * _n));
  },
  exponentialIn: function(_n) {
    return _n === 0 ? 0 : Math.pow(1024, _n - 1);
  },
  exponentialOut: function(_n) {
    return _n === 1 ? 1 : 1 - Math.pow(2, -10 * _n);
  },
  exponentialInOut: function(_n) {
    return _n === 0 ? 0 : _n === 1 ? 1 : (_n *= 2) < 1 ? 0.5 * Math.pow(1024, _n - 1) : 0.5 * (-Math.pow(2, -10 * (_n - 1)) + 2);
  },
  circularIn: function(_n) {
    return 1 - Math.sqrt(1 - _n * _n);
  },
  circularOut: function(_n) {
    return Math.sqrt(1 - --_n * _n);
  },
  circularInOut: function(_n) {
    return (_n *= 2) < 1 ? -0.5 * (Math.sqrt(1 - _n * _n) - 1) : 0.5 * (Math.sqrt(1 - (_n -= 2) * _n) + 1);
  },
  elasticIn: function(_n) {
    var nr, Cn = 0.1, Bn = 0.4;
    return _n === 0 ? 0 : _n === 1 ? 1 : (!Cn || Cn < 1 ? (Cn = 1, nr = Bn / 4) : nr = Bn * Math.asin(1 / Cn) / (2 * Math.PI), -(Cn * Math.pow(2, 10 * (_n -= 1)) * Math.sin((_n - nr) * (2 * Math.PI) / Bn)));
  },
  elasticOut: function(_n) {
    var nr, Cn = 0.1, Bn = 0.4;
    return _n === 0 ? 0 : _n === 1 ? 1 : (!Cn || Cn < 1 ? (Cn = 1, nr = Bn / 4) : nr = Bn * Math.asin(1 / Cn) / (2 * Math.PI), Cn * Math.pow(2, -10 * _n) * Math.sin((_n - nr) * (2 * Math.PI) / Bn) + 1);
  },
  elasticInOut: function(_n) {
    var nr, Cn = 0.1, Bn = 0.4;
    return _n === 0 ? 0 : _n === 1 ? 1 : (!Cn || Cn < 1 ? (Cn = 1, nr = Bn / 4) : nr = Bn * Math.asin(1 / Cn) / (2 * Math.PI), (_n *= 2) < 1 ? -0.5 * (Cn * Math.pow(2, 10 * (_n -= 1)) * Math.sin((_n - nr) * (2 * Math.PI) / Bn)) : Cn * Math.pow(2, -10 * (_n -= 1)) * Math.sin((_n - nr) * (2 * Math.PI) / Bn) * 0.5 + 1);
  },
  backIn: function(_n) {
    var nr = 1.70158;
    return _n * _n * ((nr + 1) * _n - nr);
  },
  backOut: function(_n) {
    var nr = 1.70158;
    return --_n * _n * ((nr + 1) * _n + nr) + 1;
  },
  backInOut: function(_n) {
    var nr = 2.5949095;
    return (_n *= 2) < 1 ? 0.5 * (_n * _n * ((nr + 1) * _n - nr)) : 0.5 * ((_n -= 2) * _n * ((nr + 1) * _n + nr) + 2);
  },
  bounceIn: function(_n) {
    return 1 - easingFuncs.bounceOut(1 - _n);
  },
  bounceOut: function(_n) {
    return _n < 1 / 2.75 ? 7.5625 * _n * _n : _n < 2 / 2.75 ? 7.5625 * (_n -= 1.5 / 2.75) * _n + 0.75 : _n < 2.5 / 2.75 ? 7.5625 * (_n -= 2.25 / 2.75) * _n + 0.9375 : 7.5625 * (_n -= 2.625 / 2.75) * _n + 0.984375;
  },
  bounceInOut: function(_n) {
    return _n < 0.5 ? easingFuncs.bounceIn(_n * 2) * 0.5 : easingFuncs.bounceOut(_n * 2 - 1) * 0.5 + 0.5;
  }
};
const easingFuncs$1 = easingFuncs;
var mathPow$2 = Math.pow, mathSqrt$3 = Math.sqrt, EPSILON$4 = 1e-8, EPSILON_NUMERIC = 1e-4, THREE_SQRT = mathSqrt$3(3), ONE_THIRD = 1 / 3, _v0 = create$2(), _v1 = create$2(), _v2 = create$2();
function isAroundZero$1(_n) {
  return _n > -EPSILON$4 && _n < EPSILON$4;
}
function isNotAroundZero$1(_n) {
  return _n > EPSILON$4 || _n < -EPSILON$4;
}
function cubicAt(_n, nr, Cn, Bn, In) {
  var Dn = 1 - In;
  return Dn * Dn * (Dn * _n + 3 * In * nr) + In * In * (In * Bn + 3 * Dn * Cn);
}
function cubicDerivativeAt(_n, nr, Cn, Bn, In) {
  var Dn = 1 - In;
  return 3 * (((nr - _n) * Dn + 2 * (Cn - nr) * In) * Dn + (Bn - Cn) * In * In);
}
function cubicRootAt(_n, nr, Cn, Bn, In, Dn) {
  var Ln = Bn + 3 * (nr - Cn) - _n, $n = 3 * (Cn - nr * 2 + _n), Nn = 3 * (nr - _n), Rn = _n - In, Fn = $n * $n - 3 * Ln * Nn, Pn = $n * Nn - 9 * Ln * Rn, Un = Nn * Nn - 3 * $n * Rn, Hn = 0;
  if (isAroundZero$1(Fn) && isAroundZero$1(Pn))
    if (isAroundZero$1($n))
      Dn[0] = 0;
    else {
      var zn = -Nn / $n;
      zn >= 0 && zn <= 1 && (Dn[Hn++] = zn);
    }
  else {
    var Gn = Pn * Pn - 4 * Fn * Un;
    if (isAroundZero$1(Gn)) {
      var Yn = Pn / Fn, zn = -$n / Ln + Yn, Wn = -Yn / 2;
      zn >= 0 && zn <= 1 && (Dn[Hn++] = zn), Wn >= 0 && Wn <= 1 && (Dn[Hn++] = Wn);
    } else if (Gn > 0) {
      var Xn = mathSqrt$3(Gn), ea = Fn * $n + 1.5 * Ln * (-Pn + Xn), ta = Fn * $n + 1.5 * Ln * (-Pn - Xn);
      ea < 0 ? ea = -mathPow$2(-ea, ONE_THIRD) : ea = mathPow$2(ea, ONE_THIRD), ta < 0 ? ta = -mathPow$2(-ta, ONE_THIRD) : ta = mathPow$2(ta, ONE_THIRD);
      var zn = (-$n - (ea + ta)) / (3 * Ln);
      zn >= 0 && zn <= 1 && (Dn[Hn++] = zn);
    } else {
      var na = (2 * Fn * $n - 3 * Ln * Pn) / (2 * mathSqrt$3(Fn * Fn * Fn)), ra = Math.acos(na) / 3, aa = mathSqrt$3(Fn), ia = Math.cos(ra), zn = (-$n - 2 * aa * ia) / (3 * Ln), Wn = (-$n + aa * (ia + THREE_SQRT * Math.sin(ra))) / (3 * Ln), Aa = (-$n + aa * (ia - THREE_SQRT * Math.sin(ra))) / (3 * Ln);
      zn >= 0 && zn <= 1 && (Dn[Hn++] = zn), Wn >= 0 && Wn <= 1 && (Dn[Hn++] = Wn), Aa >= 0 && Aa <= 1 && (Dn[Hn++] = Aa);
    }
  }
  return Hn;
}
function cubicExtrema(_n, nr, Cn, Bn, In) {
  var Dn = 6 * Cn - 12 * nr + 6 * _n, Ln = 9 * nr + 3 * Bn - 3 * _n - 9 * Cn, $n = 3 * nr - 3 * _n, Nn = 0;
  if (isAroundZero$1(Ln)) {
    if (isNotAroundZero$1(Dn)) {
      var Rn = -$n / Dn;
      Rn >= 0 && Rn <= 1 && (In[Nn++] = Rn);
    }
  } else {
    var Fn = Dn * Dn - 4 * Ln * $n;
    if (isAroundZero$1(Fn))
      In[0] = -Dn / (2 * Ln);
    else if (Fn > 0) {
      var Pn = mathSqrt$3(Fn), Rn = (-Dn + Pn) / (2 * Ln), Un = (-Dn - Pn) / (2 * Ln);
      Rn >= 0 && Rn <= 1 && (In[Nn++] = Rn), Un >= 0 && Un <= 1 && (In[Nn++] = Un);
    }
  }
  return Nn;
}
function cubicSubdivide(_n, nr, Cn, Bn, In, Dn) {
  var Ln = (nr - _n) * In + _n, $n = (Cn - nr) * In + nr, Nn = (Bn - Cn) * In + Cn, Rn = ($n - Ln) * In + Ln, Fn = (Nn - $n) * In + $n, Pn = (Fn - Rn) * In + Rn;
  Dn[0] = _n, Dn[1] = Ln, Dn[2] = Rn, Dn[3] = Pn, Dn[4] = Pn, Dn[5] = Fn, Dn[6] = Nn, Dn[7] = Bn;
}
function cubicProjectPoint(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn, Fn) {
  var Pn, Un = 5e-3, Hn = 1 / 0, zn, Gn, Yn, Wn;
  _v0[0] = Nn, _v0[1] = Rn;
  for (var Xn = 0; Xn < 1; Xn += 0.05)
    _v1[0] = cubicAt(_n, Cn, In, Ln, Xn), _v1[1] = cubicAt(nr, Bn, Dn, $n, Xn), Yn = distSquare(_v0, _v1), Yn < Hn && (Pn = Xn, Hn = Yn);
  Hn = 1 / 0;
  for (var ea = 0; ea < 32 && !(Un < EPSILON_NUMERIC); ea++)
    zn = Pn - Un, Gn = Pn + Un, _v1[0] = cubicAt(_n, Cn, In, Ln, zn), _v1[1] = cubicAt(nr, Bn, Dn, $n, zn), Yn = distSquare(_v1, _v0), zn >= 0 && Yn < Hn ? (Pn = zn, Hn = Yn) : (_v2[0] = cubicAt(_n, Cn, In, Ln, Gn), _v2[1] = cubicAt(nr, Bn, Dn, $n, Gn), Wn = distSquare(_v2, _v0), Gn <= 1 && Wn < Hn ? (Pn = Gn, Hn = Wn) : Un *= 0.5);
  return Fn && (Fn[0] = cubicAt(_n, Cn, In, Ln, Pn), Fn[1] = cubicAt(nr, Bn, Dn, $n, Pn)), mathSqrt$3(Hn);
}
function cubicLength(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
  for (var Rn = _n, Fn = nr, Pn = 0, Un = 1 / Nn, Hn = 1; Hn <= Nn; Hn++) {
    var zn = Hn * Un, Gn = cubicAt(_n, Cn, In, Ln, zn), Yn = cubicAt(nr, Bn, Dn, $n, zn), Wn = Gn - Rn, Xn = Yn - Fn;
    Pn += Math.sqrt(Wn * Wn + Xn * Xn), Rn = Gn, Fn = Yn;
  }
  return Pn;
}
function quadraticAt$1(_n, nr, Cn, Bn) {
  var In = 1 - Bn;
  return In * (In * _n + 2 * Bn * nr) + Bn * Bn * Cn;
}
function quadraticDerivativeAt(_n, nr, Cn, Bn) {
  return 2 * ((1 - Bn) * (nr - _n) + Bn * (Cn - nr));
}
function quadraticRootAt(_n, nr, Cn, Bn, In) {
  var Dn = _n - 2 * nr + Cn, Ln = 2 * (nr - _n), $n = _n - Bn, Nn = 0;
  if (isAroundZero$1(Dn)) {
    if (isNotAroundZero$1(Ln)) {
      var Rn = -$n / Ln;
      Rn >= 0 && Rn <= 1 && (In[Nn++] = Rn);
    }
  } else {
    var Fn = Ln * Ln - 4 * Dn * $n;
    if (isAroundZero$1(Fn)) {
      var Rn = -Ln / (2 * Dn);
      Rn >= 0 && Rn <= 1 && (In[Nn++] = Rn);
    } else if (Fn > 0) {
      var Pn = mathSqrt$3(Fn), Rn = (-Ln + Pn) / (2 * Dn), Un = (-Ln - Pn) / (2 * Dn);
      Rn >= 0 && Rn <= 1 && (In[Nn++] = Rn), Un >= 0 && Un <= 1 && (In[Nn++] = Un);
    }
  }
  return Nn;
}
function quadraticExtremum(_n, nr, Cn) {
  var Bn = _n + Cn - 2 * nr;
  return Bn === 0 ? 0.5 : (_n - nr) / Bn;
}
function quadraticSubdivide(_n, nr, Cn, Bn, In) {
  var Dn = (nr - _n) * Bn + _n, Ln = (Cn - nr) * Bn + nr, $n = (Ln - Dn) * Bn + Dn;
  In[0] = _n, In[1] = Dn, In[2] = $n, In[3] = $n, In[4] = Ln, In[5] = Cn;
}
function quadraticProjectPoint(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
  var Rn, Fn = 5e-3, Pn = 1 / 0;
  _v0[0] = Ln, _v0[1] = $n;
  for (var Un = 0; Un < 1; Un += 0.05) {
    _v1[0] = quadraticAt$1(_n, Cn, In, Un), _v1[1] = quadraticAt$1(nr, Bn, Dn, Un);
    var Hn = distSquare(_v0, _v1);
    Hn < Pn && (Rn = Un, Pn = Hn);
  }
  Pn = 1 / 0;
  for (var zn = 0; zn < 32 && !(Fn < EPSILON_NUMERIC); zn++) {
    var Gn = Rn - Fn, Yn = Rn + Fn;
    _v1[0] = quadraticAt$1(_n, Cn, In, Gn), _v1[1] = quadraticAt$1(nr, Bn, Dn, Gn);
    var Hn = distSquare(_v1, _v0);
    if (Gn >= 0 && Hn < Pn)
      Rn = Gn, Pn = Hn;
    else {
      _v2[0] = quadraticAt$1(_n, Cn, In, Yn), _v2[1] = quadraticAt$1(nr, Bn, Dn, Yn);
      var Wn = distSquare(_v2, _v0);
      Yn <= 1 && Wn < Pn ? (Rn = Yn, Pn = Wn) : Fn *= 0.5;
    }
  }
  return Nn && (Nn[0] = quadraticAt$1(_n, Cn, In, Rn), Nn[1] = quadraticAt$1(nr, Bn, Dn, Rn)), mathSqrt$3(Pn);
}
function quadraticLength(_n, nr, Cn, Bn, In, Dn, Ln) {
  for (var $n = _n, Nn = nr, Rn = 0, Fn = 1 / Ln, Pn = 1; Pn <= Ln; Pn++) {
    var Un = Pn * Fn, Hn = quadraticAt$1(_n, Cn, In, Un), zn = quadraticAt$1(nr, Bn, Dn, Un), Gn = Hn - $n, Yn = zn - Nn;
    Rn += Math.sqrt(Gn * Gn + Yn * Yn), $n = Hn, Nn = zn;
  }
  return Rn;
}
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(_n) {
  var nr = _n && regexp.exec(_n);
  if (nr) {
    var Cn = nr[1].split(","), Bn = +trim$1(Cn[0]), In = +trim$1(Cn[1]), Dn = +trim$1(Cn[2]), Ln = +trim$1(Cn[3]);
    if (isNaN(Bn + In + Dn + Ln))
      return;
    var $n = [];
    return function(Nn) {
      return Nn <= 0 ? 0 : Nn >= 1 ? 1 : cubicRootAt(0, Bn, Dn, 1, Nn, $n) && cubicAt(0, In, Ln, 1, $n[0]);
    };
  }
}
var Clip = function() {
  function _n(nr) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = nr.life || 1e3, this._delay = nr.delay || 0, this.loop = nr.loop || !1, this.onframe = nr.onframe || noop$1, this.ondestroy = nr.ondestroy || noop$1, this.onrestart = nr.onrestart || noop$1, nr.easing && this.setEasing(nr.easing);
  }
  return _n.prototype.step = function(nr, Cn) {
    if (this._inited || (this._startTime = nr + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += Cn;
      return;
    }
    var Bn = this._life, In = nr - this._startTime - this._pausedTime, Dn = In / Bn;
    Dn < 0 && (Dn = 0), Dn = Math.min(Dn, 1);
    var Ln = this.easingFunc, $n = Ln ? Ln(Dn) : Dn;
    if (this.onframe($n), Dn === 1)
      if (this.loop) {
        var Nn = In % Bn;
        this._startTime = nr - Nn, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, _n.prototype.pause = function() {
    this._paused = !0;
  }, _n.prototype.resume = function() {
    this._paused = !1;
  }, _n.prototype.setEasing = function(nr) {
    this.easing = nr, this.easingFunc = isFunction$1(nr) ? nr : easingFuncs$1[nr] || createCubicEasingFunc(nr);
  }, _n;
}();
const Clip$1 = Clip;
var Entry = function() {
  function _n(nr) {
    this.value = nr;
  }
  return _n;
}(), LinkedList = function() {
  function _n() {
    this._len = 0;
  }
  return _n.prototype.insert = function(nr) {
    var Cn = new Entry(nr);
    return this.insertEntry(Cn), Cn;
  }, _n.prototype.insertEntry = function(nr) {
    this.head ? (this.tail.next = nr, nr.prev = this.tail, nr.next = null, this.tail = nr) : this.head = this.tail = nr, this._len++;
  }, _n.prototype.remove = function(nr) {
    var Cn = nr.prev, Bn = nr.next;
    Cn ? Cn.next = Bn : this.head = Bn, Bn ? Bn.prev = Cn : this.tail = Cn, nr.next = nr.prev = null, this._len--;
  }, _n.prototype.len = function() {
    return this._len;
  }, _n.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, _n;
}(), LRU = function() {
  function _n(nr) {
    this._list = new LinkedList(), this._maxSize = 10, this._map = {}, this._maxSize = nr;
  }
  return _n.prototype.put = function(nr, Cn) {
    var Bn = this._list, In = this._map, Dn = null;
    if (In[nr] == null) {
      var Ln = Bn.len(), $n = this._lastRemovedEntry;
      if (Ln >= this._maxSize && Ln > 0) {
        var Nn = Bn.head;
        Bn.remove(Nn), delete In[Nn.key], Dn = Nn.value, this._lastRemovedEntry = Nn;
      }
      $n ? $n.value = Cn : $n = new Entry(Cn), $n.key = nr, Bn.insertEntry($n), In[nr] = $n;
    }
    return Dn;
  }, _n.prototype.get = function(nr) {
    var Cn = this._map[nr], Bn = this._list;
    if (Cn != null)
      return Cn !== Bn.tail && (Bn.remove(Cn), Bn.insertEntry(Cn)), Cn.value;
  }, _n.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, _n.prototype.len = function() {
    return this._list.len();
  }, _n;
}();
const LRU$1 = LRU;
var kCSSColorTable = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function clampCssByte(_n) {
  return _n = Math.round(_n), _n < 0 ? 0 : _n > 255 ? 255 : _n;
}
function clampCssAngle(_n) {
  return _n = Math.round(_n), _n < 0 ? 0 : _n > 360 ? 360 : _n;
}
function clampCssFloat(_n) {
  return _n < 0 ? 0 : _n > 1 ? 1 : _n;
}
function parseCssInt(_n) {
  var nr = _n;
  return nr.length && nr.charAt(nr.length - 1) === "%" ? clampCssByte(parseFloat(nr) / 100 * 255) : clampCssByte(parseInt(nr, 10));
}
function parseCssFloat(_n) {
  var nr = _n;
  return nr.length && nr.charAt(nr.length - 1) === "%" ? clampCssFloat(parseFloat(nr) / 100) : clampCssFloat(parseFloat(nr));
}
function cssHueToRgb(_n, nr, Cn) {
  return Cn < 0 ? Cn += 1 : Cn > 1 && (Cn -= 1), Cn * 6 < 1 ? _n + (nr - _n) * Cn * 6 : Cn * 2 < 1 ? nr : Cn * 3 < 2 ? _n + (nr - _n) * (2 / 3 - Cn) * 6 : _n;
}
function lerpNumber(_n, nr, Cn) {
  return _n + (nr - _n) * Cn;
}
function setRgba(_n, nr, Cn, Bn, In) {
  return _n[0] = nr, _n[1] = Cn, _n[2] = Bn, _n[3] = In, _n;
}
function copyRgba(_n, nr) {
  return _n[0] = nr[0], _n[1] = nr[1], _n[2] = nr[2], _n[3] = nr[3], _n;
}
var colorCache = new LRU$1(20), lastRemovedArr = null;
function putToCache(_n, nr) {
  lastRemovedArr && copyRgba(lastRemovedArr, nr), lastRemovedArr = colorCache.put(_n, lastRemovedArr || nr.slice());
}
function parse$2(_n, nr) {
  if (_n) {
    nr = nr || [];
    var Cn = colorCache.get(_n);
    if (Cn)
      return copyRgba(nr, Cn);
    _n = _n + "";
    var Bn = _n.replace(/ /g, "").toLowerCase();
    if (Bn in kCSSColorTable)
      return copyRgba(nr, kCSSColorTable[Bn]), putToCache(_n, nr), nr;
    var In = Bn.length;
    if (Bn.charAt(0) === "#") {
      if (In === 4 || In === 5) {
        var Dn = parseInt(Bn.slice(1, 4), 16);
        if (!(Dn >= 0 && Dn <= 4095)) {
          setRgba(nr, 0, 0, 0, 1);
          return;
        }
        return setRgba(nr, (Dn & 3840) >> 4 | (Dn & 3840) >> 8, Dn & 240 | (Dn & 240) >> 4, Dn & 15 | (Dn & 15) << 4, In === 5 ? parseInt(Bn.slice(4), 16) / 15 : 1), putToCache(_n, nr), nr;
      } else if (In === 7 || In === 9) {
        var Dn = parseInt(Bn.slice(1, 7), 16);
        if (!(Dn >= 0 && Dn <= 16777215)) {
          setRgba(nr, 0, 0, 0, 1);
          return;
        }
        return setRgba(nr, (Dn & 16711680) >> 16, (Dn & 65280) >> 8, Dn & 255, In === 9 ? parseInt(Bn.slice(7), 16) / 255 : 1), putToCache(_n, nr), nr;
      }
      return;
    }
    var Ln = Bn.indexOf("("), $n = Bn.indexOf(")");
    if (Ln !== -1 && $n + 1 === In) {
      var Nn = Bn.substr(0, Ln), Rn = Bn.substr(Ln + 1, $n - (Ln + 1)).split(","), Fn = 1;
      switch (Nn) {
        case "rgba":
          if (Rn.length !== 4)
            return Rn.length === 3 ? setRgba(nr, +Rn[0], +Rn[1], +Rn[2], 1) : setRgba(nr, 0, 0, 0, 1);
          Fn = parseCssFloat(Rn.pop());
        case "rgb":
          if (Rn.length >= 3)
            return setRgba(nr, parseCssInt(Rn[0]), parseCssInt(Rn[1]), parseCssInt(Rn[2]), Rn.length === 3 ? Fn : parseCssFloat(Rn[3])), putToCache(_n, nr), nr;
          setRgba(nr, 0, 0, 0, 1);
          return;
        case "hsla":
          if (Rn.length !== 4) {
            setRgba(nr, 0, 0, 0, 1);
            return;
          }
          return Rn[3] = parseCssFloat(Rn[3]), hsla2rgba(Rn, nr), putToCache(_n, nr), nr;
        case "hsl":
          if (Rn.length !== 3) {
            setRgba(nr, 0, 0, 0, 1);
            return;
          }
          return hsla2rgba(Rn, nr), putToCache(_n, nr), nr;
        default:
          return;
      }
    }
    setRgba(nr, 0, 0, 0, 1);
  }
}
function hsla2rgba(_n, nr) {
  var Cn = (parseFloat(_n[0]) % 360 + 360) % 360 / 360, Bn = parseCssFloat(_n[1]), In = parseCssFloat(_n[2]), Dn = In <= 0.5 ? In * (Bn + 1) : In + Bn - In * Bn, Ln = In * 2 - Dn;
  return nr = nr || [], setRgba(nr, clampCssByte(cssHueToRgb(Ln, Dn, Cn + 1 / 3) * 255), clampCssByte(cssHueToRgb(Ln, Dn, Cn) * 255), clampCssByte(cssHueToRgb(Ln, Dn, Cn - 1 / 3) * 255), 1), _n.length === 4 && (nr[3] = _n[3]), nr;
}
function rgba2hsla(_n) {
  if (_n) {
    var nr = _n[0] / 255, Cn = _n[1] / 255, Bn = _n[2] / 255, In = Math.min(nr, Cn, Bn), Dn = Math.max(nr, Cn, Bn), Ln = Dn - In, $n = (Dn + In) / 2, Nn, Rn;
    if (Ln === 0)
      Nn = 0, Rn = 0;
    else {
      $n < 0.5 ? Rn = Ln / (Dn + In) : Rn = Ln / (2 - Dn - In);
      var Fn = ((Dn - nr) / 6 + Ln / 2) / Ln, Pn = ((Dn - Cn) / 6 + Ln / 2) / Ln, Un = ((Dn - Bn) / 6 + Ln / 2) / Ln;
      nr === Dn ? Nn = Un - Pn : Cn === Dn ? Nn = 1 / 3 + Fn - Un : Bn === Dn && (Nn = 2 / 3 + Pn - Fn), Nn < 0 && (Nn += 1), Nn > 1 && (Nn -= 1);
    }
    var Hn = [Nn * 360, Rn, $n];
    return _n[3] != null && Hn.push(_n[3]), Hn;
  }
}
function lift(_n, nr) {
  var Cn = parse$2(_n);
  if (Cn) {
    for (var Bn = 0; Bn < 3; Bn++)
      nr < 0 ? Cn[Bn] = Cn[Bn] * (1 - nr) | 0 : Cn[Bn] = (255 - Cn[Bn]) * nr + Cn[Bn] | 0, Cn[Bn] > 255 ? Cn[Bn] = 255 : Cn[Bn] < 0 && (Cn[Bn] = 0);
    return stringify$1(Cn, Cn.length === 4 ? "rgba" : "rgb");
  }
}
function toHex(_n) {
  var nr = parse$2(_n);
  if (nr)
    return ((1 << 24) + (nr[0] << 16) + (nr[1] << 8) + +nr[2]).toString(16).slice(1);
}
function fastLerp(_n, nr, Cn) {
  if (!(!(nr && nr.length) || !(_n >= 0 && _n <= 1))) {
    Cn = Cn || [];
    var Bn = _n * (nr.length - 1), In = Math.floor(Bn), Dn = Math.ceil(Bn), Ln = nr[In], $n = nr[Dn], Nn = Bn - In;
    return Cn[0] = clampCssByte(lerpNumber(Ln[0], $n[0], Nn)), Cn[1] = clampCssByte(lerpNumber(Ln[1], $n[1], Nn)), Cn[2] = clampCssByte(lerpNumber(Ln[2], $n[2], Nn)), Cn[3] = clampCssFloat(lerpNumber(Ln[3], $n[3], Nn)), Cn;
  }
}
var fastMapToColor = fastLerp;
function lerp$1(_n, nr, Cn) {
  if (!(!(nr && nr.length) || !(_n >= 0 && _n <= 1))) {
    var Bn = _n * (nr.length - 1), In = Math.floor(Bn), Dn = Math.ceil(Bn), Ln = parse$2(nr[In]), $n = parse$2(nr[Dn]), Nn = Bn - In, Rn = stringify$1([
      clampCssByte(lerpNumber(Ln[0], $n[0], Nn)),
      clampCssByte(lerpNumber(Ln[1], $n[1], Nn)),
      clampCssByte(lerpNumber(Ln[2], $n[2], Nn)),
      clampCssFloat(lerpNumber(Ln[3], $n[3], Nn))
    ], "rgba");
    return Cn ? {
      color: Rn,
      leftIndex: In,
      rightIndex: Dn,
      value: Bn
    } : Rn;
  }
}
var mapToColor = lerp$1;
function modifyHSL(_n, nr, Cn, Bn) {
  var In = parse$2(_n);
  if (_n)
    return In = rgba2hsla(In), nr != null && (In[0] = clampCssAngle(nr)), Cn != null && (In[1] = parseCssFloat(Cn)), Bn != null && (In[2] = parseCssFloat(Bn)), stringify$1(hsla2rgba(In), "rgba");
}
function modifyAlpha(_n, nr) {
  var Cn = parse$2(_n);
  if (Cn && nr != null)
    return Cn[3] = clampCssFloat(nr), stringify$1(Cn, "rgba");
}
function stringify$1(_n, nr) {
  if (!(!_n || !_n.length)) {
    var Cn = _n[0] + "," + _n[1] + "," + _n[2];
    return (nr === "rgba" || nr === "hsva" || nr === "hsla") && (Cn += "," + _n[3]), nr + "(" + Cn + ")";
  }
}
function lum(_n, nr) {
  var Cn = parse$2(_n);
  return Cn ? (0.299 * Cn[0] + 0.587 * Cn[1] + 0.114 * Cn[2]) * Cn[3] / 255 + (1 - Cn[3]) * nr : 0;
}
function random() {
  return stringify$1([
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255)
  ], "rgb");
}
var liftedColorCache = new LRU$1(100);
function liftColor(_n) {
  if (isString$1(_n)) {
    var nr = liftedColorCache.get(_n);
    return nr || (nr = lift(_n, -0.1), liftedColorCache.put(_n, nr)), nr;
  } else if (isGradientObject(_n)) {
    var Cn = extend({}, _n);
    return Cn.colorStops = map$1(_n.colorStops, function(Bn) {
      return {
        offset: Bn.offset,
        color: lift(Bn.color, -0.1)
      };
    }), Cn;
  }
  return _n;
}
const color$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fastLerp,
  fastMapToColor,
  lerp: lerp$1,
  lift,
  liftColor,
  lum,
  mapToColor,
  modifyAlpha,
  modifyHSL,
  parse: parse$2,
  random,
  stringify: stringify$1,
  toHex
}, Symbol.toStringTag, { value: "Module" }));
var mathRound$1 = Math.round;
function normalizeColor(_n) {
  var nr;
  if (!_n || _n === "transparent")
    _n = "none";
  else if (typeof _n == "string" && _n.indexOf("rgba") > -1) {
    var Cn = parse$2(_n);
    Cn && (_n = "rgb(" + Cn[0] + "," + Cn[1] + "," + Cn[2] + ")", nr = Cn[3]);
  }
  return {
    color: _n,
    opacity: nr ?? 1
  };
}
var EPSILON$3 = 1e-4;
function isAroundZero(_n) {
  return _n < EPSILON$3 && _n > -EPSILON$3;
}
function round3(_n) {
  return mathRound$1(_n * 1e3) / 1e3;
}
function round4(_n) {
  return mathRound$1(_n * 1e4) / 1e4;
}
function getMatrixStr(_n) {
  return "matrix(" + round3(_n[0]) + "," + round3(_n[1]) + "," + round3(_n[2]) + "," + round3(_n[3]) + "," + round4(_n[4]) + "," + round4(_n[5]) + ")";
}
var TEXT_ALIGN_TO_ANCHOR = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function adjustTextY$1(_n, nr, Cn) {
  return Cn === "top" ? _n += nr / 2 : Cn === "bottom" && (_n -= nr / 2), _n;
}
function hasShadow(_n) {
  return _n && (_n.shadowBlur || _n.shadowOffsetX || _n.shadowOffsetY);
}
function getShadowKey(_n) {
  var nr = _n.style, Cn = _n.getGlobalScale();
  return [
    nr.shadowColor,
    (nr.shadowBlur || 0).toFixed(2),
    (nr.shadowOffsetX || 0).toFixed(2),
    (nr.shadowOffsetY || 0).toFixed(2),
    Cn[0],
    Cn[1]
  ].join(",");
}
function isImagePattern(_n) {
  return _n && !!_n.image;
}
function isSVGPattern(_n) {
  return _n && !!_n.svgElement;
}
function isPattern(_n) {
  return isImagePattern(_n) || isSVGPattern(_n);
}
function isLinearGradient$1(_n) {
  return _n.type === "linear";
}
function isRadialGradient$1(_n) {
  return _n.type === "radial";
}
function isGradient(_n) {
  return _n && (_n.type === "linear" || _n.type === "radial");
}
function getIdURL(_n) {
  return "url(#" + _n + ")";
}
function getPathPrecision(_n) {
  var nr = _n.getGlobalScale(), Cn = Math.max(nr[0], nr[1]);
  return Math.max(Math.ceil(Math.log(Cn) / Math.log(10)), 1);
}
function getSRTTransformString(_n) {
  var nr = _n.x || 0, Cn = _n.y || 0, Bn = (_n.rotation || 0) * RADIAN_TO_DEGREE, In = retrieve2(_n.scaleX, 1), Dn = retrieve2(_n.scaleY, 1), Ln = _n.skewX || 0, $n = _n.skewY || 0, Nn = [];
  return (nr || Cn) && Nn.push("translate(" + nr + "px," + Cn + "px)"), Bn && Nn.push("rotate(" + Bn + ")"), (In !== 1 || Dn !== 1) && Nn.push("scale(" + In + "," + Dn + ")"), (Ln || $n) && Nn.push("skew(" + mathRound$1(Ln * RADIAN_TO_DEGREE) + "deg, " + mathRound$1($n * RADIAN_TO_DEGREE) + "deg)"), Nn.join(" ");
}
var encodeBase64 = function() {
  return env$1.hasGlobalWindow && isFunction$1(window.btoa) ? function(_n) {
    return window.btoa(unescape(encodeURIComponent(_n)));
  } : typeof Buffer < "u" ? function(_n) {
    return Buffer.from(_n).toString("base64");
  } : function(_n) {
    return process.env.NODE_ENV !== "production" && logError("Base64 isn't natively supported in the current environment."), null;
  };
}(), arraySlice = Array.prototype.slice;
function interpolateNumber$1(_n, nr, Cn) {
  return (nr - _n) * Cn + _n;
}
function interpolate1DArray(_n, nr, Cn, Bn) {
  for (var In = nr.length, Dn = 0; Dn < In; Dn++)
    _n[Dn] = interpolateNumber$1(nr[Dn], Cn[Dn], Bn);
  return _n;
}
function interpolate2DArray(_n, nr, Cn, Bn) {
  for (var In = nr.length, Dn = In && nr[0].length, Ln = 0; Ln < In; Ln++) {
    _n[Ln] || (_n[Ln] = []);
    for (var $n = 0; $n < Dn; $n++)
      _n[Ln][$n] = interpolateNumber$1(nr[Ln][$n], Cn[Ln][$n], Bn);
  }
  return _n;
}
function add1DArray(_n, nr, Cn, Bn) {
  for (var In = nr.length, Dn = 0; Dn < In; Dn++)
    _n[Dn] = nr[Dn] + Cn[Dn] * Bn;
  return _n;
}
function add2DArray(_n, nr, Cn, Bn) {
  for (var In = nr.length, Dn = In && nr[0].length, Ln = 0; Ln < In; Ln++) {
    _n[Ln] || (_n[Ln] = []);
    for (var $n = 0; $n < Dn; $n++)
      _n[Ln][$n] = nr[Ln][$n] + Cn[Ln][$n] * Bn;
  }
  return _n;
}
function fillColorStops(_n, nr) {
  for (var Cn = _n.length, Bn = nr.length, In = Cn > Bn ? nr : _n, Dn = Math.min(Cn, Bn), Ln = In[Dn - 1] || { color: [0, 0, 0, 0], offset: 0 }, $n = Dn; $n < Math.max(Cn, Bn); $n++)
    In.push({
      offset: Ln.offset,
      color: Ln.color.slice()
    });
}
function fillArray(_n, nr, Cn) {
  var Bn = _n, In = nr;
  if (!(!Bn.push || !In.push)) {
    var Dn = Bn.length, Ln = In.length;
    if (Dn !== Ln) {
      var $n = Dn > Ln;
      if ($n)
        Bn.length = Ln;
      else
        for (var Nn = Dn; Nn < Ln; Nn++)
          Bn.push(Cn === 1 ? In[Nn] : arraySlice.call(In[Nn]));
    }
    for (var Rn = Bn[0] && Bn[0].length, Nn = 0; Nn < Bn.length; Nn++)
      if (Cn === 1)
        isNaN(Bn[Nn]) && (Bn[Nn] = In[Nn]);
      else
        for (var Fn = 0; Fn < Rn; Fn++)
          isNaN(Bn[Nn][Fn]) && (Bn[Nn][Fn] = In[Nn][Fn]);
  }
}
function cloneValue(_n) {
  if (isArrayLike$1(_n)) {
    var nr = _n.length;
    if (isArrayLike$1(_n[0])) {
      for (var Cn = [], Bn = 0; Bn < nr; Bn++)
        Cn.push(arraySlice.call(_n[Bn]));
      return Cn;
    }
    return arraySlice.call(_n);
  }
  return _n;
}
function rgba2String(_n) {
  return _n[0] = Math.floor(_n[0]) || 0, _n[1] = Math.floor(_n[1]) || 0, _n[2] = Math.floor(_n[2]) || 0, _n[3] = _n[3] == null ? 1 : _n[3], "rgba(" + _n.join(",") + ")";
}
function guessArrayDim(_n) {
  return isArrayLike$1(_n && _n[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0, VALUE_TYPE_1D_ARRAY = 1, VALUE_TYPE_2D_ARRAY = 2, VALUE_TYPE_COLOR = 3, VALUE_TYPE_LINEAR_GRADIENT = 4, VALUE_TYPE_RADIAL_GRADIENT = 5, VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(_n) {
  return _n === VALUE_TYPE_LINEAR_GRADIENT || _n === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(_n) {
  return _n === VALUE_TYPE_1D_ARRAY || _n === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0], Track = function() {
  function _n(nr) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = nr;
  }
  return _n.prototype.isFinished = function() {
    return this._finished;
  }, _n.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, _n.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, _n.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, _n.prototype.addKeyframe = function(nr, Cn, Bn) {
    this._needsSort = !0;
    var In = this.keyframes, Dn = In.length, Ln = !1, $n = VALUE_TYPE_UNKOWN, Nn = Cn;
    if (isArrayLike$1(Cn)) {
      var Rn = guessArrayDim(Cn);
      $n = Rn, (Rn === 1 && !isNumber(Cn[0]) || Rn === 2 && !isNumber(Cn[0][0])) && (Ln = !0);
    } else if (isNumber(Cn) && !eqNaN(Cn))
      $n = VALUE_TYPE_NUMBER;
    else if (isString$1(Cn))
      if (!isNaN(+Cn))
        $n = VALUE_TYPE_NUMBER;
      else {
        var Fn = parse$2(Cn);
        Fn && (Nn = Fn, $n = VALUE_TYPE_COLOR);
      }
    else if (isGradientObject(Cn)) {
      var Pn = extend({}, Nn);
      Pn.colorStops = map$1(Cn.colorStops, function(Hn) {
        return {
          offset: Hn.offset,
          color: parse$2(Hn.color)
        };
      }), isLinearGradient$1(Cn) ? $n = VALUE_TYPE_LINEAR_GRADIENT : isRadialGradient$1(Cn) && ($n = VALUE_TYPE_RADIAL_GRADIENT), Nn = Pn;
    }
    Dn === 0 ? this.valType = $n : ($n !== this.valType || $n === VALUE_TYPE_UNKOWN) && (Ln = !0), this.discrete = this.discrete || Ln;
    var Un = {
      time: nr,
      value: Nn,
      rawValue: Cn,
      percent: 0
    };
    return Bn && (Un.easing = Bn, Un.easingFunc = isFunction$1(Bn) ? Bn : easingFuncs$1[Bn] || createCubicEasingFunc(Bn)), In.push(Un), Un;
  }, _n.prototype.prepare = function(nr, Cn) {
    var Bn = this.keyframes;
    this._needsSort && Bn.sort(function(Gn, Yn) {
      return Gn.time - Yn.time;
    });
    for (var In = this.valType, Dn = Bn.length, Ln = Bn[Dn - 1], $n = this.discrete, Nn = isArrayValueType(In), Rn = isGradientValueType(In), Fn = 0; Fn < Dn; Fn++) {
      var Pn = Bn[Fn], Un = Pn.value, Hn = Ln.value;
      Pn.percent = Pn.time / nr, $n || (Nn && Fn !== Dn - 1 ? fillArray(Un, Hn, In) : Rn && fillColorStops(Un.colorStops, Hn.colorStops));
    }
    if (!$n && In !== VALUE_TYPE_RADIAL_GRADIENT && Cn && this.needsAnimate() && Cn.needsAnimate() && In === Cn.valType && !Cn._finished) {
      this._additiveTrack = Cn;
      for (var zn = Bn[0].value, Fn = 0; Fn < Dn; Fn++)
        In === VALUE_TYPE_NUMBER ? Bn[Fn].additiveValue = Bn[Fn].value - zn : In === VALUE_TYPE_COLOR ? Bn[Fn].additiveValue = add1DArray([], Bn[Fn].value, zn, -1) : isArrayValueType(In) && (Bn[Fn].additiveValue = In === VALUE_TYPE_1D_ARRAY ? add1DArray([], Bn[Fn].value, zn, -1) : add2DArray([], Bn[Fn].value, zn, -1));
    }
  }, _n.prototype.step = function(nr, Cn) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var Bn = this._additiveTrack != null, In = Bn ? "additiveValue" : "value", Dn = this.valType, Ln = this.keyframes, $n = Ln.length, Nn = this.propName, Rn = Dn === VALUE_TYPE_COLOR, Fn, Pn = this._lastFr, Un = Math.min, Hn, zn;
      if ($n === 1)
        Hn = zn = Ln[0];
      else {
        if (Cn < 0)
          Fn = 0;
        else if (Cn < this._lastFrP) {
          var Gn = Un(Pn + 1, $n - 1);
          for (Fn = Gn; Fn >= 0 && !(Ln[Fn].percent <= Cn); Fn--)
            ;
          Fn = Un(Fn, $n - 2);
        } else {
          for (Fn = Pn; Fn < $n && !(Ln[Fn].percent > Cn); Fn++)
            ;
          Fn = Un(Fn - 1, $n - 2);
        }
        zn = Ln[Fn + 1], Hn = Ln[Fn];
      }
      if (Hn && zn) {
        this._lastFr = Fn, this._lastFrP = Cn;
        var Yn = zn.percent - Hn.percent, Wn = Yn === 0 ? 1 : Un((Cn - Hn.percent) / Yn, 1);
        zn.easingFunc && (Wn = zn.easingFunc(Wn));
        var Xn = Bn ? this._additiveValue : Rn ? tmpRgba : nr[Nn];
        if ((isArrayValueType(Dn) || Rn) && !Xn && (Xn = this._additiveValue = []), this.discrete)
          nr[Nn] = Wn < 1 ? Hn.rawValue : zn.rawValue;
        else if (isArrayValueType(Dn))
          Dn === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(Xn, Hn[In], zn[In], Wn) : interpolate2DArray(Xn, Hn[In], zn[In], Wn);
        else if (isGradientValueType(Dn)) {
          var ea = Hn[In], ta = zn[In], na = Dn === VALUE_TYPE_LINEAR_GRADIENT;
          nr[Nn] = {
            type: na ? "linear" : "radial",
            x: interpolateNumber$1(ea.x, ta.x, Wn),
            y: interpolateNumber$1(ea.y, ta.y, Wn),
            colorStops: map$1(ea.colorStops, function(aa, ia) {
              var Aa = ta.colorStops[ia];
              return {
                offset: interpolateNumber$1(aa.offset, Aa.offset, Wn),
                color: rgba2String(interpolate1DArray([], aa.color, Aa.color, Wn))
              };
            }),
            global: ta.global
          }, na ? (nr[Nn].x2 = interpolateNumber$1(ea.x2, ta.x2, Wn), nr[Nn].y2 = interpolateNumber$1(ea.y2, ta.y2, Wn)) : nr[Nn].r = interpolateNumber$1(ea.r, ta.r, Wn);
        } else if (Rn)
          interpolate1DArray(Xn, Hn[In], zn[In], Wn), Bn || (nr[Nn] = rgba2String(Xn));
        else {
          var ra = interpolateNumber$1(Hn[In], zn[In], Wn);
          Bn ? this._additiveValue = ra : nr[Nn] = ra;
        }
        Bn && this._addToTarget(nr);
      }
    }
  }, _n.prototype._addToTarget = function(nr) {
    var Cn = this.valType, Bn = this.propName, In = this._additiveValue;
    Cn === VALUE_TYPE_NUMBER ? nr[Bn] = nr[Bn] + In : Cn === VALUE_TYPE_COLOR ? (parse$2(nr[Bn], tmpRgba), add1DArray(tmpRgba, tmpRgba, In, 1), nr[Bn] = rgba2String(tmpRgba)) : Cn === VALUE_TYPE_1D_ARRAY ? add1DArray(nr[Bn], nr[Bn], In, 1) : Cn === VALUE_TYPE_2D_ARRAY && add2DArray(nr[Bn], nr[Bn], In, 1);
  }, _n;
}(), Animator = function() {
  function _n(nr, Cn, Bn, In) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = nr, this._loop = Cn, Cn && In) {
      logError("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = In, this._allowDiscrete = Bn;
  }
  return _n.prototype.getMaxTime = function() {
    return this._maxTime;
  }, _n.prototype.getDelay = function() {
    return this._delay;
  }, _n.prototype.getLoop = function() {
    return this._loop;
  }, _n.prototype.getTarget = function() {
    return this._target;
  }, _n.prototype.changeTarget = function(nr) {
    this._target = nr;
  }, _n.prototype.when = function(nr, Cn, Bn) {
    return this.whenWithKeys(nr, Cn, keys(Cn), Bn);
  }, _n.prototype.whenWithKeys = function(nr, Cn, Bn, In) {
    for (var Dn = this._tracks, Ln = 0; Ln < Bn.length; Ln++) {
      var $n = Bn[Ln], Nn = Dn[$n];
      if (!Nn) {
        Nn = Dn[$n] = new Track($n);
        var Rn = void 0, Fn = this._getAdditiveTrack($n);
        if (Fn) {
          var Pn = Fn.keyframes, Un = Pn[Pn.length - 1];
          Rn = Un && Un.value, Fn.valType === VALUE_TYPE_COLOR && Rn && (Rn = rgba2String(Rn));
        } else
          Rn = this._target[$n];
        if (Rn == null)
          continue;
        nr > 0 && Nn.addKeyframe(0, cloneValue(Rn), In), this._trackKeys.push($n);
      }
      Nn.addKeyframe(nr, cloneValue(Cn[$n]), In);
    }
    return this._maxTime = Math.max(this._maxTime, nr), this;
  }, _n.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, _n.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, _n.prototype.isPaused = function() {
    return !!this._paused;
  }, _n.prototype.duration = function(nr) {
    return this._maxTime = nr, this._force = !0, this;
  }, _n.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var nr = this._doneCbs;
    if (nr)
      for (var Cn = nr.length, Bn = 0; Bn < Cn; Bn++)
        nr[Bn].call(this);
  }, _n.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var nr = this.animation, Cn = this._abortedCbs;
    if (nr && nr.removeClip(this._clip), this._clip = null, Cn)
      for (var Bn = 0; Bn < Cn.length; Bn++)
        Cn[Bn].call(this);
  }, _n.prototype._setTracksFinished = function() {
    for (var nr = this._tracks, Cn = this._trackKeys, Bn = 0; Bn < Cn.length; Bn++)
      nr[Cn[Bn]].setFinished();
  }, _n.prototype._getAdditiveTrack = function(nr) {
    var Cn, Bn = this._additiveAnimators;
    if (Bn)
      for (var In = 0; In < Bn.length; In++) {
        var Dn = Bn[In].getTrack(nr);
        Dn && (Cn = Dn);
      }
    return Cn;
  }, _n.prototype.start = function(nr) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var Cn = this, Bn = [], In = this._maxTime || 0, Dn = 0; Dn < this._trackKeys.length; Dn++) {
        var Ln = this._trackKeys[Dn], $n = this._tracks[Ln], Nn = this._getAdditiveTrack(Ln), Rn = $n.keyframes, Fn = Rn.length;
        if ($n.prepare(In, Nn), $n.needsAnimate())
          if (!this._allowDiscrete && $n.discrete) {
            var Pn = Rn[Fn - 1];
            Pn && (Cn._target[$n.propName] = Pn.rawValue), $n.setFinished();
          } else
            Bn.push($n);
      }
      if (Bn.length || this._force) {
        var Un = new Clip$1({
          life: In,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(Hn) {
            Cn._started = 2;
            var zn = Cn._additiveAnimators;
            if (zn) {
              for (var Gn = !1, Yn = 0; Yn < zn.length; Yn++)
                if (zn[Yn]._clip) {
                  Gn = !0;
                  break;
                }
              Gn || (Cn._additiveAnimators = null);
            }
            for (var Yn = 0; Yn < Bn.length; Yn++)
              Bn[Yn].step(Cn._target, Hn);
            var Wn = Cn._onframeCbs;
            if (Wn)
              for (var Yn = 0; Yn < Wn.length; Yn++)
                Wn[Yn](Cn._target, Hn);
          },
          ondestroy: function() {
            Cn._doneCallback();
          }
        });
        this._clip = Un, this.animation && this.animation.addClip(Un), nr && Un.setEasing(nr);
      } else
        this._doneCallback();
      return this;
    }
  }, _n.prototype.stop = function(nr) {
    if (this._clip) {
      var Cn = this._clip;
      nr && Cn.onframe(1), this._abortedCallback();
    }
  }, _n.prototype.delay = function(nr) {
    return this._delay = nr, this;
  }, _n.prototype.during = function(nr) {
    return nr && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(nr)), this;
  }, _n.prototype.done = function(nr) {
    return nr && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(nr)), this;
  }, _n.prototype.aborted = function(nr) {
    return nr && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(nr)), this;
  }, _n.prototype.getClip = function() {
    return this._clip;
  }, _n.prototype.getTrack = function(nr) {
    return this._tracks[nr];
  }, _n.prototype.getTracks = function() {
    var nr = this;
    return map$1(this._trackKeys, function(Cn) {
      return nr._tracks[Cn];
    });
  }, _n.prototype.stopTracks = function(nr, Cn) {
    if (!nr.length || !this._clip)
      return !0;
    for (var Bn = this._tracks, In = this._trackKeys, Dn = 0; Dn < nr.length; Dn++) {
      var Ln = Bn[nr[Dn]];
      Ln && !Ln.isFinished() && (Cn ? Ln.step(this._target, 1) : this._started === 1 && Ln.step(this._target, 0), Ln.setFinished());
    }
    for (var $n = !0, Dn = 0; Dn < In.length; Dn++)
      if (!Bn[In[Dn]].isFinished()) {
        $n = !1;
        break;
      }
    return $n && this._abortedCallback(), $n;
  }, _n.prototype.saveTo = function(nr, Cn, Bn) {
    if (nr) {
      Cn = Cn || this._trackKeys;
      for (var In = 0; In < Cn.length; In++) {
        var Dn = Cn[In], Ln = this._tracks[Dn];
        if (!(!Ln || Ln.isFinished())) {
          var $n = Ln.keyframes, Nn = $n[Bn ? 0 : $n.length - 1];
          Nn && (nr[Dn] = cloneValue(Nn.rawValue));
        }
      }
    }
  }, _n.prototype.__changeFinalValue = function(nr, Cn) {
    Cn = Cn || keys(nr);
    for (var Bn = 0; Bn < Cn.length; Bn++) {
      var In = Cn[Bn], Dn = this._tracks[In];
      if (Dn) {
        var Ln = Dn.keyframes;
        if (Ln.length > 1) {
          var $n = Ln.pop();
          Dn.addKeyframe($n.time, nr[In]), Dn.prepare(this._maxTime, Dn.getAdditiveTrack());
        }
      }
    }
  }, _n;
}();
const Animator$1 = Animator;
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var Animation = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    var Bn = _n.call(this) || this;
    return Bn._running = !1, Bn._time = 0, Bn._pausedTime = 0, Bn._pauseStart = 0, Bn._paused = !1, Cn = Cn || {}, Bn.stage = Cn.stage || {}, Bn;
  }
  return nr.prototype.addClip = function(Cn) {
    Cn.animation && this.removeClip(Cn), this._head ? (this._tail.next = Cn, Cn.prev = this._tail, Cn.next = null, this._tail = Cn) : this._head = this._tail = Cn, Cn.animation = this;
  }, nr.prototype.addAnimator = function(Cn) {
    Cn.animation = this;
    var Bn = Cn.getClip();
    Bn && this.addClip(Bn);
  }, nr.prototype.removeClip = function(Cn) {
    if (Cn.animation) {
      var Bn = Cn.prev, In = Cn.next;
      Bn ? Bn.next = In : this._head = In, In ? In.prev = Bn : this._tail = Bn, Cn.next = Cn.prev = Cn.animation = null;
    }
  }, nr.prototype.removeAnimator = function(Cn) {
    var Bn = Cn.getClip();
    Bn && this.removeClip(Bn), Cn.animation = null;
  }, nr.prototype.update = function(Cn) {
    for (var Bn = getTime() - this._pausedTime, In = Bn - this._time, Dn = this._head; Dn; ) {
      var Ln = Dn.next, $n = Dn.step(Bn, In);
      $n && (Dn.ondestroy(), this.removeClip(Dn)), Dn = Ln;
    }
    this._time = Bn, Cn || (this.trigger("frame", In), this.stage.update && this.stage.update());
  }, nr.prototype._startLoop = function() {
    var Cn = this;
    this._running = !0;
    function Bn() {
      Cn._running && (requestAnimationFrame$2(Bn), !Cn._paused && Cn.update());
    }
    requestAnimationFrame$2(Bn);
  }, nr.prototype.start = function() {
    this._running || (this._time = getTime(), this._pausedTime = 0, this._startLoop());
  }, nr.prototype.stop = function() {
    this._running = !1;
  }, nr.prototype.pause = function() {
    this._paused || (this._pauseStart = getTime(), this._paused = !0);
  }, nr.prototype.resume = function() {
    this._paused && (this._pausedTime += getTime() - this._pauseStart, this._paused = !1);
  }, nr.prototype.clear = function() {
    for (var Cn = this._head; Cn; ) {
      var Bn = Cn.next;
      Cn.prev = Cn.next = Cn.animation = null, Cn = Bn;
    }
    this._head = this._tail = null;
  }, nr.prototype.isFinished = function() {
    return this._head == null;
  }, nr.prototype.animate = function(Cn, Bn) {
    Bn = Bn || {}, this.start();
    var In = new Animator$1(Cn, Bn.loop);
    return this.addAnimator(In), In;
  }, nr;
}(Eventful$1);
const Animation$1 = Animation;
var TOUCH_CLICK_DELAY = 300, globalEventSupported = env$1.domSupported, localNativeListenerNames = function() {
  var _n = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], nr = [
    "touchstart",
    "touchend",
    "touchmove"
  ], Cn = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, Bn = map$1(_n, function(In) {
    var Dn = In.replace("mouse", "pointer");
    return Cn.hasOwnProperty(Dn) ? Dn : In;
  });
  return {
    mouse: _n,
    touch: nr,
    pointer: Bn
  };
}(), globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, wheelEventSupported = !1;
function isPointerFromTouch(_n) {
  var nr = _n.pointerType;
  return nr === "pen" || nr === "touch";
}
function setTouchTimer(_n) {
  _n.touching = !0, _n.touchTimer != null && (clearTimeout(_n.touchTimer), _n.touchTimer = null), _n.touchTimer = setTimeout(function() {
    _n.touching = !1, _n.touchTimer = null;
  }, 700);
}
function markTouch(_n) {
  _n && (_n.zrByTouch = !0);
}
function normalizeGlobalEvent(_n, nr) {
  return normalizeEvent(_n.dom, new FakeGlobalEvent(_n, nr), !0);
}
function isLocalEl(_n, nr) {
  for (var Cn = nr, Bn = !1; Cn && Cn.nodeType !== 9 && !(Bn = Cn.domBelongToZr || Cn !== nr && Cn === _n.painterRoot); )
    Cn = Cn.parentNode;
  return Bn;
}
var FakeGlobalEvent = function() {
  function _n(nr, Cn) {
    this.stopPropagation = noop$1, this.stopImmediatePropagation = noop$1, this.preventDefault = noop$1, this.type = Cn.type, this.target = this.currentTarget = nr.dom, this.pointerType = Cn.pointerType, this.clientX = Cn.clientX, this.clientY = Cn.clientY;
  }
  return _n;
}(), localDOMHandlers = {
  mousedown: function(_n) {
    _n = normalizeEvent(this.dom, _n), this.__mayPointerCapture = [_n.zrX, _n.zrY], this.trigger("mousedown", _n);
  },
  mousemove: function(_n) {
    _n = normalizeEvent(this.dom, _n);
    var nr = this.__mayPointerCapture;
    nr && (_n.zrX !== nr[0] || _n.zrY !== nr[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", _n);
  },
  mouseup: function(_n) {
    _n = normalizeEvent(this.dom, _n), this.__togglePointerCapture(!1), this.trigger("mouseup", _n);
  },
  mouseout: function(_n) {
    _n = normalizeEvent(this.dom, _n);
    var nr = _n.toElement || _n.relatedTarget;
    isLocalEl(this, nr) || (this.__pointerCapturing && (_n.zrEventControl = "no_globalout"), this.trigger("mouseout", _n));
  },
  wheel: function(_n) {
    wheelEventSupported = !0, _n = normalizeEvent(this.dom, _n), this.trigger("mousewheel", _n);
  },
  mousewheel: function(_n) {
    wheelEventSupported || (_n = normalizeEvent(this.dom, _n), this.trigger("mousewheel", _n));
  },
  touchstart: function(_n) {
    _n = normalizeEvent(this.dom, _n), markTouch(_n), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(_n, "start"), localDOMHandlers.mousemove.call(this, _n), localDOMHandlers.mousedown.call(this, _n);
  },
  touchmove: function(_n) {
    _n = normalizeEvent(this.dom, _n), markTouch(_n), this.handler.processGesture(_n, "change"), localDOMHandlers.mousemove.call(this, _n);
  },
  touchend: function(_n) {
    _n = normalizeEvent(this.dom, _n), markTouch(_n), this.handler.processGesture(_n, "end"), localDOMHandlers.mouseup.call(this, _n), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY && localDOMHandlers.click.call(this, _n);
  },
  pointerdown: function(_n) {
    localDOMHandlers.mousedown.call(this, _n);
  },
  pointermove: function(_n) {
    isPointerFromTouch(_n) || localDOMHandlers.mousemove.call(this, _n);
  },
  pointerup: function(_n) {
    localDOMHandlers.mouseup.call(this, _n);
  },
  pointerout: function(_n) {
    isPointerFromTouch(_n) || localDOMHandlers.mouseout.call(this, _n);
  }
};
each$f(["click", "dblclick", "contextmenu"], function(_n) {
  localDOMHandlers[_n] = function(nr) {
    nr = normalizeEvent(this.dom, nr), this.trigger(_n, nr);
  };
});
var globalDOMHandlers = {
  pointermove: function(_n) {
    isPointerFromTouch(_n) || globalDOMHandlers.mousemove.call(this, _n);
  },
  pointerup: function(_n) {
    globalDOMHandlers.mouseup.call(this, _n);
  },
  mousemove: function(_n) {
    this.trigger("mousemove", _n);
  },
  mouseup: function(_n) {
    var nr = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", _n), nr && (_n.zrEventControl = "only_globalout", this.trigger("mouseout", _n));
  }
};
function mountLocalDOMEventListeners(_n, nr) {
  var Cn = nr.domHandlers;
  env$1.pointerEventsSupported ? each$f(localNativeListenerNames.pointer, function(Bn) {
    mountSingleDOMEventListener(nr, Bn, function(In) {
      Cn[Bn].call(_n, In);
    });
  }) : (env$1.touchEventsSupported && each$f(localNativeListenerNames.touch, function(Bn) {
    mountSingleDOMEventListener(nr, Bn, function(In) {
      Cn[Bn].call(_n, In), setTouchTimer(nr);
    });
  }), each$f(localNativeListenerNames.mouse, function(Bn) {
    mountSingleDOMEventListener(nr, Bn, function(In) {
      In = getNativeEvent(In), nr.touching || Cn[Bn].call(_n, In);
    });
  }));
}
function mountGlobalDOMEventListeners(_n, nr) {
  env$1.pointerEventsSupported ? each$f(globalNativeListenerNames.pointer, Cn) : env$1.touchEventsSupported || each$f(globalNativeListenerNames.mouse, Cn);
  function Cn(Bn) {
    function In(Dn) {
      Dn = getNativeEvent(Dn), isLocalEl(_n, Dn.target) || (Dn = normalizeGlobalEvent(_n, Dn), nr.domHandlers[Bn].call(_n, Dn));
    }
    mountSingleDOMEventListener(nr, Bn, In, { capture: !0 });
  }
}
function mountSingleDOMEventListener(_n, nr, Cn, Bn) {
  _n.mounted[nr] = Cn, _n.listenerOpts[nr] = Bn, addEventListener(_n.domTarget, nr, Cn, Bn);
}
function unmountDOMEventListeners(_n) {
  var nr = _n.mounted;
  for (var Cn in nr)
    nr.hasOwnProperty(Cn) && removeEventListener(_n.domTarget, Cn, nr[Cn], _n.listenerOpts[Cn]);
  _n.mounted = {};
}
var DOMHandlerScope = function() {
  function _n(nr, Cn) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = nr, this.domHandlers = Cn;
  }
  return _n;
}(), HandlerDomProxy = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn, Bn) {
    var In = _n.call(this) || this;
    return In.__pointerCapturing = !1, In.dom = Cn, In.painterRoot = Bn, In._localHandlerScope = new DOMHandlerScope(Cn, localDOMHandlers), globalEventSupported && (In._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers)), mountLocalDOMEventListeners(In, In._localHandlerScope), In;
  }
  return nr.prototype.dispose = function() {
    unmountDOMEventListeners(this._localHandlerScope), globalEventSupported && unmountDOMEventListeners(this._globalHandlerScope);
  }, nr.prototype.setCursor = function(Cn) {
    this.dom.style && (this.dom.style.cursor = Cn || "default");
  }, nr.prototype.__togglePointerCapture = function(Cn) {
    if (this.__mayPointerCapture = null, globalEventSupported && +this.__pointerCapturing ^ +Cn) {
      this.__pointerCapturing = Cn;
      var Bn = this._globalHandlerScope;
      Cn ? mountGlobalDOMEventListeners(this, Bn) : unmountDOMEventListeners(Bn);
    }
  }, nr;
}(Eventful$1);
const HandlerProxy = HandlerDomProxy;
var dpr = 1;
env$1.hasGlobalWindow && (dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var devicePixelRatio = dpr, DARK_MODE_THRESHOLD = 0.4, DARK_LABEL_COLOR = "#333", LIGHT_LABEL_COLOR = "#ccc", LIGHTER_LABEL_COLOR = "#eee", mIdentity = identity$1, EPSILON$2 = 5e-5;
function isNotAroundZero(_n) {
  return _n > EPSILON$2 || _n < -EPSILON$2;
}
var scaleTmp = [], tmpTransform = [], originTransform = create$1(), abs = Math.abs, Transformable = function() {
  function _n() {
  }
  return _n.prototype.getLocalTransform = function(nr) {
    return _n.getLocalTransform(this, nr);
  }, _n.prototype.setPosition = function(nr) {
    this.x = nr[0], this.y = nr[1];
  }, _n.prototype.setScale = function(nr) {
    this.scaleX = nr[0], this.scaleY = nr[1];
  }, _n.prototype.setSkew = function(nr) {
    this.skewX = nr[0], this.skewY = nr[1];
  }, _n.prototype.setOrigin = function(nr) {
    this.originX = nr[0], this.originY = nr[1];
  }, _n.prototype.needLocalTransform = function() {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
  }, _n.prototype.updateTransform = function() {
    var nr = this.parent && this.parent.transform, Cn = this.needLocalTransform(), Bn = this.transform;
    if (!(Cn || nr)) {
      Bn && (mIdentity(Bn), this.invTransform = null);
      return;
    }
    Bn = Bn || create$1(), Cn ? this.getLocalTransform(Bn) : mIdentity(Bn), nr && (Cn ? mul(Bn, nr, Bn) : copy(Bn, nr)), this.transform = Bn, this._resolveGlobalScaleRatio(Bn);
  }, _n.prototype._resolveGlobalScaleRatio = function(nr) {
    var Cn = this.globalScaleRatio;
    if (Cn != null && Cn !== 1) {
      this.getGlobalScale(scaleTmp);
      var Bn = scaleTmp[0] < 0 ? -1 : 1, In = scaleTmp[1] < 0 ? -1 : 1, Dn = ((scaleTmp[0] - Bn) * Cn + Bn) / scaleTmp[0] || 0, Ln = ((scaleTmp[1] - In) * Cn + In) / scaleTmp[1] || 0;
      nr[0] *= Dn, nr[1] *= Dn, nr[2] *= Ln, nr[3] *= Ln;
    }
    this.invTransform = this.invTransform || create$1(), invert(this.invTransform, nr);
  }, _n.prototype.getComputedTransform = function() {
    for (var nr = this, Cn = []; nr; )
      Cn.push(nr), nr = nr.parent;
    for (; nr = Cn.pop(); )
      nr.updateTransform();
    return this.transform;
  }, _n.prototype.setLocalTransform = function(nr) {
    if (nr) {
      var Cn = nr[0] * nr[0] + nr[1] * nr[1], Bn = nr[2] * nr[2] + nr[3] * nr[3], In = Math.atan2(nr[1], nr[0]), Dn = Math.PI / 2 + In - Math.atan2(nr[3], nr[2]);
      Bn = Math.sqrt(Bn) * Math.cos(Dn), Cn = Math.sqrt(Cn), this.skewX = Dn, this.skewY = 0, this.rotation = -In, this.x = +nr[4], this.y = +nr[5], this.scaleX = Cn, this.scaleY = Bn, this.originX = 0, this.originY = 0;
    }
  }, _n.prototype.decomposeTransform = function() {
    if (this.transform) {
      var nr = this.parent, Cn = this.transform;
      nr && nr.transform && (nr.invTransform = nr.invTransform || create$1(), mul(tmpTransform, nr.invTransform, Cn), Cn = tmpTransform);
      var Bn = this.originX, In = this.originY;
      (Bn || In) && (originTransform[4] = Bn, originTransform[5] = In, mul(tmpTransform, Cn, originTransform), tmpTransform[4] -= Bn, tmpTransform[5] -= In, Cn = tmpTransform), this.setLocalTransform(Cn);
    }
  }, _n.prototype.getGlobalScale = function(nr) {
    var Cn = this.transform;
    return nr = nr || [], Cn ? (nr[0] = Math.sqrt(Cn[0] * Cn[0] + Cn[1] * Cn[1]), nr[1] = Math.sqrt(Cn[2] * Cn[2] + Cn[3] * Cn[3]), Cn[0] < 0 && (nr[0] = -nr[0]), Cn[3] < 0 && (nr[1] = -nr[1]), nr) : (nr[0] = 1, nr[1] = 1, nr);
  }, _n.prototype.transformCoordToLocal = function(nr, Cn) {
    var Bn = [nr, Cn], In = this.invTransform;
    return In && applyTransform$1(Bn, Bn, In), Bn;
  }, _n.prototype.transformCoordToGlobal = function(nr, Cn) {
    var Bn = [nr, Cn], In = this.transform;
    return In && applyTransform$1(Bn, Bn, In), Bn;
  }, _n.prototype.getLineScale = function() {
    var nr = this.transform;
    return nr && abs(nr[0] - 1) > 1e-10 && abs(nr[3] - 1) > 1e-10 ? Math.sqrt(abs(nr[0] * nr[3] - nr[2] * nr[1])) : 1;
  }, _n.prototype.copyTransform = function(nr) {
    copyTransform(this, nr);
  }, _n.getLocalTransform = function(nr, Cn) {
    Cn = Cn || [];
    var Bn = nr.originX || 0, In = nr.originY || 0, Dn = nr.scaleX, Ln = nr.scaleY, $n = nr.anchorX, Nn = nr.anchorY, Rn = nr.rotation || 0, Fn = nr.x, Pn = nr.y, Un = nr.skewX ? Math.tan(nr.skewX) : 0, Hn = nr.skewY ? Math.tan(-nr.skewY) : 0;
    if (Bn || In || $n || Nn) {
      var zn = Bn + $n, Gn = In + Nn;
      Cn[4] = -zn * Dn - Un * Gn * Ln, Cn[5] = -Gn * Ln - Hn * zn * Dn;
    } else
      Cn[4] = Cn[5] = 0;
    return Cn[0] = Dn, Cn[3] = Ln, Cn[1] = Hn * Dn, Cn[2] = Un * Ln, Rn && rotate(Cn, Cn, Rn), Cn[4] += Bn + Fn, Cn[5] += In + Pn, Cn;
  }, _n.initDefaultProps = function() {
    var nr = _n.prototype;
    nr.scaleX = nr.scaleY = nr.globalScaleRatio = 1, nr.x = nr.y = nr.originX = nr.originY = nr.skewX = nr.skewY = nr.rotation = nr.anchorX = nr.anchorY = 0;
  }(), _n;
}(), TRANSFORMABLE_PROPS = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function copyTransform(_n, nr) {
  for (var Cn = 0; Cn < TRANSFORMABLE_PROPS.length; Cn++) {
    var Bn = TRANSFORMABLE_PROPS[Cn];
    _n[Bn] = nr[Bn];
  }
}
const Transformable$1 = Transformable;
var textWidthCache = {};
function getWidth(_n, nr) {
  nr = nr || DEFAULT_FONT;
  var Cn = textWidthCache[nr];
  Cn || (Cn = textWidthCache[nr] = new LRU$1(500));
  var Bn = Cn.get(_n);
  return Bn == null && (Bn = platformApi.measureText(_n, nr).width, Cn.put(_n, Bn)), Bn;
}
function innerGetBoundingRect(_n, nr, Cn, Bn) {
  var In = getWidth(_n, nr), Dn = getLineHeight(nr), Ln = adjustTextX(0, In, Cn), $n = adjustTextY(0, Dn, Bn), Nn = new BoundingRect$1(Ln, $n, In, Dn);
  return Nn;
}
function getBoundingRect(_n, nr, Cn, Bn) {
  var In = ((_n || "") + "").split(`
`), Dn = In.length;
  if (Dn === 1)
    return innerGetBoundingRect(In[0], nr, Cn, Bn);
  for (var Ln = new BoundingRect$1(0, 0, 0, 0), $n = 0; $n < In.length; $n++) {
    var Nn = innerGetBoundingRect(In[$n], nr, Cn, Bn);
    $n === 0 ? Ln.copy(Nn) : Ln.union(Nn);
  }
  return Ln;
}
function adjustTextX(_n, nr, Cn) {
  return Cn === "right" ? _n -= nr : Cn === "center" && (_n -= nr / 2), _n;
}
function adjustTextY(_n, nr, Cn) {
  return Cn === "middle" ? _n -= nr / 2 : Cn === "bottom" && (_n -= nr), _n;
}
function getLineHeight(_n) {
  return getWidth("国", _n);
}
function parsePercent$1(_n, nr) {
  return typeof _n == "string" ? _n.lastIndexOf("%") >= 0 ? parseFloat(_n) / 100 * nr : parseFloat(_n) : _n;
}
function calculateTextPosition(_n, nr, Cn) {
  var Bn = nr.position || "inside", In = nr.distance != null ? nr.distance : 5, Dn = Cn.height, Ln = Cn.width, $n = Dn / 2, Nn = Cn.x, Rn = Cn.y, Fn = "left", Pn = "top";
  if (Bn instanceof Array)
    Nn += parsePercent$1(Bn[0], Cn.width), Rn += parsePercent$1(Bn[1], Cn.height), Fn = null, Pn = null;
  else
    switch (Bn) {
      case "left":
        Nn -= In, Rn += $n, Fn = "right", Pn = "middle";
        break;
      case "right":
        Nn += In + Ln, Rn += $n, Pn = "middle";
        break;
      case "top":
        Nn += Ln / 2, Rn -= In, Fn = "center", Pn = "bottom";
        break;
      case "bottom":
        Nn += Ln / 2, Rn += Dn + In, Fn = "center";
        break;
      case "inside":
        Nn += Ln / 2, Rn += $n, Fn = "center", Pn = "middle";
        break;
      case "insideLeft":
        Nn += In, Rn += $n, Pn = "middle";
        break;
      case "insideRight":
        Nn += Ln - In, Rn += $n, Fn = "right", Pn = "middle";
        break;
      case "insideTop":
        Nn += Ln / 2, Rn += In, Fn = "center";
        break;
      case "insideBottom":
        Nn += Ln / 2, Rn += Dn - In, Fn = "center", Pn = "bottom";
        break;
      case "insideTopLeft":
        Nn += In, Rn += In;
        break;
      case "insideTopRight":
        Nn += Ln - In, Rn += In, Fn = "right";
        break;
      case "insideBottomLeft":
        Nn += In, Rn += Dn - In, Pn = "bottom";
        break;
      case "insideBottomRight":
        Nn += Ln - In, Rn += Dn - In, Fn = "right", Pn = "bottom";
        break;
    }
  return _n = _n || {}, _n.x = Nn, _n.y = Rn, _n.align = Fn, _n.verticalAlign = Pn, _n;
}
var PRESERVED_NORMAL_STATE = "__zr_normal__", PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]), DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(_n, nr) {
  return _n[nr] = !0, _n;
}, { ignore: !1 }), tmpTextPosCalcRes = {}, tmpBoundingRect = new BoundingRect$1(0, 0, 0, 0), Element$1 = function() {
  function _n(nr) {
    this.id = guid(), this.animators = [], this.currentStates = [], this.states = {}, this._init(nr);
  }
  return _n.prototype._init = function(nr) {
    this.attr(nr);
  }, _n.prototype.drift = function(nr, Cn, Bn) {
    switch (this.draggable) {
      case "horizontal":
        Cn = 0;
        break;
      case "vertical":
        nr = 0;
        break;
    }
    var In = this.transform;
    In || (In = this.transform = [1, 0, 0, 1, 0, 0]), In[4] += nr, In[5] += Cn, this.decomposeTransform(), this.markRedraw();
  }, _n.prototype.beforeUpdate = function() {
  }, _n.prototype.afterUpdate = function() {
  }, _n.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, _n.prototype.updateInnerText = function(nr) {
    var Cn = this._textContent;
    if (Cn && (!Cn.ignore || nr)) {
      this.textConfig || (this.textConfig = {});
      var Bn = this.textConfig, In = Bn.local, Dn = Cn.innerTransformable, Ln = void 0, $n = void 0, Nn = !1;
      Dn.parent = In ? this : null;
      var Rn = !1;
      if (Dn.copyTransform(Cn), Bn.position != null) {
        var Fn = tmpBoundingRect;
        Bn.layoutRect ? Fn.copy(Bn.layoutRect) : Fn.copy(this.getBoundingRect()), In || Fn.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(tmpTextPosCalcRes, Bn, Fn) : calculateTextPosition(tmpTextPosCalcRes, Bn, Fn), Dn.x = tmpTextPosCalcRes.x, Dn.y = tmpTextPosCalcRes.y, Ln = tmpTextPosCalcRes.align, $n = tmpTextPosCalcRes.verticalAlign;
        var Pn = Bn.origin;
        if (Pn && Bn.rotation != null) {
          var Un = void 0, Hn = void 0;
          Pn === "center" ? (Un = Fn.width * 0.5, Hn = Fn.height * 0.5) : (Un = parsePercent$1(Pn[0], Fn.width), Hn = parsePercent$1(Pn[1], Fn.height)), Rn = !0, Dn.originX = -Dn.x + Un + (In ? 0 : Fn.x), Dn.originY = -Dn.y + Hn + (In ? 0 : Fn.y);
        }
      }
      Bn.rotation != null && (Dn.rotation = Bn.rotation);
      var zn = Bn.offset;
      zn && (Dn.x += zn[0], Dn.y += zn[1], Rn || (Dn.originX = -zn[0], Dn.originY = -zn[1]));
      var Gn = Bn.inside == null ? typeof Bn.position == "string" && Bn.position.indexOf("inside") >= 0 : Bn.inside, Yn = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), Wn = void 0, Xn = void 0, ea = void 0;
      Gn && this.canBeInsideText() ? (Wn = Bn.insideFill, Xn = Bn.insideStroke, (Wn == null || Wn === "auto") && (Wn = this.getInsideTextFill()), (Xn == null || Xn === "auto") && (Xn = this.getInsideTextStroke(Wn), ea = !0)) : (Wn = Bn.outsideFill, Xn = Bn.outsideStroke, (Wn == null || Wn === "auto") && (Wn = this.getOutsideFill()), (Xn == null || Xn === "auto") && (Xn = this.getOutsideStroke(Wn), ea = !0)), Wn = Wn || "#000", (Wn !== Yn.fill || Xn !== Yn.stroke || ea !== Yn.autoStroke || Ln !== Yn.align || $n !== Yn.verticalAlign) && (Nn = !0, Yn.fill = Wn, Yn.stroke = Xn, Yn.autoStroke = ea, Yn.align = Ln, Yn.verticalAlign = $n, Cn.setDefaultTextStyle(Yn)), Cn.__dirty |= REDRAW_BIT, Nn && Cn.dirtyStyle(!0);
    }
  }, _n.prototype.canBeInsideText = function() {
    return !0;
  }, _n.prototype.getInsideTextFill = function() {
    return "#fff";
  }, _n.prototype.getInsideTextStroke = function(nr) {
    return "#000";
  }, _n.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
  }, _n.prototype.getOutsideStroke = function(nr) {
    var Cn = this.__zr && this.__zr.getBackgroundColor(), Bn = typeof Cn == "string" && parse$2(Cn);
    Bn || (Bn = [255, 255, 255, 1]);
    for (var In = Bn[3], Dn = this.__zr.isDarkMode(), Ln = 0; Ln < 3; Ln++)
      Bn[Ln] = Bn[Ln] * In + (Dn ? 0 : 255) * (1 - In);
    return Bn[3] = 1, stringify$1(Bn, "rgba");
  }, _n.prototype.traverse = function(nr, Cn) {
  }, _n.prototype.attrKV = function(nr, Cn) {
    nr === "textConfig" ? this.setTextConfig(Cn) : nr === "textContent" ? this.setTextContent(Cn) : nr === "clipPath" ? this.setClipPath(Cn) : nr === "extra" ? (this.extra = this.extra || {}, extend(this.extra, Cn)) : this[nr] = Cn;
  }, _n.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, _n.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, _n.prototype.attr = function(nr, Cn) {
    if (typeof nr == "string")
      this.attrKV(nr, Cn);
    else if (isObject$6(nr))
      for (var Bn = nr, In = keys(Bn), Dn = 0; Dn < In.length; Dn++) {
        var Ln = In[Dn];
        this.attrKV(Ln, nr[Ln]);
      }
    return this.markRedraw(), this;
  }, _n.prototype.saveCurrentToNormalState = function(nr) {
    this._innerSaveToNormal(nr);
    for (var Cn = this._normalState, Bn = 0; Bn < this.animators.length; Bn++) {
      var In = this.animators[Bn], Dn = In.__fromStateTransition;
      if (!(In.getLoop() || Dn && Dn !== PRESERVED_NORMAL_STATE)) {
        var Ln = In.targetName, $n = Ln ? Cn[Ln] : Cn;
        In.saveTo($n);
      }
    }
  }, _n.prototype._innerSaveToNormal = function(nr) {
    var Cn = this._normalState;
    Cn || (Cn = this._normalState = {}), nr.textConfig && !Cn.textConfig && (Cn.textConfig = this.textConfig), this._savePrimaryToNormal(nr, Cn, PRIMARY_STATES_KEYS$1);
  }, _n.prototype._savePrimaryToNormal = function(nr, Cn, Bn) {
    for (var In = 0; In < Bn.length; In++) {
      var Dn = Bn[In];
      nr[Dn] != null && !(Dn in Cn) && (Cn[Dn] = this[Dn]);
    }
  }, _n.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, _n.prototype.getState = function(nr) {
    return this.states[nr];
  }, _n.prototype.ensureState = function(nr) {
    var Cn = this.states;
    return Cn[nr] || (Cn[nr] = {}), Cn[nr];
  }, _n.prototype.clearStates = function(nr) {
    this.useState(PRESERVED_NORMAL_STATE, !1, nr);
  }, _n.prototype.useState = function(nr, Cn, Bn, In) {
    var Dn = nr === PRESERVED_NORMAL_STATE, Ln = this.hasState();
    if (!(!Ln && Dn)) {
      var $n = this.currentStates, Nn = this.stateTransition;
      if (!(indexOf($n, nr) >= 0 && (Cn || $n.length === 1))) {
        var Rn;
        if (this.stateProxy && !Dn && (Rn = this.stateProxy(nr)), Rn || (Rn = this.states && this.states[nr]), !Rn && !Dn) {
          logError("State " + nr + " not exists.");
          return;
        }
        Dn || this.saveCurrentToNormalState(Rn);
        var Fn = !!(Rn && Rn.hoverLayer || In);
        Fn && this._toggleHoverLayerFlag(!0), this._applyStateObj(nr, Rn, this._normalState, Cn, !Bn && !this.__inHover && Nn && Nn.duration > 0, Nn);
        var Pn = this._textContent, Un = this._textGuide;
        return Pn && Pn.useState(nr, Cn, Bn, Fn), Un && Un.useState(nr, Cn, Bn, Fn), Dn ? (this.currentStates = [], this._normalState = {}) : Cn ? this.currentStates.push(nr) : this.currentStates = [nr], this._updateAnimationTargets(), this.markRedraw(), !Fn && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~REDRAW_BIT), Rn;
      }
    }
  }, _n.prototype.useStates = function(nr, Cn, Bn) {
    if (!nr.length)
      this.clearStates();
    else {
      var In = [], Dn = this.currentStates, Ln = nr.length, $n = Ln === Dn.length;
      if ($n) {
        for (var Nn = 0; Nn < Ln; Nn++)
          if (nr[Nn] !== Dn[Nn]) {
            $n = !1;
            break;
          }
      }
      if ($n)
        return;
      for (var Nn = 0; Nn < Ln; Nn++) {
        var Rn = nr[Nn], Fn = void 0;
        this.stateProxy && (Fn = this.stateProxy(Rn, nr)), Fn || (Fn = this.states[Rn]), Fn && In.push(Fn);
      }
      var Pn = In[Ln - 1], Un = !!(Pn && Pn.hoverLayer || Bn);
      Un && this._toggleHoverLayerFlag(!0);
      var Hn = this._mergeStates(In), zn = this.stateTransition;
      this.saveCurrentToNormalState(Hn), this._applyStateObj(nr.join(","), Hn, this._normalState, !1, !Cn && !this.__inHover && zn && zn.duration > 0, zn);
      var Gn = this._textContent, Yn = this._textGuide;
      Gn && Gn.useStates(nr, Cn, Un), Yn && Yn.useStates(nr, Cn, Un), this._updateAnimationTargets(), this.currentStates = nr.slice(), this.markRedraw(), !Un && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~REDRAW_BIT);
    }
  }, _n.prototype.isSilent = function() {
    for (var nr = this.silent, Cn = this.parent; !nr && Cn; ) {
      if (Cn.silent) {
        nr = !0;
        break;
      }
      Cn = Cn.parent;
    }
    return nr;
  }, _n.prototype._updateAnimationTargets = function() {
    for (var nr = 0; nr < this.animators.length; nr++) {
      var Cn = this.animators[nr];
      Cn.targetName && Cn.changeTarget(this[Cn.targetName]);
    }
  }, _n.prototype.removeState = function(nr) {
    var Cn = indexOf(this.currentStates, nr);
    if (Cn >= 0) {
      var Bn = this.currentStates.slice();
      Bn.splice(Cn, 1), this.useStates(Bn);
    }
  }, _n.prototype.replaceState = function(nr, Cn, Bn) {
    var In = this.currentStates.slice(), Dn = indexOf(In, nr), Ln = indexOf(In, Cn) >= 0;
    Dn >= 0 ? Ln ? In.splice(Dn, 1) : In[Dn] = Cn : Bn && !Ln && In.push(Cn), this.useStates(In);
  }, _n.prototype.toggleState = function(nr, Cn) {
    Cn ? this.useState(nr, !0) : this.removeState(nr);
  }, _n.prototype._mergeStates = function(nr) {
    for (var Cn = {}, Bn, In = 0; In < nr.length; In++) {
      var Dn = nr[In];
      extend(Cn, Dn), Dn.textConfig && (Bn = Bn || {}, extend(Bn, Dn.textConfig));
    }
    return Bn && (Cn.textConfig = Bn), Cn;
  }, _n.prototype._applyStateObj = function(nr, Cn, Bn, In, Dn, Ln) {
    var $n = !(Cn && In);
    Cn && Cn.textConfig ? (this.textConfig = extend({}, In ? this.textConfig : Bn.textConfig), extend(this.textConfig, Cn.textConfig)) : $n && Bn.textConfig && (this.textConfig = Bn.textConfig);
    for (var Nn = {}, Rn = !1, Fn = 0; Fn < PRIMARY_STATES_KEYS$1.length; Fn++) {
      var Pn = PRIMARY_STATES_KEYS$1[Fn], Un = Dn && DEFAULT_ANIMATABLE_MAP[Pn];
      Cn && Cn[Pn] != null ? Un ? (Rn = !0, Nn[Pn] = Cn[Pn]) : this[Pn] = Cn[Pn] : $n && Bn[Pn] != null && (Un ? (Rn = !0, Nn[Pn] = Bn[Pn]) : this[Pn] = Bn[Pn]);
    }
    if (!Dn)
      for (var Fn = 0; Fn < this.animators.length; Fn++) {
        var Hn = this.animators[Fn], zn = Hn.targetName;
        Hn.getLoop() || Hn.__changeFinalValue(zn ? (Cn || Bn)[zn] : Cn || Bn);
      }
    Rn && this._transitionState(nr, Nn, Ln);
  }, _n.prototype._attachComponent = function(nr) {
    if (nr.__zr && !nr.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (nr === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var Cn = this.__zr;
    Cn && nr.addSelfToZr(Cn), nr.__zr = Cn, nr.__hostTarget = this;
  }, _n.prototype._detachComponent = function(nr) {
    nr.__zr && nr.removeSelfFromZr(nr.__zr), nr.__zr = null, nr.__hostTarget = null;
  }, _n.prototype.getClipPath = function() {
    return this._clipPath;
  }, _n.prototype.setClipPath = function(nr) {
    this._clipPath && this._clipPath !== nr && this.removeClipPath(), this._attachComponent(nr), this._clipPath = nr, this.markRedraw();
  }, _n.prototype.removeClipPath = function() {
    var nr = this._clipPath;
    nr && (this._detachComponent(nr), this._clipPath = null, this.markRedraw());
  }, _n.prototype.getTextContent = function() {
    return this._textContent;
  }, _n.prototype.setTextContent = function(nr) {
    var Cn = this._textContent;
    if (Cn !== nr) {
      if (Cn && Cn !== nr && this.removeTextContent(), process.env.NODE_ENV !== "production" && nr.__zr && !nr.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      nr.innerTransformable = new Transformable$1(), this._attachComponent(nr), this._textContent = nr, this.markRedraw();
    }
  }, _n.prototype.setTextConfig = function(nr) {
    this.textConfig || (this.textConfig = {}), extend(this.textConfig, nr), this.markRedraw();
  }, _n.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, _n.prototype.removeTextContent = function() {
    var nr = this._textContent;
    nr && (nr.innerTransformable = null, this._detachComponent(nr), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, _n.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, _n.prototype.setTextGuideLine = function(nr) {
    this._textGuide && this._textGuide !== nr && this.removeTextGuideLine(), this._attachComponent(nr), this._textGuide = nr, this.markRedraw();
  }, _n.prototype.removeTextGuideLine = function() {
    var nr = this._textGuide;
    nr && (this._detachComponent(nr), this._textGuide = null, this.markRedraw());
  }, _n.prototype.markRedraw = function() {
    this.__dirty |= REDRAW_BIT;
    var nr = this.__zr;
    nr && (this.__inHover ? nr.refreshHover() : nr.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, _n.prototype.dirty = function() {
    this.markRedraw();
  }, _n.prototype._toggleHoverLayerFlag = function(nr) {
    this.__inHover = nr;
    var Cn = this._textContent, Bn = this._textGuide;
    Cn && (Cn.__inHover = nr), Bn && (Bn.__inHover = nr);
  }, _n.prototype.addSelfToZr = function(nr) {
    if (this.__zr !== nr) {
      this.__zr = nr;
      var Cn = this.animators;
      if (Cn)
        for (var Bn = 0; Bn < Cn.length; Bn++)
          nr.animation.addAnimator(Cn[Bn]);
      this._clipPath && this._clipPath.addSelfToZr(nr), this._textContent && this._textContent.addSelfToZr(nr), this._textGuide && this._textGuide.addSelfToZr(nr);
    }
  }, _n.prototype.removeSelfFromZr = function(nr) {
    if (this.__zr) {
      this.__zr = null;
      var Cn = this.animators;
      if (Cn)
        for (var Bn = 0; Bn < Cn.length; Bn++)
          nr.animation.removeAnimator(Cn[Bn]);
      this._clipPath && this._clipPath.removeSelfFromZr(nr), this._textContent && this._textContent.removeSelfFromZr(nr), this._textGuide && this._textGuide.removeSelfFromZr(nr);
    }
  }, _n.prototype.animate = function(nr, Cn, Bn) {
    var In = nr ? this[nr] : this;
    if (process.env.NODE_ENV !== "production" && !In) {
      logError('Property "' + nr + '" is not existed in element ' + this.id);
      return;
    }
    var Dn = new Animator$1(In, Cn, Bn);
    return nr && (Dn.targetName = nr), this.addAnimator(Dn, nr), Dn;
  }, _n.prototype.addAnimator = function(nr, Cn) {
    var Bn = this.__zr, In = this;
    nr.during(function() {
      In.updateDuringAnimation(Cn);
    }).done(function() {
      var Dn = In.animators, Ln = indexOf(Dn, nr);
      Ln >= 0 && Dn.splice(Ln, 1);
    }), this.animators.push(nr), Bn && Bn.animation.addAnimator(nr), Bn && Bn.wakeUp();
  }, _n.prototype.updateDuringAnimation = function(nr) {
    this.markRedraw();
  }, _n.prototype.stopAnimation = function(nr, Cn) {
    for (var Bn = this.animators, In = Bn.length, Dn = [], Ln = 0; Ln < In; Ln++) {
      var $n = Bn[Ln];
      !nr || nr === $n.scope ? $n.stop(Cn) : Dn.push($n);
    }
    return this.animators = Dn, this;
  }, _n.prototype.animateTo = function(nr, Cn, Bn) {
    animateTo(this, nr, Cn, Bn);
  }, _n.prototype.animateFrom = function(nr, Cn, Bn) {
    animateTo(this, nr, Cn, Bn, !0);
  }, _n.prototype._transitionState = function(nr, Cn, Bn, In) {
    for (var Dn = animateTo(this, Cn, Bn, In), Ln = 0; Ln < Dn.length; Ln++)
      Dn[Ln].__fromStateTransition = nr;
  }, _n.prototype.getBoundingRect = function() {
    return null;
  }, _n.prototype.getPaintRect = function() {
    return null;
  }, _n.initDefaultProps = function() {
    var nr = _n.prototype;
    nr.type = "element", nr.name = "", nr.ignore = nr.silent = nr.isGroup = nr.draggable = nr.dragging = nr.ignoreClip = nr.__inHover = !1, nr.__dirty = REDRAW_BIT;
    var Cn = {};
    function Bn(Dn, Ln, $n) {
      Cn[Dn + Ln + $n] || (console.warn("DEPRECATED: '" + Dn + "' has been deprecated. use '" + Ln + "', '" + $n + "' instead"), Cn[Dn + Ln + $n] = !0);
    }
    function In(Dn, Ln, $n, Nn) {
      Object.defineProperty(nr, Dn, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && Bn(Dn, $n, Nn), !this[Ln]) {
            var Fn = this[Ln] = [];
            Rn(this, Fn);
          }
          return this[Ln];
        },
        set: function(Fn) {
          process.env.NODE_ENV !== "production" && Bn(Dn, $n, Nn), this[$n] = Fn[0], this[Nn] = Fn[1], this[Ln] = Fn, Rn(this, Fn);
        }
      });
      function Rn(Fn, Pn) {
        Object.defineProperty(Pn, 0, {
          get: function() {
            return Fn[$n];
          },
          set: function(Un) {
            Fn[$n] = Un;
          }
        }), Object.defineProperty(Pn, 1, {
          get: function() {
            return Fn[Nn];
          },
          set: function(Un) {
            Fn[Nn] = Un;
          }
        });
      }
    }
    Object.defineProperty && (In("position", "_legacyPos", "x", "y"), In("scale", "_legacyScale", "scaleX", "scaleY"), In("origin", "_legacyOrigin", "originX", "originY"));
  }(), _n;
}();
mixin(Element$1, Eventful$1);
mixin(Element$1, Transformable$1);
function animateTo(_n, nr, Cn, Bn, In) {
  Cn = Cn || {};
  var Dn = [];
  animateToShallow(_n, "", _n, nr, Cn, Bn, Dn, In);
  var Ln = Dn.length, $n = !1, Nn = Cn.done, Rn = Cn.aborted, Fn = function() {
    $n = !0, Ln--, Ln <= 0 && ($n ? Nn && Nn() : Rn && Rn());
  }, Pn = function() {
    Ln--, Ln <= 0 && ($n ? Nn && Nn() : Rn && Rn());
  };
  Ln || Nn && Nn(), Dn.length > 0 && Cn.during && Dn[0].during(function(zn, Gn) {
    Cn.during(Gn);
  });
  for (var Un = 0; Un < Dn.length; Un++) {
    var Hn = Dn[Un];
    Fn && Hn.done(Fn), Pn && Hn.aborted(Pn), Cn.force && Hn.duration(Cn.duration), Hn.start(Cn.easing);
  }
  return Dn;
}
function copyArrShallow(_n, nr, Cn) {
  for (var Bn = 0; Bn < Cn; Bn++)
    _n[Bn] = nr[Bn];
}
function is2DArray(_n) {
  return isArrayLike$1(_n[0]);
}
function copyValue(_n, nr, Cn) {
  if (isArrayLike$1(nr[Cn]))
    if (isArrayLike$1(_n[Cn]) || (_n[Cn] = []), isTypedArray$2(nr[Cn])) {
      var Bn = nr[Cn].length;
      _n[Cn].length !== Bn && (_n[Cn] = new nr[Cn].constructor(Bn), copyArrShallow(_n[Cn], nr[Cn], Bn));
    } else {
      var In = nr[Cn], Dn = _n[Cn], Ln = In.length;
      if (is2DArray(In))
        for (var $n = In[0].length, Nn = 0; Nn < Ln; Nn++)
          Dn[Nn] ? copyArrShallow(Dn[Nn], In[Nn], $n) : Dn[Nn] = Array.prototype.slice.call(In[Nn]);
      else
        copyArrShallow(Dn, In, Ln);
      Dn.length = In.length;
    }
  else
    _n[Cn] = nr[Cn];
}
function isValueSame(_n, nr) {
  return _n === nr || isArrayLike$1(_n) && isArrayLike$1(nr) && is1DArraySame(_n, nr);
}
function is1DArraySame(_n, nr) {
  var Cn = _n.length;
  if (Cn !== nr.length)
    return !1;
  for (var Bn = 0; Bn < Cn; Bn++)
    if (_n[Bn] !== nr[Bn])
      return !1;
  return !0;
}
function animateToShallow(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  for (var Nn = keys(Bn), Rn = In.duration, Fn = In.delay, Pn = In.additive, Un = In.setToFinal, Hn = !isObject$6(Dn), zn = _n.animators, Gn = [], Yn = 0; Yn < Nn.length; Yn++) {
    var Wn = Nn[Yn], Xn = Bn[Wn];
    if (Xn != null && Cn[Wn] != null && (Hn || Dn[Wn]))
      if (isObject$6(Xn) && !isArrayLike$1(Xn) && !isGradientObject(Xn)) {
        if (nr) {
          $n || (Cn[Wn] = Xn, _n.updateDuringAnimation(nr));
          continue;
        }
        animateToShallow(_n, Wn, Cn[Wn], Xn, In, Dn && Dn[Wn], Ln, $n);
      } else
        Gn.push(Wn);
    else
      $n || (Cn[Wn] = Xn, _n.updateDuringAnimation(nr), Gn.push(Wn));
  }
  var ea = Gn.length;
  if (!Pn && ea)
    for (var ta = 0; ta < zn.length; ta++) {
      var na = zn[ta];
      if (na.targetName === nr) {
        var ra = na.stopTracks(Gn);
        if (ra) {
          var aa = indexOf(zn, na);
          zn.splice(aa, 1);
        }
      }
    }
  if (In.force || (Gn = filter(Gn, function(oa) {
    return !isValueSame(Bn[oa], Cn[oa]);
  }), ea = Gn.length), ea > 0 || In.force && !Ln.length) {
    var ia = void 0, Aa = void 0, sa = void 0;
    if ($n) {
      Aa = {}, Un && (ia = {});
      for (var ta = 0; ta < ea; ta++) {
        var Wn = Gn[ta];
        Aa[Wn] = Cn[Wn], Un ? ia[Wn] = Bn[Wn] : Cn[Wn] = Bn[Wn];
      }
    } else if (Un) {
      sa = {};
      for (var ta = 0; ta < ea; ta++) {
        var Wn = Gn[ta];
        sa[Wn] = cloneValue(Cn[Wn]), copyValue(Cn, Bn, Wn);
      }
    }
    var na = new Animator$1(Cn, !1, !1, Pn ? filter(zn, function(la) {
      return la.targetName === nr;
    }) : null);
    na.targetName = nr, In.scope && (na.scope = In.scope), Un && ia && na.whenWithKeys(0, ia, Gn), sa && na.whenWithKeys(0, sa, Gn), na.whenWithKeys(Rn ?? 500, $n ? Aa : Bn, Gn).delay(Fn || 0), _n.addAnimator(na, nr), Ln.push(na);
  }
}
const Element$2 = Element$1;
var Group$3 = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    var Bn = _n.call(this) || this;
    return Bn.isGroup = !0, Bn._children = [], Bn.attr(Cn), Bn;
  }
  return nr.prototype.childrenRef = function() {
    return this._children;
  }, nr.prototype.children = function() {
    return this._children.slice();
  }, nr.prototype.childAt = function(Cn) {
    return this._children[Cn];
  }, nr.prototype.childOfName = function(Cn) {
    for (var Bn = this._children, In = 0; In < Bn.length; In++)
      if (Bn[In].name === Cn)
        return Bn[In];
  }, nr.prototype.childCount = function() {
    return this._children.length;
  }, nr.prototype.add = function(Cn) {
    if (Cn && (Cn !== this && Cn.parent !== this && (this._children.push(Cn), this._doAdd(Cn)), process.env.NODE_ENV !== "production" && Cn.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, nr.prototype.addBefore = function(Cn, Bn) {
    if (Cn && Cn !== this && Cn.parent !== this && Bn && Bn.parent === this) {
      var In = this._children, Dn = In.indexOf(Bn);
      Dn >= 0 && (In.splice(Dn, 0, Cn), this._doAdd(Cn));
    }
    return this;
  }, nr.prototype.replace = function(Cn, Bn) {
    var In = indexOf(this._children, Cn);
    return In >= 0 && this.replaceAt(Bn, In), this;
  }, nr.prototype.replaceAt = function(Cn, Bn) {
    var In = this._children, Dn = In[Bn];
    if (Cn && Cn !== this && Cn.parent !== this && Cn !== Dn) {
      In[Bn] = Cn, Dn.parent = null;
      var Ln = this.__zr;
      Ln && Dn.removeSelfFromZr(Ln), this._doAdd(Cn);
    }
    return this;
  }, nr.prototype._doAdd = function(Cn) {
    Cn.parent && Cn.parent.remove(Cn), Cn.parent = this;
    var Bn = this.__zr;
    Bn && Bn !== Cn.__zr && Cn.addSelfToZr(Bn), Bn && Bn.refresh();
  }, nr.prototype.remove = function(Cn) {
    var Bn = this.__zr, In = this._children, Dn = indexOf(In, Cn);
    return Dn < 0 ? this : (In.splice(Dn, 1), Cn.parent = null, Bn && Cn.removeSelfFromZr(Bn), Bn && Bn.refresh(), this);
  }, nr.prototype.removeAll = function() {
    for (var Cn = this._children, Bn = this.__zr, In = 0; In < Cn.length; In++) {
      var Dn = Cn[In];
      Bn && Dn.removeSelfFromZr(Bn), Dn.parent = null;
    }
    return Cn.length = 0, this;
  }, nr.prototype.eachChild = function(Cn, Bn) {
    for (var In = this._children, Dn = 0; Dn < In.length; Dn++) {
      var Ln = In[Dn];
      Cn.call(Bn, Ln, Dn);
    }
    return this;
  }, nr.prototype.traverse = function(Cn, Bn) {
    for (var In = 0; In < this._children.length; In++) {
      var Dn = this._children[In], Ln = Cn.call(Bn, Dn);
      Dn.isGroup && !Ln && Dn.traverse(Cn, Bn);
    }
    return this;
  }, nr.prototype.addSelfToZr = function(Cn) {
    _n.prototype.addSelfToZr.call(this, Cn);
    for (var Bn = 0; Bn < this._children.length; Bn++) {
      var In = this._children[Bn];
      In.addSelfToZr(Cn);
    }
  }, nr.prototype.removeSelfFromZr = function(Cn) {
    _n.prototype.removeSelfFromZr.call(this, Cn);
    for (var Bn = 0; Bn < this._children.length; Bn++) {
      var In = this._children[Bn];
      In.removeSelfFromZr(Cn);
    }
  }, nr.prototype.getBoundingRect = function(Cn) {
    for (var Bn = new BoundingRect$1(0, 0, 0, 0), In = Cn || this._children, Dn = [], Ln = null, $n = 0; $n < In.length; $n++) {
      var Nn = In[$n];
      if (!(Nn.ignore || Nn.invisible)) {
        var Rn = Nn.getBoundingRect(), Fn = Nn.getLocalTransform(Dn);
        Fn ? (BoundingRect$1.applyTransform(Bn, Rn, Fn), Ln = Ln || Bn.clone(), Ln.union(Bn)) : (Ln = Ln || Rn.clone(), Ln.union(Rn));
      }
    }
    return Ln || Bn;
  }, nr;
}(Element$2);
Group$3.prototype.type = "group";
const Group$4 = Group$3;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {}, instances$1 = {};
function delInstance(_n) {
  delete instances$1[_n];
}
function isDarkMode(_n) {
  if (!_n)
    return !1;
  if (typeof _n == "string")
    return lum(_n, 1) < DARK_MODE_THRESHOLD;
  if (_n.colorStops) {
    for (var nr = _n.colorStops, Cn = 0, Bn = nr.length, In = 0; In < Bn; In++)
      Cn += lum(nr[In].color, 1);
    return Cn /= Bn, Cn < DARK_MODE_THRESHOLD;
  }
  return !1;
}
var ZRender = function() {
  function _n(nr, Cn, Bn) {
    var In = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, Bn = Bn || {}, this.dom = Cn, this.id = nr;
    var Dn = new Storage$1(), Ln = Bn.renderer || "canvas";
    if (painterCtors[Ln] || (Ln = keys(painterCtors)[0]), process.env.NODE_ENV !== "production" && !painterCtors[Ln])
      throw new Error("Renderer '" + Ln + "' is not imported. Please import it first.");
    Bn.useDirtyRect = Bn.useDirtyRect == null ? !1 : Bn.useDirtyRect;
    var $n = new painterCtors[Ln](Cn, Dn, Bn, nr), Nn = Bn.ssr || $n.ssrOnly;
    this.storage = Dn, this.painter = $n;
    var Rn = !env$1.node && !env$1.worker && !Nn ? new HandlerProxy($n.getViewportRoot(), $n.root) : null, Fn = Bn.useCoarsePointer, Pn = Fn == null || Fn === "auto" ? env$1.touchEventsSupported : !!Fn, Un = 44, Hn;
    Pn && (Hn = retrieve2(Bn.pointerSize, Un)), this.handler = new Handler$1(Dn, $n, Rn, $n.root, Hn), this.animation = new Animation$1({
      stage: {
        update: Nn ? null : function() {
          return In._flush(!0);
        }
      }
    }), Nn || this.animation.start();
  }
  return _n.prototype.add = function(nr) {
    this._disposed || !nr || (this.storage.addRoot(nr), nr.addSelfToZr(this), this.refresh());
  }, _n.prototype.remove = function(nr) {
    this._disposed || !nr || (this.storage.delRoot(nr), nr.removeSelfFromZr(this), this.refresh());
  }, _n.prototype.configLayer = function(nr, Cn) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(nr, Cn), this.refresh());
  }, _n.prototype.setBackgroundColor = function(nr) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(nr), this.refresh(), this._backgroundColor = nr, this._darkMode = isDarkMode(nr));
  }, _n.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, _n.prototype.setDarkMode = function(nr) {
    this._darkMode = nr;
  }, _n.prototype.isDarkMode = function() {
    return this._darkMode;
  }, _n.prototype.refreshImmediately = function(nr) {
    this._disposed || (nr || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, _n.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, _n.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, _n.prototype._flush = function(nr) {
    var Cn, Bn = getTime();
    this._needsRefresh && (Cn = !0, this.refreshImmediately(nr)), this._needsRefreshHover && (Cn = !0, this.refreshHoverImmediately());
    var In = getTime();
    Cn ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: In - Bn
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, _n.prototype.setSleepAfterStill = function(nr) {
    this._sleepAfterStill = nr;
  }, _n.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, _n.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, _n.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, _n.prototype.resize = function(nr) {
    this._disposed || (nr = nr || {}, this.painter.resize(nr.width, nr.height), this.handler.resize());
  }, _n.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, _n.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, _n.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, _n.prototype.setCursorStyle = function(nr) {
    this._disposed || this.handler.setCursorStyle(nr);
  }, _n.prototype.findHover = function(nr, Cn) {
    if (!this._disposed)
      return this.handler.findHover(nr, Cn);
  }, _n.prototype.on = function(nr, Cn, Bn) {
    return this._disposed || this.handler.on(nr, Cn, Bn), this;
  }, _n.prototype.off = function(nr, Cn) {
    this._disposed || this.handler.off(nr, Cn);
  }, _n.prototype.trigger = function(nr, Cn) {
    this._disposed || this.handler.trigger(nr, Cn);
  }, _n.prototype.clear = function() {
    if (!this._disposed) {
      for (var nr = this.storage.getRoots(), Cn = 0; Cn < nr.length; Cn++)
        nr[Cn] instanceof Group$4 && nr[Cn].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, _n.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, delInstance(this.id));
  }, _n;
}();
function init$2(_n, nr) {
  var Cn = new ZRender(guid(), _n, nr);
  return instances$1[Cn.id] = Cn, Cn;
}
function dispose$1(_n) {
  _n.dispose();
}
function disposeAll() {
  for (var _n in instances$1)
    instances$1.hasOwnProperty(_n) && instances$1[_n].dispose();
  instances$1 = {};
}
function getInstance(_n) {
  return instances$1[_n];
}
function registerPainter(_n, nr) {
  painterCtors[_n] = nr;
}
var ssrDataGetter;
function getElementSSRData(_n) {
  if (typeof ssrDataGetter == "function")
    return ssrDataGetter(_n);
}
function registerSSRDataGetter(_n) {
  ssrDataGetter = _n;
}
var version$3 = "5.6.1";
const zrender = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dispose: dispose$1,
  disposeAll,
  getElementSSRData,
  getInstance,
  init: init$2,
  registerPainter,
  registerSSRDataGetter,
  version: version$3
}, Symbol.toStringTag, { value: "Module" }));
var RADIAN_EPSILON = 1e-4, ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(_n) {
  return _n.replace(/^\s+|\s+$/g, "");
}
function linearMap$2(_n, nr, Cn, Bn) {
  var In = nr[0], Dn = nr[1], Ln = Cn[0], $n = Cn[1], Nn = Dn - In, Rn = $n - Ln;
  if (Nn === 0)
    return Rn === 0 ? Ln : (Ln + $n) / 2;
  if (Bn)
    if (Nn > 0) {
      if (_n <= In)
        return Ln;
      if (_n >= Dn)
        return $n;
    } else {
      if (_n >= In)
        return Ln;
      if (_n <= Dn)
        return $n;
    }
  else {
    if (_n === In)
      return Ln;
    if (_n === Dn)
      return $n;
  }
  return (_n - In) / Nn * Rn + Ln;
}
function parsePercent(_n, nr) {
  switch (_n) {
    case "center":
    case "middle":
      _n = "50%";
      break;
    case "left":
    case "top":
      _n = "0%";
      break;
    case "right":
    case "bottom":
      _n = "100%";
      break;
  }
  return isString$1(_n) ? _trim(_n).match(/%$/) ? parseFloat(_n) / 100 * nr : parseFloat(_n) : _n == null ? NaN : +_n;
}
function round$4(_n, nr, Cn) {
  return nr == null && (nr = 10), nr = Math.min(Math.max(0, nr), ROUND_SUPPORTED_PRECISION_MAX), _n = (+_n).toFixed(nr), Cn ? _n : +_n;
}
function asc$2(_n) {
  return _n.sort(function(nr, Cn) {
    return nr - Cn;
  }), _n;
}
function getPrecision(_n) {
  if (_n = +_n, isNaN(_n))
    return 0;
  if (_n > 1e-14) {
    for (var nr = 1, Cn = 0; Cn < 15; Cn++, nr *= 10)
      if (Math.round(_n * nr) / nr === _n)
        return Cn;
  }
  return getPrecisionSafe(_n);
}
function getPrecisionSafe(_n) {
  var nr = _n.toString().toLowerCase(), Cn = nr.indexOf("e"), Bn = Cn > 0 ? +nr.slice(Cn + 1) : 0, In = Cn > 0 ? Cn : nr.length, Dn = nr.indexOf("."), Ln = Dn < 0 ? 0 : In - 1 - Dn;
  return Math.max(0, Ln - Bn);
}
function getPixelPrecision(_n, nr) {
  var Cn = Math.log, Bn = Math.LN10, In = Math.floor(Cn(_n[1] - _n[0]) / Bn), Dn = Math.round(Cn(Math.abs(nr[1] - nr[0])) / Bn), Ln = Math.min(Math.max(-In + Dn, 0), 20);
  return isFinite(Ln) ? Ln : 20;
}
function getPercentWithPrecision(_n, nr, Cn) {
  if (!_n[nr])
    return 0;
  var Bn = getPercentSeats(_n, Cn);
  return Bn[nr] || 0;
}
function getPercentSeats(_n, nr) {
  var Cn = reduce(_n, function(Hn, zn) {
    return Hn + (isNaN(zn) ? 0 : zn);
  }, 0);
  if (Cn === 0)
    return [];
  for (var Bn = Math.pow(10, nr), In = map$1(_n, function(Hn) {
    return (isNaN(Hn) ? 0 : Hn) / Cn * Bn * 100;
  }), Dn = Bn * 100, Ln = map$1(In, function(Hn) {
    return Math.floor(Hn);
  }), $n = reduce(Ln, function(Hn, zn) {
    return Hn + zn;
  }, 0), Nn = map$1(In, function(Hn, zn) {
    return Hn - Ln[zn];
  }); $n < Dn; ) {
    for (var Rn = Number.NEGATIVE_INFINITY, Fn = null, Pn = 0, Un = Nn.length; Pn < Un; ++Pn)
      Nn[Pn] > Rn && (Rn = Nn[Pn], Fn = Pn);
    ++Ln[Fn], Nn[Fn] = 0, ++$n;
  }
  return map$1(Ln, function(Hn) {
    return Hn / Bn;
  });
}
function addSafe(_n, nr) {
  var Cn = Math.max(getPrecision(_n), getPrecision(nr)), Bn = _n + nr;
  return Cn > ROUND_SUPPORTED_PRECISION_MAX ? Bn : round$4(Bn, Cn);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function remRadian(_n) {
  var nr = Math.PI * 2;
  return (_n % nr + nr) % nr;
}
function isRadianAroundZero(_n) {
  return _n > -RADIAN_EPSILON && _n < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(_n) {
  if (_n instanceof Date)
    return _n;
  if (isString$1(_n)) {
    var nr = TIME_REG.exec(_n);
    if (!nr)
      return /* @__PURE__ */ new Date(NaN);
    if (nr[8]) {
      var Cn = +nr[4] || 0;
      return nr[8].toUpperCase() !== "Z" && (Cn -= +nr[8].slice(0, 3)), new Date(Date.UTC(+nr[1], +(nr[2] || 1) - 1, +nr[3] || 1, Cn, +(nr[5] || 0), +nr[6] || 0, nr[7] ? +nr[7].substring(0, 3) : 0));
    } else
      return new Date(+nr[1], +(nr[2] || 1) - 1, +nr[3] || 1, +nr[4] || 0, +(nr[5] || 0), +nr[6] || 0, nr[7] ? +nr[7].substring(0, 3) : 0);
  } else if (_n == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(_n));
}
function quantity(_n) {
  return Math.pow(10, quantityExponent(_n));
}
function quantityExponent(_n) {
  if (_n === 0)
    return 0;
  var nr = Math.floor(Math.log(_n) / Math.LN10);
  return _n / Math.pow(10, nr) >= 10 && nr++, nr;
}
function nice(_n, nr) {
  var Cn = quantityExponent(_n), Bn = Math.pow(10, Cn), In = _n / Bn, Dn;
  return nr ? In < 1.5 ? Dn = 1 : In < 2.5 ? Dn = 2 : In < 4 ? Dn = 3 : In < 7 ? Dn = 5 : Dn = 10 : In < 1 ? Dn = 1 : In < 2 ? Dn = 2 : In < 3 ? Dn = 3 : In < 5 ? Dn = 5 : Dn = 10, _n = Dn * Bn, Cn >= -20 ? +_n.toFixed(Cn < 0 ? -Cn : 0) : _n;
}
function quantile(_n, nr) {
  var Cn = (_n.length - 1) * nr + 1, Bn = Math.floor(Cn), In = +_n[Bn - 1], Dn = Cn - Bn;
  return Dn ? In + Dn * (_n[Bn] - In) : In;
}
function reformIntervals(_n) {
  _n.sort(function(Nn, Rn) {
    return $n(Nn, Rn, 0) ? -1 : 1;
  });
  for (var nr = -1 / 0, Cn = 1, Bn = 0; Bn < _n.length; ) {
    for (var In = _n[Bn].interval, Dn = _n[Bn].close, Ln = 0; Ln < 2; Ln++)
      In[Ln] <= nr && (In[Ln] = nr, Dn[Ln] = Ln ? 1 : 1 - Cn), nr = In[Ln], Cn = Dn[Ln];
    In[0] === In[1] && Dn[0] * Dn[1] !== 1 ? _n.splice(Bn, 1) : Bn++;
  }
  return _n;
  function $n(Nn, Rn, Fn) {
    return Nn.interval[Fn] < Rn.interval[Fn] || Nn.interval[Fn] === Rn.interval[Fn] && (Nn.close[Fn] - Rn.close[Fn] === (Fn ? -1 : 1) || !Fn && $n(Nn, Rn, 1));
  }
}
function numericToNumber(_n) {
  var nr = parseFloat(_n);
  return nr == _n && (nr !== 0 || !isString$1(_n) || _n.indexOf("x") <= 0) ? nr : NaN;
}
function isNumeric(_n) {
  return !isNaN(numericToNumber(_n));
}
function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(_n, nr) {
  return nr === 0 ? _n : getGreatestCommonDividor(nr, _n % nr);
}
function getLeastCommonMultiple(_n, nr) {
  return _n == null ? nr : nr == null ? _n : _n * nr / getGreatestCommonDividor(_n, nr);
}
var ECHARTS_PREFIX = "[ECharts] ", storedLogs = {}, hasConsole = typeof console < "u" && console.warn && console.log;
function outputLog(_n, nr, Cn) {
  if (hasConsole) {
    if (Cn) {
      if (storedLogs[nr])
        return;
      storedLogs[nr] = !0;
    }
    console[_n](ECHARTS_PREFIX + nr);
  }
}
function log(_n, nr) {
  outputLog("log", _n, nr);
}
function warn(_n, nr) {
  outputLog("warn", _n, nr);
}
function error(_n, nr) {
  outputLog("error", _n, nr);
}
function deprecateLog(_n) {
  process.env.NODE_ENV !== "production" && outputLog("warn", "DEPRECATED: " + _n, !0);
}
function deprecateReplaceLog(_n, nr, Cn) {
  process.env.NODE_ENV !== "production" && deprecateLog((Cn ? "[" + Cn + "]" : "") + (_n + " is deprecated, use " + nr + " instead."));
}
function makePrintable() {
  for (var _n = [], nr = 0; nr < arguments.length; nr++)
    _n[nr] = arguments[nr];
  var Cn = "";
  if (process.env.NODE_ENV !== "production") {
    var Bn = function(In) {
      return In === void 0 ? "undefined" : In === 1 / 0 ? "Infinity" : In === -1 / 0 ? "-Infinity" : eqNaN(In) ? "NaN" : In instanceof Date ? "Date(" + In.toISOString() + ")" : isFunction$1(In) ? "function () { ... }" : isRegExp(In) ? In + "" : null;
    };
    Cn = map$1(_n, function(In) {
      if (isString$1(In))
        return In;
      var Dn = Bn(In);
      if (Dn != null)
        return Dn;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(In, function(Ln, $n) {
            var Nn = Bn($n);
            return Nn ?? $n;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return Cn;
}
function throwError(_n) {
  throw new Error(_n);
}
function interpolateNumber(_n, nr, Cn) {
  return (nr - _n) * Cn + _n;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\0", INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
function normalizeToArray(_n) {
  return _n instanceof Array ? _n : _n == null ? [] : [_n];
}
function defaultEmphasis(_n, nr, Cn) {
  if (_n) {
    _n[nr] = _n[nr] || {}, _n.emphasis = _n.emphasis || {}, _n.emphasis[nr] = _n.emphasis[nr] || {};
    for (var Bn = 0, In = Cn.length; Bn < In; Bn++) {
      var Dn = Cn[Bn];
      !_n.emphasis[nr].hasOwnProperty(Dn) && _n[nr].hasOwnProperty(Dn) && (_n.emphasis[nr][Dn] = _n[nr][Dn]);
    }
  }
}
var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function getDataItemValue(_n) {
  return isObject$6(_n) && !isArray$4(_n) && !(_n instanceof Date) ? _n.value : _n;
}
function isDataItemOption(_n) {
  return isObject$6(_n) && !(_n instanceof Array);
}
function mappingToExists(_n, nr, Cn) {
  var Bn = Cn === "normalMerge", In = Cn === "replaceMerge", Dn = Cn === "replaceAll";
  _n = _n || [], nr = (nr || []).slice();
  var Ln = createHashMap();
  each$f(nr, function(Nn, Rn) {
    if (!isObject$6(Nn)) {
      nr[Rn] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (Nn.id != null && !isValidIdOrName(Nn.id) && warnInvalidateIdOrName(Nn.id), Nn.name != null && !isValidIdOrName(Nn.name) && warnInvalidateIdOrName(Nn.name));
  });
  var $n = prepareResult(_n, Ln, Cn);
  return (Bn || In) && mappingById($n, _n, Ln, nr), Bn && mappingByName($n, nr), Bn || In ? mappingByIndex($n, nr, In) : Dn && mappingInReplaceAllMode($n, nr), makeIdAndName($n), $n;
}
function prepareResult(_n, nr, Cn) {
  var Bn = [];
  if (Cn === "replaceAll")
    return Bn;
  for (var In = 0; In < _n.length; In++) {
    var Dn = _n[In];
    Dn && Dn.id != null && nr.set(Dn.id, In), Bn.push({
      existing: Cn === "replaceMerge" || isComponentIdInternal(Dn) ? null : Dn,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return Bn;
}
function mappingById(_n, nr, Cn, Bn) {
  each$f(Bn, function(In, Dn) {
    if (!(!In || In.id == null)) {
      var Ln = makeComparableKey(In.id), $n = Cn.get(Ln);
      if ($n != null) {
        var Nn = _n[$n];
        assert(!Nn.newOption, 'Duplicated option on id "' + Ln + '".'), Nn.newOption = In, Nn.existing = nr[$n], Bn[Dn] = null;
      }
    }
  });
}
function mappingByName(_n, nr) {
  each$f(nr, function(Cn, Bn) {
    if (!(!Cn || Cn.name == null))
      for (var In = 0; In < _n.length; In++) {
        var Dn = _n[In].existing;
        if (!_n[In].newOption && Dn && (Dn.id == null || Cn.id == null) && !isComponentIdInternal(Cn) && !isComponentIdInternal(Dn) && keyExistAndEqual("name", Dn, Cn)) {
          _n[In].newOption = Cn, nr[Bn] = null;
          return;
        }
      }
  });
}
function mappingByIndex(_n, nr, Cn) {
  each$f(nr, function(Bn) {
    if (Bn) {
      for (
        var In, Dn = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (In = _n[Dn]) && (In.newOption || isComponentIdInternal(In.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        In.existing && Bn.id != null && !keyExistAndEqual("id", Bn, In.existing));
      )
        Dn++;
      In ? (In.newOption = Bn, In.brandNew = Cn) : _n.push({
        newOption: Bn,
        brandNew: Cn,
        existing: null,
        keyInfo: null
      }), Dn++;
    }
  });
}
function mappingInReplaceAllMode(_n, nr) {
  each$f(nr, function(Cn) {
    _n.push({
      newOption: Cn,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function makeIdAndName(_n) {
  var nr = createHashMap();
  each$f(_n, function(Cn) {
    var Bn = Cn.existing;
    Bn && nr.set(Bn.id, Cn);
  }), each$f(_n, function(Cn) {
    var Bn = Cn.newOption;
    assert(!Bn || Bn.id == null || !nr.get(Bn.id) || nr.get(Bn.id) === Cn, "id duplicates: " + (Bn && Bn.id)), Bn && Bn.id != null && nr.set(Bn.id, Cn), !Cn.keyInfo && (Cn.keyInfo = {});
  }), each$f(_n, function(Cn, Bn) {
    var In = Cn.existing, Dn = Cn.newOption, Ln = Cn.keyInfo;
    if (isObject$6(Dn)) {
      if (Ln.name = Dn.name != null ? makeComparableKey(Dn.name) : In ? In.name : DUMMY_COMPONENT_NAME_PREFIX + Bn, In)
        Ln.id = makeComparableKey(In.id);
      else if (Dn.id != null)
        Ln.id = makeComparableKey(Dn.id);
      else {
        var $n = 0;
        do
          Ln.id = "\0" + Ln.name + "\0" + $n++;
        while (nr.get(Ln.id));
      }
      nr.set(Ln.id, Cn);
    }
  });
}
function keyExistAndEqual(_n, nr, Cn) {
  var Bn = convertOptionIdName(nr[_n], null), In = convertOptionIdName(Cn[_n], null);
  return Bn != null && In != null && Bn === In;
}
function makeComparableKey(_n) {
  if (process.env.NODE_ENV !== "production" && _n == null)
    throw new Error();
  return convertOptionIdName(_n, "");
}
function convertOptionIdName(_n, nr) {
  return _n == null ? nr : isString$1(_n) ? _n : isNumber(_n) || isStringSafe(_n) ? _n + "" : nr;
}
function warnInvalidateIdOrName(_n) {
  process.env.NODE_ENV !== "production" && warn("`" + _n + "` is invalid id or name. Must be a string or number.");
}
function isValidIdOrName(_n) {
  return isStringSafe(_n) || isNumeric(_n);
}
function isNameSpecified(_n) {
  var nr = _n.name;
  return !!(nr && nr.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(_n) {
  return _n && _n.id != null && makeComparableKey(_n.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(_n) {
  return INTERNAL_COMPONENT_ID_PREFIX + _n;
}
function setComponentTypeToKeyInfo(_n, nr, Cn) {
  each$f(_n, function(Bn) {
    var In = Bn.newOption;
    isObject$6(In) && (Bn.keyInfo.mainType = nr, Bn.keyInfo.subType = determineSubType(nr, In, Bn.existing, Cn));
  });
}
function determineSubType(_n, nr, Cn, Bn) {
  var In = nr.type ? nr.type : Cn ? Cn.subType : Bn.determineSubType(_n, nr);
  return In;
}
function compressBatches(_n, nr) {
  var Cn = {}, Bn = {};
  return In(_n || [], Cn), In(nr || [], Bn, Cn), [Dn(Cn), Dn(Bn)];
  function In(Ln, $n, Nn) {
    for (var Rn = 0, Fn = Ln.length; Rn < Fn; Rn++) {
      var Pn = convertOptionIdName(Ln[Rn].seriesId, null);
      if (Pn == null)
        return;
      for (var Un = normalizeToArray(Ln[Rn].dataIndex), Hn = Nn && Nn[Pn], zn = 0, Gn = Un.length; zn < Gn; zn++) {
        var Yn = Un[zn];
        Hn && Hn[Yn] ? Hn[Yn] = null : ($n[Pn] || ($n[Pn] = {}))[Yn] = 1;
      }
    }
  }
  function Dn(Ln, $n) {
    var Nn = [];
    for (var Rn in Ln)
      if (Ln.hasOwnProperty(Rn) && Ln[Rn] != null)
        if ($n)
          Nn.push(+Rn);
        else {
          var Fn = Dn(Ln[Rn], !0);
          Fn.length && Nn.push({
            seriesId: Rn,
            dataIndex: Fn
          });
        }
    return Nn;
  }
}
function queryDataIndex(_n, nr) {
  if (nr.dataIndexInside != null)
    return nr.dataIndexInside;
  if (nr.dataIndex != null)
    return isArray$4(nr.dataIndex) ? map$1(nr.dataIndex, function(Cn) {
      return _n.indexOfRawIndex(Cn);
    }) : _n.indexOfRawIndex(nr.dataIndex);
  if (nr.name != null)
    return isArray$4(nr.name) ? map$1(nr.name, function(Cn) {
      return _n.indexOfName(Cn);
    }) : _n.indexOfName(nr.name);
}
function makeInner() {
  var _n = "__ec_inner_" + innerUniqueIndex++;
  return function(nr) {
    return nr[_n] || (nr[_n] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder$1(_n, nr, Cn) {
  var Bn = preParseFinder(nr, Cn), In = Bn.mainTypeSpecified, Dn = Bn.queryOptionMap, Ln = Bn.others, $n = Ln, Nn = Cn ? Cn.defaultMainType : null;
  return !In && Nn && Dn.set(Nn, {}), Dn.each(function(Rn, Fn) {
    var Pn = queryReferringComponents(_n, Fn, Rn, {
      useDefault: Nn === Fn,
      enableAll: Cn && Cn.enableAll != null ? Cn.enableAll : !0,
      enableNone: Cn && Cn.enableNone != null ? Cn.enableNone : !0
    });
    $n[Fn + "Models"] = Pn.models, $n[Fn + "Model"] = Pn.models[0];
  }), $n;
}
function preParseFinder(_n, nr) {
  var Cn;
  if (isString$1(_n)) {
    var Bn = {};
    Bn[_n + "Index"] = 0, Cn = Bn;
  } else
    Cn = _n;
  var In = createHashMap(), Dn = {}, Ln = !1;
  return each$f(Cn, function($n, Nn) {
    if (Nn === "dataIndex" || Nn === "dataIndexInside") {
      Dn[Nn] = $n;
      return;
    }
    var Rn = Nn.match(/^(\w+)(Index|Id|Name)$/) || [], Fn = Rn[1], Pn = (Rn[2] || "").toLowerCase();
    if (!(!Fn || !Pn || nr && nr.includeMainTypes && indexOf(nr.includeMainTypes, Fn) < 0)) {
      Ln = Ln || !!Fn;
      var Un = In.get(Fn) || In.set(Fn, {});
      Un[Pn] = $n;
    }
  }), {
    mainTypeSpecified: Ln,
    queryOptionMap: In,
    others: Dn
  };
}
var SINGLE_REFERRING = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, MULTIPLE_REFERRING = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function queryReferringComponents(_n, nr, Cn, Bn) {
  Bn = Bn || SINGLE_REFERRING;
  var In = Cn.index, Dn = Cn.id, Ln = Cn.name, $n = {
    models: null,
    specified: In != null || Dn != null || Ln != null
  };
  if (!$n.specified) {
    var Nn = void 0;
    return $n.models = Bn.useDefault && (Nn = _n.getComponent(nr)) ? [Nn] : [], $n;
  }
  return In === "none" || In === !1 ? (assert(Bn.enableNone, '`"none"` or `false` is not a valid value on index option.'), $n.models = [], $n) : (In === "all" && (assert(Bn.enableAll, '`"all"` is not a valid value on index option.'), In = Dn = Ln = null), $n.models = _n.queryComponents({
    mainType: nr,
    index: In,
    id: Dn,
    name: Ln
  }), $n);
}
function setAttribute(_n, nr, Cn) {
  _n.setAttribute ? _n.setAttribute(nr, Cn) : _n[nr] = Cn;
}
function getAttribute(_n, nr) {
  return _n.getAttribute ? _n.getAttribute(nr) : _n[nr];
}
function getTooltipRenderMode(_n) {
  return _n === "auto" ? env$1.domSupported ? "html" : "richText" : _n || "html";
}
function groupData(_n, nr) {
  var Cn = createHashMap(), Bn = [];
  return each$f(_n, function(In) {
    var Dn = nr(In);
    (Cn.get(Dn) || (Bn.push(Dn), Cn.set(Dn, []))).push(In);
  }), {
    keys: Bn,
    buckets: Cn
  };
}
function interpolateRawValues(_n, nr, Cn, Bn, In) {
  var Dn = nr == null || nr === "auto";
  if (Bn == null)
    return Bn;
  if (isNumber(Bn)) {
    var Ln = interpolateNumber(Cn || 0, Bn, In);
    return round$4(Ln, Dn ? Math.max(getPrecision(Cn || 0), getPrecision(Bn)) : nr);
  } else {
    if (isString$1(Bn))
      return In < 1 ? Cn : Bn;
    for (var $n = [], Nn = Cn, Rn = Bn, Fn = Math.max(Nn ? Nn.length : 0, Rn.length), Pn = 0; Pn < Fn; ++Pn) {
      var Un = _n.getDimensionInfo(Pn);
      if (Un && Un.type === "ordinal")
        $n[Pn] = (In < 1 && Nn ? Nn : Rn)[Pn];
      else {
        var Hn = Nn && Nn[Pn] ? Nn[Pn] : 0, zn = Rn[Pn], Ln = interpolateNumber(Hn, zn, In);
        $n[Pn] = round$4(Ln, Dn ? Math.max(getPrecision(Hn), getPrecision(zn)) : nr);
      }
    }
    return $n;
  }
}
var TYPE_DELIMITER = ".", IS_CONTAINER = "___EC__COMPONENT__CONTAINER___", IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(_n) {
  var nr = {
    main: "",
    sub: ""
  };
  if (_n) {
    var Cn = _n.split(TYPE_DELIMITER);
    nr.main = Cn[0] || "", nr.sub = Cn[1] || "";
  }
  return nr;
}
function checkClassType(_n) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(_n), 'componentType "' + _n + '" illegal');
}
function isExtendedClass(_n) {
  return !!(_n && _n[IS_EXTENDED_CLASS]);
}
function enableClassExtend(_n, nr) {
  _n.$constructor = _n, _n.extend = function(Cn) {
    process.env.NODE_ENV !== "production" && each$f(nr, function(Dn) {
      Cn[Dn] || console.warn("Method `" + Dn + "` should be implemented" + (Cn.type ? " in " + Cn.type : "") + ".");
    });
    var Bn = this, In;
    return isESClass(Bn) ? In = /** @class */
    function(Dn) {
      __extends$2(Ln, Dn);
      function Ln() {
        return Dn.apply(this, arguments) || this;
      }
      return Ln;
    }(Bn) : (In = function() {
      (Cn.$constructor || Bn).apply(this, arguments);
    }, inherits(In, this)), extend(In.prototype, Cn), In[IS_EXTENDED_CLASS] = !0, In.extend = this.extend, In.superCall = superCall, In.superApply = superApply, In.superClass = Bn, In;
  };
}
function isESClass(_n) {
  return isFunction$1(_n) && /^class\s/.test(Function.prototype.toString.call(_n));
}
function mountExtend(_n, nr) {
  _n.extend = nr.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(_n) {
  var nr = ["__\0is_clz", classBase++].join("_");
  _n.prototype[nr] = !0, process.env.NODE_ENV !== "production" && assert(!_n.isInstance, 'The method "is" can not be defined.'), _n.isInstance = function(Cn) {
    return !!(Cn && Cn[nr]);
  };
}
function superCall(_n, nr) {
  for (var Cn = [], Bn = 2; Bn < arguments.length; Bn++)
    Cn[Bn - 2] = arguments[Bn];
  return this.superClass.prototype[nr].apply(_n, Cn);
}
function superApply(_n, nr, Cn) {
  return this.superClass.prototype[nr].apply(_n, Cn);
}
function enableClassManagement(_n) {
  var nr = {};
  _n.registerClass = function(Bn) {
    var In = Bn.type || Bn.prototype.type;
    if (In) {
      checkClassType(In), Bn.prototype.type = In;
      var Dn = parseClassType(In);
      if (!Dn.sub)
        process.env.NODE_ENV !== "production" && nr[Dn.main] && console.warn(Dn.main + " exists."), nr[Dn.main] = Bn;
      else if (Dn.sub !== IS_CONTAINER) {
        var Ln = Cn(Dn);
        Ln[Dn.sub] = Bn;
      }
    }
    return Bn;
  }, _n.getClass = function(Bn, In, Dn) {
    var Ln = nr[Bn];
    if (Ln && Ln[IS_CONTAINER] && (Ln = In ? Ln[In] : null), Dn && !Ln)
      throw new Error(In ? "Component " + Bn + "." + (In || "") + " is used but not imported." : Bn + ".type should be specified.");
    return Ln;
  }, _n.getClassesByMainType = function(Bn) {
    var In = parseClassType(Bn), Dn = [], Ln = nr[In.main];
    return Ln && Ln[IS_CONTAINER] ? each$f(Ln, function($n, Nn) {
      Nn !== IS_CONTAINER && Dn.push($n);
    }) : Dn.push(Ln), Dn;
  }, _n.hasClass = function(Bn) {
    var In = parseClassType(Bn);
    return !!nr[In.main];
  }, _n.getAllClassMainTypes = function() {
    var Bn = [];
    return each$f(nr, function(In, Dn) {
      Bn.push(Dn);
    }), Bn;
  }, _n.hasSubTypes = function(Bn) {
    var In = parseClassType(Bn), Dn = nr[In.main];
    return Dn && Dn[IS_CONTAINER];
  };
  function Cn(Bn) {
    var In = nr[Bn.main];
    return (!In || !In[IS_CONTAINER]) && (In = nr[Bn.main] = {}, In[IS_CONTAINER] = !0), In;
  }
}
function makeStyleMapper(_n, nr) {
  for (var Cn = 0; Cn < _n.length; Cn++)
    _n[Cn][1] || (_n[Cn][1] = _n[Cn][0]);
  return nr = nr || !1, function(Bn, In, Dn) {
    for (var Ln = {}, $n = 0; $n < _n.length; $n++) {
      var Nn = _n[$n][1];
      if (!(In && indexOf(In, Nn) >= 0 || Dn && indexOf(Dn, Nn) < 0)) {
        var Rn = Bn.getShallow(Nn, nr);
        Rn != null && (Ln[_n[$n][0]] = Rn);
      }
    }
    return Ln;
  };
}
var AREA_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP), AreaStyleMixin = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.getAreaStyle = function(nr, Cn) {
      return getAreaStyle(this, nr, Cn);
    }, _n;
  }()
), globalImageCache = new LRU$1(50);
function findExistImage(_n) {
  if (typeof _n == "string") {
    var nr = globalImageCache.get(_n);
    return nr && nr.image;
  } else
    return _n;
}
function createOrUpdateImage(_n, nr, Cn, Bn, In) {
  if (_n)
    if (typeof _n == "string") {
      if (nr && nr.__zrImageSrc === _n || !Cn)
        return nr;
      var Dn = globalImageCache.get(_n), Ln = { hostEl: Cn, cb: Bn, cbPayload: In };
      return Dn ? (nr = Dn.image, !isImageReady(nr) && Dn.pending.push(Ln)) : (nr = platformApi.loadImage(_n, imageOnLoad, imageOnLoad), nr.__zrImageSrc = _n, globalImageCache.put(_n, nr.__cachedImgObj = {
        image: nr,
        pending: [Ln]
      })), nr;
    } else
      return _n;
  else
    return nr;
}
function imageOnLoad() {
  var _n = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var nr = 0; nr < _n.pending.length; nr++) {
    var Cn = _n.pending[nr], Bn = Cn.cb;
    Bn && Bn(this, Cn.cbPayload), Cn.hostEl.dirty();
  }
  _n.pending.length = 0;
}
function isImageReady(_n) {
  return _n && _n.width && _n.height;
}
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(_n, nr, Cn, Bn, In) {
  var Dn = {};
  return truncateText2(Dn, _n, nr, Cn, Bn, In), Dn.text;
}
function truncateText2(_n, nr, Cn, Bn, In, Dn) {
  if (!Cn) {
    _n.text = "", _n.isTruncated = !1;
    return;
  }
  var Ln = (nr + "").split(`
`);
  Dn = prepareTruncateOptions(Cn, Bn, In, Dn);
  for (var $n = !1, Nn = {}, Rn = 0, Fn = Ln.length; Rn < Fn; Rn++)
    truncateSingleLine(Nn, Ln[Rn], Dn), Ln[Rn] = Nn.textLine, $n = $n || Nn.isTruncated;
  _n.text = Ln.join(`
`), _n.isTruncated = $n;
}
function prepareTruncateOptions(_n, nr, Cn, Bn) {
  Bn = Bn || {};
  var In = extend({}, Bn);
  In.font = nr, Cn = retrieve2(Cn, "..."), In.maxIterations = retrieve2(Bn.maxIterations, 2);
  var Dn = In.minChar = retrieve2(Bn.minChar, 0);
  In.cnCharWidth = getWidth("国", nr);
  var Ln = In.ascCharWidth = getWidth("a", nr);
  In.placeholder = retrieve2(Bn.placeholder, "");
  for (var $n = _n = Math.max(0, _n - 1), Nn = 0; Nn < Dn && $n >= Ln; Nn++)
    $n -= Ln;
  var Rn = getWidth(Cn, nr);
  return Rn > $n && (Cn = "", Rn = 0), $n = _n - Rn, In.ellipsis = Cn, In.ellipsisWidth = Rn, In.contentWidth = $n, In.containerWidth = _n, In;
}
function truncateSingleLine(_n, nr, Cn) {
  var Bn = Cn.containerWidth, In = Cn.font, Dn = Cn.contentWidth;
  if (!Bn) {
    _n.textLine = "", _n.isTruncated = !1;
    return;
  }
  var Ln = getWidth(nr, In);
  if (Ln <= Bn) {
    _n.textLine = nr, _n.isTruncated = !1;
    return;
  }
  for (var $n = 0; ; $n++) {
    if (Ln <= Dn || $n >= Cn.maxIterations) {
      nr += Cn.ellipsis;
      break;
    }
    var Nn = $n === 0 ? estimateLength(nr, Dn, Cn.ascCharWidth, Cn.cnCharWidth) : Ln > 0 ? Math.floor(nr.length * Dn / Ln) : 0;
    nr = nr.substr(0, Nn), Ln = getWidth(nr, In);
  }
  nr === "" && (nr = Cn.placeholder), _n.textLine = nr, _n.isTruncated = !0;
}
function estimateLength(_n, nr, Cn, Bn) {
  for (var In = 0, Dn = 0, Ln = _n.length; Dn < Ln && In < nr; Dn++) {
    var $n = _n.charCodeAt(Dn);
    In += 0 <= $n && $n <= 127 ? Cn : Bn;
  }
  return Dn;
}
function parsePlainText(_n, nr) {
  _n != null && (_n += "");
  var Cn = nr.overflow, Bn = nr.padding, In = nr.font, Dn = Cn === "truncate", Ln = getLineHeight(In), $n = retrieve2(nr.lineHeight, Ln), Nn = !!nr.backgroundColor, Rn = nr.lineOverflow === "truncate", Fn = !1, Pn = nr.width, Un;
  Pn != null && (Cn === "break" || Cn === "breakAll") ? Un = _n ? wrapText(_n, nr.font, Pn, Cn === "breakAll", 0).lines : [] : Un = _n ? _n.split(`
`) : [];
  var Hn = Un.length * $n, zn = retrieve2(nr.height, Hn);
  if (Hn > zn && Rn) {
    var Gn = Math.floor(zn / $n);
    Fn = Fn || Un.length > Gn, Un = Un.slice(0, Gn);
  }
  if (_n && Dn && Pn != null)
    for (var Yn = prepareTruncateOptions(Pn, In, nr.ellipsis, {
      minChar: nr.truncateMinChar,
      placeholder: nr.placeholder
    }), Wn = {}, Xn = 0; Xn < Un.length; Xn++)
      truncateSingleLine(Wn, Un[Xn], Yn), Un[Xn] = Wn.textLine, Fn = Fn || Wn.isTruncated;
  for (var ea = zn, ta = 0, Xn = 0; Xn < Un.length; Xn++)
    ta = Math.max(getWidth(Un[Xn], In), ta);
  Pn == null && (Pn = ta);
  var na = ta;
  return Bn && (ea += Bn[0] + Bn[2], na += Bn[1] + Bn[3], Pn += Bn[1] + Bn[3]), Nn && (na = Pn), {
    lines: Un,
    height: zn,
    outerWidth: na,
    outerHeight: ea,
    lineHeight: $n,
    calculatedLineHeight: Ln,
    contentWidth: ta,
    contentHeight: Hn,
    width: Pn,
    isTruncated: Fn
  };
}
var RichTextToken = function() {
  function _n() {
  }
  return _n;
}(), RichTextLine = function() {
  function _n(nr) {
    this.tokens = [], nr && (this.tokens = nr);
  }
  return _n;
}(), RichTextContentBlock = function() {
  function _n() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
  }
  return _n;
}();
function parseRichText(_n, nr) {
  var Cn = new RichTextContentBlock();
  if (_n != null && (_n += ""), !_n)
    return Cn;
  for (var Bn = nr.width, In = nr.height, Dn = nr.overflow, Ln = (Dn === "break" || Dn === "breakAll") && Bn != null ? { width: Bn, accumWidth: 0, breakAll: Dn === "breakAll" } : null, $n = STYLE_REG.lastIndex = 0, Nn; (Nn = STYLE_REG.exec(_n)) != null; ) {
    var Rn = Nn.index;
    Rn > $n && pushTokens(Cn, _n.substring($n, Rn), nr, Ln), pushTokens(Cn, Nn[2], nr, Ln, Nn[1]), $n = STYLE_REG.lastIndex;
  }
  $n < _n.length && pushTokens(Cn, _n.substring($n, _n.length), nr, Ln);
  var Fn = [], Pn = 0, Un = 0, Hn = nr.padding, zn = Dn === "truncate", Gn = nr.lineOverflow === "truncate", Yn = {};
  function Wn(Ca, ma, va) {
    Ca.width = ma, Ca.lineHeight = va, Pn += va, Un = Math.max(Un, ma);
  }
  e:
    for (var Xn = 0; Xn < Cn.lines.length; Xn++) {
      for (var ea = Cn.lines[Xn], ta = 0, na = 0, ra = 0; ra < ea.tokens.length; ra++) {
        var aa = ea.tokens[ra], ia = aa.styleName && nr.rich[aa.styleName] || {}, Aa = aa.textPadding = ia.padding, sa = Aa ? Aa[1] + Aa[3] : 0, oa = aa.font = ia.font || nr.font;
        aa.contentHeight = getLineHeight(oa);
        var la = retrieve2(ia.height, aa.contentHeight);
        if (aa.innerHeight = la, Aa && (la += Aa[0] + Aa[2]), aa.height = la, aa.lineHeight = retrieve3(ia.lineHeight, nr.lineHeight, la), aa.align = ia && ia.align || nr.align, aa.verticalAlign = ia && ia.verticalAlign || "middle", Gn && In != null && Pn + aa.lineHeight > In) {
          var ua = Cn.lines.length;
          ra > 0 ? (ea.tokens = ea.tokens.slice(0, ra), Wn(ea, na, ta), Cn.lines = Cn.lines.slice(0, Xn + 1)) : Cn.lines = Cn.lines.slice(0, Xn), Cn.isTruncated = Cn.isTruncated || Cn.lines.length < ua;
          break e;
        }
        var ca = ia.width, fa = ca == null || ca === "auto";
        if (typeof ca == "string" && ca.charAt(ca.length - 1) === "%")
          aa.percentWidth = ca, Fn.push(aa), aa.contentWidth = getWidth(aa.text, oa);
        else {
          if (fa) {
            var ha = ia.backgroundColor, pa = ha && ha.image;
            pa && (pa = findExistImage(pa), isImageReady(pa) && (aa.width = Math.max(aa.width, pa.width * la / pa.height)));
          }
          var ya = zn && Bn != null ? Bn - na : null;
          ya != null && ya < aa.width ? !fa || ya < sa ? (aa.text = "", aa.width = aa.contentWidth = 0) : (truncateText2(Yn, aa.text, ya - sa, oa, nr.ellipsis, { minChar: nr.truncateMinChar }), aa.text = Yn.text, Cn.isTruncated = Cn.isTruncated || Yn.isTruncated, aa.width = aa.contentWidth = getWidth(aa.text, oa)) : aa.contentWidth = getWidth(aa.text, oa);
        }
        aa.width += sa, na += aa.width, ia && (ta = Math.max(ta, aa.lineHeight));
      }
      Wn(ea, na, ta);
    }
  Cn.outerWidth = Cn.width = retrieve2(Bn, Un), Cn.outerHeight = Cn.height = retrieve2(In, Pn), Cn.contentHeight = Pn, Cn.contentWidth = Un, Hn && (Cn.outerWidth += Hn[1] + Hn[3], Cn.outerHeight += Hn[0] + Hn[2]);
  for (var Xn = 0; Xn < Fn.length; Xn++) {
    var aa = Fn[Xn], da = aa.percentWidth;
    aa.width = parseInt(da, 10) / 100 * Cn.width;
  }
  return Cn;
}
function pushTokens(_n, nr, Cn, Bn, In) {
  var Dn = nr === "", Ln = In && Cn.rich[In] || {}, $n = _n.lines, Nn = Ln.font || Cn.font, Rn = !1, Fn, Pn;
  if (Bn) {
    var Un = Ln.padding, Hn = Un ? Un[1] + Un[3] : 0;
    if (Ln.width != null && Ln.width !== "auto") {
      var zn = parsePercent$1(Ln.width, Bn.width) + Hn;
      $n.length > 0 && zn + Bn.accumWidth > Bn.width && (Fn = nr.split(`
`), Rn = !0), Bn.accumWidth = zn;
    } else {
      var Gn = wrapText(nr, Nn, Bn.width, Bn.breakAll, Bn.accumWidth);
      Bn.accumWidth = Gn.accumWidth + Hn, Pn = Gn.linesWidths, Fn = Gn.lines;
    }
  } else
    Fn = nr.split(`
`);
  for (var Yn = 0; Yn < Fn.length; Yn++) {
    var Wn = Fn[Yn], Xn = new RichTextToken();
    if (Xn.styleName = In, Xn.text = Wn, Xn.isLineHolder = !Wn && !Dn, typeof Ln.width == "number" ? Xn.width = Ln.width : Xn.width = Pn ? Pn[Yn] : getWidth(Wn, Nn), !Yn && !Rn) {
      var ea = ($n[$n.length - 1] || ($n[0] = new RichTextLine())).tokens, ta = ea.length;
      ta === 1 && ea[0].isLineHolder ? ea[0] = Xn : (Wn || !ta || Dn) && ea.push(Xn);
    } else
      $n.push(new RichTextLine([Xn]));
  }
}
function isAlphabeticLetter(_n) {
  var nr = _n.charCodeAt(0);
  return nr >= 32 && nr <= 591 || nr >= 880 && nr <= 4351 || nr >= 4608 && nr <= 5119 || nr >= 7680 && nr <= 8303;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(_n, nr) {
  return _n[nr] = !0, _n;
}, {});
function isWordBreakChar(_n) {
  return isAlphabeticLetter(_n) ? !!breakCharMap[_n] : !0;
}
function wrapText(_n, nr, Cn, Bn, In) {
  for (var Dn = [], Ln = [], $n = "", Nn = "", Rn = 0, Fn = 0, Pn = 0; Pn < _n.length; Pn++) {
    var Un = _n.charAt(Pn);
    if (Un === `
`) {
      Nn && ($n += Nn, Fn += Rn), Dn.push($n), Ln.push(Fn), $n = "", Nn = "", Rn = 0, Fn = 0;
      continue;
    }
    var Hn = getWidth(Un, nr), zn = Bn ? !1 : !isWordBreakChar(Un);
    if (Dn.length ? Fn + Hn > Cn : In + Fn + Hn > Cn) {
      Fn ? ($n || Nn) && (zn ? ($n || ($n = Nn, Nn = "", Rn = 0, Fn = Rn), Dn.push($n), Ln.push(Fn - Rn), Nn += Un, Rn += Hn, $n = "", Fn = Rn) : (Nn && ($n += Nn, Nn = "", Rn = 0), Dn.push($n), Ln.push(Fn), $n = Un, Fn = Hn)) : zn ? (Dn.push(Nn), Ln.push(Rn), Nn = Un, Rn = Hn) : (Dn.push(Un), Ln.push(Hn));
      continue;
    }
    Fn += Hn, zn ? (Nn += Un, Rn += Hn) : (Nn && ($n += Nn, Nn = "", Rn = 0), $n += Un);
  }
  return !Dn.length && !$n && ($n = _n, Nn = "", Rn = 0), Nn && ($n += Nn), $n && (Dn.push($n), Ln.push(Fn)), Dn.length === 1 && (Fn += In), {
    accumWidth: Fn,
    lines: Dn,
    linesWidths: Ln
  };
}
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10), DEFAULT_COMMON_STYLE = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, DEFAULT_COMMON_ANIMATION_PROPS = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = !0;
var PRIMARY_STATES_KEYS = ["z", "z2", "invisible"], PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"], Displayable = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype._init = function(Cn) {
    for (var Bn = keys(Cn), In = 0; In < Bn.length; In++) {
      var Dn = Bn[In];
      Dn === "style" ? this.useStyle(Cn[Dn]) : _n.prototype.attrKV.call(this, Dn, Cn[Dn]);
    }
    this.style || this.useStyle({});
  }, nr.prototype.beforeBrush = function() {
  }, nr.prototype.afterBrush = function() {
  }, nr.prototype.innerBeforeBrush = function() {
  }, nr.prototype.innerAfterBrush = function() {
  }, nr.prototype.shouldBePainted = function(Cn, Bn, In, Dn) {
    var Ln = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, Cn, Bn) || Ln && !Ln[0] && !Ln[3])
      return !1;
    if (In && this.__clipPaths) {
      for (var $n = 0; $n < this.__clipPaths.length; ++$n)
        if (this.__clipPaths[$n].isZeroArea())
          return !1;
    }
    if (Dn && this.parent)
      for (var Nn = this.parent; Nn; ) {
        if (Nn.ignore)
          return !1;
        Nn = Nn.parent;
      }
    return !0;
  }, nr.prototype.contain = function(Cn, Bn) {
    return this.rectContain(Cn, Bn);
  }, nr.prototype.traverse = function(Cn, Bn) {
    Cn.call(Bn, this);
  }, nr.prototype.rectContain = function(Cn, Bn) {
    var In = this.transformCoordToLocal(Cn, Bn), Dn = this.getBoundingRect();
    return Dn.contain(In[0], In[1]);
  }, nr.prototype.getPaintRect = function() {
    var Cn = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var Bn = this.transform, In = this.getBoundingRect(), Dn = this.style, Ln = Dn.shadowBlur || 0, $n = Dn.shadowOffsetX || 0, Nn = Dn.shadowOffsetY || 0;
      Cn = this._paintRect || (this._paintRect = new BoundingRect$1(0, 0, 0, 0)), Bn ? BoundingRect$1.applyTransform(Cn, In, Bn) : Cn.copy(In), (Ln || $n || Nn) && (Cn.width += Ln * 2 + Math.abs($n), Cn.height += Ln * 2 + Math.abs(Nn), Cn.x = Math.min(Cn.x, Cn.x + $n - Ln), Cn.y = Math.min(Cn.y, Cn.y + Nn - Ln));
      var Rn = this.dirtyRectTolerance;
      Cn.isZero() || (Cn.x = Math.floor(Cn.x - Rn), Cn.y = Math.floor(Cn.y - Rn), Cn.width = Math.ceil(Cn.width + 1 + Rn * 2), Cn.height = Math.ceil(Cn.height + 1 + Rn * 2));
    }
    return Cn;
  }, nr.prototype.setPrevPaintRect = function(Cn) {
    Cn ? (this._prevPaintRect = this._prevPaintRect || new BoundingRect$1(0, 0, 0, 0), this._prevPaintRect.copy(Cn)) : this._prevPaintRect = null;
  }, nr.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, nr.prototype.animateStyle = function(Cn) {
    return this.animate("style", Cn);
  }, nr.prototype.updateDuringAnimation = function(Cn) {
    Cn === "style" ? this.dirtyStyle() : this.markRedraw();
  }, nr.prototype.attrKV = function(Cn, Bn) {
    Cn !== "style" ? _n.prototype.attrKV.call(this, Cn, Bn) : this.style ? this.setStyle(Bn) : this.useStyle(Bn);
  }, nr.prototype.setStyle = function(Cn, Bn) {
    return typeof Cn == "string" ? this.style[Cn] = Bn : extend(this.style, Cn), this.dirtyStyle(), this;
  }, nr.prototype.dirtyStyle = function(Cn) {
    Cn || this.markRedraw(), this.__dirty |= STYLE_CHANGED_BIT, this._rect && (this._rect = null);
  }, nr.prototype.dirty = function() {
    this.dirtyStyle();
  }, nr.prototype.styleChanged = function() {
    return !!(this.__dirty & STYLE_CHANGED_BIT);
  }, nr.prototype.styleUpdated = function() {
    this.__dirty &= ~STYLE_CHANGED_BIT;
  }, nr.prototype.createStyle = function(Cn) {
    return createObject(DEFAULT_COMMON_STYLE, Cn);
  }, nr.prototype.useStyle = function(Cn) {
    Cn[STYLE_MAGIC_KEY] || (Cn = this.createStyle(Cn)), this.__inHover ? this.__hoverStyle = Cn : this.style = Cn, this.dirtyStyle();
  }, nr.prototype.isStyleObject = function(Cn) {
    return Cn[STYLE_MAGIC_KEY];
  }, nr.prototype._innerSaveToNormal = function(Cn) {
    _n.prototype._innerSaveToNormal.call(this, Cn);
    var Bn = this._normalState;
    Cn.style && !Bn.style && (Bn.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(Cn, Bn, PRIMARY_STATES_KEYS);
  }, nr.prototype._applyStateObj = function(Cn, Bn, In, Dn, Ln, $n) {
    _n.prototype._applyStateObj.call(this, Cn, Bn, In, Dn, Ln, $n);
    var Nn = !(Bn && Dn), Rn;
    if (Bn && Bn.style ? Ln ? Dn ? Rn = Bn.style : (Rn = this._mergeStyle(this.createStyle(), In.style), this._mergeStyle(Rn, Bn.style)) : (Rn = this._mergeStyle(this.createStyle(), Dn ? this.style : In.style), this._mergeStyle(Rn, Bn.style)) : Nn && (Rn = In.style), Rn)
      if (Ln) {
        var Fn = this.style;
        if (this.style = this.createStyle(Nn ? {} : Fn), Nn)
          for (var Pn = keys(Fn), Un = 0; Un < Pn.length; Un++) {
            var Hn = Pn[Un];
            Hn in Rn && (Rn[Hn] = Rn[Hn], this.style[Hn] = Fn[Hn]);
          }
        for (var zn = keys(Rn), Un = 0; Un < zn.length; Un++) {
          var Hn = zn[Un];
          this.style[Hn] = this.style[Hn];
        }
        this._transitionState(Cn, {
          style: Rn
        }, $n, this.getAnimationStyleProps());
      } else
        this.useStyle(Rn);
    for (var Gn = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS, Un = 0; Un < Gn.length; Un++) {
      var Hn = Gn[Un];
      Bn && Bn[Hn] != null ? this[Hn] = Bn[Hn] : Nn && In[Hn] != null && (this[Hn] = In[Hn]);
    }
  }, nr.prototype._mergeStates = function(Cn) {
    for (var Bn = _n.prototype._mergeStates.call(this, Cn), In, Dn = 0; Dn < Cn.length; Dn++) {
      var Ln = Cn[Dn];
      Ln.style && (In = In || {}, this._mergeStyle(In, Ln.style));
    }
    return In && (Bn.style = In), Bn;
  }, nr.prototype._mergeStyle = function(Cn, Bn) {
    return extend(Cn, Bn), Cn;
  }, nr.prototype.getAnimationStyleProps = function() {
    return DEFAULT_COMMON_ANIMATION_PROPS;
  }, nr.initDefaultProps = function() {
    var Cn = nr.prototype;
    Cn.type = "displayable", Cn.invisible = !1, Cn.z = 0, Cn.z2 = 0, Cn.zlevel = 0, Cn.culling = !1, Cn.cursor = "pointer", Cn.rectHover = !1, Cn.incremental = !1, Cn._rect = null, Cn.dirtyRectTolerance = 0, Cn.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
  }(), nr;
}(Element$2), tmpRect = new BoundingRect$1(0, 0, 0, 0), viewRect = new BoundingRect$1(0, 0, 0, 0);
function isDisplayableCulled(_n, nr, Cn) {
  return tmpRect.copy(_n.getBoundingRect()), _n.transform && tmpRect.applyTransform(_n.transform), viewRect.width = nr, viewRect.height = Cn, !tmpRect.intersect(viewRect);
}
const Displayable$1 = Displayable;
var mathMin$9 = Math.min, mathMax$9 = Math.max, mathSin$4 = Math.sin, mathCos$4 = Math.cos, PI2$8 = Math.PI * 2, start$1 = create$2(), end$1 = create$2(), extremity = create$2();
function fromPoints(_n, nr, Cn) {
  if (_n.length !== 0) {
    for (var Bn = _n[0], In = Bn[0], Dn = Bn[0], Ln = Bn[1], $n = Bn[1], Nn = 1; Nn < _n.length; Nn++)
      Bn = _n[Nn], In = mathMin$9(In, Bn[0]), Dn = mathMax$9(Dn, Bn[0]), Ln = mathMin$9(Ln, Bn[1]), $n = mathMax$9($n, Bn[1]);
    nr[0] = In, nr[1] = Ln, Cn[0] = Dn, Cn[1] = $n;
  }
}
function fromLine(_n, nr, Cn, Bn, In, Dn) {
  In[0] = mathMin$9(_n, Cn), In[1] = mathMin$9(nr, Bn), Dn[0] = mathMax$9(_n, Cn), Dn[1] = mathMax$9(nr, Bn);
}
var xDim = [], yDim = [];
function fromCubic(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn) {
  var Fn = cubicExtrema, Pn = cubicAt, Un = Fn(_n, Cn, In, Ln, xDim);
  Nn[0] = 1 / 0, Nn[1] = 1 / 0, Rn[0] = -1 / 0, Rn[1] = -1 / 0;
  for (var Hn = 0; Hn < Un; Hn++) {
    var zn = Pn(_n, Cn, In, Ln, xDim[Hn]);
    Nn[0] = mathMin$9(zn, Nn[0]), Rn[0] = mathMax$9(zn, Rn[0]);
  }
  Un = Fn(nr, Bn, Dn, $n, yDim);
  for (var Hn = 0; Hn < Un; Hn++) {
    var Gn = Pn(nr, Bn, Dn, $n, yDim[Hn]);
    Nn[1] = mathMin$9(Gn, Nn[1]), Rn[1] = mathMax$9(Gn, Rn[1]);
  }
  Nn[0] = mathMin$9(_n, Nn[0]), Rn[0] = mathMax$9(_n, Rn[0]), Nn[0] = mathMin$9(Ln, Nn[0]), Rn[0] = mathMax$9(Ln, Rn[0]), Nn[1] = mathMin$9(nr, Nn[1]), Rn[1] = mathMax$9(nr, Rn[1]), Nn[1] = mathMin$9($n, Nn[1]), Rn[1] = mathMax$9($n, Rn[1]);
}
function fromQuadratic(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  var Nn = quadraticExtremum, Rn = quadraticAt$1, Fn = mathMax$9(mathMin$9(Nn(_n, Cn, In), 1), 0), Pn = mathMax$9(mathMin$9(Nn(nr, Bn, Dn), 1), 0), Un = Rn(_n, Cn, In, Fn), Hn = Rn(nr, Bn, Dn, Pn);
  Ln[0] = mathMin$9(_n, In, Un), Ln[1] = mathMin$9(nr, Dn, Hn), $n[0] = mathMax$9(_n, In, Un), $n[1] = mathMax$9(nr, Dn, Hn);
}
function fromArc(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
  var Rn = min$2, Fn = max$3, Pn = Math.abs(In - Dn);
  if (Pn % PI2$8 < 1e-4 && Pn > 1e-4) {
    $n[0] = _n - Cn, $n[1] = nr - Bn, Nn[0] = _n + Cn, Nn[1] = nr + Bn;
    return;
  }
  if (start$1[0] = mathCos$4(In) * Cn + _n, start$1[1] = mathSin$4(In) * Bn + nr, end$1[0] = mathCos$4(Dn) * Cn + _n, end$1[1] = mathSin$4(Dn) * Bn + nr, Rn($n, start$1, end$1), Fn(Nn, start$1, end$1), In = In % PI2$8, In < 0 && (In = In + PI2$8), Dn = Dn % PI2$8, Dn < 0 && (Dn = Dn + PI2$8), In > Dn && !Ln ? Dn += PI2$8 : In < Dn && Ln && (In += PI2$8), Ln) {
    var Un = Dn;
    Dn = In, In = Un;
  }
  for (var Hn = 0; Hn < Dn; Hn += Math.PI / 2)
    Hn > In && (extremity[0] = mathCos$4(Hn) * Cn + _n, extremity[1] = mathSin$4(Hn) * Bn + nr, Rn($n, extremity, $n), Fn(Nn, extremity, Nn));
}
var CMD$4 = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, tmpOutX = [], tmpOutY = [], min$1 = [], max$2 = [], min2 = [], max2 = [], mathMin$8 = Math.min, mathMax$8 = Math.max, mathCos$3 = Math.cos, mathSin$3 = Math.sin, mathAbs$2 = Math.abs, PI$8 = Math.PI, PI2$7 = PI$8 * 2, hasTypedArray = typeof Float32Array < "u", tmpAngles = [];
function modPI2(_n) {
  var nr = Math.round(_n / PI$8 * 1e8) / 1e8;
  return nr % 2 * PI$8;
}
function normalizeArcAngles(_n, nr) {
  var Cn = modPI2(_n[0]);
  Cn < 0 && (Cn += PI2$7);
  var Bn = Cn - _n[0], In = _n[1];
  In += Bn, !nr && In - Cn >= PI2$7 ? In = Cn + PI2$7 : nr && Cn - In >= PI2$7 ? In = Cn - PI2$7 : !nr && Cn > In ? In = Cn + (PI2$7 - modPI2(Cn - In)) : nr && Cn < In && (In = Cn - (PI2$7 - modPI2(In - Cn))), _n[0] = Cn, _n[1] = In;
}
var PathProxy = function() {
  function _n(nr) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, nr && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return _n.prototype.increaseVersion = function() {
    this._version++;
  }, _n.prototype.getVersion = function() {
    return this._version;
  }, _n.prototype.setScale = function(nr, Cn, Bn) {
    Bn = Bn || 0, Bn > 0 && (this._ux = mathAbs$2(Bn / devicePixelRatio / nr) || 0, this._uy = mathAbs$2(Bn / devicePixelRatio / Cn) || 0);
  }, _n.prototype.setDPR = function(nr) {
    this.dpr = nr;
  }, _n.prototype.setContext = function(nr) {
    this._ctx = nr;
  }, _n.prototype.getContext = function() {
    return this._ctx;
  }, _n.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, _n.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, _n.prototype.moveTo = function(nr, Cn) {
    return this._drawPendingPt(), this.addData(CMD$4.M, nr, Cn), this._ctx && this._ctx.moveTo(nr, Cn), this._x0 = nr, this._y0 = Cn, this._xi = nr, this._yi = Cn, this;
  }, _n.prototype.lineTo = function(nr, Cn) {
    var Bn = mathAbs$2(nr - this._xi), In = mathAbs$2(Cn - this._yi), Dn = Bn > this._ux || In > this._uy;
    if (this.addData(CMD$4.L, nr, Cn), this._ctx && Dn && this._ctx.lineTo(nr, Cn), Dn)
      this._xi = nr, this._yi = Cn, this._pendingPtDist = 0;
    else {
      var Ln = Bn * Bn + In * In;
      Ln > this._pendingPtDist && (this._pendingPtX = nr, this._pendingPtY = Cn, this._pendingPtDist = Ln);
    }
    return this;
  }, _n.prototype.bezierCurveTo = function(nr, Cn, Bn, In, Dn, Ln) {
    return this._drawPendingPt(), this.addData(CMD$4.C, nr, Cn, Bn, In, Dn, Ln), this._ctx && this._ctx.bezierCurveTo(nr, Cn, Bn, In, Dn, Ln), this._xi = Dn, this._yi = Ln, this;
  }, _n.prototype.quadraticCurveTo = function(nr, Cn, Bn, In) {
    return this._drawPendingPt(), this.addData(CMD$4.Q, nr, Cn, Bn, In), this._ctx && this._ctx.quadraticCurveTo(nr, Cn, Bn, In), this._xi = Bn, this._yi = In, this;
  }, _n.prototype.arc = function(nr, Cn, Bn, In, Dn, Ln) {
    this._drawPendingPt(), tmpAngles[0] = In, tmpAngles[1] = Dn, normalizeArcAngles(tmpAngles, Ln), In = tmpAngles[0], Dn = tmpAngles[1];
    var $n = Dn - In;
    return this.addData(CMD$4.A, nr, Cn, Bn, Bn, In, $n, 0, Ln ? 0 : 1), this._ctx && this._ctx.arc(nr, Cn, Bn, In, Dn, Ln), this._xi = mathCos$3(Dn) * Bn + nr, this._yi = mathSin$3(Dn) * Bn + Cn, this;
  }, _n.prototype.arcTo = function(nr, Cn, Bn, In, Dn) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(nr, Cn, Bn, In, Dn), this;
  }, _n.prototype.rect = function(nr, Cn, Bn, In) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(nr, Cn, Bn, In), this.addData(CMD$4.R, nr, Cn, Bn, In), this;
  }, _n.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(CMD$4.Z);
    var nr = this._ctx, Cn = this._x0, Bn = this._y0;
    return nr && nr.closePath(), this._xi = Cn, this._yi = Bn, this;
  }, _n.prototype.fill = function(nr) {
    nr && nr.fill(), this.toStatic();
  }, _n.prototype.stroke = function(nr) {
    nr && nr.stroke(), this.toStatic();
  }, _n.prototype.len = function() {
    return this._len;
  }, _n.prototype.setData = function(nr) {
    var Cn = nr.length;
    !(this.data && this.data.length === Cn) && hasTypedArray && (this.data = new Float32Array(Cn));
    for (var Bn = 0; Bn < Cn; Bn++)
      this.data[Bn] = nr[Bn];
    this._len = Cn;
  }, _n.prototype.appendPath = function(nr) {
    nr instanceof Array || (nr = [nr]);
    for (var Cn = nr.length, Bn = 0, In = this._len, Dn = 0; Dn < Cn; Dn++)
      Bn += nr[Dn].len();
    hasTypedArray && this.data instanceof Float32Array && (this.data = new Float32Array(In + Bn));
    for (var Dn = 0; Dn < Cn; Dn++)
      for (var Ln = nr[Dn].data, $n = 0; $n < Ln.length; $n++)
        this.data[In++] = Ln[$n];
    this._len = In;
  }, _n.prototype.addData = function(nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn) {
    if (this._saveData) {
      var Fn = this.data;
      this._len + arguments.length > Fn.length && (this._expandData(), Fn = this.data);
      for (var Pn = 0; Pn < arguments.length; Pn++)
        Fn[this._len++] = arguments[Pn];
    }
  }, _n.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, _n.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var nr = [], Cn = 0; Cn < this._len; Cn++)
        nr[Cn] = this.data[Cn];
      this.data = nr;
    }
  }, _n.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var nr = this.data;
      nr instanceof Array && (nr.length = this._len, hasTypedArray && this._len > 11 && (this.data = new Float32Array(nr)));
    }
  }, _n.prototype.getBoundingRect = function() {
    min$1[0] = min$1[1] = min2[0] = min2[1] = Number.MAX_VALUE, max$2[0] = max$2[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var nr = this.data, Cn = 0, Bn = 0, In = 0, Dn = 0, Ln;
    for (Ln = 0; Ln < this._len; ) {
      var $n = nr[Ln++], Nn = Ln === 1;
      switch (Nn && (Cn = nr[Ln], Bn = nr[Ln + 1], In = Cn, Dn = Bn), $n) {
        case CMD$4.M:
          Cn = In = nr[Ln++], Bn = Dn = nr[Ln++], min2[0] = In, min2[1] = Dn, max2[0] = In, max2[1] = Dn;
          break;
        case CMD$4.L:
          fromLine(Cn, Bn, nr[Ln], nr[Ln + 1], min2, max2), Cn = nr[Ln++], Bn = nr[Ln++];
          break;
        case CMD$4.C:
          fromCubic(Cn, Bn, nr[Ln++], nr[Ln++], nr[Ln++], nr[Ln++], nr[Ln], nr[Ln + 1], min2, max2), Cn = nr[Ln++], Bn = nr[Ln++];
          break;
        case CMD$4.Q:
          fromQuadratic(Cn, Bn, nr[Ln++], nr[Ln++], nr[Ln], nr[Ln + 1], min2, max2), Cn = nr[Ln++], Bn = nr[Ln++];
          break;
        case CMD$4.A:
          var Rn = nr[Ln++], Fn = nr[Ln++], Pn = nr[Ln++], Un = nr[Ln++], Hn = nr[Ln++], zn = nr[Ln++] + Hn;
          Ln += 1;
          var Gn = !nr[Ln++];
          Nn && (In = mathCos$3(Hn) * Pn + Rn, Dn = mathSin$3(Hn) * Un + Fn), fromArc(Rn, Fn, Pn, Un, Hn, zn, Gn, min2, max2), Cn = mathCos$3(zn) * Pn + Rn, Bn = mathSin$3(zn) * Un + Fn;
          break;
        case CMD$4.R:
          In = Cn = nr[Ln++], Dn = Bn = nr[Ln++];
          var Yn = nr[Ln++], Wn = nr[Ln++];
          fromLine(In, Dn, In + Yn, Dn + Wn, min2, max2);
          break;
        case CMD$4.Z:
          Cn = In, Bn = Dn;
          break;
      }
      min$2(min$1, min$1, min2), max$3(max$2, max$2, max2);
    }
    return Ln === 0 && (min$1[0] = min$1[1] = max$2[0] = max$2[1] = 0), new BoundingRect$1(min$1[0], min$1[1], max$2[0] - min$1[0], max$2[1] - min$1[1]);
  }, _n.prototype._calculateLength = function() {
    var nr = this.data, Cn = this._len, Bn = this._ux, In = this._uy, Dn = 0, Ln = 0, $n = 0, Nn = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var Rn = this._pathSegLen, Fn = 0, Pn = 0, Un = 0; Un < Cn; ) {
      var Hn = nr[Un++], zn = Un === 1;
      zn && (Dn = nr[Un], Ln = nr[Un + 1], $n = Dn, Nn = Ln);
      var Gn = -1;
      switch (Hn) {
        case CMD$4.M:
          Dn = $n = nr[Un++], Ln = Nn = nr[Un++];
          break;
        case CMD$4.L: {
          var Yn = nr[Un++], Wn = nr[Un++], Xn = Yn - Dn, ea = Wn - Ln;
          (mathAbs$2(Xn) > Bn || mathAbs$2(ea) > In || Un === Cn - 1) && (Gn = Math.sqrt(Xn * Xn + ea * ea), Dn = Yn, Ln = Wn);
          break;
        }
        case CMD$4.C: {
          var ta = nr[Un++], na = nr[Un++], Yn = nr[Un++], Wn = nr[Un++], ra = nr[Un++], aa = nr[Un++];
          Gn = cubicLength(Dn, Ln, ta, na, Yn, Wn, ra, aa, 10), Dn = ra, Ln = aa;
          break;
        }
        case CMD$4.Q: {
          var ta = nr[Un++], na = nr[Un++], Yn = nr[Un++], Wn = nr[Un++];
          Gn = quadraticLength(Dn, Ln, ta, na, Yn, Wn, 10), Dn = Yn, Ln = Wn;
          break;
        }
        case CMD$4.A:
          var ia = nr[Un++], Aa = nr[Un++], sa = nr[Un++], oa = nr[Un++], la = nr[Un++], ua = nr[Un++], ca = ua + la;
          Un += 1, zn && ($n = mathCos$3(la) * sa + ia, Nn = mathSin$3(la) * oa + Aa), Gn = mathMax$8(sa, oa) * mathMin$8(PI2$7, Math.abs(ua)), Dn = mathCos$3(ca) * sa + ia, Ln = mathSin$3(ca) * oa + Aa;
          break;
        case CMD$4.R: {
          $n = Dn = nr[Un++], Nn = Ln = nr[Un++];
          var fa = nr[Un++], ha = nr[Un++];
          Gn = fa * 2 + ha * 2;
          break;
        }
        case CMD$4.Z: {
          var Xn = $n - Dn, ea = Nn - Ln;
          Gn = Math.sqrt(Xn * Xn + ea * ea), Dn = $n, Ln = Nn;
          break;
        }
      }
      Gn >= 0 && (Rn[Pn++] = Gn, Fn += Gn);
    }
    return this._pathLen = Fn, Fn;
  }, _n.prototype.rebuildPath = function(nr, Cn) {
    var Bn = this.data, In = this._ux, Dn = this._uy, Ln = this._len, $n, Nn, Rn, Fn, Pn, Un, Hn = Cn < 1, zn, Gn, Yn = 0, Wn = 0, Xn, ea = 0, ta, na;
    if (!(Hn && (this._pathSegLen || this._calculateLength(), zn = this._pathSegLen, Gn = this._pathLen, Xn = Cn * Gn, !Xn)))
      e:
        for (var ra = 0; ra < Ln; ) {
          var aa = Bn[ra++], ia = ra === 1;
          switch (ia && (Rn = Bn[ra], Fn = Bn[ra + 1], $n = Rn, Nn = Fn), aa !== CMD$4.L && ea > 0 && (nr.lineTo(ta, na), ea = 0), aa) {
            case CMD$4.M:
              $n = Rn = Bn[ra++], Nn = Fn = Bn[ra++], nr.moveTo(Rn, Fn);
              break;
            case CMD$4.L: {
              Pn = Bn[ra++], Un = Bn[ra++];
              var Aa = mathAbs$2(Pn - Rn), sa = mathAbs$2(Un - Fn);
              if (Aa > In || sa > Dn) {
                if (Hn) {
                  var oa = zn[Wn++];
                  if (Yn + oa > Xn) {
                    var la = (Xn - Yn) / oa;
                    nr.lineTo(Rn * (1 - la) + Pn * la, Fn * (1 - la) + Un * la);
                    break e;
                  }
                  Yn += oa;
                }
                nr.lineTo(Pn, Un), Rn = Pn, Fn = Un, ea = 0;
              } else {
                var ua = Aa * Aa + sa * sa;
                ua > ea && (ta = Pn, na = Un, ea = ua);
              }
              break;
            }
            case CMD$4.C: {
              var ca = Bn[ra++], fa = Bn[ra++], ha = Bn[ra++], pa = Bn[ra++], ya = Bn[ra++], da = Bn[ra++];
              if (Hn) {
                var oa = zn[Wn++];
                if (Yn + oa > Xn) {
                  var la = (Xn - Yn) / oa;
                  cubicSubdivide(Rn, ca, ha, ya, la, tmpOutX), cubicSubdivide(Fn, fa, pa, da, la, tmpOutY), nr.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                  break e;
                }
                Yn += oa;
              }
              nr.bezierCurveTo(ca, fa, ha, pa, ya, da), Rn = ya, Fn = da;
              break;
            }
            case CMD$4.Q: {
              var ca = Bn[ra++], fa = Bn[ra++], ha = Bn[ra++], pa = Bn[ra++];
              if (Hn) {
                var oa = zn[Wn++];
                if (Yn + oa > Xn) {
                  var la = (Xn - Yn) / oa;
                  quadraticSubdivide(Rn, ca, ha, la, tmpOutX), quadraticSubdivide(Fn, fa, pa, la, tmpOutY), nr.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                  break e;
                }
                Yn += oa;
              }
              nr.quadraticCurveTo(ca, fa, ha, pa), Rn = ha, Fn = pa;
              break;
            }
            case CMD$4.A:
              var Ca = Bn[ra++], ma = Bn[ra++], va = Bn[ra++], ga = Bn[ra++], xa = Bn[ra++], wa = Bn[ra++], ba = Bn[ra++], Ta = !Bn[ra++], Sa = va > ga ? va : ga, Ea = mathAbs$2(va - ga) > 1e-3, Ia = xa + wa, Ba = !1;
              if (Hn) {
                var oa = zn[Wn++];
                Yn + oa > Xn && (Ia = xa + wa * (Xn - Yn) / oa, Ba = !0), Yn += oa;
              }
              if (Ea && nr.ellipse ? nr.ellipse(Ca, ma, va, ga, ba, xa, Ia, Ta) : nr.arc(Ca, ma, Sa, xa, Ia, Ta), Ba)
                break e;
              ia && ($n = mathCos$3(xa) * va + Ca, Nn = mathSin$3(xa) * ga + ma), Rn = mathCos$3(Ia) * va + Ca, Fn = mathSin$3(Ia) * ga + ma;
              break;
            case CMD$4.R:
              $n = Rn = Bn[ra], Nn = Fn = Bn[ra + 1], Pn = Bn[ra++], Un = Bn[ra++];
              var Ma = Bn[ra++], La = Bn[ra++];
              if (Hn) {
                var oa = zn[Wn++];
                if (Yn + oa > Xn) {
                  var Da = Xn - Yn;
                  nr.moveTo(Pn, Un), nr.lineTo(Pn + mathMin$8(Da, Ma), Un), Da -= Ma, Da > 0 && nr.lineTo(Pn + Ma, Un + mathMin$8(Da, La)), Da -= La, Da > 0 && nr.lineTo(Pn + mathMax$8(Ma - Da, 0), Un + La), Da -= Ma, Da > 0 && nr.lineTo(Pn, Un + mathMax$8(La - Da, 0));
                  break e;
                }
                Yn += oa;
              }
              nr.rect(Pn, Un, Ma, La);
              break;
            case CMD$4.Z:
              if (Hn) {
                var oa = zn[Wn++];
                if (Yn + oa > Xn) {
                  var la = (Xn - Yn) / oa;
                  nr.lineTo(Rn * (1 - la) + $n * la, Fn * (1 - la) + Nn * la);
                  break e;
                }
                Yn += oa;
              }
              nr.closePath(), Rn = $n, Fn = Nn;
          }
        }
  }, _n.prototype.clone = function() {
    var nr = new _n(), Cn = this.data;
    return nr.data = Cn.slice ? Cn.slice() : Array.prototype.slice.call(Cn), nr._len = this._len, nr;
  }, _n.CMD = CMD$4, _n.initDefaultProps = function() {
    var nr = _n.prototype;
    nr._saveData = !0, nr._ux = 0, nr._uy = 0, nr._pendingPtDist = 0, nr._version = 0;
  }(), _n;
}();
const PathProxy$1 = PathProxy;
function containStroke$4(_n, nr, Cn, Bn, In, Dn, Ln) {
  if (In === 0)
    return !1;
  var $n = In, Nn = 0, Rn = _n;
  if (Ln > nr + $n && Ln > Bn + $n || Ln < nr - $n && Ln < Bn - $n || Dn > _n + $n && Dn > Cn + $n || Dn < _n - $n && Dn < Cn - $n)
    return !1;
  if (_n !== Cn)
    Nn = (nr - Bn) / (_n - Cn), Rn = (_n * Bn - Cn * nr) / (_n - Cn);
  else
    return Math.abs(Dn - _n) <= $n / 2;
  var Fn = Nn * Dn - Ln + Rn, Pn = Fn * Fn / (Nn * Nn + 1);
  return Pn <= $n / 2 * $n / 2;
}
function containStroke$3(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn, Fn) {
  if (Nn === 0)
    return !1;
  var Pn = Nn;
  if (Fn > nr + Pn && Fn > Bn + Pn && Fn > Dn + Pn && Fn > $n + Pn || Fn < nr - Pn && Fn < Bn - Pn && Fn < Dn - Pn && Fn < $n - Pn || Rn > _n + Pn && Rn > Cn + Pn && Rn > In + Pn && Rn > Ln + Pn || Rn < _n - Pn && Rn < Cn - Pn && Rn < In - Pn && Rn < Ln - Pn)
    return !1;
  var Un = cubicProjectPoint(_n, nr, Cn, Bn, In, Dn, Ln, $n, Rn, Fn, null);
  return Un <= Pn / 2;
}
function containStroke$2(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
  if (Ln === 0)
    return !1;
  var Rn = Ln;
  if (Nn > nr + Rn && Nn > Bn + Rn && Nn > Dn + Rn || Nn < nr - Rn && Nn < Bn - Rn && Nn < Dn - Rn || $n > _n + Rn && $n > Cn + Rn && $n > In + Rn || $n < _n - Rn && $n < Cn - Rn && $n < In - Rn)
    return !1;
  var Fn = quadraticProjectPoint(_n, nr, Cn, Bn, In, Dn, $n, Nn, null);
  return Fn <= Rn / 2;
}
var PI2$6 = Math.PI * 2;
function normalizeRadian(_n) {
  return _n %= PI2$6, _n < 0 && (_n += PI2$6), _n;
}
var PI2$5 = Math.PI * 2;
function containStroke$1(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
  if (Ln === 0)
    return !1;
  var Rn = Ln;
  $n -= _n, Nn -= nr;
  var Fn = Math.sqrt($n * $n + Nn * Nn);
  if (Fn - Rn > Cn || Fn + Rn < Cn)
    return !1;
  if (Math.abs(Bn - In) % PI2$5 < 1e-4)
    return !0;
  if (Dn) {
    var Pn = Bn;
    Bn = normalizeRadian(In), In = normalizeRadian(Pn);
  } else
    Bn = normalizeRadian(Bn), In = normalizeRadian(In);
  Bn > In && (In += PI2$5);
  var Un = Math.atan2(Nn, $n);
  return Un < 0 && (Un += PI2$5), Un >= Bn && Un <= In || Un + PI2$5 >= Bn && Un + PI2$5 <= In;
}
function windingLine(_n, nr, Cn, Bn, In, Dn) {
  if (Dn > nr && Dn > Bn || Dn < nr && Dn < Bn || Bn === nr)
    return 0;
  var Ln = (Dn - nr) / (Bn - nr), $n = Bn < nr ? 1 : -1;
  (Ln === 1 || Ln === 0) && ($n = Bn < nr ? 0.5 : -0.5);
  var Nn = Ln * (Cn - _n) + _n;
  return Nn === In ? 1 / 0 : Nn > In ? $n : 0;
}
var CMD$3 = PathProxy$1.CMD, PI2$4 = Math.PI * 2, EPSILON$1 = 1e-4;
function isAroundEqual$1(_n, nr) {
  return Math.abs(_n - nr) < EPSILON$1;
}
var roots = [-1, -1, -1], extrema = [-1, -1];
function swapExtrema() {
  var _n = extrema[0];
  extrema[0] = extrema[1], extrema[1] = _n;
}
function windingCubic(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn) {
  if (Rn > nr && Rn > Bn && Rn > Dn && Rn > $n || Rn < nr && Rn < Bn && Rn < Dn && Rn < $n)
    return 0;
  var Fn = cubicRootAt(nr, Bn, Dn, $n, Rn, roots);
  if (Fn === 0)
    return 0;
  for (var Pn = 0, Un = -1, Hn = void 0, zn = void 0, Gn = 0; Gn < Fn; Gn++) {
    var Yn = roots[Gn], Wn = Yn === 0 || Yn === 1 ? 0.5 : 1, Xn = cubicAt(_n, Cn, In, Ln, Yn);
    Xn < Nn || (Un < 0 && (Un = cubicExtrema(nr, Bn, Dn, $n, extrema), extrema[1] < extrema[0] && Un > 1 && swapExtrema(), Hn = cubicAt(nr, Bn, Dn, $n, extrema[0]), Un > 1 && (zn = cubicAt(nr, Bn, Dn, $n, extrema[1]))), Un === 2 ? Yn < extrema[0] ? Pn += Hn < nr ? Wn : -Wn : Yn < extrema[1] ? Pn += zn < Hn ? Wn : -Wn : Pn += $n < zn ? Wn : -Wn : Yn < extrema[0] ? Pn += Hn < nr ? Wn : -Wn : Pn += $n < Hn ? Wn : -Wn);
  }
  return Pn;
}
function windingQuadratic(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  if ($n > nr && $n > Bn && $n > Dn || $n < nr && $n < Bn && $n < Dn)
    return 0;
  var Nn = quadraticRootAt(nr, Bn, Dn, $n, roots);
  if (Nn === 0)
    return 0;
  var Rn = quadraticExtremum(nr, Bn, Dn);
  if (Rn >= 0 && Rn <= 1) {
    for (var Fn = 0, Pn = quadraticAt$1(nr, Bn, Dn, Rn), Un = 0; Un < Nn; Un++) {
      var Hn = roots[Un] === 0 || roots[Un] === 1 ? 0.5 : 1, zn = quadraticAt$1(_n, Cn, In, roots[Un]);
      zn < Ln || (roots[Un] < Rn ? Fn += Pn < nr ? Hn : -Hn : Fn += Dn < Pn ? Hn : -Hn);
    }
    return Fn;
  } else {
    var Hn = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1, zn = quadraticAt$1(_n, Cn, In, roots[0]);
    return zn < Ln ? 0 : Dn < nr ? Hn : -Hn;
  }
}
function windingArc(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  if ($n -= nr, $n > Cn || $n < -Cn)
    return 0;
  var Nn = Math.sqrt(Cn * Cn - $n * $n);
  roots[0] = -Nn, roots[1] = Nn;
  var Rn = Math.abs(Bn - In);
  if (Rn < 1e-4)
    return 0;
  if (Rn >= PI2$4 - 1e-4) {
    Bn = 0, In = PI2$4;
    var Fn = Dn ? 1 : -1;
    return Ln >= roots[0] + _n && Ln <= roots[1] + _n ? Fn : 0;
  }
  if (Bn > In) {
    var Pn = Bn;
    Bn = In, In = Pn;
  }
  Bn < 0 && (Bn += PI2$4, In += PI2$4);
  for (var Un = 0, Hn = 0; Hn < 2; Hn++) {
    var zn = roots[Hn];
    if (zn + _n > Ln) {
      var Gn = Math.atan2($n, zn), Fn = Dn ? 1 : -1;
      Gn < 0 && (Gn = PI2$4 + Gn), (Gn >= Bn && Gn <= In || Gn + PI2$4 >= Bn && Gn + PI2$4 <= In) && (Gn > Math.PI / 2 && Gn < Math.PI * 1.5 && (Fn = -Fn), Un += Fn);
    }
  }
  return Un;
}
function containPath(_n, nr, Cn, Bn, In) {
  for (var Dn = _n.data, Ln = _n.len(), $n = 0, Nn = 0, Rn = 0, Fn = 0, Pn = 0, Un, Hn, zn = 0; zn < Ln; ) {
    var Gn = Dn[zn++], Yn = zn === 1;
    switch (Gn === CMD$3.M && zn > 1 && (Cn || ($n += windingLine(Nn, Rn, Fn, Pn, Bn, In))), Yn && (Nn = Dn[zn], Rn = Dn[zn + 1], Fn = Nn, Pn = Rn), Gn) {
      case CMD$3.M:
        Fn = Dn[zn++], Pn = Dn[zn++], Nn = Fn, Rn = Pn;
        break;
      case CMD$3.L:
        if (Cn) {
          if (containStroke$4(Nn, Rn, Dn[zn], Dn[zn + 1], nr, Bn, In))
            return !0;
        } else
          $n += windingLine(Nn, Rn, Dn[zn], Dn[zn + 1], Bn, In) || 0;
        Nn = Dn[zn++], Rn = Dn[zn++];
        break;
      case CMD$3.C:
        if (Cn) {
          if (containStroke$3(Nn, Rn, Dn[zn++], Dn[zn++], Dn[zn++], Dn[zn++], Dn[zn], Dn[zn + 1], nr, Bn, In))
            return !0;
        } else
          $n += windingCubic(Nn, Rn, Dn[zn++], Dn[zn++], Dn[zn++], Dn[zn++], Dn[zn], Dn[zn + 1], Bn, In) || 0;
        Nn = Dn[zn++], Rn = Dn[zn++];
        break;
      case CMD$3.Q:
        if (Cn) {
          if (containStroke$2(Nn, Rn, Dn[zn++], Dn[zn++], Dn[zn], Dn[zn + 1], nr, Bn, In))
            return !0;
        } else
          $n += windingQuadratic(Nn, Rn, Dn[zn++], Dn[zn++], Dn[zn], Dn[zn + 1], Bn, In) || 0;
        Nn = Dn[zn++], Rn = Dn[zn++];
        break;
      case CMD$3.A:
        var Wn = Dn[zn++], Xn = Dn[zn++], ea = Dn[zn++], ta = Dn[zn++], na = Dn[zn++], ra = Dn[zn++];
        zn += 1;
        var aa = !!(1 - Dn[zn++]);
        Un = Math.cos(na) * ea + Wn, Hn = Math.sin(na) * ta + Xn, Yn ? (Fn = Un, Pn = Hn) : $n += windingLine(Nn, Rn, Un, Hn, Bn, In);
        var ia = (Bn - Wn) * ta / ea + Wn;
        if (Cn) {
          if (containStroke$1(Wn, Xn, ta, na, na + ra, aa, nr, ia, In))
            return !0;
        } else
          $n += windingArc(Wn, Xn, ta, na, na + ra, aa, ia, In);
        Nn = Math.cos(na + ra) * ea + Wn, Rn = Math.sin(na + ra) * ta + Xn;
        break;
      case CMD$3.R:
        Fn = Nn = Dn[zn++], Pn = Rn = Dn[zn++];
        var Aa = Dn[zn++], sa = Dn[zn++];
        if (Un = Fn + Aa, Hn = Pn + sa, Cn) {
          if (containStroke$4(Fn, Pn, Un, Pn, nr, Bn, In) || containStroke$4(Un, Pn, Un, Hn, nr, Bn, In) || containStroke$4(Un, Hn, Fn, Hn, nr, Bn, In) || containStroke$4(Fn, Hn, Fn, Pn, nr, Bn, In))
            return !0;
        } else
          $n += windingLine(Un, Pn, Un, Hn, Bn, In), $n += windingLine(Fn, Hn, Fn, Pn, Bn, In);
        break;
      case CMD$3.Z:
        if (Cn) {
          if (containStroke$4(Nn, Rn, Fn, Pn, nr, Bn, In))
            return !0;
        } else
          $n += windingLine(Nn, Rn, Fn, Pn, Bn, In);
        Nn = Fn, Rn = Pn;
        break;
    }
  }
  return !Cn && !isAroundEqual$1(Rn, Pn) && ($n += windingLine(Nn, Rn, Fn, Pn, Bn, In) || 0), $n !== 0;
}
function contain$2(_n, nr, Cn) {
  return containPath(_n, 0, !1, nr, Cn);
}
function containStroke(_n, nr, Cn, Bn) {
  return containPath(_n, nr, !0, Cn, Bn);
}
var DEFAULT_PATH_STYLE = defaults({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, DEFAULT_COMMON_STYLE), DEFAULT_PATH_ANIMATION_PROPS = {
  style: defaults({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
}, pathCopyParams = TRANSFORMABLE_PROPS.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), Path = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.update = function() {
    var Cn = this;
    _n.prototype.update.call(this);
    var Bn = this.style;
    if (Bn.decal) {
      var In = this._decalEl = this._decalEl || new nr();
      In.buildPath === nr.prototype.buildPath && (In.buildPath = function(Nn) {
        Cn.buildPath(Nn, Cn.shape);
      }), In.silent = !0;
      var Dn = In.style;
      for (var Ln in Bn)
        Dn[Ln] !== Bn[Ln] && (Dn[Ln] = Bn[Ln]);
      Dn.fill = Bn.fill ? Bn.decal : null, Dn.decal = null, Dn.shadowColor = null, Bn.strokeFirst && (Dn.stroke = null);
      for (var $n = 0; $n < pathCopyParams.length; ++$n)
        In[pathCopyParams[$n]] = this[pathCopyParams[$n]];
      In.__dirty |= REDRAW_BIT;
    } else
      this._decalEl && (this._decalEl = null);
  }, nr.prototype.getDecalElement = function() {
    return this._decalEl;
  }, nr.prototype._init = function(Cn) {
    var Bn = keys(Cn);
    this.shape = this.getDefaultShape();
    var In = this.getDefaultStyle();
    In && this.useStyle(In);
    for (var Dn = 0; Dn < Bn.length; Dn++) {
      var Ln = Bn[Dn], $n = Cn[Ln];
      Ln === "style" ? this.style ? extend(this.style, $n) : this.useStyle($n) : Ln === "shape" ? extend(this.shape, $n) : _n.prototype.attrKV.call(this, Ln, $n);
    }
    this.style || this.useStyle({});
  }, nr.prototype.getDefaultStyle = function() {
    return null;
  }, nr.prototype.getDefaultShape = function() {
    return {};
  }, nr.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, nr.prototype.getInsideTextFill = function() {
    var Cn = this.style.fill;
    if (Cn !== "none") {
      if (isString$1(Cn)) {
        var Bn = lum(Cn, 0);
        return Bn > 0.5 ? DARK_LABEL_COLOR : Bn > 0.2 ? LIGHTER_LABEL_COLOR : LIGHT_LABEL_COLOR;
      } else if (Cn)
        return LIGHT_LABEL_COLOR;
    }
    return DARK_LABEL_COLOR;
  }, nr.prototype.getInsideTextStroke = function(Cn) {
    var Bn = this.style.fill;
    if (isString$1(Bn)) {
      var In = this.__zr, Dn = !!(In && In.isDarkMode()), Ln = lum(Cn, 0) < DARK_MODE_THRESHOLD;
      if (Dn === Ln)
        return Bn;
    }
  }, nr.prototype.buildPath = function(Cn, Bn, In) {
  }, nr.prototype.pathUpdated = function() {
    this.__dirty &= ~SHAPE_CHANGED_BIT;
  }, nr.prototype.getUpdatedPathProxy = function(Cn) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, Cn), this.path;
  }, nr.prototype.createPathProxy = function() {
    this.path = new PathProxy$1(!1);
  }, nr.prototype.hasStroke = function() {
    var Cn = this.style, Bn = Cn.stroke;
    return !(Bn == null || Bn === "none" || !(Cn.lineWidth > 0));
  }, nr.prototype.hasFill = function() {
    var Cn = this.style, Bn = Cn.fill;
    return Bn != null && Bn !== "none";
  }, nr.prototype.getBoundingRect = function() {
    var Cn = this._rect, Bn = this.style, In = !Cn;
    if (In) {
      var Dn = !1;
      this.path || (Dn = !0, this.createPathProxy());
      var Ln = this.path;
      (Dn || this.__dirty & SHAPE_CHANGED_BIT) && (Ln.beginPath(), this.buildPath(Ln, this.shape, !1), this.pathUpdated()), Cn = Ln.getBoundingRect();
    }
    if (this._rect = Cn, this.hasStroke() && this.path && this.path.len() > 0) {
      var $n = this._rectStroke || (this._rectStroke = Cn.clone());
      if (this.__dirty || In) {
        $n.copy(Cn);
        var Nn = Bn.strokeNoScale ? this.getLineScale() : 1, Rn = Bn.lineWidth;
        if (!this.hasFill()) {
          var Fn = this.strokeContainThreshold;
          Rn = Math.max(Rn, Fn ?? 4);
        }
        Nn > 1e-10 && ($n.width += Rn / Nn, $n.height += Rn / Nn, $n.x -= Rn / Nn / 2, $n.y -= Rn / Nn / 2);
      }
      return $n;
    }
    return Cn;
  }, nr.prototype.contain = function(Cn, Bn) {
    var In = this.transformCoordToLocal(Cn, Bn), Dn = this.getBoundingRect(), Ln = this.style;
    if (Cn = In[0], Bn = In[1], Dn.contain(Cn, Bn)) {
      var $n = this.path;
      if (this.hasStroke()) {
        var Nn = Ln.lineWidth, Rn = Ln.strokeNoScale ? this.getLineScale() : 1;
        if (Rn > 1e-10 && (this.hasFill() || (Nn = Math.max(Nn, this.strokeContainThreshold)), containStroke($n, Nn / Rn, Cn, Bn)))
          return !0;
      }
      if (this.hasFill())
        return contain$2($n, Cn, Bn);
    }
    return !1;
  }, nr.prototype.dirtyShape = function() {
    this.__dirty |= SHAPE_CHANGED_BIT, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, nr.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, nr.prototype.animateShape = function(Cn) {
    return this.animate("shape", Cn);
  }, nr.prototype.updateDuringAnimation = function(Cn) {
    Cn === "style" ? this.dirtyStyle() : Cn === "shape" ? this.dirtyShape() : this.markRedraw();
  }, nr.prototype.attrKV = function(Cn, Bn) {
    Cn === "shape" ? this.setShape(Bn) : _n.prototype.attrKV.call(this, Cn, Bn);
  }, nr.prototype.setShape = function(Cn, Bn) {
    var In = this.shape;
    return In || (In = this.shape = {}), typeof Cn == "string" ? In[Cn] = Bn : extend(In, Cn), this.dirtyShape(), this;
  }, nr.prototype.shapeChanged = function() {
    return !!(this.__dirty & SHAPE_CHANGED_BIT);
  }, nr.prototype.createStyle = function(Cn) {
    return createObject(DEFAULT_PATH_STYLE, Cn);
  }, nr.prototype._innerSaveToNormal = function(Cn) {
    _n.prototype._innerSaveToNormal.call(this, Cn);
    var Bn = this._normalState;
    Cn.shape && !Bn.shape && (Bn.shape = extend({}, this.shape));
  }, nr.prototype._applyStateObj = function(Cn, Bn, In, Dn, Ln, $n) {
    _n.prototype._applyStateObj.call(this, Cn, Bn, In, Dn, Ln, $n);
    var Nn = !(Bn && Dn), Rn;
    if (Bn && Bn.shape ? Ln ? Dn ? Rn = Bn.shape : (Rn = extend({}, In.shape), extend(Rn, Bn.shape)) : (Rn = extend({}, Dn ? this.shape : In.shape), extend(Rn, Bn.shape)) : Nn && (Rn = In.shape), Rn)
      if (Ln) {
        this.shape = extend({}, this.shape);
        for (var Fn = {}, Pn = keys(Rn), Un = 0; Un < Pn.length; Un++) {
          var Hn = Pn[Un];
          typeof Rn[Hn] == "object" ? this.shape[Hn] = Rn[Hn] : Fn[Hn] = Rn[Hn];
        }
        this._transitionState(Cn, {
          shape: Fn
        }, $n);
      } else
        this.shape = Rn, this.dirtyShape();
  }, nr.prototype._mergeStates = function(Cn) {
    for (var Bn = _n.prototype._mergeStates.call(this, Cn), In, Dn = 0; Dn < Cn.length; Dn++) {
      var Ln = Cn[Dn];
      Ln.shape && (In = In || {}, this._mergeStyle(In, Ln.shape));
    }
    return In && (Bn.shape = In), Bn;
  }, nr.prototype.getAnimationStyleProps = function() {
    return DEFAULT_PATH_ANIMATION_PROPS;
  }, nr.prototype.isZeroArea = function() {
    return !1;
  }, nr.extend = function(Cn) {
    var Bn = function(Dn) {
      __extends$2(Ln, Dn);
      function Ln($n) {
        var Nn = Dn.call(this, $n) || this;
        return Cn.init && Cn.init.call(Nn, $n), Nn;
      }
      return Ln.prototype.getDefaultStyle = function() {
        return clone$4(Cn.style);
      }, Ln.prototype.getDefaultShape = function() {
        return clone$4(Cn.shape);
      }, Ln;
    }(nr);
    for (var In in Cn)
      typeof Cn[In] == "function" && (Bn.prototype[In] = Cn[In]);
    return Bn;
  }, nr.initDefaultProps = function() {
    var Cn = nr.prototype;
    Cn.type = "path", Cn.strokeContainThreshold = 5, Cn.segmentIgnoreThreshold = 0, Cn.subPixelOptimize = !1, Cn.autoBatch = !1, Cn.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
  }(), nr;
}(Displayable$1);
const Path$1 = Path;
var DEFAULT_TSPAN_STYLE = defaults({
  strokeFirst: !0,
  font: DEFAULT_FONT,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, DEFAULT_PATH_STYLE), TSpan = function(_n) {
  __extends$2(nr, _n);
  function nr() {
    return _n !== null && _n.apply(this, arguments) || this;
  }
  return nr.prototype.hasStroke = function() {
    var Cn = this.style, Bn = Cn.stroke;
    return Bn != null && Bn !== "none" && Cn.lineWidth > 0;
  }, nr.prototype.hasFill = function() {
    var Cn = this.style, Bn = Cn.fill;
    return Bn != null && Bn !== "none";
  }, nr.prototype.createStyle = function(Cn) {
    return createObject(DEFAULT_TSPAN_STYLE, Cn);
  }, nr.prototype.setBoundingRect = function(Cn) {
    this._rect = Cn;
  }, nr.prototype.getBoundingRect = function() {
    var Cn = this.style;
    if (!this._rect) {
      var Bn = Cn.text;
      Bn != null ? Bn += "" : Bn = "";
      var In = getBoundingRect(Bn, Cn.font, Cn.textAlign, Cn.textBaseline);
      if (In.x += Cn.x || 0, In.y += Cn.y || 0, this.hasStroke()) {
        var Dn = Cn.lineWidth;
        In.x -= Dn / 2, In.y -= Dn / 2, In.width += Dn, In.height += Dn;
      }
      this._rect = In;
    }
    return this._rect;
  }, nr.initDefaultProps = function() {
    var Cn = nr.prototype;
    Cn.dirtyRectTolerance = 10;
  }(), nr;
}(Displayable$1);
TSpan.prototype.type = "tspan";
const TSpan$1 = TSpan;
var DEFAULT_IMAGE_STYLE = defaults({
  x: 0,
  y: 0
}, DEFAULT_COMMON_STYLE), DEFAULT_IMAGE_ANIMATION_PROPS = {
  style: defaults({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike$1(_n) {
  return !!(_n && typeof _n != "string" && _n.width && _n.height);
}
var ZRImage = function(_n) {
  __extends$2(nr, _n);
  function nr() {
    return _n !== null && _n.apply(this, arguments) || this;
  }
  return nr.prototype.createStyle = function(Cn) {
    return createObject(DEFAULT_IMAGE_STYLE, Cn);
  }, nr.prototype._getSize = function(Cn) {
    var Bn = this.style, In = Bn[Cn];
    if (In != null)
      return In;
    var Dn = isImageLike$1(Bn.image) ? Bn.image : this.__image;
    if (!Dn)
      return 0;
    var Ln = Cn === "width" ? "height" : "width", $n = Bn[Ln];
    return $n == null ? Dn[Cn] : Dn[Cn] / Dn[Ln] * $n;
  }, nr.prototype.getWidth = function() {
    return this._getSize("width");
  }, nr.prototype.getHeight = function() {
    return this._getSize("height");
  }, nr.prototype.getAnimationStyleProps = function() {
    return DEFAULT_IMAGE_ANIMATION_PROPS;
  }, nr.prototype.getBoundingRect = function() {
    var Cn = this.style;
    return this._rect || (this._rect = new BoundingRect$1(Cn.x || 0, Cn.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, nr;
}(Displayable$1);
ZRImage.prototype.type = "image";
const ZRImage$1 = ZRImage;
function buildPath$2(_n, nr) {
  var Cn = nr.x, Bn = nr.y, In = nr.width, Dn = nr.height, Ln = nr.r, $n, Nn, Rn, Fn;
  In < 0 && (Cn = Cn + In, In = -In), Dn < 0 && (Bn = Bn + Dn, Dn = -Dn), typeof Ln == "number" ? $n = Nn = Rn = Fn = Ln : Ln instanceof Array ? Ln.length === 1 ? $n = Nn = Rn = Fn = Ln[0] : Ln.length === 2 ? ($n = Rn = Ln[0], Nn = Fn = Ln[1]) : Ln.length === 3 ? ($n = Ln[0], Nn = Fn = Ln[1], Rn = Ln[2]) : ($n = Ln[0], Nn = Ln[1], Rn = Ln[2], Fn = Ln[3]) : $n = Nn = Rn = Fn = 0;
  var Pn;
  $n + Nn > In && (Pn = $n + Nn, $n *= In / Pn, Nn *= In / Pn), Rn + Fn > In && (Pn = Rn + Fn, Rn *= In / Pn, Fn *= In / Pn), Nn + Rn > Dn && (Pn = Nn + Rn, Nn *= Dn / Pn, Rn *= Dn / Pn), $n + Fn > Dn && (Pn = $n + Fn, $n *= Dn / Pn, Fn *= Dn / Pn), _n.moveTo(Cn + $n, Bn), _n.lineTo(Cn + In - Nn, Bn), Nn !== 0 && _n.arc(Cn + In - Nn, Bn + Nn, Nn, -Math.PI / 2, 0), _n.lineTo(Cn + In, Bn + Dn - Rn), Rn !== 0 && _n.arc(Cn + In - Rn, Bn + Dn - Rn, Rn, 0, Math.PI / 2), _n.lineTo(Cn + Fn, Bn + Dn), Fn !== 0 && _n.arc(Cn + Fn, Bn + Dn - Fn, Fn, Math.PI / 2, Math.PI), _n.lineTo(Cn, Bn + $n), $n !== 0 && _n.arc(Cn + $n, Bn + $n, $n, Math.PI, Math.PI * 1.5);
}
var round$3 = Math.round;
function subPixelOptimizeLine$1(_n, nr, Cn) {
  if (nr) {
    var Bn = nr.x1, In = nr.x2, Dn = nr.y1, Ln = nr.y2;
    _n.x1 = Bn, _n.x2 = In, _n.y1 = Dn, _n.y2 = Ln;
    var $n = Cn && Cn.lineWidth;
    return $n && (round$3(Bn * 2) === round$3(In * 2) && (_n.x1 = _n.x2 = subPixelOptimize$1(Bn, $n, !0)), round$3(Dn * 2) === round$3(Ln * 2) && (_n.y1 = _n.y2 = subPixelOptimize$1(Dn, $n, !0))), _n;
  }
}
function subPixelOptimizeRect$1(_n, nr, Cn) {
  if (nr) {
    var Bn = nr.x, In = nr.y, Dn = nr.width, Ln = nr.height;
    _n.x = Bn, _n.y = In, _n.width = Dn, _n.height = Ln;
    var $n = Cn && Cn.lineWidth;
    return $n && (_n.x = subPixelOptimize$1(Bn, $n, !0), _n.y = subPixelOptimize$1(In, $n, !0), _n.width = Math.max(subPixelOptimize$1(Bn + Dn, $n, !1) - _n.x, Dn === 0 ? 0 : 1), _n.height = Math.max(subPixelOptimize$1(In + Ln, $n, !1) - _n.y, Ln === 0 ? 0 : 1)), _n;
  }
}
function subPixelOptimize$1(_n, nr, Cn) {
  if (!nr)
    return _n;
  var Bn = round$3(_n * 2);
  return (Bn + round$3(nr)) % 2 === 0 ? Bn / 2 : (Bn + (Cn ? 1 : -1)) / 2;
}
var RectShape = function() {
  function _n() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return _n;
}(), subPixelOptimizeOutputShape$1 = {}, Rect$2 = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultShape = function() {
    return new RectShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    var In, Dn, Ln, $n;
    if (this.subPixelOptimize) {
      var Nn = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, Bn, this.style);
      In = Nn.x, Dn = Nn.y, Ln = Nn.width, $n = Nn.height, Nn.r = Bn.r, Bn = Nn;
    } else
      In = Bn.x, Dn = Bn.y, Ln = Bn.width, $n = Bn.height;
    Bn.r ? buildPath$2(Cn, Bn) : Cn.rect(In, Dn, Ln, $n);
  }, nr.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, nr;
}(Path$1);
Rect$2.prototype.type = "rect";
const Rect$3 = Rect$2;
var DEFAULT_RICH_TEXT_COLOR = {
  fill: "#000"
}, DEFAULT_STROKE_LINE_WIDTH = 2, DEFAULT_TEXT_ANIMATION_PROPS = {
  style: defaults({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
}, ZRText = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    var Bn = _n.call(this) || this;
    return Bn.type = "text", Bn._children = [], Bn._defaultStyle = DEFAULT_RICH_TEXT_COLOR, Bn.attr(Cn), Bn;
  }
  return nr.prototype.childrenRef = function() {
    return this._children;
  }, nr.prototype.update = function() {
    _n.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var Cn = 0; Cn < this._children.length; Cn++) {
      var Bn = this._children[Cn];
      Bn.zlevel = this.zlevel, Bn.z = this.z, Bn.z2 = this.z2, Bn.culling = this.culling, Bn.cursor = this.cursor, Bn.invisible = this.invisible;
    }
  }, nr.prototype.updateTransform = function() {
    var Cn = this.innerTransformable;
    Cn ? (Cn.updateTransform(), Cn.transform && (this.transform = Cn.transform)) : _n.prototype.updateTransform.call(this);
  }, nr.prototype.getLocalTransform = function(Cn) {
    var Bn = this.innerTransformable;
    return Bn ? Bn.getLocalTransform(Cn) : _n.prototype.getLocalTransform.call(this, Cn);
  }, nr.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), _n.prototype.getComputedTransform.call(this);
  }, nr.prototype._updateSubTexts = function() {
    this._childCursor = 0, normalizeTextStyle(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, nr.prototype.addSelfToZr = function(Cn) {
    _n.prototype.addSelfToZr.call(this, Cn);
    for (var Bn = 0; Bn < this._children.length; Bn++)
      this._children[Bn].__zr = Cn;
  }, nr.prototype.removeSelfFromZr = function(Cn) {
    _n.prototype.removeSelfFromZr.call(this, Cn);
    for (var Bn = 0; Bn < this._children.length; Bn++)
      this._children[Bn].__zr = null;
  }, nr.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var Cn = new BoundingRect$1(0, 0, 0, 0), Bn = this._children, In = [], Dn = null, Ln = 0; Ln < Bn.length; Ln++) {
        var $n = Bn[Ln], Nn = $n.getBoundingRect(), Rn = $n.getLocalTransform(In);
        Rn ? (Cn.copy(Nn), Cn.applyTransform(Rn), Dn = Dn || Cn.clone(), Dn.union(Cn)) : (Dn = Dn || Nn.clone(), Dn.union(Nn));
      }
      this._rect = Dn || Cn;
    }
    return this._rect;
  }, nr.prototype.setDefaultTextStyle = function(Cn) {
    this._defaultStyle = Cn || DEFAULT_RICH_TEXT_COLOR;
  }, nr.prototype.setTextContent = function(Cn) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, nr.prototype._mergeStyle = function(Cn, Bn) {
    if (!Bn)
      return Cn;
    var In = Bn.rich, Dn = Cn.rich || In && {};
    return extend(Cn, Bn), In && Dn ? (this._mergeRich(Dn, In), Cn.rich = Dn) : Dn && (Cn.rich = Dn), Cn;
  }, nr.prototype._mergeRich = function(Cn, Bn) {
    for (var In = keys(Bn), Dn = 0; Dn < In.length; Dn++) {
      var Ln = In[Dn];
      Cn[Ln] = Cn[Ln] || {}, extend(Cn[Ln], Bn[Ln]);
    }
  }, nr.prototype.getAnimationStyleProps = function() {
    return DEFAULT_TEXT_ANIMATION_PROPS;
  }, nr.prototype._getOrCreateChild = function(Cn) {
    var Bn = this._children[this._childCursor];
    return (!Bn || !(Bn instanceof Cn)) && (Bn = new Cn()), this._children[this._childCursor++] = Bn, Bn.__zr = this.__zr, Bn.parent = this, Bn;
  }, nr.prototype._updatePlainTexts = function() {
    var Cn = this.style, Bn = Cn.font || DEFAULT_FONT, In = Cn.padding, Dn = getStyleText(Cn), Ln = parsePlainText(Dn, Cn), $n = needDrawBackground(Cn), Nn = !!Cn.backgroundColor, Rn = Ln.outerHeight, Fn = Ln.outerWidth, Pn = Ln.contentWidth, Un = Ln.lines, Hn = Ln.lineHeight, zn = this._defaultStyle;
    this.isTruncated = !!Ln.isTruncated;
    var Gn = Cn.x || 0, Yn = Cn.y || 0, Wn = Cn.align || zn.align || "left", Xn = Cn.verticalAlign || zn.verticalAlign || "top", ea = Gn, ta = adjustTextY(Yn, Ln.contentHeight, Xn);
    if ($n || In) {
      var na = adjustTextX(Gn, Fn, Wn), ra = adjustTextY(Yn, Rn, Xn);
      $n && this._renderBackground(Cn, Cn, na, ra, Fn, Rn);
    }
    ta += Hn / 2, In && (ea = getTextXForPadding(Gn, Wn, In), Xn === "top" ? ta += In[0] : Xn === "bottom" && (ta -= In[2]));
    for (var aa = 0, ia = !1, Aa = getFill("fill" in Cn ? Cn.fill : (ia = !0, zn.fill)), sa = getStroke("stroke" in Cn ? Cn.stroke : !Nn && (!zn.autoStroke || ia) ? (aa = DEFAULT_STROKE_LINE_WIDTH, zn.stroke) : null), oa = Cn.textShadowBlur > 0, la = Cn.width != null && (Cn.overflow === "truncate" || Cn.overflow === "break" || Cn.overflow === "breakAll"), ua = Ln.calculatedLineHeight, ca = 0; ca < Un.length; ca++) {
      var fa = this._getOrCreateChild(TSpan$1), ha = fa.createStyle();
      fa.useStyle(ha), ha.text = Un[ca], ha.x = ea, ha.y = ta, Wn && (ha.textAlign = Wn), ha.textBaseline = "middle", ha.opacity = Cn.opacity, ha.strokeFirst = !0, oa && (ha.shadowBlur = Cn.textShadowBlur || 0, ha.shadowColor = Cn.textShadowColor || "transparent", ha.shadowOffsetX = Cn.textShadowOffsetX || 0, ha.shadowOffsetY = Cn.textShadowOffsetY || 0), ha.stroke = sa, ha.fill = Aa, sa && (ha.lineWidth = Cn.lineWidth || aa, ha.lineDash = Cn.lineDash, ha.lineDashOffset = Cn.lineDashOffset || 0), ha.font = Bn, setSeparateFont(ha, Cn), ta += Hn, la && fa.setBoundingRect(new BoundingRect$1(adjustTextX(ha.x, Pn, ha.textAlign), adjustTextY(ha.y, ua, ha.textBaseline), Pn, ua));
    }
  }, nr.prototype._updateRichTexts = function() {
    var Cn = this.style, Bn = getStyleText(Cn), In = parseRichText(Bn, Cn), Dn = In.width, Ln = In.outerWidth, $n = In.outerHeight, Nn = Cn.padding, Rn = Cn.x || 0, Fn = Cn.y || 0, Pn = this._defaultStyle, Un = Cn.align || Pn.align, Hn = Cn.verticalAlign || Pn.verticalAlign;
    this.isTruncated = !!In.isTruncated;
    var zn = adjustTextX(Rn, Ln, Un), Gn = adjustTextY(Fn, $n, Hn), Yn = zn, Wn = Gn;
    Nn && (Yn += Nn[3], Wn += Nn[0]);
    var Xn = Yn + Dn;
    needDrawBackground(Cn) && this._renderBackground(Cn, Cn, zn, Gn, Ln, $n);
    for (var ea = !!Cn.backgroundColor, ta = 0; ta < In.lines.length; ta++) {
      for (var na = In.lines[ta], ra = na.tokens, aa = ra.length, ia = na.lineHeight, Aa = na.width, sa = 0, oa = Yn, la = Xn, ua = aa - 1, ca = void 0; sa < aa && (ca = ra[sa], !ca.align || ca.align === "left"); )
        this._placeToken(ca, Cn, ia, Wn, oa, "left", ea), Aa -= ca.width, oa += ca.width, sa++;
      for (; ua >= 0 && (ca = ra[ua], ca.align === "right"); )
        this._placeToken(ca, Cn, ia, Wn, la, "right", ea), Aa -= ca.width, la -= ca.width, ua--;
      for (oa += (Dn - (oa - Yn) - (Xn - la) - Aa) / 2; sa <= ua; )
        ca = ra[sa], this._placeToken(ca, Cn, ia, Wn, oa + ca.width / 2, "center", ea), oa += ca.width, sa++;
      Wn += ia;
    }
  }, nr.prototype._placeToken = function(Cn, Bn, In, Dn, Ln, $n, Nn) {
    var Rn = Bn.rich[Cn.styleName] || {};
    Rn.text = Cn.text;
    var Fn = Cn.verticalAlign, Pn = Dn + In / 2;
    Fn === "top" ? Pn = Dn + Cn.height / 2 : Fn === "bottom" && (Pn = Dn + In - Cn.height / 2);
    var Un = !Cn.isLineHolder && needDrawBackground(Rn);
    Un && this._renderBackground(Rn, Bn, $n === "right" ? Ln - Cn.width : $n === "center" ? Ln - Cn.width / 2 : Ln, Pn - Cn.height / 2, Cn.width, Cn.height);
    var Hn = !!Rn.backgroundColor, zn = Cn.textPadding;
    zn && (Ln = getTextXForPadding(Ln, $n, zn), Pn -= Cn.height / 2 - zn[0] - Cn.innerHeight / 2);
    var Gn = this._getOrCreateChild(TSpan$1), Yn = Gn.createStyle();
    Gn.useStyle(Yn);
    var Wn = this._defaultStyle, Xn = !1, ea = 0, ta = getFill("fill" in Rn ? Rn.fill : "fill" in Bn ? Bn.fill : (Xn = !0, Wn.fill)), na = getStroke("stroke" in Rn ? Rn.stroke : "stroke" in Bn ? Bn.stroke : !Hn && !Nn && (!Wn.autoStroke || Xn) ? (ea = DEFAULT_STROKE_LINE_WIDTH, Wn.stroke) : null), ra = Rn.textShadowBlur > 0 || Bn.textShadowBlur > 0;
    Yn.text = Cn.text, Yn.x = Ln, Yn.y = Pn, ra && (Yn.shadowBlur = Rn.textShadowBlur || Bn.textShadowBlur || 0, Yn.shadowColor = Rn.textShadowColor || Bn.textShadowColor || "transparent", Yn.shadowOffsetX = Rn.textShadowOffsetX || Bn.textShadowOffsetX || 0, Yn.shadowOffsetY = Rn.textShadowOffsetY || Bn.textShadowOffsetY || 0), Yn.textAlign = $n, Yn.textBaseline = "middle", Yn.font = Cn.font || DEFAULT_FONT, Yn.opacity = retrieve3(Rn.opacity, Bn.opacity, 1), setSeparateFont(Yn, Rn), na && (Yn.lineWidth = retrieve3(Rn.lineWidth, Bn.lineWidth, ea), Yn.lineDash = retrieve2(Rn.lineDash, Bn.lineDash), Yn.lineDashOffset = Bn.lineDashOffset || 0, Yn.stroke = na), ta && (Yn.fill = ta);
    var aa = Cn.contentWidth, ia = Cn.contentHeight;
    Gn.setBoundingRect(new BoundingRect$1(adjustTextX(Yn.x, aa, Yn.textAlign), adjustTextY(Yn.y, ia, Yn.textBaseline), aa, ia));
  }, nr.prototype._renderBackground = function(Cn, Bn, In, Dn, Ln, $n) {
    var Nn = Cn.backgroundColor, Rn = Cn.borderWidth, Fn = Cn.borderColor, Pn = Nn && Nn.image, Un = Nn && !Pn, Hn = Cn.borderRadius, zn = this, Gn, Yn;
    if (Un || Cn.lineHeight || Rn && Fn) {
      Gn = this._getOrCreateChild(Rect$3), Gn.useStyle(Gn.createStyle()), Gn.style.fill = null;
      var Wn = Gn.shape;
      Wn.x = In, Wn.y = Dn, Wn.width = Ln, Wn.height = $n, Wn.r = Hn, Gn.dirtyShape();
    }
    if (Un) {
      var Xn = Gn.style;
      Xn.fill = Nn || null, Xn.fillOpacity = retrieve2(Cn.fillOpacity, 1);
    } else if (Pn) {
      Yn = this._getOrCreateChild(ZRImage$1), Yn.onload = function() {
        zn.dirtyStyle();
      };
      var ea = Yn.style;
      ea.image = Nn.image, ea.x = In, ea.y = Dn, ea.width = Ln, ea.height = $n;
    }
    if (Rn && Fn) {
      var Xn = Gn.style;
      Xn.lineWidth = Rn, Xn.stroke = Fn, Xn.strokeOpacity = retrieve2(Cn.strokeOpacity, 1), Xn.lineDash = Cn.borderDash, Xn.lineDashOffset = Cn.borderDashOffset || 0, Gn.strokeContainThreshold = 0, Gn.hasFill() && Gn.hasStroke() && (Xn.strokeFirst = !0, Xn.lineWidth *= 2);
    }
    var ta = (Gn || Yn).style;
    ta.shadowBlur = Cn.shadowBlur || 0, ta.shadowColor = Cn.shadowColor || "transparent", ta.shadowOffsetX = Cn.shadowOffsetX || 0, ta.shadowOffsetY = Cn.shadowOffsetY || 0, ta.opacity = retrieve3(Cn.opacity, Bn.opacity, 1);
  }, nr.makeFont = function(Cn) {
    var Bn = "";
    return hasSeparateFont(Cn) && (Bn = [
      Cn.fontStyle,
      Cn.fontWeight,
      parseFontSize(Cn.fontSize),
      Cn.fontFamily || "sans-serif"
    ].join(" ")), Bn && trim$1(Bn) || Cn.textFont || Cn.font;
  }, nr;
}(Displayable$1), VALID_TEXT_ALIGN = { left: !0, right: 1, center: 1 }, VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 }, FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function parseFontSize(_n) {
  return typeof _n == "string" && (_n.indexOf("px") !== -1 || _n.indexOf("rem") !== -1 || _n.indexOf("em") !== -1) ? _n : isNaN(+_n) ? DEFAULT_FONT_SIZE + "px" : _n + "px";
}
function setSeparateFont(_n, nr) {
  for (var Cn = 0; Cn < FONT_PARTS.length; Cn++) {
    var Bn = FONT_PARTS[Cn], In = nr[Bn];
    In != null && (_n[Bn] = In);
  }
}
function hasSeparateFont(_n) {
  return _n.fontSize != null || _n.fontFamily || _n.fontWeight;
}
function normalizeTextStyle(_n) {
  return normalizeStyle(_n), each$f(_n.rich, normalizeStyle), _n;
}
function normalizeStyle(_n) {
  if (_n) {
    _n.font = ZRText.makeFont(_n);
    var nr = _n.align;
    nr === "middle" && (nr = "center"), _n.align = nr == null || VALID_TEXT_ALIGN[nr] ? nr : "left";
    var Cn = _n.verticalAlign;
    Cn === "center" && (Cn = "middle"), _n.verticalAlign = Cn == null || VALID_TEXT_VERTICAL_ALIGN[Cn] ? Cn : "top";
    var Bn = _n.padding;
    Bn && (_n.padding = normalizeCssArray$1(_n.padding));
  }
}
function getStroke(_n, nr) {
  return _n == null || nr <= 0 || _n === "transparent" || _n === "none" ? null : _n.image || _n.colorStops ? "#000" : _n;
}
function getFill(_n) {
  return _n == null || _n === "none" ? null : _n.image || _n.colorStops ? "#000" : _n;
}
function getTextXForPadding(_n, nr, Cn) {
  return nr === "right" ? _n - Cn[1] : nr === "center" ? _n + Cn[3] / 2 - Cn[1] / 2 : _n + Cn[3];
}
function getStyleText(_n) {
  var nr = _n.text;
  return nr != null && (nr += ""), nr;
}
function needDrawBackground(_n) {
  return !!(_n.backgroundColor || _n.lineHeight || _n.borderWidth && _n.borderColor);
}
const ZRText$1 = ZRText;
var getECData = makeInner(), setCommonECData = function(_n, nr, Cn, Bn) {
  if (Bn) {
    var In = getECData(Bn);
    In.dataIndex = Cn, In.dataType = nr, In.seriesIndex = _n, In.ssrType = "chart", Bn.type === "group" && Bn.traverse(function(Dn) {
      var Ln = getECData(Dn);
      Ln.seriesIndex = _n, Ln.dataIndex = Cn, Ln.dataType = nr, Ln.ssrType = "chart";
    });
  }
}, _highlightNextDigit = 1, _highlightKeyMap = {}, getSavedStates = makeInner(), getComponentStates = makeInner(), HOVER_STATE_NORMAL = 0, HOVER_STATE_BLUR = 1, HOVER_STATE_EMPHASIS = 2, SPECIAL_STATES = ["emphasis", "blur", "select"], DISPLAY_STATES = ["normal", "emphasis", "blur", "select"], Z2_EMPHASIS_LIFT = 10, Z2_SELECT_LIFT = 9, HIGHLIGHT_ACTION_TYPE = "highlight", DOWNPLAY_ACTION_TYPE = "downplay", SELECT_ACTION_TYPE = "select", UNSELECT_ACTION_TYPE = "unselect", TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
function hasFillOrStroke(_n) {
  return _n != null && _n !== "none";
}
function doChangeHoverState(_n, nr, Cn) {
  _n.onHoverStateChange && (_n.hoverState || 0) !== Cn && _n.onHoverStateChange(nr), _n.hoverState = Cn;
}
function singleEnterEmphasis(_n) {
  doChangeHoverState(_n, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(_n) {
  _n.hoverState === HOVER_STATE_EMPHASIS && doChangeHoverState(_n, "normal", HOVER_STATE_NORMAL);
}
function singleEnterBlur(_n) {
  doChangeHoverState(_n, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(_n) {
  _n.hoverState === HOVER_STATE_BLUR && doChangeHoverState(_n, "normal", HOVER_STATE_NORMAL);
}
function singleEnterSelect(_n) {
  _n.selected = !0;
}
function singleLeaveSelect(_n) {
  _n.selected = !1;
}
function updateElementState(_n, nr, Cn) {
  nr(_n, Cn);
}
function traverseUpdateState(_n, nr, Cn) {
  updateElementState(_n, nr, Cn), _n.isGroup && _n.traverse(function(Bn) {
    updateElementState(Bn, nr, Cn);
  });
}
function setStatesFlag(_n, nr) {
  switch (nr) {
    case "emphasis":
      _n.hoverState = HOVER_STATE_EMPHASIS;
      break;
    case "normal":
      _n.hoverState = HOVER_STATE_NORMAL;
      break;
    case "blur":
      _n.hoverState = HOVER_STATE_BLUR;
      break;
    case "select":
      _n.selected = !0;
  }
}
function getFromStateStyle(_n, nr, Cn, Bn) {
  for (var In = _n.style, Dn = {}, Ln = 0; Ln < nr.length; Ln++) {
    var $n = nr[Ln], Nn = In[$n];
    Dn[$n] = Nn ?? (Bn && Bn[$n]);
  }
  for (var Ln = 0; Ln < _n.animators.length; Ln++) {
    var Rn = _n.animators[Ln];
    Rn.__fromStateTransition && Rn.__fromStateTransition.indexOf(Cn) < 0 && Rn.targetName === "style" && Rn.saveTo(Dn, nr);
  }
  return Dn;
}
function createEmphasisDefaultState(_n, nr, Cn, Bn) {
  var In = Cn && indexOf(Cn, "select") >= 0, Dn = !1;
  if (_n instanceof Path$1) {
    var Ln = getSavedStates(_n), $n = In && Ln.selectFill || Ln.normalFill, Nn = In && Ln.selectStroke || Ln.normalStroke;
    if (hasFillOrStroke($n) || hasFillOrStroke(Nn)) {
      Bn = Bn || {};
      var Rn = Bn.style || {};
      Rn.fill === "inherit" ? (Dn = !0, Bn = extend({}, Bn), Rn = extend({}, Rn), Rn.fill = $n) : !hasFillOrStroke(Rn.fill) && hasFillOrStroke($n) ? (Dn = !0, Bn = extend({}, Bn), Rn = extend({}, Rn), Rn.fill = liftColor($n)) : !hasFillOrStroke(Rn.stroke) && hasFillOrStroke(Nn) && (Dn || (Bn = extend({}, Bn), Rn = extend({}, Rn)), Rn.stroke = liftColor(Nn)), Bn.style = Rn;
    }
  }
  if (Bn && Bn.z2 == null) {
    Dn || (Bn = extend({}, Bn));
    var Fn = _n.z2EmphasisLift;
    Bn.z2 = _n.z2 + (Fn ?? Z2_EMPHASIS_LIFT);
  }
  return Bn;
}
function createSelectDefaultState(_n, nr, Cn) {
  if (Cn && Cn.z2 == null) {
    Cn = extend({}, Cn);
    var Bn = _n.z2SelectLift;
    Cn.z2 = _n.z2 + (Bn ?? Z2_SELECT_LIFT);
  }
  return Cn;
}
function createBlurDefaultState(_n, nr, Cn) {
  var Bn = indexOf(_n.currentStates, nr) >= 0, In = _n.style.opacity, Dn = Bn ? null : getFromStateStyle(_n, ["opacity"], nr, {
    opacity: 1
  });
  Cn = Cn || {};
  var Ln = Cn.style || {};
  return Ln.opacity == null && (Cn = extend({}, Cn), Ln = extend({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: Bn ? In : Dn.opacity * 0.1
  }, Ln), Cn.style = Ln), Cn;
}
function elementStateProxy(_n, nr) {
  var Cn = this.states[_n];
  if (this.style) {
    if (_n === "emphasis")
      return createEmphasisDefaultState(this, _n, nr, Cn);
    if (_n === "blur")
      return createBlurDefaultState(this, _n, Cn);
    if (_n === "select")
      return createSelectDefaultState(this, _n, Cn);
  }
  return Cn;
}
function setDefaultStateProxy(_n) {
  _n.stateProxy = elementStateProxy;
  var nr = _n.getTextContent(), Cn = _n.getTextGuideLine();
  nr && (nr.stateProxy = elementStateProxy), Cn && (Cn.stateProxy = elementStateProxy);
}
function enterEmphasisWhenMouseOver(_n, nr) {
  !shouldSilent(_n, nr) && !_n.__highByOuter && traverseUpdateState(_n, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(_n, nr) {
  !shouldSilent(_n, nr) && !_n.__highByOuter && traverseUpdateState(_n, singleLeaveEmphasis);
}
function enterEmphasis(_n, nr) {
  _n.__highByOuter |= 1 << (nr || 0), traverseUpdateState(_n, singleEnterEmphasis);
}
function leaveEmphasis(_n, nr) {
  !(_n.__highByOuter &= ~(1 << (nr || 0))) && traverseUpdateState(_n, singleLeaveEmphasis);
}
function enterBlur(_n) {
  traverseUpdateState(_n, singleEnterBlur);
}
function leaveBlur(_n) {
  traverseUpdateState(_n, singleLeaveBlur);
}
function enterSelect(_n) {
  traverseUpdateState(_n, singleEnterSelect);
}
function leaveSelect(_n) {
  traverseUpdateState(_n, singleLeaveSelect);
}
function shouldSilent(_n, nr) {
  return _n.__highDownSilentOnTouch && nr.zrByTouch;
}
function allLeaveBlur(_n) {
  var nr = _n.getModel(), Cn = [], Bn = [];
  nr.eachComponent(function(In, Dn) {
    var Ln = getComponentStates(Dn), $n = In === "series", Nn = $n ? _n.getViewOfSeriesModel(Dn) : _n.getViewOfComponentModel(Dn);
    !$n && Bn.push(Nn), Ln.isBlured && (Nn.group.traverse(function(Rn) {
      singleLeaveBlur(Rn);
    }), $n && Cn.push(Dn)), Ln.isBlured = !1;
  }), each$f(Bn, function(In) {
    In && In.toggleBlurSeries && In.toggleBlurSeries(Cn, !1, nr);
  });
}
function blurSeries(_n, nr, Cn, Bn) {
  var In = Bn.getModel();
  Cn = Cn || "coordinateSystem";
  function Dn(Rn, Fn) {
    for (var Pn = 0; Pn < Fn.length; Pn++) {
      var Un = Rn.getItemGraphicEl(Fn[Pn]);
      Un && leaveBlur(Un);
    }
  }
  if (_n != null && !(!nr || nr === "none")) {
    var Ln = In.getSeriesByIndex(_n), $n = Ln.coordinateSystem;
    $n && $n.master && ($n = $n.master);
    var Nn = [];
    In.eachSeries(function(Rn) {
      var Fn = Ln === Rn, Pn = Rn.coordinateSystem;
      Pn && Pn.master && (Pn = Pn.master);
      var Un = Pn && $n ? Pn === $n : Fn;
      if (!// Not blur other series if blurScope series
      (Cn === "series" && !Fn || Cn === "coordinateSystem" && !Un || nr === "series" && Fn)) {
        var Hn = Bn.getViewOfSeriesModel(Rn);
        if (Hn.group.traverse(function(Yn) {
          Yn.__highByOuter && Fn && nr === "self" || singleEnterBlur(Yn);
        }), isArrayLike$1(nr))
          Dn(Rn.getData(), nr);
        else if (isObject$6(nr))
          for (var zn = keys(nr), Gn = 0; Gn < zn.length; Gn++)
            Dn(Rn.getData(zn[Gn]), nr[zn[Gn]]);
        Nn.push(Rn), getComponentStates(Rn).isBlured = !0;
      }
    }), In.eachComponent(function(Rn, Fn) {
      if (Rn !== "series") {
        var Pn = Bn.getViewOfComponentModel(Fn);
        Pn && Pn.toggleBlurSeries && Pn.toggleBlurSeries(Nn, !0, In);
      }
    });
  }
}
function blurComponent(_n, nr, Cn) {
  if (!(_n == null || nr == null)) {
    var Bn = Cn.getModel().getComponent(_n, nr);
    if (Bn) {
      getComponentStates(Bn).isBlured = !0;
      var In = Cn.getViewOfComponentModel(Bn);
      !In || !In.focusBlurEnabled || In.group.traverse(function(Dn) {
        singleEnterBlur(Dn);
      });
    }
  }
}
function blurSeriesFromHighlightPayload(_n, nr, Cn) {
  var Bn = _n.seriesIndex, In = _n.getData(nr.dataType);
  if (!In) {
    process.env.NODE_ENV !== "production" && error("Unknown dataType " + nr.dataType);
    return;
  }
  var Dn = queryDataIndex(In, nr);
  Dn = (isArray$4(Dn) ? Dn[0] : Dn) || 0;
  var Ln = In.getItemGraphicEl(Dn);
  if (!Ln)
    for (var $n = In.count(), Nn = 0; !Ln && Nn < $n; )
      Ln = In.getItemGraphicEl(Nn++);
  if (Ln) {
    var Rn = getECData(Ln);
    blurSeries(Bn, Rn.focus, Rn.blurScope, Cn);
  } else {
    var Fn = _n.get(["emphasis", "focus"]), Pn = _n.get(["emphasis", "blurScope"]);
    Fn != null && blurSeries(Bn, Fn, Pn, Cn);
  }
}
function findComponentHighDownDispatchers(_n, nr, Cn, Bn) {
  var In = {
    focusSelf: !1,
    dispatchers: null
  };
  if (_n == null || _n === "series" || nr == null || Cn == null)
    return In;
  var Dn = Bn.getModel().getComponent(_n, nr);
  if (!Dn)
    return In;
  var Ln = Bn.getViewOfComponentModel(Dn);
  if (!Ln || !Ln.findHighDownDispatchers)
    return In;
  for (var $n = Ln.findHighDownDispatchers(Cn), Nn, Rn = 0; Rn < $n.length; Rn++)
    if (process.env.NODE_ENV !== "production" && !isHighDownDispatcher($n[Rn]) && error("param should be highDownDispatcher"), getECData($n[Rn]).focus === "self") {
      Nn = !0;
      break;
    }
  return {
    focusSelf: Nn,
    dispatchers: $n
  };
}
function handleGlobalMouseOverForHighDown(_n, nr, Cn) {
  process.env.NODE_ENV !== "production" && !isHighDownDispatcher(_n) && error("param should be highDownDispatcher");
  var Bn = getECData(_n), In = findComponentHighDownDispatchers(Bn.componentMainType, Bn.componentIndex, Bn.componentHighDownName, Cn), Dn = In.dispatchers, Ln = In.focusSelf;
  Dn ? (Ln && blurComponent(Bn.componentMainType, Bn.componentIndex, Cn), each$f(Dn, function($n) {
    return enterEmphasisWhenMouseOver($n, nr);
  })) : (blurSeries(Bn.seriesIndex, Bn.focus, Bn.blurScope, Cn), Bn.focus === "self" && blurComponent(Bn.componentMainType, Bn.componentIndex, Cn), enterEmphasisWhenMouseOver(_n, nr));
}
function handleGlobalMouseOutForHighDown(_n, nr, Cn) {
  process.env.NODE_ENV !== "production" && !isHighDownDispatcher(_n) && error("param should be highDownDispatcher"), allLeaveBlur(Cn);
  var Bn = getECData(_n), In = findComponentHighDownDispatchers(Bn.componentMainType, Bn.componentIndex, Bn.componentHighDownName, Cn).dispatchers;
  In ? each$f(In, function(Dn) {
    return leaveEmphasisWhenMouseOut(Dn, nr);
  }) : leaveEmphasisWhenMouseOut(_n, nr);
}
function toggleSelectionFromPayload(_n, nr, Cn) {
  if (isSelectChangePayload(nr)) {
    var Bn = nr.dataType, In = _n.getData(Bn), Dn = queryDataIndex(In, nr);
    isArray$4(Dn) || (Dn = [Dn]), _n[nr.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : nr.type === SELECT_ACTION_TYPE ? "select" : "unselect"](Dn, Bn);
  }
}
function updateSeriesElementSelection(_n) {
  var nr = _n.getAllData();
  each$f(nr, function(Cn) {
    var Bn = Cn.data, In = Cn.type;
    Bn.eachItemGraphicEl(function(Dn, Ln) {
      _n.isSelected(Ln, In) ? enterSelect(Dn) : leaveSelect(Dn);
    });
  });
}
function getAllSelectedIndices(_n) {
  var nr = [];
  return _n.eachSeries(function(Cn) {
    var Bn = Cn.getAllData();
    each$f(Bn, function(In) {
      In.data;
      var Dn = In.type, Ln = Cn.getSelectedDataIndices();
      if (Ln.length > 0) {
        var $n = {
          dataIndex: Ln,
          seriesIndex: Cn.seriesIndex
        };
        Dn != null && ($n.dataType = Dn), nr.push($n);
      }
    });
  }), nr;
}
function enableHoverEmphasis(_n, nr, Cn) {
  setAsHighDownDispatcher(_n, !0), traverseUpdateState(_n, setDefaultStateProxy), enableHoverFocus(_n, nr, Cn);
}
function disableHoverEmphasis(_n) {
  setAsHighDownDispatcher(_n, !1);
}
function toggleHoverEmphasis(_n, nr, Cn, Bn) {
  Bn ? disableHoverEmphasis(_n) : enableHoverEmphasis(_n, nr, Cn);
}
function enableHoverFocus(_n, nr, Cn) {
  var Bn = getECData(_n);
  nr != null ? (Bn.focus = nr, Bn.blurScope = Cn) : Bn.focus && (Bn.focus = null);
}
var OTHER_STATES = ["emphasis", "blur", "select"], defaultStyleGetterMap = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(_n, nr, Cn, Bn) {
  Cn = Cn || "itemStyle";
  for (var In = 0; In < OTHER_STATES.length; In++) {
    var Dn = OTHER_STATES[In], Ln = nr.getModel([Dn, Cn]), $n = _n.ensureState(Dn);
    $n.style = Bn ? Bn(Ln) : Ln[defaultStyleGetterMap[Cn]]();
  }
}
function setAsHighDownDispatcher(_n, nr) {
  var Cn = nr === !1, Bn = _n;
  _n.highDownSilentOnTouch && (Bn.__highDownSilentOnTouch = _n.highDownSilentOnTouch), (!Cn || Bn.__highDownDispatcher) && (Bn.__highByOuter = Bn.__highByOuter || 0, Bn.__highDownDispatcher = !Cn);
}
function isHighDownDispatcher(_n) {
  return !!(_n && _n.__highDownDispatcher);
}
function enableComponentHighDownFeatures(_n, nr, Cn) {
  var Bn = getECData(_n);
  Bn.componentMainType = nr.mainType, Bn.componentIndex = nr.componentIndex, Bn.componentHighDownName = Cn;
}
function getHighlightDigit(_n) {
  var nr = _highlightKeyMap[_n];
  return nr == null && _highlightNextDigit <= 32 && (nr = _highlightKeyMap[_n] = _highlightNextDigit++), nr;
}
function isSelectChangePayload(_n) {
  var nr = _n.type;
  return nr === SELECT_ACTION_TYPE || nr === UNSELECT_ACTION_TYPE || nr === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(_n) {
  var nr = _n.type;
  return nr === HIGHLIGHT_ACTION_TYPE || nr === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(_n) {
  var nr = getSavedStates(_n);
  nr.normalFill = _n.style.fill, nr.normalStroke = _n.style.stroke;
  var Cn = _n.states.select || {};
  nr.selectFill = Cn.style && Cn.style.fill || null, nr.selectStroke = Cn.style && Cn.style.stroke || null;
}
var CMD$2 = PathProxy$1.CMD, points$2 = [[], [], []], mathSqrt$2 = Math.sqrt, mathAtan2 = Math.atan2;
function transformPath$1(_n, nr) {
  if (nr) {
    var Cn = _n.data, Bn = _n.len(), In, Dn, Ln, $n, Nn, Rn, Fn = CMD$2.M, Pn = CMD$2.C, Un = CMD$2.L, Hn = CMD$2.R, zn = CMD$2.A, Gn = CMD$2.Q;
    for (Ln = 0, $n = 0; Ln < Bn; ) {
      switch (In = Cn[Ln++], $n = Ln, Dn = 0, In) {
        case Fn:
          Dn = 1;
          break;
        case Un:
          Dn = 1;
          break;
        case Pn:
          Dn = 3;
          break;
        case Gn:
          Dn = 2;
          break;
        case zn:
          var Yn = nr[4], Wn = nr[5], Xn = mathSqrt$2(nr[0] * nr[0] + nr[1] * nr[1]), ea = mathSqrt$2(nr[2] * nr[2] + nr[3] * nr[3]), ta = mathAtan2(-nr[1] / ea, nr[0] / Xn);
          Cn[Ln] *= Xn, Cn[Ln++] += Yn, Cn[Ln] *= ea, Cn[Ln++] += Wn, Cn[Ln++] *= Xn, Cn[Ln++] *= ea, Cn[Ln++] += ta, Cn[Ln++] += ta, Ln += 2, $n = Ln;
          break;
        case Hn:
          Rn[0] = Cn[Ln++], Rn[1] = Cn[Ln++], applyTransform$1(Rn, Rn, nr), Cn[$n++] = Rn[0], Cn[$n++] = Rn[1], Rn[0] += Cn[Ln++], Rn[1] += Cn[Ln++], applyTransform$1(Rn, Rn, nr), Cn[$n++] = Rn[0], Cn[$n++] = Rn[1];
      }
      for (Nn = 0; Nn < Dn; Nn++) {
        var na = points$2[Nn];
        na[0] = Cn[Ln++], na[1] = Cn[Ln++], applyTransform$1(na, na, nr), Cn[$n++] = na[0], Cn[$n++] = na[1];
      }
    }
    _n.increaseVersion();
  }
}
var mathSqrt$1 = Math.sqrt, mathSin$2 = Math.sin, mathCos$2 = Math.cos, PI$7 = Math.PI;
function vMag(_n) {
  return Math.sqrt(_n[0] * _n[0] + _n[1] * _n[1]);
}
function vRatio(_n, nr) {
  return (_n[0] * nr[0] + _n[1] * nr[1]) / (vMag(_n) * vMag(nr));
}
function vAngle(_n, nr) {
  return (_n[0] * nr[1] < _n[1] * nr[0] ? -1 : 1) * Math.acos(vRatio(_n, nr));
}
function processArc(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn, Fn) {
  var Pn = Nn * (PI$7 / 180), Un = mathCos$2(Pn) * (_n - Cn) / 2 + mathSin$2(Pn) * (nr - Bn) / 2, Hn = -1 * mathSin$2(Pn) * (_n - Cn) / 2 + mathCos$2(Pn) * (nr - Bn) / 2, zn = Un * Un / (Ln * Ln) + Hn * Hn / ($n * $n);
  zn > 1 && (Ln *= mathSqrt$1(zn), $n *= mathSqrt$1(zn));
  var Gn = (In === Dn ? -1 : 1) * mathSqrt$1((Ln * Ln * ($n * $n) - Ln * Ln * (Hn * Hn) - $n * $n * (Un * Un)) / (Ln * Ln * (Hn * Hn) + $n * $n * (Un * Un))) || 0, Yn = Gn * Ln * Hn / $n, Wn = Gn * -$n * Un / Ln, Xn = (_n + Cn) / 2 + mathCos$2(Pn) * Yn - mathSin$2(Pn) * Wn, ea = (nr + Bn) / 2 + mathSin$2(Pn) * Yn + mathCos$2(Pn) * Wn, ta = vAngle([1, 0], [(Un - Yn) / Ln, (Hn - Wn) / $n]), na = [(Un - Yn) / Ln, (Hn - Wn) / $n], ra = [(-1 * Un - Yn) / Ln, (-1 * Hn - Wn) / $n], aa = vAngle(na, ra);
  if (vRatio(na, ra) <= -1 && (aa = PI$7), vRatio(na, ra) >= 1 && (aa = 0), aa < 0) {
    var ia = Math.round(aa / PI$7 * 1e6) / 1e6;
    aa = PI$7 * 2 + ia % 2 * PI$7;
  }
  Fn.addData(Rn, Xn, ea, Ln, $n, ta, aa, Pn, Dn);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(_n) {
  var nr = new PathProxy$1();
  if (!_n)
    return nr;
  var Cn = 0, Bn = 0, In = Cn, Dn = Bn, Ln, $n = PathProxy$1.CMD, Nn = _n.match(commandReg);
  if (!Nn)
    return nr;
  for (var Rn = 0; Rn < Nn.length; Rn++) {
    for (var Fn = Nn[Rn], Pn = Fn.charAt(0), Un = void 0, Hn = Fn.match(numberReg$1) || [], zn = Hn.length, Gn = 0; Gn < zn; Gn++)
      Hn[Gn] = parseFloat(Hn[Gn]);
    for (var Yn = 0; Yn < zn; ) {
      var Wn = void 0, Xn = void 0, ea = void 0, ta = void 0, na = void 0, ra = void 0, aa = void 0, ia = Cn, Aa = Bn, sa = void 0, oa = void 0;
      switch (Pn) {
        case "l":
          Cn += Hn[Yn++], Bn += Hn[Yn++], Un = $n.L, nr.addData(Un, Cn, Bn);
          break;
        case "L":
          Cn = Hn[Yn++], Bn = Hn[Yn++], Un = $n.L, nr.addData(Un, Cn, Bn);
          break;
        case "m":
          Cn += Hn[Yn++], Bn += Hn[Yn++], Un = $n.M, nr.addData(Un, Cn, Bn), In = Cn, Dn = Bn, Pn = "l";
          break;
        case "M":
          Cn = Hn[Yn++], Bn = Hn[Yn++], Un = $n.M, nr.addData(Un, Cn, Bn), In = Cn, Dn = Bn, Pn = "L";
          break;
        case "h":
          Cn += Hn[Yn++], Un = $n.L, nr.addData(Un, Cn, Bn);
          break;
        case "H":
          Cn = Hn[Yn++], Un = $n.L, nr.addData(Un, Cn, Bn);
          break;
        case "v":
          Bn += Hn[Yn++], Un = $n.L, nr.addData(Un, Cn, Bn);
          break;
        case "V":
          Bn = Hn[Yn++], Un = $n.L, nr.addData(Un, Cn, Bn);
          break;
        case "C":
          Un = $n.C, nr.addData(Un, Hn[Yn++], Hn[Yn++], Hn[Yn++], Hn[Yn++], Hn[Yn++], Hn[Yn++]), Cn = Hn[Yn - 2], Bn = Hn[Yn - 1];
          break;
        case "c":
          Un = $n.C, nr.addData(Un, Hn[Yn++] + Cn, Hn[Yn++] + Bn, Hn[Yn++] + Cn, Hn[Yn++] + Bn, Hn[Yn++] + Cn, Hn[Yn++] + Bn), Cn += Hn[Yn - 2], Bn += Hn[Yn - 1];
          break;
        case "S":
          Wn = Cn, Xn = Bn, sa = nr.len(), oa = nr.data, Ln === $n.C && (Wn += Cn - oa[sa - 4], Xn += Bn - oa[sa - 3]), Un = $n.C, ia = Hn[Yn++], Aa = Hn[Yn++], Cn = Hn[Yn++], Bn = Hn[Yn++], nr.addData(Un, Wn, Xn, ia, Aa, Cn, Bn);
          break;
        case "s":
          Wn = Cn, Xn = Bn, sa = nr.len(), oa = nr.data, Ln === $n.C && (Wn += Cn - oa[sa - 4], Xn += Bn - oa[sa - 3]), Un = $n.C, ia = Cn + Hn[Yn++], Aa = Bn + Hn[Yn++], Cn += Hn[Yn++], Bn += Hn[Yn++], nr.addData(Un, Wn, Xn, ia, Aa, Cn, Bn);
          break;
        case "Q":
          ia = Hn[Yn++], Aa = Hn[Yn++], Cn = Hn[Yn++], Bn = Hn[Yn++], Un = $n.Q, nr.addData(Un, ia, Aa, Cn, Bn);
          break;
        case "q":
          ia = Hn[Yn++] + Cn, Aa = Hn[Yn++] + Bn, Cn += Hn[Yn++], Bn += Hn[Yn++], Un = $n.Q, nr.addData(Un, ia, Aa, Cn, Bn);
          break;
        case "T":
          Wn = Cn, Xn = Bn, sa = nr.len(), oa = nr.data, Ln === $n.Q && (Wn += Cn - oa[sa - 4], Xn += Bn - oa[sa - 3]), Cn = Hn[Yn++], Bn = Hn[Yn++], Un = $n.Q, nr.addData(Un, Wn, Xn, Cn, Bn);
          break;
        case "t":
          Wn = Cn, Xn = Bn, sa = nr.len(), oa = nr.data, Ln === $n.Q && (Wn += Cn - oa[sa - 4], Xn += Bn - oa[sa - 3]), Cn += Hn[Yn++], Bn += Hn[Yn++], Un = $n.Q, nr.addData(Un, Wn, Xn, Cn, Bn);
          break;
        case "A":
          ea = Hn[Yn++], ta = Hn[Yn++], na = Hn[Yn++], ra = Hn[Yn++], aa = Hn[Yn++], ia = Cn, Aa = Bn, Cn = Hn[Yn++], Bn = Hn[Yn++], Un = $n.A, processArc(ia, Aa, Cn, Bn, ra, aa, ea, ta, na, Un, nr);
          break;
        case "a":
          ea = Hn[Yn++], ta = Hn[Yn++], na = Hn[Yn++], ra = Hn[Yn++], aa = Hn[Yn++], ia = Cn, Aa = Bn, Cn += Hn[Yn++], Bn += Hn[Yn++], Un = $n.A, processArc(ia, Aa, Cn, Bn, ra, aa, ea, ta, na, Un, nr);
          break;
      }
    }
    (Pn === "z" || Pn === "Z") && (Un = $n.Z, nr.addData(Un), Cn = In, Bn = Dn), Ln = Un;
  }
  return nr.toStatic(), nr;
}
var SVGPath = function(_n) {
  __extends$2(nr, _n);
  function nr() {
    return _n !== null && _n.apply(this, arguments) || this;
  }
  return nr.prototype.applyTransform = function(Cn) {
  }, nr;
}(Path$1);
function isPathProxy(_n) {
  return _n.setData != null;
}
function createPathOptions(_n, nr) {
  var Cn = createPathProxyFromString(_n), Bn = extend({}, nr);
  return Bn.buildPath = function(In) {
    if (isPathProxy(In)) {
      In.setData(Cn.data);
      var Dn = In.getContext();
      Dn && In.rebuildPath(Dn, 1);
    } else {
      var Dn = In;
      Cn.rebuildPath(Dn, 1);
    }
  }, Bn.applyTransform = function(In) {
    transformPath$1(Cn, In), this.dirtyShape();
  }, Bn;
}
function createFromString(_n, nr) {
  return new SVGPath(createPathOptions(_n, nr));
}
function extendFromString(_n, nr) {
  var Cn = createPathOptions(_n, nr), Bn = function(In) {
    __extends$2(Dn, In);
    function Dn(Ln) {
      var $n = In.call(this, Ln) || this;
      return $n.applyTransform = Cn.applyTransform, $n.buildPath = Cn.buildPath, $n;
    }
    return Dn;
  }(SVGPath);
  return Bn;
}
function mergePath$1(_n, nr) {
  for (var Cn = [], Bn = _n.length, In = 0; In < Bn; In++) {
    var Dn = _n[In];
    Cn.push(Dn.getUpdatedPathProxy(!0));
  }
  var Ln = new Path$1(nr);
  return Ln.createPathProxy(), Ln.buildPath = function($n) {
    if (isPathProxy($n)) {
      $n.appendPath(Cn);
      var Nn = $n.getContext();
      Nn && $n.rebuildPath(Nn, 1);
    }
  }, Ln;
}
function clonePath(_n, nr) {
  nr = nr || {};
  var Cn = new Path$1();
  return _n.shape && Cn.setShape(_n.shape), Cn.setStyle(_n.style), nr.bakeTransform ? transformPath$1(Cn.path, _n.getComputedTransform()) : nr.toLocal ? Cn.setLocalTransform(_n.getComputedTransform()) : Cn.copyTransform(_n), Cn.buildPath = _n.buildPath, Cn.applyTransform = Cn.applyTransform, Cn.z = _n.z, Cn.z2 = _n.z2, Cn.zlevel = _n.zlevel, Cn;
}
var CircleShape = function() {
  function _n() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return _n;
}(), Circle = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultShape = function() {
    return new CircleShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    Cn.moveTo(Bn.cx + Bn.r, Bn.cy), Cn.arc(Bn.cx, Bn.cy, Bn.r, 0, Math.PI * 2);
  }, nr;
}(Path$1);
Circle.prototype.type = "circle";
const Circle$1 = Circle;
var EllipseShape = function() {
  function _n() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return _n;
}(), Ellipse = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultShape = function() {
    return new EllipseShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    var In = 0.5522848, Dn = Bn.cx, Ln = Bn.cy, $n = Bn.rx, Nn = Bn.ry, Rn = $n * In, Fn = Nn * In;
    Cn.moveTo(Dn - $n, Ln), Cn.bezierCurveTo(Dn - $n, Ln - Fn, Dn - Rn, Ln - Nn, Dn, Ln - Nn), Cn.bezierCurveTo(Dn + Rn, Ln - Nn, Dn + $n, Ln - Fn, Dn + $n, Ln), Cn.bezierCurveTo(Dn + $n, Ln + Fn, Dn + Rn, Ln + Nn, Dn, Ln + Nn), Cn.bezierCurveTo(Dn - Rn, Ln + Nn, Dn - $n, Ln + Fn, Dn - $n, Ln), Cn.closePath();
  }, nr;
}(Path$1);
Ellipse.prototype.type = "ellipse";
const Ellipse$1 = Ellipse;
var PI$6 = Math.PI, PI2$3 = PI$6 * 2, mathSin$1 = Math.sin, mathCos$1 = Math.cos, mathACos = Math.acos, mathATan2 = Math.atan2, mathAbs$1 = Math.abs, mathSqrt = Math.sqrt, mathMax$7 = Math.max, mathMin$7 = Math.min, e$2 = 1e-4;
function intersect(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  var Nn = Cn - _n, Rn = Bn - nr, Fn = Ln - In, Pn = $n - Dn, Un = Pn * Nn - Fn * Rn;
  if (!(Un * Un < e$2))
    return Un = (Fn * (nr - Dn) - Pn * (_n - In)) / Un, [_n + Un * Nn, nr + Un * Rn];
}
function computeCornerTangents(_n, nr, Cn, Bn, In, Dn, Ln) {
  var $n = _n - Cn, Nn = nr - Bn, Rn = (Ln ? Dn : -Dn) / mathSqrt($n * $n + Nn * Nn), Fn = Rn * Nn, Pn = -Rn * $n, Un = _n + Fn, Hn = nr + Pn, zn = Cn + Fn, Gn = Bn + Pn, Yn = (Un + zn) / 2, Wn = (Hn + Gn) / 2, Xn = zn - Un, ea = Gn - Hn, ta = Xn * Xn + ea * ea, na = In - Dn, ra = Un * Gn - zn * Hn, aa = (ea < 0 ? -1 : 1) * mathSqrt(mathMax$7(0, na * na * ta - ra * ra)), ia = (ra * ea - Xn * aa) / ta, Aa = (-ra * Xn - ea * aa) / ta, sa = (ra * ea + Xn * aa) / ta, oa = (-ra * Xn + ea * aa) / ta, la = ia - Yn, ua = Aa - Wn, ca = sa - Yn, fa = oa - Wn;
  return la * la + ua * ua > ca * ca + fa * fa && (ia = sa, Aa = oa), {
    cx: ia,
    cy: Aa,
    x0: -Fn,
    y0: -Pn,
    x1: ia * (In / na - 1),
    y1: Aa * (In / na - 1)
  };
}
function normalizeCornerRadius(_n) {
  var nr;
  if (isArray$4(_n)) {
    var Cn = _n.length;
    if (!Cn)
      return _n;
    Cn === 1 ? nr = [_n[0], _n[0], 0, 0] : Cn === 2 ? nr = [_n[0], _n[0], _n[1], _n[1]] : Cn === 3 ? nr = _n.concat(_n[2]) : nr = _n;
  } else
    nr = [_n, _n, _n, _n];
  return nr;
}
function buildPath$1(_n, nr) {
  var Cn, Bn = mathMax$7(nr.r, 0), In = mathMax$7(nr.r0 || 0, 0), Dn = Bn > 0, Ln = In > 0;
  if (!(!Dn && !Ln)) {
    if (Dn || (Bn = In, In = 0), In > Bn) {
      var $n = Bn;
      Bn = In, In = $n;
    }
    var Nn = nr.startAngle, Rn = nr.endAngle;
    if (!(isNaN(Nn) || isNaN(Rn))) {
      var Fn = nr.cx, Pn = nr.cy, Un = !!nr.clockwise, Hn = mathAbs$1(Rn - Nn), zn = Hn > PI2$3 && Hn % PI2$3;
      if (zn > e$2 && (Hn = zn), !(Bn > e$2))
        _n.moveTo(Fn, Pn);
      else if (Hn > PI2$3 - e$2)
        _n.moveTo(Fn + Bn * mathCos$1(Nn), Pn + Bn * mathSin$1(Nn)), _n.arc(Fn, Pn, Bn, Nn, Rn, !Un), In > e$2 && (_n.moveTo(Fn + In * mathCos$1(Rn), Pn + In * mathSin$1(Rn)), _n.arc(Fn, Pn, In, Rn, Nn, Un));
      else {
        var Gn = void 0, Yn = void 0, Wn = void 0, Xn = void 0, ea = void 0, ta = void 0, na = void 0, ra = void 0, aa = void 0, ia = void 0, Aa = void 0, sa = void 0, oa = void 0, la = void 0, ua = void 0, ca = void 0, fa = Bn * mathCos$1(Nn), ha = Bn * mathSin$1(Nn), pa = In * mathCos$1(Rn), ya = In * mathSin$1(Rn), da = Hn > e$2;
        if (da) {
          var Ca = nr.cornerRadius;
          Ca && (Cn = normalizeCornerRadius(Ca), Gn = Cn[0], Yn = Cn[1], Wn = Cn[2], Xn = Cn[3]);
          var ma = mathAbs$1(Bn - In) / 2;
          if (ea = mathMin$7(ma, Wn), ta = mathMin$7(ma, Xn), na = mathMin$7(ma, Gn), ra = mathMin$7(ma, Yn), Aa = aa = mathMax$7(ea, ta), sa = ia = mathMax$7(na, ra), (aa > e$2 || ia > e$2) && (oa = Bn * mathCos$1(Rn), la = Bn * mathSin$1(Rn), ua = In * mathCos$1(Nn), ca = In * mathSin$1(Nn), Hn < PI$6)) {
            var va = intersect(fa, ha, ua, ca, oa, la, pa, ya);
            if (va) {
              var ga = fa - va[0], xa = ha - va[1], wa = oa - va[0], ba = la - va[1], Ta = 1 / mathSin$1(mathACos((ga * wa + xa * ba) / (mathSqrt(ga * ga + xa * xa) * mathSqrt(wa * wa + ba * ba))) / 2), Sa = mathSqrt(va[0] * va[0] + va[1] * va[1]);
              Aa = mathMin$7(aa, (Bn - Sa) / (Ta + 1)), sa = mathMin$7(ia, (In - Sa) / (Ta - 1));
            }
          }
        }
        if (!da)
          _n.moveTo(Fn + fa, Pn + ha);
        else if (Aa > e$2) {
          var Ea = mathMin$7(Wn, Aa), Ia = mathMin$7(Xn, Aa), Ba = computeCornerTangents(ua, ca, fa, ha, Bn, Ea, Un), Ma = computeCornerTangents(oa, la, pa, ya, Bn, Ia, Un);
          _n.moveTo(Fn + Ba.cx + Ba.x0, Pn + Ba.cy + Ba.y0), Aa < aa && Ea === Ia ? _n.arc(Fn + Ba.cx, Pn + Ba.cy, Aa, mathATan2(Ba.y0, Ba.x0), mathATan2(Ma.y0, Ma.x0), !Un) : (Ea > 0 && _n.arc(Fn + Ba.cx, Pn + Ba.cy, Ea, mathATan2(Ba.y0, Ba.x0), mathATan2(Ba.y1, Ba.x1), !Un), _n.arc(Fn, Pn, Bn, mathATan2(Ba.cy + Ba.y1, Ba.cx + Ba.x1), mathATan2(Ma.cy + Ma.y1, Ma.cx + Ma.x1), !Un), Ia > 0 && _n.arc(Fn + Ma.cx, Pn + Ma.cy, Ia, mathATan2(Ma.y1, Ma.x1), mathATan2(Ma.y0, Ma.x0), !Un));
        } else
          _n.moveTo(Fn + fa, Pn + ha), _n.arc(Fn, Pn, Bn, Nn, Rn, !Un);
        if (!(In > e$2) || !da)
          _n.lineTo(Fn + pa, Pn + ya);
        else if (sa > e$2) {
          var Ea = mathMin$7(Gn, sa), Ia = mathMin$7(Yn, sa), Ba = computeCornerTangents(pa, ya, oa, la, In, -Ia, Un), Ma = computeCornerTangents(fa, ha, ua, ca, In, -Ea, Un);
          _n.lineTo(Fn + Ba.cx + Ba.x0, Pn + Ba.cy + Ba.y0), sa < ia && Ea === Ia ? _n.arc(Fn + Ba.cx, Pn + Ba.cy, sa, mathATan2(Ba.y0, Ba.x0), mathATan2(Ma.y0, Ma.x0), !Un) : (Ia > 0 && _n.arc(Fn + Ba.cx, Pn + Ba.cy, Ia, mathATan2(Ba.y0, Ba.x0), mathATan2(Ba.y1, Ba.x1), !Un), _n.arc(Fn, Pn, In, mathATan2(Ba.cy + Ba.y1, Ba.cx + Ba.x1), mathATan2(Ma.cy + Ma.y1, Ma.cx + Ma.x1), Un), Ea > 0 && _n.arc(Fn + Ma.cx, Pn + Ma.cy, Ea, mathATan2(Ma.y1, Ma.x1), mathATan2(Ma.y0, Ma.x0), !Un));
        } else
          _n.lineTo(Fn + pa, Pn + ya), _n.arc(Fn, Pn, In, Rn, Nn, Un);
      }
      _n.closePath();
    }
  }
}
var SectorShape = function() {
  function _n() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return _n;
}(), Sector = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultShape = function() {
    return new SectorShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    buildPath$1(Cn, Bn);
  }, nr.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, nr;
}(Path$1);
Sector.prototype.type = "sector";
const Sector$1 = Sector;
var RingShape = function() {
  function _n() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return _n;
}(), Ring = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultShape = function() {
    return new RingShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    var In = Bn.cx, Dn = Bn.cy, Ln = Math.PI * 2;
    Cn.moveTo(In + Bn.r, Dn), Cn.arc(In, Dn, Bn.r, 0, Ln, !1), Cn.moveTo(In + Bn.r0, Dn), Cn.arc(In, Dn, Bn.r0, 0, Ln, !0);
  }, nr;
}(Path$1);
Ring.prototype.type = "ring";
const Ring$1 = Ring;
function smoothBezier(_n, nr, Cn, Bn) {
  var In = [], Dn = [], Ln = [], $n = [], Nn, Rn, Fn, Pn;
  if (Bn) {
    Fn = [1 / 0, 1 / 0], Pn = [-1 / 0, -1 / 0];
    for (var Un = 0, Hn = _n.length; Un < Hn; Un++)
      min$2(Fn, Fn, _n[Un]), max$3(Pn, Pn, _n[Un]);
    min$2(Fn, Fn, Bn[0]), max$3(Pn, Pn, Bn[1]);
  }
  for (var Un = 0, Hn = _n.length; Un < Hn; Un++) {
    var zn = _n[Un];
    if (Cn)
      Nn = _n[Un ? Un - 1 : Hn - 1], Rn = _n[(Un + 1) % Hn];
    else if (Un === 0 || Un === Hn - 1) {
      In.push(clone$3(_n[Un]));
      continue;
    } else
      Nn = _n[Un - 1], Rn = _n[Un + 1];
    sub(Dn, Rn, Nn), scale$2(Dn, Dn, nr);
    var Gn = distance$1(zn, Nn), Yn = distance$1(zn, Rn), Wn = Gn + Yn;
    Wn !== 0 && (Gn /= Wn, Yn /= Wn), scale$2(Ln, Dn, -Gn), scale$2($n, Dn, Yn);
    var Xn = add([], zn, Ln), ea = add([], zn, $n);
    Bn && (max$3(Xn, Xn, Fn), min$2(Xn, Xn, Pn), max$3(ea, ea, Fn), min$2(ea, ea, Pn)), In.push(Xn), In.push(ea);
  }
  return Cn && In.push(In.shift()), In;
}
function buildPath(_n, nr, Cn) {
  var Bn = nr.smooth, In = nr.points;
  if (In && In.length >= 2) {
    if (Bn) {
      var Dn = smoothBezier(In, Bn, Cn, nr.smoothConstraint);
      _n.moveTo(In[0][0], In[0][1]);
      for (var Ln = In.length, $n = 0; $n < (Cn ? Ln : Ln - 1); $n++) {
        var Nn = Dn[$n * 2], Rn = Dn[$n * 2 + 1], Fn = In[($n + 1) % Ln];
        _n.bezierCurveTo(Nn[0], Nn[1], Rn[0], Rn[1], Fn[0], Fn[1]);
      }
    } else {
      _n.moveTo(In[0][0], In[0][1]);
      for (var $n = 1, Pn = In.length; $n < Pn; $n++)
        _n.lineTo(In[$n][0], In[$n][1]);
    }
    Cn && _n.closePath();
  }
}
var PolygonShape = function() {
  function _n() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return _n;
}(), Polygon = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultShape = function() {
    return new PolygonShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    buildPath(Cn, Bn, !0);
  }, nr;
}(Path$1);
Polygon.prototype.type = "polygon";
const Polygon$1 = Polygon;
var PolylineShape = function() {
  function _n() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return _n;
}(), Polyline$2 = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, nr.prototype.getDefaultShape = function() {
    return new PolylineShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    buildPath(Cn, Bn, !1);
  }, nr;
}(Path$1);
Polyline$2.prototype.type = "polyline";
const Polyline$3 = Polyline$2;
var subPixelOptimizeOutputShape = {}, LineShape = function() {
  function _n() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return _n;
}(), Line$2 = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, nr.prototype.getDefaultShape = function() {
    return new LineShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    var In, Dn, Ln, $n;
    if (this.subPixelOptimize) {
      var Nn = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, Bn, this.style);
      In = Nn.x1, Dn = Nn.y1, Ln = Nn.x2, $n = Nn.y2;
    } else
      In = Bn.x1, Dn = Bn.y1, Ln = Bn.x2, $n = Bn.y2;
    var Rn = Bn.percent;
    Rn !== 0 && (Cn.moveTo(In, Dn), Rn < 1 && (Ln = In * (1 - Rn) + Ln * Rn, $n = Dn * (1 - Rn) + $n * Rn), Cn.lineTo(Ln, $n));
  }, nr.prototype.pointAt = function(Cn) {
    var Bn = this.shape;
    return [
      Bn.x1 * (1 - Cn) + Bn.x2 * Cn,
      Bn.y1 * (1 - Cn) + Bn.y2 * Cn
    ];
  }, nr;
}(Path$1);
Line$2.prototype.type = "line";
const Line$3 = Line$2;
var out = [], BezierCurveShape = function() {
  function _n() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return _n;
}();
function someVectorAt(_n, nr, Cn) {
  var Bn = _n.cpx2, In = _n.cpy2;
  return Bn != null || In != null ? [
    (Cn ? cubicDerivativeAt : cubicAt)(_n.x1, _n.cpx1, _n.cpx2, _n.x2, nr),
    (Cn ? cubicDerivativeAt : cubicAt)(_n.y1, _n.cpy1, _n.cpy2, _n.y2, nr)
  ] : [
    (Cn ? quadraticDerivativeAt : quadraticAt$1)(_n.x1, _n.cpx1, _n.x2, nr),
    (Cn ? quadraticDerivativeAt : quadraticAt$1)(_n.y1, _n.cpy1, _n.y2, nr)
  ];
}
var BezierCurve$1 = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, nr.prototype.getDefaultShape = function() {
    return new BezierCurveShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    var In = Bn.x1, Dn = Bn.y1, Ln = Bn.x2, $n = Bn.y2, Nn = Bn.cpx1, Rn = Bn.cpy1, Fn = Bn.cpx2, Pn = Bn.cpy2, Un = Bn.percent;
    Un !== 0 && (Cn.moveTo(In, Dn), Fn == null || Pn == null ? (Un < 1 && (quadraticSubdivide(In, Nn, Ln, Un, out), Nn = out[1], Ln = out[2], quadraticSubdivide(Dn, Rn, $n, Un, out), Rn = out[1], $n = out[2]), Cn.quadraticCurveTo(Nn, Rn, Ln, $n)) : (Un < 1 && (cubicSubdivide(In, Nn, Fn, Ln, Un, out), Nn = out[1], Fn = out[2], Ln = out[3], cubicSubdivide(Dn, Rn, Pn, $n, Un, out), Rn = out[1], Pn = out[2], $n = out[3]), Cn.bezierCurveTo(Nn, Rn, Fn, Pn, Ln, $n)));
  }, nr.prototype.pointAt = function(Cn) {
    return someVectorAt(this.shape, Cn, !1);
  }, nr.prototype.tangentAt = function(Cn) {
    var Bn = someVectorAt(this.shape, Cn, !0);
    return normalize$3(Bn, Bn);
  }, nr;
}(Path$1);
BezierCurve$1.prototype.type = "bezier-curve";
const BezierCurve$2 = BezierCurve$1;
var ArcShape = function() {
  function _n() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return _n;
}(), Arc = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn) {
    return _n.call(this, Cn) || this;
  }
  return nr.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, nr.prototype.getDefaultShape = function() {
    return new ArcShape();
  }, nr.prototype.buildPath = function(Cn, Bn) {
    var In = Bn.cx, Dn = Bn.cy, Ln = Math.max(Bn.r, 0), $n = Bn.startAngle, Nn = Bn.endAngle, Rn = Bn.clockwise, Fn = Math.cos($n), Pn = Math.sin($n);
    Cn.moveTo(Fn * Ln + In, Pn * Ln + Dn), Cn.arc(In, Dn, Ln, $n, Nn, !Rn);
  }, nr;
}(Path$1);
Arc.prototype.type = "arc";
const Arc$1 = Arc;
var CompoundPath = function(_n) {
  __extends$2(nr, _n);
  function nr() {
    var Cn = _n !== null && _n.apply(this, arguments) || this;
    return Cn.type = "compound", Cn;
  }
  return nr.prototype._updatePathDirty = function() {
    for (var Cn = this.shape.paths, Bn = this.shapeChanged(), In = 0; In < Cn.length; In++)
      Bn = Bn || Cn[In].shapeChanged();
    Bn && this.dirtyShape();
  }, nr.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var Cn = this.shape.paths || [], Bn = this.getGlobalScale(), In = 0; In < Cn.length; In++)
      Cn[In].path || Cn[In].createPathProxy(), Cn[In].path.setScale(Bn[0], Bn[1], Cn[In].segmentIgnoreThreshold);
  }, nr.prototype.buildPath = function(Cn, Bn) {
    for (var In = Bn.paths || [], Dn = 0; Dn < In.length; Dn++)
      In[Dn].buildPath(Cn, In[Dn].shape, !0);
  }, nr.prototype.afterBrush = function() {
    for (var Cn = this.shape.paths || [], Bn = 0; Bn < Cn.length; Bn++)
      Cn[Bn].pathUpdated();
  }, nr.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), Path$1.prototype.getBoundingRect.call(this);
  }, nr;
}(Path$1);
const CompoundPath$1 = CompoundPath;
var Gradient = function() {
  function _n(nr) {
    this.colorStops = nr || [];
  }
  return _n.prototype.addColorStop = function(nr, Cn) {
    this.colorStops.push({
      offset: nr,
      color: Cn
    });
  }, _n;
}();
const Gradient$1 = Gradient;
var LinearGradient = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn, Bn, In, Dn, Ln, $n) {
    var Nn = _n.call(this, Ln) || this;
    return Nn.x = Cn ?? 0, Nn.y = Bn ?? 0, Nn.x2 = In ?? 1, Nn.y2 = Dn ?? 0, Nn.type = "linear", Nn.global = $n || !1, Nn;
  }
  return nr;
}(Gradient$1);
const LinearGradient$1 = LinearGradient;
var RadialGradient = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn, Bn, In, Dn, Ln) {
    var $n = _n.call(this, Dn) || this;
    return $n.x = Cn ?? 0.5, $n.y = Bn ?? 0.5, $n.r = In ?? 0.5, $n.type = "radial", $n.global = Ln || !1, $n;
  }
  return nr;
}(Gradient$1);
const RadialGradient$1 = RadialGradient;
var extent = [0, 0], extent2 = [0, 0], minTv = new Point$1(), maxTv = new Point$1(), OrientedBoundingRect = function() {
  function _n(nr, Cn) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var Bn = 0; Bn < 4; Bn++)
      this._corners[Bn] = new Point$1();
    for (var Bn = 0; Bn < 2; Bn++)
      this._axes[Bn] = new Point$1();
    nr && this.fromBoundingRect(nr, Cn);
  }
  return _n.prototype.fromBoundingRect = function(nr, Cn) {
    var Bn = this._corners, In = this._axes, Dn = nr.x, Ln = nr.y, $n = Dn + nr.width, Nn = Ln + nr.height;
    if (Bn[0].set(Dn, Ln), Bn[1].set($n, Ln), Bn[2].set($n, Nn), Bn[3].set(Dn, Nn), Cn)
      for (var Rn = 0; Rn < 4; Rn++)
        Bn[Rn].transform(Cn);
    Point$1.sub(In[0], Bn[1], Bn[0]), Point$1.sub(In[1], Bn[3], Bn[0]), In[0].normalize(), In[1].normalize();
    for (var Rn = 0; Rn < 2; Rn++)
      this._origin[Rn] = In[Rn].dot(Bn[0]);
  }, _n.prototype.intersect = function(nr, Cn) {
    var Bn = !0, In = !Cn;
    return minTv.set(1 / 0, 1 / 0), maxTv.set(0, 0), !this._intersectCheckOneSide(this, nr, minTv, maxTv, In, 1) && (Bn = !1, In) || !this._intersectCheckOneSide(nr, this, minTv, maxTv, In, -1) && (Bn = !1, In) || In || Point$1.copy(Cn, Bn ? minTv : maxTv), Bn;
  }, _n.prototype._intersectCheckOneSide = function(nr, Cn, Bn, In, Dn, Ln) {
    for (var $n = !0, Nn = 0; Nn < 2; Nn++) {
      var Rn = this._axes[Nn];
      if (this._getProjMinMaxOnAxis(Nn, nr._corners, extent), this._getProjMinMaxOnAxis(Nn, Cn._corners, extent2), extent[1] < extent2[0] || extent[0] > extent2[1]) {
        if ($n = !1, Dn)
          return $n;
        var Fn = Math.abs(extent2[0] - extent[1]), Pn = Math.abs(extent[0] - extent2[1]);
        Math.min(Fn, Pn) > In.len() && (Fn < Pn ? Point$1.scale(In, Rn, -Fn * Ln) : Point$1.scale(In, Rn, Pn * Ln));
      } else if (Bn) {
        var Fn = Math.abs(extent2[0] - extent[1]), Pn = Math.abs(extent[0] - extent2[1]);
        Math.min(Fn, Pn) < Bn.len() && (Fn < Pn ? Point$1.scale(Bn, Rn, Fn * Ln) : Point$1.scale(Bn, Rn, -Pn * Ln));
      }
    }
    return $n;
  }, _n.prototype._getProjMinMaxOnAxis = function(nr, Cn, Bn) {
    for (var In = this._axes[nr], Dn = this._origin, Ln = Cn[0].dot(In) + Dn[nr], $n = Ln, Nn = Ln, Rn = 1; Rn < Cn.length; Rn++) {
      var Fn = Cn[Rn].dot(In) + Dn[nr];
      $n = Math.min(Fn, $n), Nn = Math.max(Fn, Nn);
    }
    Bn[0] = $n, Bn[1] = Nn;
  }, _n;
}();
const OrientedBoundingRect$1 = OrientedBoundingRect;
var m$2 = [], IncrementalDisplayable = function(_n) {
  __extends$2(nr, _n);
  function nr() {
    var Cn = _n !== null && _n.apply(this, arguments) || this;
    return Cn.notClear = !0, Cn.incremental = !0, Cn._displayables = [], Cn._temporaryDisplayables = [], Cn._cursor = 0, Cn;
  }
  return nr.prototype.traverse = function(Cn, Bn) {
    Cn.call(Bn, this);
  }, nr.prototype.useStyle = function() {
    this.style = {};
  }, nr.prototype.getCursor = function() {
    return this._cursor;
  }, nr.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, nr.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, nr.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, nr.prototype.addDisplayable = function(Cn, Bn) {
    Bn ? this._temporaryDisplayables.push(Cn) : this._displayables.push(Cn), this.markRedraw();
  }, nr.prototype.addDisplayables = function(Cn, Bn) {
    Bn = Bn || !1;
    for (var In = 0; In < Cn.length; In++)
      this.addDisplayable(Cn[In], Bn);
  }, nr.prototype.getDisplayables = function() {
    return this._displayables;
  }, nr.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, nr.prototype.eachPendingDisplayable = function(Cn) {
    for (var Bn = this._cursor; Bn < this._displayables.length; Bn++)
      Cn && Cn(this._displayables[Bn]);
    for (var Bn = 0; Bn < this._temporaryDisplayables.length; Bn++)
      Cn && Cn(this._temporaryDisplayables[Bn]);
  }, nr.prototype.update = function() {
    this.updateTransform();
    for (var Cn = this._cursor; Cn < this._displayables.length; Cn++) {
      var Bn = this._displayables[Cn];
      Bn.parent = this, Bn.update(), Bn.parent = null;
    }
    for (var Cn = 0; Cn < this._temporaryDisplayables.length; Cn++) {
      var Bn = this._temporaryDisplayables[Cn];
      Bn.parent = this, Bn.update(), Bn.parent = null;
    }
  }, nr.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var Cn = new BoundingRect$1(1 / 0, 1 / 0, -1 / 0, -1 / 0), Bn = 0; Bn < this._displayables.length; Bn++) {
        var In = this._displayables[Bn], Dn = In.getBoundingRect().clone();
        In.needLocalTransform() && Dn.applyTransform(In.getLocalTransform(m$2)), Cn.union(Dn);
      }
      this._rect = Cn;
    }
    return this._rect;
  }, nr.prototype.contain = function(Cn, Bn) {
    var In = this.transformCoordToLocal(Cn, Bn), Dn = this.getBoundingRect();
    if (Dn.contain(In[0], In[1]))
      for (var Ln = 0; Ln < this._displayables.length; Ln++) {
        var $n = this._displayables[Ln];
        if ($n.contain(Cn, Bn))
          return !0;
      }
    return !1;
  }, nr;
}(Displayable$1);
const IncrementalDisplayable$1 = IncrementalDisplayable;
var transitionStore = makeInner();
function getAnimationConfig(_n, nr, Cn, Bn, In) {
  var Dn;
  if (nr && nr.ecModel) {
    var Ln = nr.ecModel.getUpdatePayload();
    Dn = Ln && Ln.animation;
  }
  var $n = nr && nr.isAnimationEnabled(), Nn = _n === "update";
  if ($n) {
    var Rn = void 0, Fn = void 0, Pn = void 0;
    Bn ? (Rn = retrieve2(Bn.duration, 200), Fn = retrieve2(Bn.easing, "cubicOut"), Pn = 0) : (Rn = nr.getShallow(Nn ? "animationDurationUpdate" : "animationDuration"), Fn = nr.getShallow(Nn ? "animationEasingUpdate" : "animationEasing"), Pn = nr.getShallow(Nn ? "animationDelayUpdate" : "animationDelay")), Dn && (Dn.duration != null && (Rn = Dn.duration), Dn.easing != null && (Fn = Dn.easing), Dn.delay != null && (Pn = Dn.delay)), isFunction$1(Pn) && (Pn = Pn(Cn, In)), isFunction$1(Rn) && (Rn = Rn(Cn));
    var Un = {
      duration: Rn || 0,
      delay: Pn,
      easing: Fn
    };
    return Un;
  } else
    return null;
}
function animateOrSetProps(_n, nr, Cn, Bn, In, Dn, Ln) {
  var $n = !1, Nn;
  isFunction$1(In) ? (Ln = Dn, Dn = In, In = null) : isObject$6(In) && (Dn = In.cb, Ln = In.during, $n = In.isFrom, Nn = In.removeOpt, In = In.dataIndex);
  var Rn = _n === "leave";
  Rn || nr.stopAnimation("leave");
  var Fn = getAnimationConfig(_n, Bn, In, Rn ? Nn || {} : null, Bn && Bn.getAnimationDelayParams ? Bn.getAnimationDelayParams(nr, In) : null);
  if (Fn && Fn.duration > 0) {
    var Pn = Fn.duration, Un = Fn.delay, Hn = Fn.easing, zn = {
      duration: Pn,
      delay: Un || 0,
      easing: Hn,
      done: Dn,
      force: !!Dn || !!Ln,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !Rn,
      scope: _n,
      during: Ln
    };
    $n ? nr.animateFrom(Cn, zn) : nr.animateTo(Cn, zn);
  } else
    nr.stopAnimation(), !$n && nr.attr(Cn), Ln && Ln(1), Dn && Dn();
}
function updateProps$1(_n, nr, Cn, Bn, In, Dn) {
  animateOrSetProps("update", _n, nr, Cn, Bn, In, Dn);
}
function initProps(_n, nr, Cn, Bn, In, Dn) {
  animateOrSetProps("enter", _n, nr, Cn, Bn, In, Dn);
}
function isElementRemoved(_n) {
  if (!_n.__zr)
    return !0;
  for (var nr = 0; nr < _n.animators.length; nr++) {
    var Cn = _n.animators[nr];
    if (Cn.scope === "leave")
      return !0;
  }
  return !1;
}
function removeElement(_n, nr, Cn, Bn, In, Dn) {
  isElementRemoved(_n) || animateOrSetProps("leave", _n, nr, Cn, Bn, In, Dn);
}
function fadeOutDisplayable(_n, nr, Cn, Bn) {
  _n.removeTextContent(), _n.removeTextGuideLine(), removeElement(_n, {
    style: {
      opacity: 0
    }
  }, nr, Cn, Bn);
}
function removeElementWithFadeOut(_n, nr, Cn) {
  function Bn() {
    _n.parent && _n.parent.remove(_n);
  }
  _n.isGroup ? _n.traverse(function(In) {
    In.isGroup || fadeOutDisplayable(In, nr, Cn, Bn);
  }) : fadeOutDisplayable(_n, nr, Cn, Bn);
}
function saveOldStyle(_n) {
  transitionStore(_n).oldStyle = _n.style;
}
function getOldStyle(_n) {
  return transitionStore(_n).oldStyle;
}
var mathMax$6 = Math.max, mathMin$6 = Math.min, _customShapeMap = {};
function extendShape(_n) {
  return Path$1.extend(_n);
}
var extendPathFromString = extendFromString;
function extendPath(_n, nr) {
  return extendPathFromString(_n, nr);
}
function registerShape(_n, nr) {
  _customShapeMap[_n] = nr;
}
function getShapeClass(_n) {
  if (_customShapeMap.hasOwnProperty(_n))
    return _customShapeMap[_n];
}
function makePath(_n, nr, Cn, Bn) {
  var In = createFromString(_n, nr);
  return Cn && (Bn === "center" && (Cn = centerGraphic(Cn, In.getBoundingRect())), resizePath(In, Cn)), In;
}
function makeImage(_n, nr, Cn) {
  var Bn = new ZRImage$1({
    style: {
      image: _n,
      x: nr.x,
      y: nr.y,
      width: nr.width,
      height: nr.height
    },
    onload: function(In) {
      if (Cn === "center") {
        var Dn = {
          width: In.width,
          height: In.height
        };
        Bn.setStyle(centerGraphic(nr, Dn));
      }
    }
  });
  return Bn;
}
function centerGraphic(_n, nr) {
  var Cn = nr.width / nr.height, Bn = _n.height * Cn, In;
  Bn <= _n.width ? In = _n.height : (Bn = _n.width, In = Bn / Cn);
  var Dn = _n.x + _n.width / 2, Ln = _n.y + _n.height / 2;
  return {
    x: Dn - Bn / 2,
    y: Ln - In / 2,
    width: Bn,
    height: In
  };
}
var mergePath = mergePath$1;
function resizePath(_n, nr) {
  if (_n.applyTransform) {
    var Cn = _n.getBoundingRect(), Bn = Cn.calculateTransform(nr);
    _n.applyTransform(Bn);
  }
}
function subPixelOptimizeLine(_n, nr) {
  return subPixelOptimizeLine$1(_n, _n, {
    lineWidth: nr
  }), _n;
}
function subPixelOptimizeRect(_n) {
  return subPixelOptimizeRect$1(_n.shape, _n.shape, _n.style), _n;
}
var subPixelOptimize = subPixelOptimize$1;
function getTransform$1(_n, nr) {
  for (var Cn = identity$1([]); _n && _n !== nr; )
    mul(Cn, _n.getLocalTransform(), Cn), _n = _n.parent;
  return Cn;
}
function applyTransform(_n, nr, Cn) {
  return nr && !isArrayLike$1(nr) && (nr = Transformable$1.getLocalTransform(nr)), Cn && (nr = invert([], nr)), applyTransform$1([], _n, nr);
}
function transformDirection(_n, nr, Cn) {
  var Bn = nr[4] === 0 || nr[5] === 0 || nr[0] === 0 ? 1 : Math.abs(2 * nr[4] / nr[0]), In = nr[4] === 0 || nr[5] === 0 || nr[2] === 0 ? 1 : Math.abs(2 * nr[4] / nr[2]), Dn = [_n === "left" ? -Bn : _n === "right" ? Bn : 0, _n === "top" ? -In : _n === "bottom" ? In : 0];
  return Dn = applyTransform(Dn, nr, Cn), Math.abs(Dn[0]) > Math.abs(Dn[1]) ? Dn[0] > 0 ? "right" : "left" : Dn[1] > 0 ? "bottom" : "top";
}
function isNotGroup(_n) {
  return !_n.isGroup;
}
function isPath$1(_n) {
  return _n.shape != null;
}
function groupTransition(_n, nr, Cn) {
  if (!_n || !nr)
    return;
  function Bn(Ln) {
    var $n = {};
    return Ln.traverse(function(Nn) {
      isNotGroup(Nn) && Nn.anid && ($n[Nn.anid] = Nn);
    }), $n;
  }
  function In(Ln) {
    var $n = {
      x: Ln.x,
      y: Ln.y,
      rotation: Ln.rotation
    };
    return isPath$1(Ln) && ($n.shape = extend({}, Ln.shape)), $n;
  }
  var Dn = Bn(_n);
  nr.traverse(function(Ln) {
    if (isNotGroup(Ln) && Ln.anid) {
      var $n = Dn[Ln.anid];
      if ($n) {
        var Nn = In(Ln);
        Ln.attr(In($n)), updateProps$1(Ln, Nn, Cn, getECData(Ln).dataIndex);
      }
    }
  });
}
function clipPointsByRect(_n, nr) {
  return map$1(_n, function(Cn) {
    var Bn = Cn[0];
    Bn = mathMax$6(Bn, nr.x), Bn = mathMin$6(Bn, nr.x + nr.width);
    var In = Cn[1];
    return In = mathMax$6(In, nr.y), In = mathMin$6(In, nr.y + nr.height), [Bn, In];
  });
}
function clipRectByRect(_n, nr) {
  var Cn = mathMax$6(_n.x, nr.x), Bn = mathMin$6(_n.x + _n.width, nr.x + nr.width), In = mathMax$6(_n.y, nr.y), Dn = mathMin$6(_n.y + _n.height, nr.y + nr.height);
  if (Bn >= Cn && Dn >= In)
    return {
      x: Cn,
      y: In,
      width: Bn - Cn,
      height: Dn - In
    };
}
function createIcon(_n, nr, Cn) {
  var Bn = extend({
    rectHover: !0
  }, nr), In = Bn.style = {
    strokeNoScale: !0
  };
  if (Cn = Cn || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, _n)
    return _n.indexOf("image://") === 0 ? (In.image = _n.slice(8), defaults(In, Cn), new ZRImage$1(Bn)) : makePath(_n.replace("path://", ""), Bn, Cn, "center");
}
function linePolygonIntersect(_n, nr, Cn, Bn, In) {
  for (var Dn = 0, Ln = In[In.length - 1]; Dn < In.length; Dn++) {
    var $n = In[Dn];
    if (lineLineIntersect$1(_n, nr, Cn, Bn, $n[0], $n[1], Ln[0], Ln[1]))
      return !0;
    Ln = $n;
  }
}
function lineLineIntersect$1(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  var Nn = Cn - _n, Rn = Bn - nr, Fn = Ln - In, Pn = $n - Dn, Un = crossProduct2d$1(Fn, Pn, Nn, Rn);
  if (nearZero(Un))
    return !1;
  var Hn = _n - In, zn = nr - Dn, Gn = crossProduct2d$1(Hn, zn, Nn, Rn) / Un;
  if (Gn < 0 || Gn > 1)
    return !1;
  var Yn = crossProduct2d$1(Hn, zn, Fn, Pn) / Un;
  return !(Yn < 0 || Yn > 1);
}
function crossProduct2d$1(_n, nr, Cn, Bn) {
  return _n * Bn - Cn * nr;
}
function nearZero(_n) {
  return _n <= 1e-6 && _n >= -1e-6;
}
function setTooltipConfig(_n) {
  var nr = _n.itemTooltipOption, Cn = _n.componentModel, Bn = _n.itemName, In = isString$1(nr) ? {
    formatter: nr
  } : nr, Dn = Cn.mainType, Ln = Cn.componentIndex, $n = {
    componentType: Dn,
    name: Bn,
    $vars: ["name"]
  };
  $n[Dn + "Index"] = Ln;
  var Nn = _n.formatterParamsExtra;
  Nn && each$f(keys(Nn), function(Fn) {
    hasOwn($n, Fn) || ($n[Fn] = Nn[Fn], $n.$vars.push(Fn));
  });
  var Rn = getECData(_n.el);
  Rn.componentMainType = Dn, Rn.componentIndex = Ln, Rn.tooltipConfig = {
    name: Bn,
    option: defaults({
      content: Bn,
      encodeHTMLContent: !0,
      formatterParams: $n
    }, In)
  };
}
function traverseElement(_n, nr) {
  var Cn;
  _n.isGroup && (Cn = nr(_n)), Cn || _n.traverse(nr);
}
function traverseElements(_n, nr) {
  if (_n)
    if (isArray$4(_n))
      for (var Cn = 0; Cn < _n.length; Cn++)
        traverseElement(_n[Cn], nr);
    else
      traverseElement(_n, nr);
}
registerShape("circle", Circle$1);
registerShape("ellipse", Ellipse$1);
registerShape("sector", Sector$1);
registerShape("ring", Ring$1);
registerShape("polygon", Polygon$1);
registerShape("polyline", Polyline$3);
registerShape("rect", Rect$3);
registerShape("line", Line$3);
registerShape("bezierCurve", BezierCurve$2);
registerShape("arc", Arc$1);
const graphic$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: Arc$1,
  BezierCurve: BezierCurve$2,
  BoundingRect: BoundingRect$1,
  Circle: Circle$1,
  CompoundPath: CompoundPath$1,
  Ellipse: Ellipse$1,
  Group: Group$4,
  Image: ZRImage$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  Line: Line$3,
  LinearGradient: LinearGradient$1,
  OrientedBoundingRect: OrientedBoundingRect$1,
  Path: Path$1,
  Point: Point$1,
  Polygon: Polygon$1,
  Polyline: Polyline$3,
  RadialGradient: RadialGradient$1,
  Rect: Rect$3,
  Ring: Ring$1,
  Sector: Sector$1,
  Text: ZRText$1,
  applyTransform,
  clipPointsByRect,
  clipRectByRect,
  createIcon,
  extendPath,
  extendShape,
  getShapeClass,
  getTransform: getTransform$1,
  groupTransition,
  initProps,
  isElementRemoved,
  lineLineIntersect: lineLineIntersect$1,
  linePolygonIntersect,
  makeImage,
  makePath,
  mergePath,
  registerShape,
  removeElement,
  removeElementWithFadeOut,
  resizePath,
  setTooltipConfig,
  subPixelOptimize,
  subPixelOptimizeLine,
  subPixelOptimizeRect,
  transformDirection,
  traverseElements,
  updateProps: updateProps$1
}, Symbol.toStringTag, { value: "Module" }));
var EMPTY_OBJ = {};
function setLabelText(_n, nr) {
  for (var Cn = 0; Cn < SPECIAL_STATES.length; Cn++) {
    var Bn = SPECIAL_STATES[Cn], In = nr[Bn], Dn = _n.ensureState(Bn);
    Dn.style = Dn.style || {}, Dn.style.text = In;
  }
  var Ln = _n.currentStates.slice();
  _n.clearStates(!0), _n.setStyle({
    text: nr.normal
  }), _n.useStates(Ln, !0);
}
function getLabelText(_n, nr, Cn) {
  var Bn = _n.labelFetcher, In = _n.labelDataIndex, Dn = _n.labelDimIndex, Ln = nr.normal, $n;
  Bn && ($n = Bn.getFormattedLabel(In, "normal", null, Dn, Ln && Ln.get("formatter"), Cn != null ? {
    interpolatedValue: Cn
  } : null)), $n == null && ($n = isFunction$1(_n.defaultText) ? _n.defaultText(In, _n, Cn) : _n.defaultText);
  for (var Nn = {
    normal: $n
  }, Rn = 0; Rn < SPECIAL_STATES.length; Rn++) {
    var Fn = SPECIAL_STATES[Rn], Pn = nr[Fn];
    Nn[Fn] = retrieve2(Bn ? Bn.getFormattedLabel(In, Fn, null, Dn, Pn && Pn.get("formatter")) : null, $n);
  }
  return Nn;
}
function setLabelStyle(_n, nr, Cn, Bn) {
  Cn = Cn || EMPTY_OBJ;
  for (var In = _n instanceof ZRText$1, Dn = !1, Ln = 0; Ln < DISPLAY_STATES.length; Ln++) {
    var $n = nr[DISPLAY_STATES[Ln]];
    if ($n && $n.getShallow("show")) {
      Dn = !0;
      break;
    }
  }
  var Nn = In ? _n : _n.getTextContent();
  if (Dn) {
    In || (Nn || (Nn = new ZRText$1(), _n.setTextContent(Nn)), _n.stateProxy && (Nn.stateProxy = _n.stateProxy));
    var Rn = getLabelText(Cn, nr), Fn = nr.normal, Pn = !!Fn.getShallow("show"), Un = createTextStyle$1(Fn, Bn && Bn.normal, Cn, !1, !In);
    Un.text = Rn.normal, In || _n.setTextConfig(createTextConfig(Fn, Cn, !1));
    for (var Ln = 0; Ln < SPECIAL_STATES.length; Ln++) {
      var Hn = SPECIAL_STATES[Ln], $n = nr[Hn];
      if ($n) {
        var zn = Nn.ensureState(Hn), Gn = !!retrieve2($n.getShallow("show"), Pn);
        if (Gn !== Pn && (zn.ignore = !Gn), zn.style = createTextStyle$1($n, Bn && Bn[Hn], Cn, !0, !In), zn.style.text = Rn[Hn], !In) {
          var Yn = _n.ensureState(Hn);
          Yn.textConfig = createTextConfig($n, Cn, !0);
        }
      }
    }
    Nn.silent = !!Fn.getShallow("silent"), Nn.style.x != null && (Un.x = Nn.style.x), Nn.style.y != null && (Un.y = Nn.style.y), Nn.ignore = !Pn, Nn.useStyle(Un), Nn.dirty(), Cn.enableTextSetter && (labelInner(Nn).setLabelText = function(Wn) {
      var Xn = getLabelText(Cn, nr, Wn);
      setLabelText(Nn, Xn);
    });
  } else
    Nn && (Nn.ignore = !0);
  _n.dirty();
}
function getLabelStatesModels(_n, nr) {
  nr = nr || "label";
  for (var Cn = {
    normal: _n.getModel(nr)
  }, Bn = 0; Bn < SPECIAL_STATES.length; Bn++) {
    var In = SPECIAL_STATES[Bn];
    Cn[In] = _n.getModel([In, nr]);
  }
  return Cn;
}
function createTextStyle$1(_n, nr, Cn, Bn, In) {
  var Dn = {};
  return setTextStyleCommon(Dn, _n, Cn, Bn, In), nr && extend(Dn, nr), Dn;
}
function createTextConfig(_n, nr, Cn) {
  nr = nr || {};
  var Bn = {}, In, Dn = _n.getShallow("rotate"), Ln = retrieve2(_n.getShallow("distance"), Cn ? null : 5), $n = _n.getShallow("offset");
  return In = _n.getShallow("position") || (Cn ? null : "inside"), In === "outside" && (In = nr.defaultOutsidePosition || "top"), In != null && (Bn.position = In), $n != null && (Bn.offset = $n), Dn != null && (Dn *= Math.PI / 180, Bn.rotation = Dn), Ln != null && (Bn.distance = Ln), Bn.outsideFill = _n.get("color") === "inherit" ? nr.inheritColor || null : "auto", Bn;
}
function setTextStyleCommon(_n, nr, Cn, Bn, In) {
  Cn = Cn || EMPTY_OBJ;
  var Dn = nr.ecModel, Ln = Dn && Dn.option.textStyle, $n = getRichItemNames(nr), Nn;
  if ($n) {
    Nn = {};
    for (var Rn in $n)
      if ($n.hasOwnProperty(Rn)) {
        var Fn = nr.getModel(["rich", Rn]);
        setTokenTextStyle(Nn[Rn] = {}, Fn, Ln, Cn, Bn, In, !1, !0);
      }
  }
  Nn && (_n.rich = Nn);
  var Pn = nr.get("overflow");
  Pn && (_n.overflow = Pn);
  var Un = nr.get("minMargin");
  Un != null && (_n.margin = Un), setTokenTextStyle(_n, nr, Ln, Cn, Bn, In, !0, !1);
}
function getRichItemNames(_n) {
  for (var nr; _n && _n !== _n.ecModel; ) {
    var Cn = (_n.option || EMPTY_OBJ).rich;
    if (Cn) {
      nr = nr || {};
      for (var Bn = keys(Cn), In = 0; In < Bn.length; In++) {
        var Dn = Bn[In];
        nr[Dn] = 1;
      }
    }
    _n = _n.parentModel;
  }
  return nr;
}
var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function setTokenTextStyle(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  Cn = !In && Cn || EMPTY_OBJ;
  var Nn = Bn && Bn.inheritColor, Rn = nr.getShallow("color"), Fn = nr.getShallow("textBorderColor"), Pn = retrieve2(nr.getShallow("opacity"), Cn.opacity);
  (Rn === "inherit" || Rn === "auto") && (process.env.NODE_ENV !== "production" && Rn === "auto" && deprecateReplaceLog("color: 'auto'", "color: 'inherit'"), Nn ? Rn = Nn : Rn = null), (Fn === "inherit" || Fn === "auto") && (process.env.NODE_ENV !== "production" && Fn === "auto" && deprecateReplaceLog("color: 'auto'", "color: 'inherit'"), Nn ? Fn = Nn : Fn = null), Dn || (Rn = Rn || Cn.color, Fn = Fn || Cn.textBorderColor), Rn != null && (_n.fill = Rn), Fn != null && (_n.stroke = Fn);
  var Un = retrieve2(nr.getShallow("textBorderWidth"), Cn.textBorderWidth);
  Un != null && (_n.lineWidth = Un);
  var Hn = retrieve2(nr.getShallow("textBorderType"), Cn.textBorderType);
  Hn != null && (_n.lineDash = Hn);
  var zn = retrieve2(nr.getShallow("textBorderDashOffset"), Cn.textBorderDashOffset);
  zn != null && (_n.lineDashOffset = zn), !In && Pn == null && !$n && (Pn = Bn && Bn.defaultOpacity), Pn != null && (_n.opacity = Pn), !In && !Dn && _n.fill == null && Bn.inheritColor && (_n.fill = Bn.inheritColor);
  for (var Gn = 0; Gn < TEXT_PROPS_WITH_GLOBAL.length; Gn++) {
    var Yn = TEXT_PROPS_WITH_GLOBAL[Gn], Wn = retrieve2(nr.getShallow(Yn), Cn[Yn]);
    Wn != null && (_n[Yn] = Wn);
  }
  for (var Gn = 0; Gn < TEXT_PROPS_SELF.length; Gn++) {
    var Yn = TEXT_PROPS_SELF[Gn], Wn = nr.getShallow(Yn);
    Wn != null && (_n[Yn] = Wn);
  }
  if (_n.verticalAlign == null) {
    var Xn = nr.getShallow("baseline");
    Xn != null && (_n.verticalAlign = Xn);
  }
  if (!Ln || !Bn.disableBox) {
    for (var Gn = 0; Gn < TEXT_PROPS_BOX.length; Gn++) {
      var Yn = TEXT_PROPS_BOX[Gn], Wn = nr.getShallow(Yn);
      Wn != null && (_n[Yn] = Wn);
    }
    var ea = nr.getShallow("borderType");
    ea != null && (_n.borderDash = ea), (_n.backgroundColor === "auto" || _n.backgroundColor === "inherit") && Nn && (process.env.NODE_ENV !== "production" && _n.backgroundColor === "auto" && deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), _n.backgroundColor = Nn), (_n.borderColor === "auto" || _n.borderColor === "inherit") && Nn && (process.env.NODE_ENV !== "production" && _n.borderColor === "auto" && deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'"), _n.borderColor = Nn);
  }
}
function getFont(_n, nr) {
  var Cn = nr && nr.getModel("textStyle");
  return trim$1([
    // FIXME in node-canvas fontWeight is before fontStyle
    _n.fontStyle || Cn && Cn.getShallow("fontStyle") || "",
    _n.fontWeight || Cn && Cn.getShallow("fontWeight") || "",
    (_n.fontSize || Cn && Cn.getShallow("fontSize") || 12) + "px",
    _n.fontFamily || Cn && Cn.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(_n, nr, Cn, Bn) {
  if (_n) {
    var In = labelInner(_n);
    In.prevValue = In.value, In.value = Cn;
    var Dn = nr.normal;
    In.valueAnimation = Dn.get("valueAnimation"), In.valueAnimation && (In.precision = Dn.get("precision"), In.defaultInterpolatedText = Bn, In.statesModels = nr);
  }
}
function animateLabelValue(_n, nr, Cn, Bn, In) {
  var Dn = labelInner(_n);
  if (!Dn.valueAnimation || Dn.prevValue === Dn.value)
    return;
  var Ln = Dn.defaultInterpolatedText, $n = retrieve2(Dn.interpolatedValue, Dn.prevValue), Nn = Dn.value;
  function Rn(Fn) {
    var Pn = interpolateRawValues(Cn, Dn.precision, $n, Nn, Fn);
    Dn.interpolatedValue = Fn === 1 ? null : Pn;
    var Un = getLabelText({
      labelDataIndex: nr,
      labelFetcher: In,
      defaultText: Ln ? Ln(Pn) : Pn + ""
    }, Dn.statesModels, Pn);
    setLabelText(_n, Un);
  }
  _n.percent = 0, (Dn.prevValue == null ? initProps : updateProps$1)(_n, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, Bn, nr, null, Rn);
}
var PATH_COLOR = ["textStyle", "color"], textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], tmpText = new ZRText$1(), TextStyleMixin = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.getTextColor = function(nr) {
      var Cn = this.ecModel;
      return this.getShallow("color") || (!nr && Cn ? Cn.get(PATH_COLOR) : null);
    }, _n.prototype.getFont = function() {
      return getFont({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, _n.prototype.getTextRect = function(nr) {
      for (var Cn = {
        text: nr,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, Bn = 0; Bn < textStyleParams.length; Bn++)
        Cn[textStyleParams[Bn]] = this.getShallow(textStyleParams[Bn]);
      return tmpText.useStyle(Cn), tmpText.update(), tmpText.getBoundingRect();
    }, _n;
  }()
);
const TextStyleMixin$1 = TextStyleMixin;
var LINE_STYLE_KEY_MAP = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP), LineStyleMixin = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.getLineStyle = function(nr) {
      return getLineStyle(this, nr);
    }, _n;
  }()
), ITEM_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP), ItemStyleMixin = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.getItemStyle = function(nr, Cn) {
      return getItemStyle(this, nr, Cn);
    }, _n;
  }()
), Model = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.parentModel = Cn, this.ecModel = Bn, this.option = nr;
    }
    return _n.prototype.init = function(nr, Cn, Bn) {
    }, _n.prototype.mergeOption = function(nr, Cn) {
      merge$1(this.option, nr, !0);
    }, _n.prototype.get = function(nr, Cn) {
      return nr == null ? this.option : this._doGet(this.parsePath(nr), !Cn && this.parentModel);
    }, _n.prototype.getShallow = function(nr, Cn) {
      var Bn = this.option, In = Bn == null ? Bn : Bn[nr];
      if (In == null && !Cn) {
        var Dn = this.parentModel;
        Dn && (In = Dn.getShallow(nr));
      }
      return In;
    }, _n.prototype.getModel = function(nr, Cn) {
      var Bn = nr != null, In = Bn ? this.parsePath(nr) : null, Dn = Bn ? this._doGet(In) : this.option;
      return Cn = Cn || this.parentModel && this.parentModel.getModel(this.resolveParentPath(In)), new _n(Dn, Cn, this.ecModel);
    }, _n.prototype.isEmpty = function() {
      return this.option == null;
    }, _n.prototype.restoreData = function() {
    }, _n.prototype.clone = function() {
      var nr = this.constructor;
      return new nr(clone$4(this.option));
    }, _n.prototype.parsePath = function(nr) {
      return typeof nr == "string" ? nr.split(".") : nr;
    }, _n.prototype.resolveParentPath = function(nr) {
      return nr;
    }, _n.prototype.isAnimationEnabled = function() {
      if (!env$1.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, _n.prototype._doGet = function(nr, Cn) {
      var Bn = this.option;
      if (!nr)
        return Bn;
      for (var In = 0; In < nr.length && !(nr[In] && (Bn = Bn && typeof Bn == "object" ? Bn[nr[In]] : null, Bn == null)); In++)
        ;
      return Bn == null && Cn && (Bn = Cn._doGet(this.resolveParentPath(nr), Cn.parentModel)), Bn;
    }, _n;
  }()
);
enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, TextStyleMixin$1);
const Model$1 = Model;
var base = Math.round(Math.random() * 10);
function getUID(_n) {
  return [_n || "", base++].join("_");
}
function enableSubTypeDefaulter(_n) {
  var nr = {};
  _n.registerSubTypeDefaulter = function(Cn, Bn) {
    var In = parseClassType(Cn);
    nr[In.main] = Bn;
  }, _n.determineSubType = function(Cn, Bn) {
    var In = Bn.type;
    if (!In) {
      var Dn = parseClassType(Cn).main;
      _n.hasSubTypes(Cn) && nr[Dn] && (In = nr[Dn](Bn));
    }
    return In;
  };
}
function enableTopologicalTravel(_n, nr) {
  _n.topologicalTravel = function(Dn, Ln, $n, Nn) {
    if (!Dn.length)
      return;
    var Rn = Cn(Ln), Fn = Rn.graph, Pn = Rn.noEntryList, Un = {};
    for (each$f(Dn, function(Xn) {
      Un[Xn] = !0;
    }); Pn.length; ) {
      var Hn = Pn.pop(), zn = Fn[Hn], Gn = !!Un[Hn];
      Gn && ($n.call(Nn, Hn, zn.originalDeps.slice()), delete Un[Hn]), each$f(zn.successor, Gn ? Wn : Yn);
    }
    each$f(Un, function() {
      var Xn = "";
      throw process.env.NODE_ENV !== "production" && (Xn = makePrintable("Circular dependency may exists: ", Un, Dn, Ln)), new Error(Xn);
    });
    function Yn(Xn) {
      Fn[Xn].entryCount--, Fn[Xn].entryCount === 0 && Pn.push(Xn);
    }
    function Wn(Xn) {
      Un[Xn] = !0, Yn(Xn);
    }
  };
  function Cn(Dn) {
    var Ln = {}, $n = [];
    return each$f(Dn, function(Nn) {
      var Rn = Bn(Ln, Nn), Fn = Rn.originalDeps = nr(Nn), Pn = In(Fn, Dn);
      Rn.entryCount = Pn.length, Rn.entryCount === 0 && $n.push(Nn), each$f(Pn, function(Un) {
        indexOf(Rn.predecessor, Un) < 0 && Rn.predecessor.push(Un);
        var Hn = Bn(Ln, Un);
        indexOf(Hn.successor, Un) < 0 && Hn.successor.push(Nn);
      });
    }), {
      graph: Ln,
      noEntryList: $n
    };
  }
  function Bn(Dn, Ln) {
    return Dn[Ln] || (Dn[Ln] = {
      predecessor: [],
      successor: []
    }), Dn[Ln];
  }
  function In(Dn, Ln) {
    var $n = [];
    return each$f(Dn, function(Nn) {
      indexOf(Ln, Nn) >= 0 && $n.push(Nn);
    }), $n;
  }
}
function inheritDefaultOption(_n, nr) {
  return merge$1(merge$1({}, _n, !0), nr, !0);
}
const langEN = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, langZH = {
  time: {
    month: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    monthAbbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
    dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    dayOfWeekAbbr: ["日", "一", "二", "三", "四", "五", "六"]
  },
  legend: {
    selector: {
      all: "全选",
      inverse: "反选"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "矩形选择",
        polygon: "圈选",
        lineX: "横向选择",
        lineY: "纵向选择",
        keep: "保持选择",
        clear: "清除选择"
      }
    },
    dataView: {
      title: "数据视图",
      lang: ["数据视图", "关闭", "刷新"]
    },
    dataZoom: {
      title: {
        zoom: "区域缩放",
        back: "区域缩放还原"
      }
    },
    magicType: {
      title: {
        line: "切换为折线图",
        bar: "切换为柱状图",
        stack: "切换为堆叠",
        tiled: "切换为平铺"
      }
    },
    restore: {
      title: "还原"
    },
    saveAsImage: {
      title: "保存为图片",
      lang: ["右键另存为图片"]
    }
  },
  series: {
    typeNames: {
      pie: "饼图",
      bar: "柱状图",
      line: "折线图",
      scatter: "散点图",
      effectScatter: "涟漪散点图",
      radar: "雷达图",
      tree: "树图",
      treemap: "矩形树图",
      boxplot: "箱型图",
      candlestick: "K线图",
      k: "K线图",
      heatmap: "热力图",
      map: "地图",
      parallel: "平行坐标图",
      lines: "线图",
      graph: "关系图",
      sankey: "桑基图",
      funnel: "漏斗图",
      gauge: "仪表盘图",
      pictorialBar: "象形柱图",
      themeRiver: "主题河流图",
      sunburst: "旭日图",
      custom: "自定义图表",
      chart: "图表"
    }
  },
  aria: {
    general: {
      withTitle: "这是一个关于“{title}”的图表。",
      withoutTitle: "这是一个图表，"
    },
    series: {
      single: {
        prefix: "",
        withName: "图表类型是{seriesType}，表示{seriesName}。",
        withoutName: "图表类型是{seriesType}。"
      },
      multiple: {
        prefix: "它由{seriesCount}个图表系列组成。",
        withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
        withoutName: "第{seriesId}个系列是一个{seriesType}，",
        separator: {
          middle: "；",
          end: "。"
        }
      }
    },
    data: {
      allData: "其数据是——",
      partialData: "其中，前{displayCnt}项是——",
      withName: "{name}的数据是{value}",
      withoutName: "{value}",
      separator: {
        middle: "，",
        end: ""
      }
    }
  }
};
var LOCALE_ZH = "ZH", LOCALE_EN = "EN", DEFAULT_LOCALE = LOCALE_EN, localeStorage = {}, localeModels = {}, SYSTEM_LANG = env$1.domSupported ? function() {
  var _n = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase()
  );
  return _n.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}() : DEFAULT_LOCALE;
function registerLocale(_n, nr) {
  _n = _n.toUpperCase(), localeModels[_n] = new Model$1(nr), localeStorage[_n] = nr;
}
function createLocaleObject(_n) {
  if (isString$1(_n)) {
    var nr = localeStorage[_n.toUpperCase()] || {};
    return _n === LOCALE_ZH || _n === LOCALE_EN ? clone$4(nr) : merge$1(clone$4(nr), clone$4(localeStorage[DEFAULT_LOCALE]), !1);
  } else
    return merge$1(clone$4(_n), clone$4(localeStorage[DEFAULT_LOCALE]), !1);
}
function getLocaleModel(_n) {
  return localeModels[_n];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN);
registerLocale(LOCALE_ZH, langZH);
var ONE_SECOND = 1e3, ONE_MINUTE = ONE_SECOND * 60, ONE_HOUR = ONE_MINUTE * 60, ONE_DAY = ONE_HOUR * 24, ONE_YEAR = ONE_DAY * 365, defaultLeveledFormatter = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, fullDayFormatter = "{yyyy}-{MM}-{dd}", fullLeveledFormatter = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: fullDayFormatter,
  hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
  minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
  second: fullDayFormatter + " " + defaultLeveledFormatter.second,
  millisecond: defaultLeveledFormatter.none
}, primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"], timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function pad(_n, nr) {
  return _n += "", "0000".substr(0, nr - _n.length) + _n;
}
function getPrimaryTimeUnit(_n) {
  switch (_n) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return _n;
  }
}
function isPrimaryTimeUnit(_n) {
  return _n === getPrimaryTimeUnit(_n);
}
function getDefaultFormatPrecisionOfInterval(_n) {
  switch (_n) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function format$1(_n, nr, Cn, Bn) {
  var In = parseDate(_n), Dn = In[fullYearGetterName(Cn)](), Ln = In[monthGetterName(Cn)]() + 1, $n = Math.floor((Ln - 1) / 3) + 1, Nn = In[dateGetterName(Cn)](), Rn = In["get" + (Cn ? "UTC" : "") + "Day"](), Fn = In[hoursGetterName(Cn)](), Pn = (Fn - 1) % 12 + 1, Un = In[minutesGetterName(Cn)](), Hn = In[secondsGetterName(Cn)](), zn = In[millisecondsGetterName(Cn)](), Gn = Fn >= 12 ? "pm" : "am", Yn = Gn.toUpperCase(), Wn = Bn instanceof Model$1 ? Bn : getLocaleModel(Bn || SYSTEM_LANG) || getDefaultLocaleModel(), Xn = Wn.getModel("time"), ea = Xn.get("month"), ta = Xn.get("monthAbbr"), na = Xn.get("dayOfWeek"), ra = Xn.get("dayOfWeekAbbr");
  return (nr || "").replace(/{a}/g, Gn + "").replace(/{A}/g, Yn + "").replace(/{yyyy}/g, Dn + "").replace(/{yy}/g, pad(Dn % 100 + "", 2)).replace(/{Q}/g, $n + "").replace(/{MMMM}/g, ea[Ln - 1]).replace(/{MMM}/g, ta[Ln - 1]).replace(/{MM}/g, pad(Ln, 2)).replace(/{M}/g, Ln + "").replace(/{dd}/g, pad(Nn, 2)).replace(/{d}/g, Nn + "").replace(/{eeee}/g, na[Rn]).replace(/{ee}/g, ra[Rn]).replace(/{e}/g, Rn + "").replace(/{HH}/g, pad(Fn, 2)).replace(/{H}/g, Fn + "").replace(/{hh}/g, pad(Pn + "", 2)).replace(/{h}/g, Pn + "").replace(/{mm}/g, pad(Un, 2)).replace(/{m}/g, Un + "").replace(/{ss}/g, pad(Hn, 2)).replace(/{s}/g, Hn + "").replace(/{SSS}/g, pad(zn, 3)).replace(/{S}/g, zn + "");
}
function leveledFormat(_n, nr, Cn, Bn, In) {
  var Dn = null;
  if (isString$1(Cn))
    Dn = Cn;
  else if (isFunction$1(Cn))
    Dn = Cn(_n.value, nr, {
      level: _n.level
    });
  else {
    var Ln = extend({}, defaultLeveledFormatter);
    if (_n.level > 0)
      for (var $n = 0; $n < primaryTimeUnits.length; ++$n)
        Ln[primaryTimeUnits[$n]] = "{primary|" + Ln[primaryTimeUnits[$n]] + "}";
    var Nn = Cn ? Cn.inherit === !1 ? Cn : defaults(Cn, Ln) : Ln, Rn = getUnitFromValue(_n.value, In);
    if (Nn[Rn])
      Dn = Nn[Rn];
    else if (Nn.inherit) {
      for (var Fn = timeUnits.indexOf(Rn), $n = Fn - 1; $n >= 0; --$n)
        if (Nn[Rn]) {
          Dn = Nn[Rn];
          break;
        }
      Dn = Dn || Ln.none;
    }
    if (isArray$4(Dn)) {
      var Pn = _n.level == null ? 0 : _n.level >= 0 ? _n.level : Dn.length + _n.level;
      Pn = Math.min(Pn, Dn.length - 1), Dn = Dn[Pn];
    }
  }
  return format$1(new Date(_n.value), Dn, In, Bn);
}
function getUnitFromValue(_n, nr) {
  var Cn = parseDate(_n), Bn = Cn[monthGetterName(nr)]() + 1, In = Cn[dateGetterName(nr)](), Dn = Cn[hoursGetterName(nr)](), Ln = Cn[minutesGetterName(nr)](), $n = Cn[secondsGetterName(nr)](), Nn = Cn[millisecondsGetterName(nr)](), Rn = Nn === 0, Fn = Rn && $n === 0, Pn = Fn && Ln === 0, Un = Pn && Dn === 0, Hn = Un && In === 1, zn = Hn && Bn === 1;
  return zn ? "year" : Hn ? "month" : Un ? "day" : Pn ? "hour" : Fn ? "minute" : Rn ? "second" : "millisecond";
}
function getUnitValue(_n, nr, Cn) {
  var Bn = isNumber(_n) ? parseDate(_n) : _n;
  switch (nr = nr || getUnitFromValue(_n, Cn), nr) {
    case "year":
      return Bn[fullYearGetterName(Cn)]();
    case "half-year":
      return Bn[monthGetterName(Cn)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((Bn[monthGetterName(Cn)]() + 1) / 4);
    case "month":
      return Bn[monthGetterName(Cn)]();
    case "day":
      return Bn[dateGetterName(Cn)]();
    case "half-day":
      return Bn[hoursGetterName(Cn)]() / 24;
    case "hour":
      return Bn[hoursGetterName(Cn)]();
    case "minute":
      return Bn[minutesGetterName(Cn)]();
    case "second":
      return Bn[secondsGetterName(Cn)]();
    case "millisecond":
      return Bn[millisecondsGetterName(Cn)]();
  }
}
function fullYearGetterName(_n) {
  return _n ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(_n) {
  return _n ? "getUTCMonth" : "getMonth";
}
function dateGetterName(_n) {
  return _n ? "getUTCDate" : "getDate";
}
function hoursGetterName(_n) {
  return _n ? "getUTCHours" : "getHours";
}
function minutesGetterName(_n) {
  return _n ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(_n) {
  return _n ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(_n) {
  return _n ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(_n) {
  return _n ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(_n) {
  return _n ? "setUTCMonth" : "setMonth";
}
function dateSetterName(_n) {
  return _n ? "setUTCDate" : "setDate";
}
function hoursSetterName(_n) {
  return _n ? "setUTCHours" : "setHours";
}
function minutesSetterName(_n) {
  return _n ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(_n) {
  return _n ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(_n) {
  return _n ? "setUTCMilliseconds" : "setMilliseconds";
}
function getTextRect(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  var Nn = new ZRText$1({
    style: {
      text: _n,
      font: nr,
      align: Cn,
      verticalAlign: Bn,
      padding: In,
      rich: Dn,
      overflow: Ln ? "truncate" : null,
      lineHeight: $n
    }
  });
  return Nn.getBoundingRect();
}
function addCommas(_n) {
  if (!isNumeric(_n))
    return isString$1(_n) ? _n : "-";
  var nr = (_n + "").split(".");
  return nr[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (nr.length > 1 ? "." + nr[1] : "");
}
function toCamelCase(_n, nr) {
  return _n = (_n || "").toLowerCase().replace(/-(.)/g, function(Cn, Bn) {
    return Bn.toUpperCase();
  }), nr && _n && (_n = _n.charAt(0).toUpperCase() + _n.slice(1)), _n;
}
var normalizeCssArray = normalizeCssArray$1;
function makeValueReadable(_n, nr, Cn) {
  var Bn = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function In(Fn) {
    return Fn && trim$1(Fn) ? Fn : "-";
  }
  function Dn(Fn) {
    return !!(Fn != null && !isNaN(Fn) && isFinite(Fn));
  }
  var Ln = nr === "time", $n = _n instanceof Date;
  if (Ln || $n) {
    var Nn = Ln ? parseDate(_n) : _n;
    if (isNaN(+Nn)) {
      if ($n)
        return "-";
    } else
      return format$1(Nn, Bn, Cn);
  }
  if (nr === "ordinal")
    return isStringSafe(_n) ? In(_n) : isNumber(_n) && Dn(_n) ? _n + "" : "-";
  var Rn = numericToNumber(_n);
  return Dn(Rn) ? addCommas(Rn) : isStringSafe(_n) ? In(_n) : typeof _n == "boolean" ? _n + "" : "-";
}
var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"], wrapVar = function(_n, nr) {
  return "{" + _n + (nr ?? "") + "}";
};
function formatTpl(_n, nr, Cn) {
  isArray$4(nr) || (nr = [nr]);
  var Bn = nr.length;
  if (!Bn)
    return "";
  for (var In = nr[0].$vars || [], Dn = 0; Dn < In.length; Dn++) {
    var Ln = TPL_VAR_ALIAS[Dn];
    _n = _n.replace(wrapVar(Ln), wrapVar(Ln, 0));
  }
  for (var $n = 0; $n < Bn; $n++)
    for (var Nn = 0; Nn < In.length; Nn++) {
      var Rn = nr[$n][In[Nn]];
      _n = _n.replace(wrapVar(TPL_VAR_ALIAS[Nn], $n), Cn ? encodeHTML(Rn) : Rn);
    }
  return _n;
}
function formatTplSimple(_n, nr, Cn) {
  return each$f(nr, function(Bn, In) {
    _n = _n.replace("{" + In + "}", Cn ? encodeHTML(Bn) : Bn);
  }), _n;
}
function getTooltipMarker(_n, nr) {
  var Cn = isString$1(_n) ? {
    color: _n,
    extraCssText: nr
  } : _n || {}, Bn = Cn.color, In = Cn.type;
  nr = Cn.extraCssText;
  var Dn = Cn.renderMode || "html";
  if (!Bn)
    return "";
  if (Dn === "html")
    return In === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(Bn) + ";" + (nr || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(Bn) + ";" + (nr || "") + '"></span>';
  var Ln = Cn.markerId || "markerX";
  return {
    renderMode: Dn,
    content: "{" + Ln + "|}  ",
    style: In === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: Bn
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: Bn
    }
  };
}
function formatTime(_n, nr, Cn) {
  process.env.NODE_ENV !== "production" && deprecateReplaceLog("echarts.format.formatTime", "echarts.time.format"), (_n === "week" || _n === "month" || _n === "quarter" || _n === "half-year" || _n === "year") && (_n = `MM-dd
yyyy`);
  var Bn = parseDate(nr), In = Cn ? "getUTC" : "get", Dn = Bn[In + "FullYear"](), Ln = Bn[In + "Month"]() + 1, $n = Bn[In + "Date"](), Nn = Bn[In + "Hours"](), Rn = Bn[In + "Minutes"](), Fn = Bn[In + "Seconds"](), Pn = Bn[In + "Milliseconds"]();
  return _n = _n.replace("MM", pad(Ln, 2)).replace("M", Ln).replace("yyyy", Dn).replace("yy", pad(Dn % 100 + "", 2)).replace("dd", pad($n, 2)).replace("d", $n).replace("hh", pad(Nn, 2)).replace("h", Nn).replace("mm", pad(Rn, 2)).replace("m", Rn).replace("ss", pad(Fn, 2)).replace("s", Fn).replace("SSS", pad(Pn, 3)), _n;
}
function capitalFirst(_n) {
  return _n && _n.charAt(0).toUpperCase() + _n.substr(1);
}
function convertToColorString(_n, nr) {
  return nr = nr || "transparent", isString$1(_n) ? _n : isObject$6(_n) && _n.colorStops && (_n.colorStops[0] || {}).color || nr;
}
function windowOpen(_n, nr) {
  if (nr === "_blank" || nr === "blank") {
    var Cn = window.open();
    Cn.opener = null, Cn.location.href = _n;
  } else
    window.open(_n, nr);
}
var each$e = each$f, LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"], HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
function boxLayout(_n, nr, Cn, Bn, In) {
  var Dn = 0, Ln = 0;
  Bn == null && (Bn = 1 / 0), In == null && (In = 1 / 0);
  var $n = 0;
  nr.eachChild(function(Nn, Rn) {
    var Fn = Nn.getBoundingRect(), Pn = nr.childAt(Rn + 1), Un = Pn && Pn.getBoundingRect(), Hn, zn;
    if (_n === "horizontal") {
      var Gn = Fn.width + (Un ? -Un.x + Fn.x : 0);
      Hn = Dn + Gn, Hn > Bn || Nn.newline ? (Dn = 0, Hn = Gn, Ln += $n + Cn, $n = Fn.height) : $n = Math.max($n, Fn.height);
    } else {
      var Yn = Fn.height + (Un ? -Un.y + Fn.y : 0);
      zn = Ln + Yn, zn > In || Nn.newline ? (Dn += $n + Cn, Ln = 0, zn = Yn, $n = Fn.width) : $n = Math.max($n, Fn.width);
    }
    Nn.newline || (Nn.x = Dn, Nn.y = Ln, Nn.markRedraw(), _n === "horizontal" ? Dn = Hn + Cn : Ln = zn + Cn);
  });
}
var box = boxLayout;
curry$1(boxLayout, "vertical");
curry$1(boxLayout, "horizontal");
function getAvailableSize(_n, nr, Cn) {
  var Bn = nr.width, In = nr.height, Dn = parsePercent(_n.left, Bn), Ln = parsePercent(_n.top, In), $n = parsePercent(_n.right, Bn), Nn = parsePercent(_n.bottom, In);
  return (isNaN(Dn) || isNaN(parseFloat(_n.left))) && (Dn = 0), (isNaN($n) || isNaN(parseFloat(_n.right))) && ($n = Bn), (isNaN(Ln) || isNaN(parseFloat(_n.top))) && (Ln = 0), (isNaN(Nn) || isNaN(parseFloat(_n.bottom))) && (Nn = In), Cn = normalizeCssArray(Cn || 0), {
    width: Math.max($n - Dn - Cn[1] - Cn[3], 0),
    height: Math.max(Nn - Ln - Cn[0] - Cn[2], 0)
  };
}
function getLayoutRect$1(_n, nr, Cn) {
  Cn = normalizeCssArray(Cn || 0);
  var Bn = nr.width, In = nr.height, Dn = parsePercent(_n.left, Bn), Ln = parsePercent(_n.top, In), $n = parsePercent(_n.right, Bn), Nn = parsePercent(_n.bottom, In), Rn = parsePercent(_n.width, Bn), Fn = parsePercent(_n.height, In), Pn = Cn[2] + Cn[0], Un = Cn[1] + Cn[3], Hn = _n.aspect;
  switch (isNaN(Rn) && (Rn = Bn - $n - Un - Dn), isNaN(Fn) && (Fn = In - Nn - Pn - Ln), Hn != null && (isNaN(Rn) && isNaN(Fn) && (Hn > Bn / In ? Rn = Bn * 0.8 : Fn = In * 0.8), isNaN(Rn) && (Rn = Hn * Fn), isNaN(Fn) && (Fn = Rn / Hn)), isNaN(Dn) && (Dn = Bn - $n - Rn - Un), isNaN(Ln) && (Ln = In - Nn - Fn - Pn), _n.left || _n.right) {
    case "center":
      Dn = Bn / 2 - Rn / 2 - Cn[3];
      break;
    case "right":
      Dn = Bn - Rn - Un;
      break;
  }
  switch (_n.top || _n.bottom) {
    case "middle":
    case "center":
      Ln = In / 2 - Fn / 2 - Cn[0];
      break;
    case "bottom":
      Ln = In - Fn - Pn;
      break;
  }
  Dn = Dn || 0, Ln = Ln || 0, isNaN(Rn) && (Rn = Bn - Un - Dn - ($n || 0)), isNaN(Fn) && (Fn = In - Pn - Ln - (Nn || 0));
  var zn = new BoundingRect$1(Dn + Cn[3], Ln + Cn[0], Rn, Fn);
  return zn.margin = Cn, zn;
}
function positionElement(_n, nr, Cn, Bn, In, Dn) {
  var Ln = !In || !In.hv || In.hv[0], $n = !In || !In.hv || In.hv[1], Nn = In && In.boundingMode || "all";
  if (Dn = Dn || _n, Dn.x = _n.x, Dn.y = _n.y, !Ln && !$n)
    return !1;
  var Rn;
  if (Nn === "raw")
    Rn = _n.type === "group" ? new BoundingRect$1(0, 0, +nr.width || 0, +nr.height || 0) : _n.getBoundingRect();
  else if (Rn = _n.getBoundingRect(), _n.needLocalTransform()) {
    var Fn = _n.getLocalTransform();
    Rn = Rn.clone(), Rn.applyTransform(Fn);
  }
  var Pn = getLayoutRect$1(defaults({
    width: Rn.width,
    height: Rn.height
  }, nr), Cn, Bn), Un = Ln ? Pn.x - Rn.x : 0, Hn = $n ? Pn.y - Rn.y : 0;
  return Nn === "raw" ? (Dn.x = Un, Dn.y = Hn) : (Dn.x += Un, Dn.y += Hn), Dn === _n && _n.markRedraw(), !0;
}
function sizeCalculable(_n, nr) {
  return _n[HV_NAMES[nr][0]] != null || _n[HV_NAMES[nr][1]] != null && _n[HV_NAMES[nr][2]] != null;
}
function fetchLayoutMode(_n) {
  var nr = _n.layoutMode || _n.constructor.layoutMode;
  return isObject$6(nr) ? nr : nr ? {
    type: nr
  } : null;
}
function mergeLayoutParam(_n, nr, Cn) {
  var Bn = Cn && Cn.ignoreSize;
  !isArray$4(Bn) && (Bn = [Bn, Bn]);
  var In = Ln(HV_NAMES[0], 0), Dn = Ln(HV_NAMES[1], 1);
  Rn(HV_NAMES[0], _n, In), Rn(HV_NAMES[1], _n, Dn);
  function Ln(Fn, Pn) {
    var Un = {}, Hn = 0, zn = {}, Gn = 0, Yn = 2;
    if (each$e(Fn, function(ea) {
      zn[ea] = _n[ea];
    }), each$e(Fn, function(ea) {
      $n(nr, ea) && (Un[ea] = zn[ea] = nr[ea]), Nn(Un, ea) && Hn++, Nn(zn, ea) && Gn++;
    }), Bn[Pn])
      return Nn(nr, Fn[1]) ? zn[Fn[2]] = null : Nn(nr, Fn[2]) && (zn[Fn[1]] = null), zn;
    if (Gn === Yn || !Hn)
      return zn;
    if (Hn >= Yn)
      return Un;
    for (var Wn = 0; Wn < Fn.length; Wn++) {
      var Xn = Fn[Wn];
      if (!$n(Un, Xn) && $n(_n, Xn)) {
        Un[Xn] = _n[Xn];
        break;
      }
    }
    return Un;
  }
  function $n(Fn, Pn) {
    return Fn.hasOwnProperty(Pn);
  }
  function Nn(Fn, Pn) {
    return Fn[Pn] != null && Fn[Pn] !== "auto";
  }
  function Rn(Fn, Pn, Un) {
    each$e(Fn, function(Hn) {
      Pn[Hn] = Un[Hn];
    });
  }
}
function getLayoutParams(_n) {
  return copyLayoutParams({}, _n);
}
function copyLayoutParams(_n, nr) {
  return nr && _n && each$e(LOCATION_PARAMS, function(Cn) {
    nr.hasOwnProperty(Cn) && (_n[Cn] = nr[Cn]);
  }), _n;
}
var inner$l = makeInner(), ComponentModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In) {
      var Dn = _n.call(this, Cn, Bn, In) || this;
      return Dn.uid = getUID("ec_cpt_model"), Dn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      this.mergeDefaultAndTheme(Cn, In);
    }, nr.prototype.mergeDefaultAndTheme = function(Cn, Bn) {
      var In = fetchLayoutMode(this), Dn = In ? getLayoutParams(Cn) : {}, Ln = Bn.getTheme();
      merge$1(Cn, Ln.get(this.mainType)), merge$1(Cn, this.getDefaultOption()), In && mergeLayoutParam(Cn, Dn, In);
    }, nr.prototype.mergeOption = function(Cn, Bn) {
      merge$1(this.option, Cn, !0);
      var In = fetchLayoutMode(this);
      In && mergeLayoutParam(this.option, Cn, In);
    }, nr.prototype.optionUpdated = function(Cn, Bn) {
    }, nr.prototype.getDefaultOption = function() {
      var Cn = this.constructor;
      if (!isExtendedClass(Cn))
        return Cn.defaultOption;
      var Bn = inner$l(this);
      if (!Bn.defaultOption) {
        for (var In = [], Dn = Cn; Dn; ) {
          var Ln = Dn.prototype.defaultOption;
          Ln && In.push(Ln), Dn = Dn.superClass;
        }
        for (var $n = {}, Nn = In.length - 1; Nn >= 0; Nn--)
          $n = merge$1($n, In[Nn], !0);
        Bn.defaultOption = $n;
      }
      return Bn.defaultOption;
    }, nr.prototype.getReferringComponents = function(Cn, Bn) {
      var In = Cn + "Index", Dn = Cn + "Id";
      return queryReferringComponents(this.ecModel, Cn, {
        index: this.get(In, !0),
        id: this.get(Dn, !0)
      }, Bn);
    }, nr.prototype.getBoxLayoutParams = function() {
      var Cn = this;
      return {
        left: Cn.get("left"),
        top: Cn.get("top"),
        right: Cn.get("right"),
        bottom: Cn.get("bottom"),
        width: Cn.get("width"),
        height: Cn.get("height")
      };
    }, nr.prototype.getZLevelKey = function() {
      return "";
    }, nr.prototype.setZLevel = function(Cn) {
      this.option.zlevel = Cn;
    }, nr.protoInitialize = function() {
      var Cn = nr.prototype;
      Cn.type = "component", Cn.id = "", Cn.name = "", Cn.mainType = "", Cn.subType = "", Cn.componentIndex = 0;
    }(), nr;
  }(Model$1)
);
mountExtend(ComponentModel, Model$1);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(_n) {
  var nr = [];
  return each$f(ComponentModel.getClassesByMainType(_n), function(Cn) {
    nr = nr.concat(Cn.dependencies || Cn.prototype.dependencies || []);
  }), nr = map$1(nr, function(Cn) {
    return parseClassType(Cn).main;
  }), _n !== "dataset" && indexOf(nr, "dataset") <= 0 && nr.unshift("dataset"), nr;
}
const ComponentModel$1 = ComponentModel;
var platform = "";
typeof navigator < "u" && (platform = navigator.platform || "");
var decalColor = "rgba(0, 0, 0, 0.2)";
const globalDefault = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), SOURCE_FORMAT_ORIGINAL = "original", SOURCE_FORMAT_ARRAY_ROWS = "arrayRows", SOURCE_FORMAT_OBJECT_ROWS = "objectRows", SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns", SOURCE_FORMAT_TYPED_ARRAY = "typedArray", SOURCE_FORMAT_UNKNOWN = "unknown", SERIES_LAYOUT_BY_COLUMN = "column", SERIES_LAYOUT_BY_ROW = "row", BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, innerGlobalModel = makeInner();
function resetSourceDefaulter(_n) {
  innerGlobalModel(_n).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(_n, nr, Cn) {
  var Bn = {}, In = querySeriesUpstreamDatasetModel(nr);
  if (!In || !_n)
    return Bn;
  var Dn = [], Ln = [], $n = nr.ecModel, Nn = innerGlobalModel($n).datasetMap, Rn = In.uid + "_" + Cn.seriesLayoutBy, Fn, Pn;
  _n = _n.slice(), each$f(_n, function(Gn, Yn) {
    var Wn = isObject$6(Gn) ? Gn : _n[Yn] = {
      name: Gn
    };
    Wn.type === "ordinal" && Fn == null && (Fn = Yn, Pn = zn(Wn)), Bn[Wn.name] = [];
  });
  var Un = Nn.get(Rn) || Nn.set(Rn, {
    categoryWayDim: Pn,
    valueWayDim: 0
  });
  each$f(_n, function(Gn, Yn) {
    var Wn = Gn.name, Xn = zn(Gn);
    if (Fn == null) {
      var ea = Un.valueWayDim;
      Hn(Bn[Wn], ea, Xn), Hn(Ln, ea, Xn), Un.valueWayDim += Xn;
    } else if (Fn === Yn)
      Hn(Bn[Wn], 0, Xn), Hn(Dn, 0, Xn);
    else {
      var ea = Un.categoryWayDim;
      Hn(Bn[Wn], ea, Xn), Hn(Ln, ea, Xn), Un.categoryWayDim += Xn;
    }
  });
  function Hn(Gn, Yn, Wn) {
    for (var Xn = 0; Xn < Wn; Xn++)
      Gn.push(Yn + Xn);
  }
  function zn(Gn) {
    var Yn = Gn.dimsDef;
    return Yn ? Yn.length : 1;
  }
  return Dn.length && (Bn.itemName = Dn), Ln.length && (Bn.seriesName = Ln), Bn;
}
function makeSeriesEncodeForNameBased(_n, nr, Cn) {
  var Bn = {}, In = querySeriesUpstreamDatasetModel(_n);
  if (!In)
    return Bn;
  var Dn = nr.sourceFormat, Ln = nr.dimensionsDefine, $n;
  (Dn === SOURCE_FORMAT_OBJECT_ROWS || Dn === SOURCE_FORMAT_KEYED_COLUMNS) && each$f(Ln, function(Fn, Pn) {
    (isObject$6(Fn) ? Fn.name : Fn) === "name" && ($n = Pn);
  });
  var Nn = function() {
    for (var Fn = {}, Pn = {}, Un = [], Hn = 0, zn = Math.min(5, Cn); Hn < zn; Hn++) {
      var Gn = doGuessOrdinal(nr.data, Dn, nr.seriesLayoutBy, Ln, nr.startIndex, Hn);
      Un.push(Gn);
      var Yn = Gn === BE_ORDINAL.Not;
      if (Yn && Fn.v == null && Hn !== $n && (Fn.v = Hn), (Fn.n == null || Fn.n === Fn.v || !Yn && Un[Fn.n] === BE_ORDINAL.Not) && (Fn.n = Hn), Wn(Fn) && Un[Fn.n] !== BE_ORDINAL.Not)
        return Fn;
      Yn || (Gn === BE_ORDINAL.Might && Pn.v == null && Hn !== $n && (Pn.v = Hn), (Pn.n == null || Pn.n === Pn.v) && (Pn.n = Hn));
    }
    function Wn(Xn) {
      return Xn.v != null && Xn.n != null;
    }
    return Wn(Fn) ? Fn : Wn(Pn) ? Pn : null;
  }();
  if (Nn) {
    Bn.value = [Nn.v];
    var Rn = $n ?? Nn.n;
    Bn.itemName = [Rn], Bn.seriesName = [Rn];
  }
  return Bn;
}
function querySeriesUpstreamDatasetModel(_n) {
  var nr = _n.get("data", !0);
  if (!nr)
    return queryReferringComponents(_n.ecModel, "dataset", {
      index: _n.get("datasetIndex", !0),
      id: _n.get("datasetId", !0)
    }, SINGLE_REFERRING).models[0];
}
function queryDatasetUpstreamDatasetModels(_n) {
  return !_n.get("transform", !0) && !_n.get("fromTransformResult", !0) ? [] : queryReferringComponents(_n.ecModel, "dataset", {
    index: _n.get("fromDatasetIndex", !0),
    id: _n.get("fromDatasetId", !0)
  }, SINGLE_REFERRING).models;
}
function guessOrdinal(_n, nr) {
  return doGuessOrdinal(_n.data, _n.sourceFormat, _n.seriesLayoutBy, _n.dimensionsDefine, _n.startIndex, nr);
}
function doGuessOrdinal(_n, nr, Cn, Bn, In, Dn) {
  var Ln, $n = 5;
  if (isTypedArray$2(_n))
    return BE_ORDINAL.Not;
  var Nn, Rn;
  if (Bn) {
    var Fn = Bn[Dn];
    isObject$6(Fn) ? (Nn = Fn.name, Rn = Fn.type) : isString$1(Fn) && (Nn = Fn);
  }
  if (Rn != null)
    return Rn === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  if (nr === SOURCE_FORMAT_ARRAY_ROWS) {
    var Pn = _n;
    if (Cn === SERIES_LAYOUT_BY_ROW) {
      for (var Un = Pn[Dn], Hn = 0; Hn < (Un || []).length && Hn < $n; Hn++)
        if ((Ln = ta(Un[In + Hn])) != null)
          return Ln;
    } else
      for (var Hn = 0; Hn < Pn.length && Hn < $n; Hn++) {
        var zn = Pn[In + Hn];
        if (zn && (Ln = ta(zn[Dn])) != null)
          return Ln;
      }
  } else if (nr === SOURCE_FORMAT_OBJECT_ROWS) {
    var Gn = _n;
    if (!Nn)
      return BE_ORDINAL.Not;
    for (var Hn = 0; Hn < Gn.length && Hn < $n; Hn++) {
      var Yn = Gn[Hn];
      if (Yn && (Ln = ta(Yn[Nn])) != null)
        return Ln;
    }
  } else if (nr === SOURCE_FORMAT_KEYED_COLUMNS) {
    var Wn = _n;
    if (!Nn)
      return BE_ORDINAL.Not;
    var Un = Wn[Nn];
    if (!Un || isTypedArray$2(Un))
      return BE_ORDINAL.Not;
    for (var Hn = 0; Hn < Un.length && Hn < $n; Hn++)
      if ((Ln = ta(Un[Hn])) != null)
        return Ln;
  } else if (nr === SOURCE_FORMAT_ORIGINAL)
    for (var Xn = _n, Hn = 0; Hn < Xn.length && Hn < $n; Hn++) {
      var Yn = Xn[Hn], ea = getDataItemValue(Yn);
      if (!isArray$4(ea))
        return BE_ORDINAL.Not;
      if ((Ln = ta(ea[Dn])) != null)
        return Ln;
    }
  function ta(na) {
    var ra = isString$1(na);
    if (na != null && Number.isFinite(Number(na)) && na !== "")
      return ra ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    if (ra && na !== "-")
      return BE_ORDINAL.Must;
  }
  return BE_ORDINAL.Not;
}
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(_n, nr) {
  assert(internalOptionCreatorMap.get(_n) == null && nr), internalOptionCreatorMap.set(_n, nr);
}
function concatInternalOptions(_n, nr, Cn) {
  var Bn = internalOptionCreatorMap.get(nr);
  if (!Bn)
    return Cn;
  var In = Bn(_n);
  if (!In)
    return Cn;
  if (process.env.NODE_ENV !== "production")
    for (var Dn = 0; Dn < In.length; Dn++)
      assert(isComponentIdInternal(In[Dn]));
  return Cn.concat(In);
}
var innerColor = makeInner(), innerDecal = makeInner(), PaletteMixin = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.getColorFromPalette = function(nr, Cn, Bn) {
      var In = normalizeToArray(this.get("color", !0)), Dn = this.get("colorLayer", !0);
      return getFromPalette(this, innerColor, In, Dn, nr, Cn, Bn);
    }, _n.prototype.clearColorPalette = function() {
      clearPalette(this, innerColor);
    }, _n;
  }()
);
function getDecalFromPalette(_n, nr, Cn, Bn) {
  var In = normalizeToArray(_n.get(["aria", "decal", "decals"]));
  return getFromPalette(_n, innerDecal, In, null, nr, Cn, Bn);
}
function getNearestPalette(_n, nr) {
  for (var Cn = _n.length, Bn = 0; Bn < Cn; Bn++)
    if (_n[Bn].length > nr)
      return _n[Bn];
  return _n[Cn - 1];
}
function getFromPalette(_n, nr, Cn, Bn, In, Dn, Ln) {
  Dn = Dn || _n;
  var $n = nr(Dn), Nn = $n.paletteIdx || 0, Rn = $n.paletteNameMap = $n.paletteNameMap || {};
  if (Rn.hasOwnProperty(In))
    return Rn[In];
  var Fn = Ln == null || !Bn ? Cn : getNearestPalette(Bn, Ln);
  if (Fn = Fn || Cn, !(!Fn || !Fn.length)) {
    var Pn = Fn[Nn];
    return In && (Rn[In] = Pn), $n.paletteIdx = (Nn + 1) % Fn.length, Pn;
  }
}
function clearPalette(_n, nr) {
  nr(_n).paletteIdx = 0, nr(_n).paletteNameMap = {};
}
var reCreateSeriesIndices, assertSeriesInitialized, initBase, OPTION_INNER_KEY = "\0_ec_inner", OPTION_INNER_VALUE = 1, BUITIN_COMPONENTS_MAP = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, BUILTIN_CHARTS_MAP = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, componetsMissingLogPrinted = {};
function checkMissingComponents(_n) {
  each$f(_n, function(nr, Cn) {
    if (!ComponentModel$1.hasClass(Cn)) {
      var Bn = BUITIN_COMPONENTS_MAP[Cn];
      Bn && !componetsMissingLogPrinted[Bn] && (error("Component " + Cn + ` is used but not imported.
import { ` + Bn + ` } from 'echarts/components';
echarts.use([` + Bn + "]);"), componetsMissingLogPrinted[Bn] = !0);
    }
  });
}
var GlobalModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.init = function(Cn, Bn, In, Dn, Ln, $n) {
      Dn = Dn || {}, this.option = null, this._theme = new Model$1(Dn), this._locale = new Model$1(Ln), this._optionManager = $n;
    }, nr.prototype.setOption = function(Cn, Bn, In) {
      process.env.NODE_ENV !== "production" && (assert(Cn != null, "option is null/undefined"), assert(Cn[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()"));
      var Dn = normalizeSetOptionInput(Bn);
      this._optionManager.setOption(Cn, In, Dn), this._resetOption(null, Dn);
    }, nr.prototype.resetOption = function(Cn, Bn) {
      return this._resetOption(Cn, normalizeSetOptionInput(Bn));
    }, nr.prototype._resetOption = function(Cn, Bn) {
      var In = !1, Dn = this._optionManager;
      if (!Cn || Cn === "recreate") {
        var Ln = Dn.mountOption(Cn === "recreate");
        process.env.NODE_ENV !== "production" && checkMissingComponents(Ln), !this.option || Cn === "recreate" ? initBase(this, Ln) : (this.restoreData(), this._mergeOption(Ln, Bn)), In = !0;
      }
      if ((Cn === "timeline" || Cn === "media") && this.restoreData(), !Cn || Cn === "recreate" || Cn === "timeline") {
        var $n = Dn.getTimelineOption(this);
        $n && (In = !0, this._mergeOption($n, Bn));
      }
      if (!Cn || Cn === "recreate" || Cn === "media") {
        var Nn = Dn.getMediaOption(this);
        Nn.length && each$f(Nn, function(Rn) {
          In = !0, this._mergeOption(Rn, Bn);
        }, this);
      }
      return In;
    }, nr.prototype.mergeOption = function(Cn) {
      this._mergeOption(Cn, null);
    }, nr.prototype._mergeOption = function(Cn, Bn) {
      var In = this.option, Dn = this._componentsMap, Ln = this._componentsCount, $n = [], Nn = createHashMap(), Rn = Bn && Bn.replaceMergeMainTypeMap;
      resetSourceDefaulter(this), each$f(Cn, function(Pn, Un) {
        Pn != null && (ComponentModel$1.hasClass(Un) ? Un && ($n.push(Un), Nn.set(Un, !0)) : In[Un] = In[Un] == null ? clone$4(Pn) : merge$1(In[Un], Pn, !0));
      }), Rn && Rn.each(function(Pn, Un) {
        ComponentModel$1.hasClass(Un) && !Nn.get(Un) && ($n.push(Un), Nn.set(Un, !0));
      }), ComponentModel$1.topologicalTravel($n, ComponentModel$1.getAllClassMainTypes(), Fn, this);
      function Fn(Pn) {
        var Un = concatInternalOptions(this, Pn, normalizeToArray(Cn[Pn])), Hn = Dn.get(Pn), zn = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          Hn ? Rn && Rn.get(Pn) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), Gn = mappingToExists(Hn, Un, zn);
        setComponentTypeToKeyInfo(Gn, Pn, ComponentModel$1), In[Pn] = null, Dn.set(Pn, null), Ln.set(Pn, 0);
        var Yn = [], Wn = [], Xn = 0, ea, ta;
        each$f(Gn, function(na, ra) {
          var aa = na.existing, ia = na.newOption;
          if (!ia)
            aa && (aa.mergeOption({}, this), aa.optionUpdated({}, !1));
          else {
            var Aa = Pn === "series", sa = ComponentModel$1.getClass(
              Pn,
              na.keyInfo.subType,
              !Aa
              // Give a more detailed warn later if series don't exists
            );
            if (!sa) {
              if (process.env.NODE_ENV !== "production") {
                var oa = na.keyInfo.subType, la = BUILTIN_CHARTS_MAP[oa];
                componetsMissingLogPrinted[oa] || (componetsMissingLogPrinted[oa] = !0, error(la ? "Series " + oa + ` is used but not imported.
import { ` + la + ` } from 'echarts/charts';
echarts.use([` + la + "]);" : "Unknown series " + oa));
              }
              return;
            }
            if (Pn === "tooltip") {
              if (ea) {
                process.env.NODE_ENV !== "production" && (ta || (warn("Currently only one tooltip component is allowed."), ta = !0));
                return;
              }
              ea = !0;
            }
            if (aa && aa.constructor === sa)
              aa.name = na.keyInfo.name, aa.mergeOption(ia, this), aa.optionUpdated(ia, !1);
            else {
              var ua = extend({
                componentIndex: ra
              }, na.keyInfo);
              aa = new sa(ia, this, this, ua), extend(aa, ua), na.brandNew && (aa.__requireNewView = !0), aa.init(ia, this, this), aa.optionUpdated(null, !0);
            }
          }
          aa ? (Yn.push(aa.option), Wn.push(aa), Xn++) : (Yn.push(void 0), Wn.push(void 0));
        }, this), In[Pn] = Yn, Dn.set(Pn, Wn), Ln.set(Pn, Xn), Pn === "series" && reCreateSeriesIndices(this);
      }
      this._seriesIndices || reCreateSeriesIndices(this);
    }, nr.prototype.getOption = function() {
      var Cn = clone$4(this.option);
      return each$f(Cn, function(Bn, In) {
        if (ComponentModel$1.hasClass(In)) {
          for (var Dn = normalizeToArray(Bn), Ln = Dn.length, $n = !1, Nn = Ln - 1; Nn >= 0; Nn--)
            Dn[Nn] && !isComponentIdInternal(Dn[Nn]) ? $n = !0 : (Dn[Nn] = null, !$n && Ln--);
          Dn.length = Ln, Cn[In] = Dn;
        }
      }), delete Cn[OPTION_INNER_KEY], Cn;
    }, nr.prototype.getTheme = function() {
      return this._theme;
    }, nr.prototype.getLocaleModel = function() {
      return this._locale;
    }, nr.prototype.setUpdatePayload = function(Cn) {
      this._payload = Cn;
    }, nr.prototype.getUpdatePayload = function() {
      return this._payload;
    }, nr.prototype.getComponent = function(Cn, Bn) {
      var In = this._componentsMap.get(Cn);
      if (In) {
        var Dn = In[Bn || 0];
        if (Dn)
          return Dn;
        if (Bn == null) {
          for (var Ln = 0; Ln < In.length; Ln++)
            if (In[Ln])
              return In[Ln];
        }
      }
    }, nr.prototype.queryComponents = function(Cn) {
      var Bn = Cn.mainType;
      if (!Bn)
        return [];
      var In = Cn.index, Dn = Cn.id, Ln = Cn.name, $n = this._componentsMap.get(Bn);
      if (!$n || !$n.length)
        return [];
      var Nn;
      return In != null ? (Nn = [], each$f(normalizeToArray(In), function(Rn) {
        $n[Rn] && Nn.push($n[Rn]);
      })) : Dn != null ? Nn = queryByIdOrName("id", Dn, $n) : Ln != null ? Nn = queryByIdOrName("name", Ln, $n) : Nn = filter($n, function(Rn) {
        return !!Rn;
      }), filterBySubType(Nn, Cn);
    }, nr.prototype.findComponents = function(Cn) {
      var Bn = Cn.query, In = Cn.mainType, Dn = $n(Bn), Ln = Dn ? this.queryComponents(Dn) : filter(this._componentsMap.get(In), function(Rn) {
        return !!Rn;
      });
      return Nn(filterBySubType(Ln, Cn));
      function $n(Rn) {
        var Fn = In + "Index", Pn = In + "Id", Un = In + "Name";
        return Rn && (Rn[Fn] != null || Rn[Pn] != null || Rn[Un] != null) ? {
          mainType: In,
          // subType will be filtered finally.
          index: Rn[Fn],
          id: Rn[Pn],
          name: Rn[Un]
        } : null;
      }
      function Nn(Rn) {
        return Cn.filter ? filter(Rn, Cn.filter) : Rn;
      }
    }, nr.prototype.eachComponent = function(Cn, Bn, In) {
      var Dn = this._componentsMap;
      if (isFunction$1(Cn)) {
        var Ln = Bn, $n = Cn;
        Dn.each(function(Pn, Un) {
          for (var Hn = 0; Pn && Hn < Pn.length; Hn++) {
            var zn = Pn[Hn];
            zn && $n.call(Ln, Un, zn, zn.componentIndex);
          }
        });
      } else
        for (var Nn = isString$1(Cn) ? Dn.get(Cn) : isObject$6(Cn) ? this.findComponents(Cn) : null, Rn = 0; Nn && Rn < Nn.length; Rn++) {
          var Fn = Nn[Rn];
          Fn && Bn.call(In, Fn, Fn.componentIndex);
        }
    }, nr.prototype.getSeriesByName = function(Cn) {
      var Bn = convertOptionIdName(Cn, null);
      return filter(this._componentsMap.get("series"), function(In) {
        return !!In && Bn != null && In.name === Bn;
      });
    }, nr.prototype.getSeriesByIndex = function(Cn) {
      return this._componentsMap.get("series")[Cn];
    }, nr.prototype.getSeriesByType = function(Cn) {
      return filter(this._componentsMap.get("series"), function(Bn) {
        return !!Bn && Bn.subType === Cn;
      });
    }, nr.prototype.getSeries = function() {
      return filter(this._componentsMap.get("series"), function(Cn) {
        return !!Cn;
      });
    }, nr.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, nr.prototype.eachSeries = function(Cn, Bn) {
      assertSeriesInitialized(this), each$f(this._seriesIndices, function(In) {
        var Dn = this._componentsMap.get("series")[In];
        Cn.call(Bn, Dn, In);
      }, this);
    }, nr.prototype.eachRawSeries = function(Cn, Bn) {
      each$f(this._componentsMap.get("series"), function(In) {
        In && Cn.call(Bn, In, In.componentIndex);
      });
    }, nr.prototype.eachSeriesByType = function(Cn, Bn, In) {
      assertSeriesInitialized(this), each$f(this._seriesIndices, function(Dn) {
        var Ln = this._componentsMap.get("series")[Dn];
        Ln.subType === Cn && Bn.call(In, Ln, Dn);
      }, this);
    }, nr.prototype.eachRawSeriesByType = function(Cn, Bn, In) {
      return each$f(this.getSeriesByType(Cn), Bn, In);
    }, nr.prototype.isSeriesFiltered = function(Cn) {
      return assertSeriesInitialized(this), this._seriesIndicesMap.get(Cn.componentIndex) == null;
    }, nr.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, nr.prototype.filterSeries = function(Cn, Bn) {
      assertSeriesInitialized(this);
      var In = [];
      each$f(this._seriesIndices, function(Dn) {
        var Ln = this._componentsMap.get("series")[Dn];
        Cn.call(Bn, Ln, Dn) && In.push(Dn);
      }, this), this._seriesIndices = In, this._seriesIndicesMap = createHashMap(In);
    }, nr.prototype.restoreData = function(Cn) {
      reCreateSeriesIndices(this);
      var Bn = this._componentsMap, In = [];
      Bn.each(function(Dn, Ln) {
        ComponentModel$1.hasClass(Ln) && In.push(Ln);
      }), ComponentModel$1.topologicalTravel(In, ComponentModel$1.getAllClassMainTypes(), function(Dn) {
        each$f(Bn.get(Dn), function(Ln) {
          Ln && (Dn !== "series" || !isNotTargetSeries(Ln, Cn)) && Ln.restoreData();
        });
      });
    }, nr.internalField = function() {
      reCreateSeriesIndices = function(Cn) {
        var Bn = Cn._seriesIndices = [];
        each$f(Cn._componentsMap.get("series"), function(In) {
          In && Bn.push(In.componentIndex);
        }), Cn._seriesIndicesMap = createHashMap(Bn);
      }, assertSeriesInitialized = function(Cn) {
        if (process.env.NODE_ENV !== "production" && !Cn._seriesIndices)
          throw new Error("Option should contains series.");
      }, initBase = function(Cn, Bn) {
        Cn.option = {}, Cn.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE, Cn._componentsMap = createHashMap({
          series: []
        }), Cn._componentsCount = createHashMap();
        var In = Bn.aria;
        isObject$6(In) && In.enabled == null && (In.enabled = !0), mergeTheme(Bn, Cn._theme.option), merge$1(Bn, globalDefault, !1), Cn._mergeOption(Bn, null);
      };
    }(), nr;
  }(Model$1)
);
function isNotTargetSeries(_n, nr) {
  if (nr) {
    var Cn = nr.seriesIndex, Bn = nr.seriesId, In = nr.seriesName;
    return Cn != null && _n.componentIndex !== Cn || Bn != null && _n.id !== Bn || In != null && _n.name !== In;
  }
}
function mergeTheme(_n, nr) {
  var Cn = _n.color && !_n.colorLayer;
  each$f(nr, function(Bn, In) {
    In === "colorLayer" && Cn || ComponentModel$1.hasClass(In) || (typeof Bn == "object" ? _n[In] = _n[In] ? merge$1(_n[In], Bn, !1) : clone$4(Bn) : _n[In] == null && (_n[In] = Bn));
  });
}
function queryByIdOrName(_n, nr, Cn) {
  if (isArray$4(nr)) {
    var Bn = createHashMap();
    return each$f(nr, function(Dn) {
      if (Dn != null) {
        var Ln = convertOptionIdName(Dn, null);
        Ln != null && Bn.set(Dn, !0);
      }
    }), filter(Cn, function(Dn) {
      return Dn && Bn.get(Dn[_n]);
    });
  } else {
    var In = convertOptionIdName(nr, null);
    return filter(Cn, function(Dn) {
      return Dn && In != null && Dn[_n] === In;
    });
  }
}
function filterBySubType(_n, nr) {
  return nr.hasOwnProperty("subType") ? filter(_n, function(Cn) {
    return Cn && Cn.subType === nr.subType;
  }) : _n;
}
function normalizeSetOptionInput(_n) {
  var nr = createHashMap();
  return _n && each$f(normalizeToArray(_n.replaceMerge), function(Cn) {
    process.env.NODE_ENV !== "production" && assert(ComponentModel$1.hasClass(Cn), '"' + Cn + '" is not valid component main type in "replaceMerge"'), nr.set(Cn, !0);
  }), {
    replaceMergeMainTypeMap: nr
  };
}
mixin(GlobalModel, PaletteMixin);
const GlobalModel$1 = GlobalModel;
var availableMethods = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], ExtensionAPI = (
  /** @class */
  function() {
    function _n(nr) {
      each$f(availableMethods, function(Cn) {
        this[Cn] = bind$1(nr[Cn], nr);
      }, this);
    }
    return _n;
  }()
);
const ExtensionAPI$1 = ExtensionAPI;
var coordinateSystemCreators = {}, CoordinateSystemManager = (
  /** @class */
  function() {
    function _n() {
      this._coordinateSystems = [];
    }
    return _n.prototype.create = function(nr, Cn) {
      var Bn = [];
      each$f(coordinateSystemCreators, function(In, Dn) {
        var Ln = In.create(nr, Cn);
        Bn = Bn.concat(Ln || []);
      }), this._coordinateSystems = Bn;
    }, _n.prototype.update = function(nr, Cn) {
      each$f(this._coordinateSystems, function(Bn) {
        Bn.update && Bn.update(nr, Cn);
      });
    }, _n.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, _n.register = function(nr, Cn) {
      coordinateSystemCreators[nr] = Cn;
    }, _n.get = function(nr) {
      return coordinateSystemCreators[nr];
    }, _n;
  }()
);
const CoordinateSystem = CoordinateSystemManager;
var QUERY_REG = /^(min|max)?(.+)$/, OptionManager = (
  /** @class */
  function() {
    function _n(nr) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = nr;
    }
    return _n.prototype.setOption = function(nr, Cn, Bn) {
      nr && (each$f(normalizeToArray(nr.series), function(Ln) {
        Ln && Ln.data && isTypedArray$2(Ln.data) && setAsPrimitive(Ln.data);
      }), each$f(normalizeToArray(nr.dataset), function(Ln) {
        Ln && Ln.source && isTypedArray$2(Ln.source) && setAsPrimitive(Ln.source);
      })), nr = clone$4(nr);
      var In = this._optionBackup, Dn = parseRawOption(nr, Cn, !In);
      this._newBaseOption = Dn.baseOption, In ? (Dn.timelineOptions.length && (In.timelineOptions = Dn.timelineOptions), Dn.mediaList.length && (In.mediaList = Dn.mediaList), Dn.mediaDefault && (In.mediaDefault = Dn.mediaDefault)) : this._optionBackup = Dn;
    }, _n.prototype.mountOption = function(nr) {
      var Cn = this._optionBackup;
      return this._timelineOptions = Cn.timelineOptions, this._mediaList = Cn.mediaList, this._mediaDefault = Cn.mediaDefault, this._currentMediaIndices = [], clone$4(nr ? Cn.baseOption : this._newBaseOption);
    }, _n.prototype.getTimelineOption = function(nr) {
      var Cn, Bn = this._timelineOptions;
      if (Bn.length) {
        var In = nr.getComponent("timeline");
        In && (Cn = clone$4(
          // FIXME:TS as TimelineModel or quivlant interface
          Bn[In.getCurrentIndex()]
        ));
      }
      return Cn;
    }, _n.prototype.getMediaOption = function(nr) {
      var Cn = this._api.getWidth(), Bn = this._api.getHeight(), In = this._mediaList, Dn = this._mediaDefault, Ln = [], $n = [];
      if (!In.length && !Dn)
        return $n;
      for (var Nn = 0, Rn = In.length; Nn < Rn; Nn++)
        applyMediaQuery(In[Nn].query, Cn, Bn) && Ln.push(Nn);
      return !Ln.length && Dn && (Ln = [-1]), Ln.length && !indicesEquals(Ln, this._currentMediaIndices) && ($n = map$1(Ln, function(Fn) {
        return clone$4(Fn === -1 ? Dn.option : In[Fn].option);
      })), this._currentMediaIndices = Ln, $n;
    }, _n;
  }()
);
function parseRawOption(_n, nr, Cn) {
  var Bn = [], In, Dn, Ln = _n.baseOption, $n = _n.timeline, Nn = _n.options, Rn = _n.media, Fn = !!_n.media, Pn = !!(Nn || $n || Ln && Ln.timeline);
  Ln ? (Dn = Ln, Dn.timeline || (Dn.timeline = $n)) : ((Pn || Fn) && (_n.options = _n.media = null), Dn = _n), Fn && (isArray$4(Rn) ? each$f(Rn, function(Hn) {
    process.env.NODE_ENV !== "production" && Hn && !Hn.option && isObject$6(Hn.query) && isObject$6(Hn.query.option) && error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), Hn && Hn.option && (Hn.query ? Bn.push(Hn) : In || (In = Hn));
  }) : process.env.NODE_ENV !== "production" && error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), Un(Dn), each$f(Nn, function(Hn) {
    return Un(Hn);
  }), each$f(Bn, function(Hn) {
    return Un(Hn.option);
  });
  function Un(Hn) {
    each$f(nr, function(zn) {
      zn(Hn, Cn);
    });
  }
  return {
    baseOption: Dn,
    timelineOptions: Nn || [],
    mediaDefault: In,
    mediaList: Bn
  };
}
function applyMediaQuery(_n, nr, Cn) {
  var Bn = {
    width: nr,
    height: Cn,
    aspectratio: nr / Cn
    // lower case for convenience.
  }, In = !0;
  return each$f(_n, function(Dn, Ln) {
    var $n = Ln.match(QUERY_REG);
    if (!(!$n || !$n[1] || !$n[2])) {
      var Nn = $n[1], Rn = $n[2].toLowerCase();
      compare(Bn[Rn], Dn, Nn) || (In = !1);
    }
  }), In;
}
function compare(_n, nr, Cn) {
  return Cn === "min" ? _n >= nr : Cn === "max" ? _n <= nr : _n === nr;
}
function indicesEquals(_n, nr) {
  return _n.join(",") === nr.join(",");
}
const OptionManager$1 = OptionManager;
var each$d = each$f, isObject$5 = isObject$6, POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function compatEC2ItemStyle(_n) {
  var nr = _n && _n.itemStyle;
  if (nr)
    for (var Cn = 0, Bn = POSSIBLE_STYLES.length; Cn < Bn; Cn++) {
      var In = POSSIBLE_STYLES[Cn], Dn = nr.normal, Ln = nr.emphasis;
      Dn && Dn[In] && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("itemStyle.normal." + In, In), _n[In] = _n[In] || {}, _n[In].normal ? merge$1(_n[In].normal, Dn[In]) : _n[In].normal = Dn[In], Dn[In] = null), Ln && Ln[In] && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("itemStyle.emphasis." + In, "emphasis." + In), _n[In] = _n[In] || {}, _n[In].emphasis ? merge$1(_n[In].emphasis, Ln[In]) : _n[In].emphasis = Ln[In], Ln[In] = null);
    }
}
function convertNormalEmphasis(_n, nr, Cn) {
  if (_n && _n[nr] && (_n[nr].normal || _n[nr].emphasis)) {
    var Bn = _n[nr].normal, In = _n[nr].emphasis;
    Bn && (process.env.NODE_ENV !== "production" && deprecateLog("'normal' hierarchy in " + nr + " has been removed since 4.0. All style properties are configured in " + nr + " directly now."), Cn ? (_n[nr].normal = _n[nr].emphasis = null, defaults(_n[nr], Bn)) : _n[nr] = Bn), In && (process.env.NODE_ENV !== "production" && deprecateLog(nr + ".emphasis has been changed to emphasis." + nr + " since 4.0"), _n.emphasis = _n.emphasis || {}, _n.emphasis[nr] = In, In.focus && (_n.emphasis.focus = In.focus), In.blurScope && (_n.emphasis.blurScope = In.blurScope));
  }
}
function removeEC3NormalStatus(_n) {
  convertNormalEmphasis(_n, "itemStyle"), convertNormalEmphasis(_n, "lineStyle"), convertNormalEmphasis(_n, "areaStyle"), convertNormalEmphasis(_n, "label"), convertNormalEmphasis(_n, "labelLine"), convertNormalEmphasis(_n, "upperLabel"), convertNormalEmphasis(_n, "edgeLabel");
}
function compatTextStyle(_n, nr) {
  var Cn = isObject$5(_n) && _n[nr], Bn = isObject$5(Cn) && Cn.textStyle;
  if (Bn) {
    process.env.NODE_ENV !== "production" && deprecateLog("textStyle hierarchy in " + nr + " has been removed since 4.0. All textStyle properties are configured in " + nr + " directly now.");
    for (var In = 0, Dn = TEXT_STYLE_OPTIONS.length; In < Dn; In++) {
      var Ln = TEXT_STYLE_OPTIONS[In];
      Bn.hasOwnProperty(Ln) && (Cn[Ln] = Bn[Ln]);
    }
  }
}
function compatEC3CommonStyles(_n) {
  _n && (removeEC3NormalStatus(_n), compatTextStyle(_n, "label"), _n.emphasis && compatTextStyle(_n.emphasis, "label"));
}
function processSeries(_n) {
  if (isObject$5(_n)) {
    compatEC2ItemStyle(_n), removeEC3NormalStatus(_n), compatTextStyle(_n, "label"), compatTextStyle(_n, "upperLabel"), compatTextStyle(_n, "edgeLabel"), _n.emphasis && (compatTextStyle(_n.emphasis, "label"), compatTextStyle(_n.emphasis, "upperLabel"), compatTextStyle(_n.emphasis, "edgeLabel"));
    var nr = _n.markPoint;
    nr && (compatEC2ItemStyle(nr), compatEC3CommonStyles(nr));
    var Cn = _n.markLine;
    Cn && (compatEC2ItemStyle(Cn), compatEC3CommonStyles(Cn));
    var Bn = _n.markArea;
    Bn && compatEC3CommonStyles(Bn);
    var In = _n.data;
    if (_n.type === "graph") {
      In = In || _n.nodes;
      var Dn = _n.links || _n.edges;
      if (Dn && !isTypedArray$2(Dn))
        for (var Ln = 0; Ln < Dn.length; Ln++)
          compatEC3CommonStyles(Dn[Ln]);
      each$f(_n.categories, function(Rn) {
        removeEC3NormalStatus(Rn);
      });
    }
    if (In && !isTypedArray$2(In))
      for (var Ln = 0; Ln < In.length; Ln++)
        compatEC3CommonStyles(In[Ln]);
    if (nr = _n.markPoint, nr && nr.data)
      for (var $n = nr.data, Ln = 0; Ln < $n.length; Ln++)
        compatEC3CommonStyles($n[Ln]);
    if (Cn = _n.markLine, Cn && Cn.data)
      for (var Nn = Cn.data, Ln = 0; Ln < Nn.length; Ln++)
        isArray$4(Nn[Ln]) ? (compatEC3CommonStyles(Nn[Ln][0]), compatEC3CommonStyles(Nn[Ln][1])) : compatEC3CommonStyles(Nn[Ln]);
    _n.type === "gauge" ? (compatTextStyle(_n, "axisLabel"), compatTextStyle(_n, "title"), compatTextStyle(_n, "detail")) : _n.type === "treemap" ? (convertNormalEmphasis(_n.breadcrumb, "itemStyle"), each$f(_n.levels, function(Rn) {
      removeEC3NormalStatus(Rn);
    })) : _n.type === "tree" && removeEC3NormalStatus(_n.leaves);
  }
}
function toArr(_n) {
  return isArray$4(_n) ? _n : _n ? [_n] : [];
}
function toObj(_n) {
  return (isArray$4(_n) ? _n[0] : _n) || {};
}
function globalCompatStyle(_n, nr) {
  each$d(toArr(_n.series), function(Bn) {
    isObject$5(Bn) && processSeries(Bn);
  });
  var Cn = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  nr && Cn.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), each$d(Cn, function(Bn) {
    each$d(toArr(_n[Bn]), function(In) {
      In && (compatTextStyle(In, "axisLabel"), compatTextStyle(In.axisPointer, "label"));
    });
  }), each$d(toArr(_n.parallel), function(Bn) {
    var In = Bn && Bn.parallelAxisDefault;
    compatTextStyle(In, "axisLabel"), compatTextStyle(In && In.axisPointer, "label");
  }), each$d(toArr(_n.calendar), function(Bn) {
    convertNormalEmphasis(Bn, "itemStyle"), compatTextStyle(Bn, "dayLabel"), compatTextStyle(Bn, "monthLabel"), compatTextStyle(Bn, "yearLabel");
  }), each$d(toArr(_n.radar), function(Bn) {
    compatTextStyle(Bn, "name"), Bn.name && Bn.axisName == null && (Bn.axisName = Bn.name, delete Bn.name, process.env.NODE_ENV !== "production" && deprecateLog("name property in radar component has been changed to axisName")), Bn.nameGap != null && Bn.axisNameGap == null && (Bn.axisNameGap = Bn.nameGap, delete Bn.nameGap, process.env.NODE_ENV !== "production" && deprecateLog("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && each$d(Bn.indicator, function(In) {
      In.text && deprecateReplaceLog("text", "name", "radar.indicator");
    });
  }), each$d(toArr(_n.geo), function(Bn) {
    isObject$5(Bn) && (compatEC3CommonStyles(Bn), each$d(toArr(Bn.regions), function(In) {
      compatEC3CommonStyles(In);
    }));
  }), each$d(toArr(_n.timeline), function(Bn) {
    compatEC3CommonStyles(Bn), convertNormalEmphasis(Bn, "label"), convertNormalEmphasis(Bn, "itemStyle"), convertNormalEmphasis(Bn, "controlStyle", !0);
    var In = Bn.data;
    isArray$4(In) && each$f(In, function(Dn) {
      isObject$6(Dn) && (convertNormalEmphasis(Dn, "label"), convertNormalEmphasis(Dn, "itemStyle"));
    });
  }), each$d(toArr(_n.toolbox), function(Bn) {
    convertNormalEmphasis(Bn, "iconStyle"), each$d(Bn.feature, function(In) {
      convertNormalEmphasis(In, "iconStyle");
    });
  }), compatTextStyle(toObj(_n.axisPointer), "label"), compatTextStyle(toObj(_n.tooltip).axisPointer, "label");
}
function get$2(_n, nr) {
  for (var Cn = nr.split(","), Bn = _n, In = 0; In < Cn.length && (Bn = Bn && Bn[Cn[In]], Bn != null); In++)
    ;
  return Bn;
}
function set$1(_n, nr, Cn, Bn) {
  for (var In = nr.split(","), Dn = _n, Ln, $n = 0; $n < In.length - 1; $n++)
    Ln = In[$n], Dn[Ln] == null && (Dn[Ln] = {}), Dn = Dn[Ln];
  (Bn || Dn[In[$n]] == null) && (Dn[In[$n]] = Cn);
}
function compatLayoutProperties(_n) {
  _n && each$f(LAYOUT_PROPERTIES, function(nr) {
    nr[0] in _n && !(nr[1] in _n) && (_n[nr[1]] = _n[nr[0]]);
  });
}
var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function compatBarItemStyle(_n) {
  var nr = _n && _n.itemStyle;
  if (nr)
    for (var Cn = 0; Cn < BAR_ITEM_STYLE_MAP.length; Cn++) {
      var Bn = BAR_ITEM_STYLE_MAP[Cn][1], In = BAR_ITEM_STYLE_MAP[Cn][0];
      nr[Bn] != null && (nr[In] = nr[Bn], process.env.NODE_ENV !== "production" && deprecateReplaceLog(Bn, In));
    }
}
function compatPieLabel(_n) {
  _n && _n.alignTo === "edge" && _n.margin != null && _n.edgeDistance == null && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("label.margin", "label.edgeDistance", "pie"), _n.edgeDistance = _n.margin);
}
function compatSunburstState(_n) {
  _n && _n.downplay && !_n.blur && (_n.blur = _n.downplay, process.env.NODE_ENV !== "production" && deprecateReplaceLog("downplay", "blur", "sunburst"));
}
function compatGraphFocus(_n) {
  _n && _n.focusNodeAdjacency != null && (_n.emphasis = _n.emphasis || {}, _n.emphasis.focus == null && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), _n.emphasis.focus = "adjacency"));
}
function traverseTree(_n, nr) {
  if (_n)
    for (var Cn = 0; Cn < _n.length; Cn++)
      nr(_n[Cn]), _n[Cn] && traverseTree(_n[Cn].children, nr);
}
function globalBackwardCompat(_n, nr) {
  globalCompatStyle(_n, nr), _n.series = normalizeToArray(_n.series), each$f(_n.series, function(Cn) {
    if (isObject$6(Cn)) {
      var Bn = Cn.type;
      if (Bn === "line")
        Cn.clipOverflow != null && (Cn.clip = Cn.clipOverflow, process.env.NODE_ENV !== "production" && deprecateReplaceLog("clipOverflow", "clip", "line"));
      else if (Bn === "pie" || Bn === "gauge") {
        Cn.clockWise != null && (Cn.clockwise = Cn.clockWise, process.env.NODE_ENV !== "production" && deprecateReplaceLog("clockWise", "clockwise")), compatPieLabel(Cn.label);
        var In = Cn.data;
        if (In && !isTypedArray$2(In))
          for (var Dn = 0; Dn < In.length; Dn++)
            compatPieLabel(In[Dn]);
        Cn.hoverOffset != null && (Cn.emphasis = Cn.emphasis || {}, (Cn.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("hoverOffset", "emphasis.scaleSize"), Cn.emphasis.scaleSize = Cn.hoverOffset));
      } else if (Bn === "gauge") {
        var Ln = get$2(Cn, "pointer.color");
        Ln != null && set$1(Cn, "itemStyle.color", Ln);
      } else if (Bn === "bar") {
        compatBarItemStyle(Cn), compatBarItemStyle(Cn.backgroundStyle), compatBarItemStyle(Cn.emphasis);
        var In = Cn.data;
        if (In && !isTypedArray$2(In))
          for (var Dn = 0; Dn < In.length; Dn++)
            typeof In[Dn] == "object" && (compatBarItemStyle(In[Dn]), compatBarItemStyle(In[Dn] && In[Dn].emphasis));
      } else if (Bn === "sunburst") {
        var $n = Cn.highlightPolicy;
        $n && (Cn.emphasis = Cn.emphasis || {}, Cn.emphasis.focus || (Cn.emphasis.focus = $n, process.env.NODE_ENV !== "production" && deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst"))), compatSunburstState(Cn), traverseTree(Cn.data, compatSunburstState);
      } else
        Bn === "graph" || Bn === "sankey" ? compatGraphFocus(Cn) : Bn === "map" && (Cn.mapType && !Cn.map && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("mapType", "map", "map"), Cn.map = Cn.mapType), Cn.mapLocation && (process.env.NODE_ENV !== "production" && deprecateLog("`mapLocation` is not used anymore."), defaults(Cn, Cn.mapLocation)));
      Cn.hoverAnimation != null && (Cn.emphasis = Cn.emphasis || {}, Cn.emphasis && Cn.emphasis.scale == null && (process.env.NODE_ENV !== "production" && deprecateReplaceLog("hoverAnimation", "emphasis.scale"), Cn.emphasis.scale = Cn.hoverAnimation)), compatLayoutProperties(Cn);
    }
  }), _n.dataRange && (_n.visualMap = _n.dataRange), each$f(COMPATITABLE_COMPONENTS, function(Cn) {
    var Bn = _n[Cn];
    Bn && (isArray$4(Bn) || (Bn = [Bn]), each$f(Bn, function(In) {
      compatLayoutProperties(In);
    }));
  });
}
function dataStack$1(_n) {
  var nr = createHashMap();
  _n.eachSeries(function(Cn) {
    var Bn = Cn.get("stack");
    if (Bn) {
      var In = nr.get(Bn) || nr.set(Bn, []), Dn = Cn.getData(), Ln = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: Dn.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: Dn.getCalculationInfo("stackedOverDimension"),
        stackedDimension: Dn.getCalculationInfo("stackedDimension"),
        stackedByDimension: Dn.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: Dn.getCalculationInfo("isStackedByIndex"),
        data: Dn,
        seriesModel: Cn
      };
      if (!Ln.stackedDimension || !(Ln.isStackedByIndex || Ln.stackedByDimension))
        return;
      In.length && Dn.setCalculationInfo("stackedOnSeries", In[In.length - 1].seriesModel), In.push(Ln);
    }
  }), nr.each(calculateStack);
}
function calculateStack(_n) {
  each$f(_n, function(nr, Cn) {
    var Bn = [], In = [NaN, NaN], Dn = [nr.stackResultDimension, nr.stackedOverDimension], Ln = nr.data, $n = nr.isStackedByIndex, Nn = nr.seriesModel.get("stackStrategy") || "samesign";
    Ln.modify(Dn, function(Rn, Fn, Pn) {
      var Un = Ln.get(nr.stackedDimension, Pn);
      if (isNaN(Un))
        return In;
      var Hn, zn;
      $n ? zn = Ln.getRawIndex(Pn) : Hn = Ln.get(nr.stackedByDimension, Pn);
      for (var Gn = NaN, Yn = Cn - 1; Yn >= 0; Yn--) {
        var Wn = _n[Yn];
        if ($n || (zn = Wn.data.rawIndexOf(Wn.stackedByDimension, Hn)), zn >= 0) {
          var Xn = Wn.data.getByRawIndex(Wn.stackResultDimension, zn);
          if (Nn === "all" || Nn === "positive" && Xn > 0 || Nn === "negative" && Xn < 0 || Nn === "samesign" && Un >= 0 && Xn > 0 || Nn === "samesign" && Un <= 0 && Xn < 0) {
            Un = addSafe(Un, Xn), Gn = Xn;
            break;
          }
        }
      }
      return Bn[0] = Un, Bn[1] = Gn, Bn;
    });
  });
}
var SourceImpl = (
  /** @class */
  function() {
    function _n(nr) {
      this.data = nr.data || (nr.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []), this.sourceFormat = nr.sourceFormat || SOURCE_FORMAT_UNKNOWN, this.seriesLayoutBy = nr.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN, this.startIndex = nr.startIndex || 0, this.dimensionsDetectedCount = nr.dimensionsDetectedCount, this.metaRawOption = nr.metaRawOption;
      var Cn = this.dimensionsDefine = nr.dimensionsDefine;
      if (Cn)
        for (var Bn = 0; Bn < Cn.length; Bn++) {
          var In = Cn[Bn];
          In.type == null && guessOrdinal(this, Bn) === BE_ORDINAL.Must && (In.type = "ordinal");
        }
    }
    return _n;
  }()
);
function isSourceInstance(_n) {
  return _n instanceof SourceImpl;
}
function createSource(_n, nr, Cn) {
  Cn = Cn || detectSourceFormat(_n);
  var Bn = nr.seriesLayoutBy, In = determineSourceDimensions(_n, Cn, Bn, nr.sourceHeader, nr.dimensions), Dn = new SourceImpl({
    data: _n,
    sourceFormat: Cn,
    seriesLayoutBy: Bn,
    dimensionsDefine: In.dimensionsDefine,
    startIndex: In.startIndex,
    dimensionsDetectedCount: In.dimensionsDetectedCount,
    metaRawOption: clone$4(nr)
  });
  return Dn;
}
function createSourceFromSeriesDataOption(_n) {
  return new SourceImpl({
    data: _n,
    sourceFormat: isTypedArray$2(_n) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
function cloneSourceShallow(_n) {
  return new SourceImpl({
    data: _n.data,
    sourceFormat: _n.sourceFormat,
    seriesLayoutBy: _n.seriesLayoutBy,
    dimensionsDefine: clone$4(_n.dimensionsDefine),
    startIndex: _n.startIndex,
    dimensionsDetectedCount: _n.dimensionsDetectedCount
  });
}
function detectSourceFormat(_n) {
  var nr = SOURCE_FORMAT_UNKNOWN;
  if (isTypedArray$2(_n))
    nr = SOURCE_FORMAT_TYPED_ARRAY;
  else if (isArray$4(_n)) {
    _n.length === 0 && (nr = SOURCE_FORMAT_ARRAY_ROWS);
    for (var Cn = 0, Bn = _n.length; Cn < Bn; Cn++) {
      var In = _n[Cn];
      if (In != null) {
        if (isArray$4(In) || isTypedArray$2(In)) {
          nr = SOURCE_FORMAT_ARRAY_ROWS;
          break;
        } else if (isObject$6(In)) {
          nr = SOURCE_FORMAT_OBJECT_ROWS;
          break;
        }
      }
    }
  } else if (isObject$6(_n)) {
    for (var Dn in _n)
      if (hasOwn(_n, Dn) && isArrayLike$1(_n[Dn])) {
        nr = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
  }
  return nr;
}
function determineSourceDimensions(_n, nr, Cn, Bn, In) {
  var Dn, Ln;
  if (!_n)
    return {
      dimensionsDefine: normalizeDimensionsOption(In),
      startIndex: Ln,
      dimensionsDetectedCount: Dn
    };
  if (nr === SOURCE_FORMAT_ARRAY_ROWS) {
    var $n = _n;
    Bn === "auto" || Bn == null ? arrayRowsTravelFirst(function(Rn) {
      Rn != null && Rn !== "-" && (isString$1(Rn) ? Ln == null && (Ln = 1) : Ln = 0);
    }, Cn, $n, 10) : Ln = isNumber(Bn) ? Bn : Bn ? 1 : 0, !In && Ln === 1 && (In = [], arrayRowsTravelFirst(function(Rn, Fn) {
      In[Fn] = Rn != null ? Rn + "" : "";
    }, Cn, $n, 1 / 0)), Dn = In ? In.length : Cn === SERIES_LAYOUT_BY_ROW ? $n.length : $n[0] ? $n[0].length : null;
  } else if (nr === SOURCE_FORMAT_OBJECT_ROWS)
    In || (In = objectRowsCollectDimensions(_n));
  else if (nr === SOURCE_FORMAT_KEYED_COLUMNS)
    In || (In = [], each$f(_n, function(Rn, Fn) {
      In.push(Fn);
    }));
  else if (nr === SOURCE_FORMAT_ORIGINAL) {
    var Nn = getDataItemValue(_n[0]);
    Dn = isArray$4(Nn) && Nn.length || 1;
  } else
    nr === SOURCE_FORMAT_TYPED_ARRAY && process.env.NODE_ENV !== "production" && assert(!!In, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: Ln,
    dimensionsDefine: normalizeDimensionsOption(In),
    dimensionsDetectedCount: Dn
  };
}
function objectRowsCollectDimensions(_n) {
  for (var nr = 0, Cn; nr < _n.length && !(Cn = _n[nr++]); )
    ;
  if (Cn)
    return keys(Cn);
}
function normalizeDimensionsOption(_n) {
  if (_n) {
    var nr = createHashMap();
    return map$1(_n, function(Cn, Bn) {
      Cn = isObject$6(Cn) ? Cn : {
        name: Cn
      };
      var In = {
        name: Cn.name,
        displayName: Cn.displayName,
        type: Cn.type
      };
      if (In.name == null)
        return In;
      In.name += "", In.displayName == null && (In.displayName = In.name);
      var Dn = nr.get(In.name);
      return Dn ? In.name += "-" + Dn.count++ : nr.set(In.name, {
        count: 1
      }), In;
    });
  }
}
function arrayRowsTravelFirst(_n, nr, Cn, Bn) {
  if (nr === SERIES_LAYOUT_BY_ROW)
    for (var In = 0; In < Cn.length && In < Bn; In++)
      _n(Cn[In] ? Cn[In][0] : null, In);
  else
    for (var Dn = Cn[0] || [], In = 0; In < Dn.length && In < Bn; In++)
      _n(Dn[In], In);
}
function shouldRetrieveDataByName(_n) {
  var nr = _n.sourceFormat;
  return nr === SOURCE_FORMAT_OBJECT_ROWS || nr === SOURCE_FORMAT_KEYED_COLUMNS;
}
var _a$1, _b, _c, providerMethods, mountMethods, DefaultDataProvider = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      var Bn = isSourceInstance(nr) ? nr : createSourceFromSeriesDataOption(nr);
      this._source = Bn;
      var In = this._data = Bn.data;
      if (Bn.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        if (process.env.NODE_ENV !== "production" && Cn == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = Cn, this._data = In;
      }
      mountMethods(this, In, Bn);
    }
    return _n.prototype.getSource = function() {
      return this._source;
    }, _n.prototype.count = function() {
      return 0;
    }, _n.prototype.getItem = function(nr, Cn) {
    }, _n.prototype.appendData = function(nr) {
    }, _n.prototype.clean = function() {
    }, _n.protoInitialize = function() {
      var nr = _n.prototype;
      nr.pure = !1, nr.persistent = !0;
    }(), _n.internalField = function() {
      var nr;
      mountMethods = function(Ln, $n, Nn) {
        var Rn = Nn.sourceFormat, Fn = Nn.seriesLayoutBy, Pn = Nn.startIndex, Un = Nn.dimensionsDefine, Hn = providerMethods[getMethodMapKey(Rn, Fn)];
        if (process.env.NODE_ENV !== "production" && assert(Hn, "Invalide sourceFormat: " + Rn), extend(Ln, Hn), Rn === SOURCE_FORMAT_TYPED_ARRAY)
          Ln.getItem = Cn, Ln.count = In, Ln.fillStorage = Bn;
        else {
          var zn = getRawSourceItemGetter(Rn, Fn);
          Ln.getItem = bind$1(zn, null, $n, Pn, Un);
          var Gn = getRawSourceDataCounter(Rn, Fn);
          Ln.count = bind$1(Gn, null, $n, Pn, Un);
        }
      };
      var Cn = function(Ln, $n) {
        Ln = Ln - this._offset, $n = $n || [];
        for (var Nn = this._data, Rn = this._dimSize, Fn = Rn * Ln, Pn = 0; Pn < Rn; Pn++)
          $n[Pn] = Nn[Fn + Pn];
        return $n;
      }, Bn = function(Ln, $n, Nn, Rn) {
        for (var Fn = this._data, Pn = this._dimSize, Un = 0; Un < Pn; Un++) {
          for (var Hn = Rn[Un], zn = Hn[0] == null ? 1 / 0 : Hn[0], Gn = Hn[1] == null ? -1 / 0 : Hn[1], Yn = $n - Ln, Wn = Nn[Un], Xn = 0; Xn < Yn; Xn++) {
            var ea = Fn[Xn * Pn + Un];
            Wn[Ln + Xn] = ea, ea < zn && (zn = ea), ea > Gn && (Gn = ea);
          }
          Hn[0] = zn, Hn[1] = Gn;
        }
      }, In = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      providerMethods = (nr = {}, nr[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
        pure: !0,
        appendData: Dn
      }, nr[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, nr[SOURCE_FORMAT_OBJECT_ROWS] = {
        pure: !0,
        appendData: Dn
      }, nr[SOURCE_FORMAT_KEYED_COLUMNS] = {
        pure: !0,
        appendData: function(Ln) {
          var $n = this._data;
          each$f(Ln, function(Nn, Rn) {
            for (var Fn = $n[Rn] || ($n[Rn] = []), Pn = 0; Pn < (Nn || []).length; Pn++)
              Fn.push(Nn[Pn]);
          });
        }
      }, nr[SOURCE_FORMAT_ORIGINAL] = {
        appendData: Dn
      }, nr[SOURCE_FORMAT_TYPED_ARRAY] = {
        persistent: !1,
        pure: !0,
        appendData: function(Ln) {
          process.env.NODE_ENV !== "production" && assert(isTypedArray$2(Ln), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = Ln;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, nr);
      function Dn(Ln) {
        for (var $n = 0; $n < Ln.length; $n++)
          this._data.push(Ln[$n]);
      }
    }(), _n;
  }()
), getItemSimply = function(_n, nr, Cn, Bn) {
  return _n[Bn];
}, rawSourceItemGetterMap = (_a$1 = {}, _a$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(_n, nr, Cn, Bn) {
  return _n[Bn + nr];
}, _a$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(_n, nr, Cn, Bn, In) {
  Bn += nr;
  for (var Dn = In || [], Ln = _n, $n = 0; $n < Ln.length; $n++) {
    var Nn = Ln[$n];
    Dn[$n] = Nn ? Nn[Bn] : null;
  }
  return Dn;
}, _a$1[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a$1[SOURCE_FORMAT_KEYED_COLUMNS] = function(_n, nr, Cn, Bn, In) {
  for (var Dn = In || [], Ln = 0; Ln < Cn.length; Ln++) {
    var $n = Cn[Ln].name;
    if (process.env.NODE_ENV !== "production" && $n == null)
      throw new Error();
    var Nn = _n[$n];
    Dn[Ln] = Nn ? Nn[Bn] : null;
  }
  return Dn;
}, _a$1[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a$1);
function getRawSourceItemGetter(_n, nr) {
  var Cn = rawSourceItemGetterMap[getMethodMapKey(_n, nr)];
  return process.env.NODE_ENV !== "production" && assert(Cn, 'Do not support get item on "' + _n + '", "' + nr + '".'), Cn;
}
var countSimply = function(_n, nr, Cn) {
  return _n.length;
}, rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(_n, nr, Cn) {
  return Math.max(0, _n.length - nr);
}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(_n, nr, Cn) {
  var Bn = _n[0];
  return Bn ? Math.max(0, Bn.length - nr) : 0;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(_n, nr, Cn) {
  var Bn = Cn[0].name;
  if (process.env.NODE_ENV !== "production" && Bn == null)
    throw new Error();
  var In = _n[Bn];
  return In ? In.length : 0;
}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
function getRawSourceDataCounter(_n, nr) {
  var Cn = rawSourceDataCounterMap[getMethodMapKey(_n, nr)];
  return process.env.NODE_ENV !== "production" && assert(Cn, 'Do not support count on "' + _n + '", "' + nr + '".'), Cn;
}
var getRawValueSimply = function(_n, nr, Cn) {
  return _n[nr];
}, rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function(_n, nr, Cn) {
  return _n[Cn];
}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function(_n, nr, Cn) {
  var Bn = getDataItemValue(_n);
  return Bn instanceof Array ? Bn[nr] : Bn;
}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
function getRawSourceValueGetter(_n) {
  var nr = rawSourceValueGetterMap[_n];
  return process.env.NODE_ENV !== "production" && assert(nr, 'Do not support get value on "' + _n + '".'), nr;
}
function getMethodMapKey(_n, nr) {
  return _n === SOURCE_FORMAT_ARRAY_ROWS ? _n + "_" + nr : _n;
}
function retrieveRawValue(_n, nr, Cn) {
  if (_n) {
    var Bn = _n.getRawDataItem(nr);
    if (Bn != null) {
      var In = _n.getStore(), Dn = In.getSource().sourceFormat;
      if (Cn != null) {
        var Ln = _n.getDimensionIndex(Cn), $n = In.getDimensionProperty(Ln);
        return getRawSourceValueGetter(Dn)(Bn, Ln, $n);
      } else {
        var Nn = Bn;
        return Dn === SOURCE_FORMAT_ORIGINAL && (Nn = getDataItemValue(Bn)), Nn;
      }
    }
  }
}
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g, DataFormatMixin = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.getDataParams = function(nr, Cn) {
      var Bn = this.getData(Cn), In = this.getRawValue(nr, Cn), Dn = Bn.getRawIndex(nr), Ln = Bn.getName(nr), $n = Bn.getRawDataItem(nr), Nn = Bn.getItemVisual(nr, "style"), Rn = Nn && Nn[Bn.getItemVisual(nr, "drawType") || "fill"], Fn = Nn && Nn.stroke, Pn = this.mainType, Un = Pn === "series", Hn = Bn.userOutput && Bn.userOutput.get();
      return {
        componentType: Pn,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: Un ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: Un ? this.id : null,
        seriesName: Un ? this.name : null,
        name: Ln,
        dataIndex: Dn,
        data: $n,
        dataType: Cn,
        value: In,
        color: Rn,
        borderColor: Fn,
        dimensionNames: Hn ? Hn.fullDimensions : null,
        encode: Hn ? Hn.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, _n.prototype.getFormattedLabel = function(nr, Cn, Bn, In, Dn, Ln) {
      Cn = Cn || "normal";
      var $n = this.getData(Bn), Nn = this.getDataParams(nr, Bn);
      if (Ln && (Nn.value = Ln.interpolatedValue), In != null && isArray$4(Nn.value) && (Nn.value = Nn.value[In]), !Dn) {
        var Rn = $n.getItemModel(nr);
        Dn = Rn.get(Cn === "normal" ? ["label", "formatter"] : [Cn, "label", "formatter"]);
      }
      if (isFunction$1(Dn))
        return Nn.status = Cn, Nn.dimensionIndex = In, Dn(Nn);
      if (isString$1(Dn)) {
        var Fn = formatTpl(Dn, Nn);
        return Fn.replace(DIMENSION_LABEL_REG, function(Pn, Un) {
          var Hn = Un.length, zn = Un;
          zn.charAt(0) === "[" && zn.charAt(Hn - 1) === "]" && (zn = +zn.slice(1, Hn - 1), process.env.NODE_ENV !== "production" && isNaN(zn) && error("Invalide label formatter: @" + Un + ", only support @[0], @[1], @[2], ..."));
          var Gn = retrieveRawValue($n, nr, zn);
          if (Ln && isArray$4(Ln.interpolatedValue)) {
            var Yn = $n.getDimensionIndex(zn);
            Yn >= 0 && (Gn = Ln.interpolatedValue[Yn]);
          }
          return Gn != null ? Gn + "" : "";
        });
      }
    }, _n.prototype.getRawValue = function(nr, Cn) {
      return retrieveRawValue(this.getData(Cn), nr);
    }, _n.prototype.formatTooltip = function(nr, Cn, Bn) {
    }, _n;
  }()
);
function normalizeTooltipFormatResult(_n) {
  var nr, Cn;
  return isObject$6(_n) ? _n.type ? Cn = _n : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(_n)) : nr = _n, {
    text: nr,
    // markers: markers || markersExisting,
    frag: Cn
  };
}
function createTask(_n) {
  return new Task(_n);
}
var Task = (
  /** @class */
  function() {
    function _n(nr) {
      nr = nr || {}, this._reset = nr.reset, this._plan = nr.plan, this._count = nr.count, this._onDirty = nr.onDirty, this._dirty = !0;
    }
    return _n.prototype.perform = function(nr) {
      var Cn = this._upstream, Bn = nr && nr.skip;
      if (this._dirty && Cn) {
        var In = this.context;
        In.data = In.outputData = Cn.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var Dn;
      this._plan && !Bn && (Dn = this._plan(this.context));
      var Ln = Fn(this._modBy), $n = this._modDataCount || 0, Nn = Fn(nr && nr.modBy), Rn = nr && nr.modDataCount || 0;
      (Ln !== Nn || $n !== Rn) && (Dn = "reset");
      function Fn(Xn) {
        return !(Xn >= 1) && (Xn = 1), Xn;
      }
      var Pn;
      (this._dirty || Dn === "reset") && (this._dirty = !1, Pn = this._doReset(Bn)), this._modBy = Nn, this._modDataCount = Rn;
      var Un = nr && nr.step;
      if (Cn ? (process.env.NODE_ENV !== "production" && assert(Cn._outputDueEnd != null), this._dueEnd = Cn._outputDueEnd) : (process.env.NODE_ENV !== "production" && assert(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var Hn = this._dueIndex, zn = Math.min(Un != null ? this._dueIndex + Un : 1 / 0, this._dueEnd);
        if (!Bn && (Pn || Hn < zn)) {
          var Gn = this._progress;
          if (isArray$4(Gn))
            for (var Yn = 0; Yn < Gn.length; Yn++)
              this._doProgress(Gn[Yn], Hn, zn, Nn, Rn);
          else
            this._doProgress(Gn, Hn, zn, Nn, Rn);
        }
        this._dueIndex = zn;
        var Wn = this._settedOutputEnd != null ? this._settedOutputEnd : zn;
        process.env.NODE_ENV !== "production" && assert(Wn >= this._outputDueEnd), this._outputDueEnd = Wn;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, _n.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, _n.prototype._doProgress = function(nr, Cn, Bn, In, Dn) {
      iterator.reset(Cn, Bn, In, Dn), this._callingProgress = nr, this._callingProgress({
        start: Cn,
        end: Bn,
        count: Bn - Cn,
        next: iterator.next
      }, this.context);
    }, _n.prototype._doReset = function(nr) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var Cn, Bn;
      !nr && this._reset && (Cn = this._reset(this.context), Cn && Cn.progress && (Bn = Cn.forceFirstProgress, Cn = Cn.progress), isArray$4(Cn) && !Cn.length && (Cn = null)), this._progress = Cn, this._modBy = this._modDataCount = null;
      var In = this._downstream;
      return In && In.dirty(), Bn;
    }, _n.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, _n.prototype.pipe = function(nr) {
      process.env.NODE_ENV !== "production" && assert(nr && !nr._disposed && nr !== this), (this._downstream !== nr || this._dirty) && (this._downstream = nr, nr._upstream = this, nr.dirty());
    }, _n.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, _n.prototype.getUpstream = function() {
      return this._upstream;
    }, _n.prototype.getDownstream = function() {
      return this._downstream;
    }, _n.prototype.setOutputEnd = function(nr) {
      this._outputDueEnd = this._settedOutputEnd = nr;
    }, _n;
  }()
), iterator = function() {
  var _n, nr, Cn, Bn, In, Dn = {
    reset: function(Nn, Rn, Fn, Pn) {
      nr = Nn, _n = Rn, Cn = Fn, Bn = Pn, In = Math.ceil(Bn / Cn), Dn.next = Cn > 1 && Bn > 0 ? $n : Ln;
    }
  };
  return Dn;
  function Ln() {
    return nr < _n ? nr++ : null;
  }
  function $n() {
    var Nn = nr % In * Cn + Math.ceil(nr / In), Rn = nr >= _n ? null : Nn < Bn ? Nn : nr;
    return nr++, Rn;
  }
}();
function parseDataValue(_n, nr) {
  var Cn = nr && nr.type;
  return Cn === "ordinal" ? _n : (Cn === "time" && !isNumber(_n) && _n != null && _n !== "-" && (_n = +parseDate(_n)), _n == null || _n === "" ? NaN : Number(_n));
}
var valueParserMap = createHashMap({
  number: function(_n) {
    return parseFloat(_n);
  },
  time: function(_n) {
    return +parseDate(_n);
  },
  trim: function(_n) {
    return isString$1(_n) ? trim$1(_n) : _n;
  }
});
function getRawValueParser(_n) {
  return valueParserMap.get(_n);
}
var ORDER_COMPARISON_OP_MAP = {
  lt: function(_n, nr) {
    return _n < nr;
  },
  lte: function(_n, nr) {
    return _n <= nr;
  },
  gt: function(_n, nr) {
    return _n > nr;
  },
  gte: function(_n, nr) {
    return _n >= nr;
  }
}, FilterOrderComparator = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      if (!isNumber(Cn)) {
        var Bn = "";
        process.env.NODE_ENV !== "production" && (Bn = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'), throwError(Bn);
      }
      this._opFn = ORDER_COMPARISON_OP_MAP[nr], this._rvalFloat = numericToNumber(Cn);
    }
    return _n.prototype.evaluate = function(nr) {
      return isNumber(nr) ? this._opFn(nr, this._rvalFloat) : this._opFn(numericToNumber(nr), this._rvalFloat);
    }, _n;
  }()
), SortOrderComparator = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      var Bn = nr === "desc";
      this._resultLT = Bn ? 1 : -1, Cn == null && (Cn = Bn ? "min" : "max"), this._incomparable = Cn === "min" ? -1 / 0 : 1 / 0;
    }
    return _n.prototype.evaluate = function(nr, Cn) {
      var Bn = isNumber(nr) ? nr : numericToNumber(nr), In = isNumber(Cn) ? Cn : numericToNumber(Cn), Dn = isNaN(Bn), Ln = isNaN(In);
      if (Dn && (Bn = this._incomparable), Ln && (In = this._incomparable), Dn && Ln) {
        var $n = isString$1(nr), Nn = isString$1(Cn);
        $n && (Bn = Nn ? nr : 0), Nn && (In = $n ? Cn : 0);
      }
      return Bn < In ? this._resultLT : Bn > In ? -this._resultLT : 0;
    }, _n;
  }()
), FilterEqualityComparator = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this._rval = Cn, this._isEQ = nr, this._rvalTypeof = typeof Cn, this._rvalFloat = numericToNumber(Cn);
    }
    return _n.prototype.evaluate = function(nr) {
      var Cn = nr === this._rval;
      if (!Cn) {
        var Bn = typeof nr;
        Bn !== this._rvalTypeof && (Bn === "number" || this._rvalTypeof === "number") && (Cn = numericToNumber(nr) === this._rvalFloat);
      }
      return this._isEQ ? Cn : !Cn;
    }, _n;
  }()
);
function createFilterComparator(_n, nr) {
  return _n === "eq" || _n === "ne" ? new FilterEqualityComparator(_n === "eq", nr) : hasOwn(ORDER_COMPARISON_OP_MAP, _n) ? new FilterOrderComparator(_n, nr) : null;
}
var ExternalSource = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.getRawData = function() {
      throw new Error("not supported");
    }, _n.prototype.getRawDataItem = function(nr) {
      throw new Error("not supported");
    }, _n.prototype.cloneRawData = function() {
    }, _n.prototype.getDimensionInfo = function(nr) {
    }, _n.prototype.cloneAllDimensionInfo = function() {
    }, _n.prototype.count = function() {
    }, _n.prototype.retrieveValue = function(nr, Cn) {
    }, _n.prototype.retrieveValueFromItem = function(nr, Cn) {
    }, _n.prototype.convertValue = function(nr, Cn) {
      return parseDataValue(nr, Cn);
    }, _n;
  }()
);
function createExternalSource(_n, nr) {
  var Cn = new ExternalSource(), Bn = _n.data, In = Cn.sourceFormat = _n.sourceFormat, Dn = _n.startIndex, Ln = "";
  _n.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN && (process.env.NODE_ENV !== "production" && (Ln = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), throwError(Ln));
  var $n = [], Nn = {}, Rn = _n.dimensionsDefine;
  if (Rn)
    each$f(Rn, function(Gn, Yn) {
      var Wn = Gn.name, Xn = {
        index: Yn,
        name: Wn,
        displayName: Gn.displayName
      };
      if ($n.push(Xn), Wn != null) {
        var ea = "";
        hasOwn(Nn, Wn) && (process.env.NODE_ENV !== "production" && (ea = 'dimension name "' + Wn + '" duplicated.'), throwError(ea)), Nn[Wn] = Xn;
      }
    });
  else
    for (var Fn = 0; Fn < _n.dimensionsDetectedCount; Fn++)
      $n.push({
        index: Fn
      });
  var Pn = getRawSourceItemGetter(In, SERIES_LAYOUT_BY_COLUMN);
  nr.__isBuiltIn && (Cn.getRawDataItem = function(Gn) {
    return Pn(Bn, Dn, $n, Gn);
  }, Cn.getRawData = bind$1(getRawData, null, _n)), Cn.cloneRawData = bind$1(cloneRawData, null, _n);
  var Un = getRawSourceDataCounter(In, SERIES_LAYOUT_BY_COLUMN);
  Cn.count = bind$1(Un, null, Bn, Dn, $n);
  var Hn = getRawSourceValueGetter(In);
  Cn.retrieveValue = function(Gn, Yn) {
    var Wn = Pn(Bn, Dn, $n, Gn);
    return zn(Wn, Yn);
  };
  var zn = Cn.retrieveValueFromItem = function(Gn, Yn) {
    if (Gn != null) {
      var Wn = $n[Yn];
      if (Wn)
        return Hn(Gn, Yn, Wn.name);
    }
  };
  return Cn.getDimensionInfo = bind$1(getDimensionInfo, null, $n, Nn), Cn.cloneAllDimensionInfo = bind$1(cloneAllDimensionInfo, null, $n), Cn;
}
function getRawData(_n) {
  var nr = _n.sourceFormat;
  if (!isSupportedSourceFormat(nr)) {
    var Cn = "";
    process.env.NODE_ENV !== "production" && (Cn = "`getRawData` is not supported in source format " + nr), throwError(Cn);
  }
  return _n.data;
}
function cloneRawData(_n) {
  var nr = _n.sourceFormat, Cn = _n.data;
  if (!isSupportedSourceFormat(nr)) {
    var Bn = "";
    process.env.NODE_ENV !== "production" && (Bn = "`cloneRawData` is not supported in source format " + nr), throwError(Bn);
  }
  if (nr === SOURCE_FORMAT_ARRAY_ROWS) {
    for (var In = [], Dn = 0, Ln = Cn.length; Dn < Ln; Dn++)
      In.push(Cn[Dn].slice());
    return In;
  } else if (nr === SOURCE_FORMAT_OBJECT_ROWS) {
    for (var In = [], Dn = 0, Ln = Cn.length; Dn < Ln; Dn++)
      In.push(extend({}, Cn[Dn]));
    return In;
  }
}
function getDimensionInfo(_n, nr, Cn) {
  if (Cn != null) {
    if (isNumber(Cn) || !isNaN(Cn) && !hasOwn(nr, Cn))
      return _n[Cn];
    if (hasOwn(nr, Cn))
      return nr[Cn];
  }
}
function cloneAllDimensionInfo(_n) {
  return clone$4(_n);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(_n) {
  _n = clone$4(_n);
  var nr = _n.type, Cn = "";
  nr || (process.env.NODE_ENV !== "production" && (Cn = "Must have a `type` when `registerTransform`."), throwError(Cn));
  var Bn = nr.split(":");
  Bn.length !== 2 && (process.env.NODE_ENV !== "production" && (Cn = 'Name must include namespace like "ns:regression".'), throwError(Cn));
  var In = !1;
  Bn[0] === "echarts" && (nr = Bn[1], In = !0), _n.__isBuiltIn = In, externalTransformMap.set(nr, _n);
}
function applyDataTransform(_n, nr, Cn) {
  var Bn = normalizeToArray(_n), In = Bn.length, Dn = "";
  In || (process.env.NODE_ENV !== "production" && (Dn = "If `transform` declared, it should at least contain one transform."), throwError(Dn));
  for (var Ln = 0, $n = In; Ln < $n; Ln++) {
    var Nn = Bn[Ln];
    nr = applySingleDataTransform(Nn, nr, Cn, In === 1 ? null : Ln), Ln !== $n - 1 && (nr.length = Math.max(nr.length, 1));
  }
  return nr;
}
function applySingleDataTransform(_n, nr, Cn, Bn) {
  var In = "";
  nr.length || (process.env.NODE_ENV !== "production" && (In = "Must have at least one upstream dataset."), throwError(In)), isObject$6(_n) || (process.env.NODE_ENV !== "production" && (In = "transform declaration must be an object rather than " + typeof _n + "."), throwError(In));
  var Dn = _n.type, Ln = externalTransformMap.get(Dn);
  Ln || (process.env.NODE_ENV !== "production" && (In = 'Can not find transform on type "' + Dn + '".'), throwError(In));
  var $n = map$1(nr, function(Fn) {
    return createExternalSource(Fn, Ln);
  }), Nn = normalizeToArray(Ln.transform({
    upstream: $n[0],
    upstreamList: $n,
    config: clone$4(_n.config)
  }));
  if (process.env.NODE_ENV !== "production" && _n.print) {
    var Rn = map$1(Nn, function(Fn) {
      var Pn = Bn != null ? " === pipe index: " + Bn : "";
      return ["=== dataset index: " + Cn.datasetIndex + Pn + " ===", "- transform result data:", makePrintable(Fn.data), "- transform result dimensions:", makePrintable(Fn.dimensions)].join(`
`);
    }).join(`
`);
    log(Rn);
  }
  return map$1(Nn, function(Fn, Pn) {
    var Un = "";
    isObject$6(Fn) || (process.env.NODE_ENV !== "production" && (Un = "A transform should not return some empty results."), throwError(Un)), Fn.data || (process.env.NODE_ENV !== "production" && (Un = "Transform result data should be not be null or undefined"), throwError(Un));
    var Hn = detectSourceFormat(Fn.data);
    isSupportedSourceFormat(Hn) || (process.env.NODE_ENV !== "production" && (Un = "Transform result data should be array rows or object rows."), throwError(Un));
    var zn, Gn = nr[0];
    if (Gn && Pn === 0 && !Fn.dimensions) {
      var Yn = Gn.startIndex;
      Yn && (Fn.data = Gn.data.slice(0, Yn).concat(Fn.data)), zn = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: Yn,
        dimensions: Gn.metaRawOption.dimensions
      };
    } else
      zn = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: Fn.dimensions
      };
    return createSource(Fn.data, zn, null);
  });
}
function isSupportedSourceFormat(_n) {
  return _n === SOURCE_FORMAT_ARRAY_ROWS || _n === SOURCE_FORMAT_OBJECT_ROWS;
}
var UNDEFINED = "undefined", CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array, CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array, CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array, CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array, dataCtors = {
  float: CtorFloat64Array,
  int: CtorInt32Array$1,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: CtorFloat64Array
}, defaultDimValueGetters;
function getIndicesCtor(_n) {
  return _n > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
  return [1 / 0, -1 / 0];
}
function cloneChunk(_n) {
  var nr = _n.constructor;
  return nr === Array ? _n.slice() : new nr(_n);
}
function prepareStore(_n, nr, Cn, Bn, In) {
  var Dn = dataCtors[Cn || "float"];
  if (In) {
    var Ln = _n[nr], $n = Ln && Ln.length;
    if ($n !== Bn) {
      for (var Nn = new Dn(Bn), Rn = 0; Rn < $n; Rn++)
        Nn[Rn] = Ln[Rn];
      _n[nr] = Nn;
    }
  } else
    _n[nr] = new Dn(Bn);
}
var DataStore = (
  /** @class */
  function() {
    function _n() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = createHashMap();
    }
    return _n.prototype.initData = function(nr, Cn, Bn) {
      process.env.NODE_ENV !== "production" && assert(isFunction$1(nr.getItem) && isFunction$1(nr.count), "Invalid data provider."), this._provider = nr, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var In = nr.getSource(), Dn = this.defaultDimValueGetter = defaultDimValueGetters[In.sourceFormat];
      this._dimValueGetter = Bn || Dn, this._rawExtent = [];
      var Ln = shouldRetrieveDataByName(In);
      this._dimensions = map$1(Cn, function($n) {
        return process.env.NODE_ENV !== "production" && Ln && assert($n.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: $n.type,
          property: $n.property
        };
      }), this._initDataFromProvider(0, nr.count());
    }, _n.prototype.getProvider = function() {
      return this._provider;
    }, _n.prototype.getSource = function() {
      return this._provider.getSource();
    }, _n.prototype.ensureCalculationDimension = function(nr, Cn) {
      var Bn = this._calcDimNameToIdx, In = this._dimensions, Dn = Bn.get(nr);
      if (Dn != null) {
        if (In[Dn].type === Cn)
          return Dn;
      } else
        Dn = In.length;
      return In[Dn] = {
        type: Cn
      }, Bn.set(nr, Dn), this._chunks[Dn] = new dataCtors[Cn || "float"](this._rawCount), this._rawExtent[Dn] = getInitialExtent(), Dn;
    }, _n.prototype.collectOrdinalMeta = function(nr, Cn) {
      var Bn = this._chunks[nr], In = this._dimensions[nr], Dn = this._rawExtent, Ln = In.ordinalOffset || 0, $n = Bn.length;
      Ln === 0 && (Dn[nr] = getInitialExtent());
      for (var Nn = Dn[nr], Rn = Ln; Rn < $n; Rn++) {
        var Fn = Bn[Rn] = Cn.parseAndCollect(Bn[Rn]);
        isNaN(Fn) || (Nn[0] = Math.min(Fn, Nn[0]), Nn[1] = Math.max(Fn, Nn[1]));
      }
      In.ordinalMeta = Cn, In.ordinalOffset = $n, In.type = "ordinal";
    }, _n.prototype.getOrdinalMeta = function(nr) {
      var Cn = this._dimensions[nr], Bn = Cn.ordinalMeta;
      return Bn;
    }, _n.prototype.getDimensionProperty = function(nr) {
      var Cn = this._dimensions[nr];
      return Cn && Cn.property;
    }, _n.prototype.appendData = function(nr) {
      process.env.NODE_ENV !== "production" && assert(!this._indices, "appendData can only be called on raw data.");
      var Cn = this._provider, Bn = this.count();
      Cn.appendData(nr);
      var In = Cn.count();
      return Cn.persistent || (In += Bn), Bn < In && this._initDataFromProvider(Bn, In, !0), [Bn, In];
    }, _n.prototype.appendValues = function(nr, Cn) {
      for (var Bn = this._chunks, In = this._dimensions, Dn = In.length, Ln = this._rawExtent, $n = this.count(), Nn = $n + Math.max(nr.length, Cn || 0), Rn = 0; Rn < Dn; Rn++) {
        var Fn = In[Rn];
        prepareStore(Bn, Rn, Fn.type, Nn, !0);
      }
      for (var Pn = [], Un = $n; Un < Nn; Un++)
        for (var Hn = Un - $n, zn = 0; zn < Dn; zn++) {
          var Fn = In[zn], Gn = defaultDimValueGetters.arrayRows.call(this, nr[Hn] || Pn, Fn.property, Hn, zn);
          Bn[zn][Un] = Gn;
          var Yn = Ln[zn];
          Gn < Yn[0] && (Yn[0] = Gn), Gn > Yn[1] && (Yn[1] = Gn);
        }
      return this._rawCount = this._count = Nn, {
        start: $n,
        end: Nn
      };
    }, _n.prototype._initDataFromProvider = function(nr, Cn, Bn) {
      for (var In = this._provider, Dn = this._chunks, Ln = this._dimensions, $n = Ln.length, Nn = this._rawExtent, Rn = map$1(Ln, function(Xn) {
        return Xn.property;
      }), Fn = 0; Fn < $n; Fn++) {
        var Pn = Ln[Fn];
        Nn[Fn] || (Nn[Fn] = getInitialExtent()), prepareStore(Dn, Fn, Pn.type, Cn, Bn);
      }
      if (In.fillStorage)
        In.fillStorage(nr, Cn, Dn, Nn);
      else
        for (var Un = [], Hn = nr; Hn < Cn; Hn++) {
          Un = In.getItem(Hn, Un);
          for (var zn = 0; zn < $n; zn++) {
            var Gn = Dn[zn], Yn = this._dimValueGetter(Un, Rn[zn], Hn, zn);
            Gn[Hn] = Yn;
            var Wn = Nn[zn];
            Yn < Wn[0] && (Wn[0] = Yn), Yn > Wn[1] && (Wn[1] = Yn);
          }
        }
      !In.persistent && In.clean && In.clean(), this._rawCount = this._count = Cn, this._extent = [];
    }, _n.prototype.count = function() {
      return this._count;
    }, _n.prototype.get = function(nr, Cn) {
      if (!(Cn >= 0 && Cn < this._count))
        return NaN;
      var Bn = this._chunks[nr];
      return Bn ? Bn[this.getRawIndex(Cn)] : NaN;
    }, _n.prototype.getValues = function(nr, Cn) {
      var Bn = [], In = [];
      if (Cn == null) {
        Cn = nr, nr = [];
        for (var Dn = 0; Dn < this._dimensions.length; Dn++)
          In.push(Dn);
      } else
        In = nr;
      for (var Dn = 0, Ln = In.length; Dn < Ln; Dn++)
        Bn.push(this.get(In[Dn], Cn));
      return Bn;
    }, _n.prototype.getByRawIndex = function(nr, Cn) {
      if (!(Cn >= 0 && Cn < this._rawCount))
        return NaN;
      var Bn = this._chunks[nr];
      return Bn ? Bn[Cn] : NaN;
    }, _n.prototype.getSum = function(nr) {
      var Cn = this._chunks[nr], Bn = 0;
      if (Cn)
        for (var In = 0, Dn = this.count(); In < Dn; In++) {
          var Ln = this.get(nr, In);
          isNaN(Ln) || (Bn += Ln);
        }
      return Bn;
    }, _n.prototype.getMedian = function(nr) {
      var Cn = [];
      this.each([nr], function(Dn) {
        isNaN(Dn) || Cn.push(Dn);
      });
      var Bn = Cn.sort(function(Dn, Ln) {
        return Dn - Ln;
      }), In = this.count();
      return In === 0 ? 0 : In % 2 === 1 ? Bn[(In - 1) / 2] : (Bn[In / 2] + Bn[In / 2 - 1]) / 2;
    }, _n.prototype.indexOfRawIndex = function(nr) {
      if (nr >= this._rawCount || nr < 0)
        return -1;
      if (!this._indices)
        return nr;
      var Cn = this._indices, Bn = Cn[nr];
      if (Bn != null && Bn < this._count && Bn === nr)
        return nr;
      for (var In = 0, Dn = this._count - 1; In <= Dn; ) {
        var Ln = (In + Dn) / 2 | 0;
        if (Cn[Ln] < nr)
          In = Ln + 1;
        else if (Cn[Ln] > nr)
          Dn = Ln - 1;
        else
          return Ln;
      }
      return -1;
    }, _n.prototype.indicesOfNearest = function(nr, Cn, Bn) {
      var In = this._chunks, Dn = In[nr], Ln = [];
      if (!Dn)
        return Ln;
      Bn == null && (Bn = 1 / 0);
      for (var $n = 1 / 0, Nn = -1, Rn = 0, Fn = 0, Pn = this.count(); Fn < Pn; Fn++) {
        var Un = this.getRawIndex(Fn), Hn = Cn - Dn[Un], zn = Math.abs(Hn);
        zn <= Bn && ((zn < $n || zn === $n && Hn >= 0 && Nn < 0) && ($n = zn, Nn = Hn, Rn = 0), Hn === Nn && (Ln[Rn++] = Fn));
      }
      return Ln.length = Rn, Ln;
    }, _n.prototype.getIndices = function() {
      var nr, Cn = this._indices;
      if (Cn) {
        var Bn = Cn.constructor, In = this._count;
        if (Bn === Array) {
          nr = new Bn(In);
          for (var Dn = 0; Dn < In; Dn++)
            nr[Dn] = Cn[Dn];
        } else
          nr = new Bn(Cn.buffer, 0, In);
      } else {
        var Bn = getIndicesCtor(this._rawCount);
        nr = new Bn(this.count());
        for (var Dn = 0; Dn < nr.length; Dn++)
          nr[Dn] = Dn;
      }
      return nr;
    }, _n.prototype.filter = function(nr, Cn) {
      if (!this._count)
        return this;
      for (var Bn = this.clone(), In = Bn.count(), Dn = getIndicesCtor(Bn._rawCount), Ln = new Dn(In), $n = [], Nn = nr.length, Rn = 0, Fn = nr[0], Pn = Bn._chunks, Un = 0; Un < In; Un++) {
        var Hn = void 0, zn = Bn.getRawIndex(Un);
        if (Nn === 0)
          Hn = Cn(Un);
        else if (Nn === 1) {
          var Gn = Pn[Fn][zn];
          Hn = Cn(Gn, Un);
        } else {
          for (var Yn = 0; Yn < Nn; Yn++)
            $n[Yn] = Pn[nr[Yn]][zn];
          $n[Yn] = Un, Hn = Cn.apply(null, $n);
        }
        Hn && (Ln[Rn++] = zn);
      }
      return Rn < In && (Bn._indices = Ln), Bn._count = Rn, Bn._extent = [], Bn._updateGetRawIdx(), Bn;
    }, _n.prototype.selectRange = function(nr) {
      var Cn = this.clone(), Bn = Cn._count;
      if (!Bn)
        return this;
      var In = keys(nr), Dn = In.length;
      if (!Dn)
        return this;
      var Ln = Cn.count(), $n = getIndicesCtor(Cn._rawCount), Nn = new $n(Ln), Rn = 0, Fn = In[0], Pn = nr[Fn][0], Un = nr[Fn][1], Hn = Cn._chunks, zn = !1;
      if (!Cn._indices) {
        var Gn = 0;
        if (Dn === 1) {
          for (var Yn = Hn[In[0]], Wn = 0; Wn < Bn; Wn++) {
            var Xn = Yn[Wn];
            (Xn >= Pn && Xn <= Un || isNaN(Xn)) && (Nn[Rn++] = Gn), Gn++;
          }
          zn = !0;
        } else if (Dn === 2) {
          for (var Yn = Hn[In[0]], ea = Hn[In[1]], ta = nr[In[1]][0], na = nr[In[1]][1], Wn = 0; Wn < Bn; Wn++) {
            var Xn = Yn[Wn], ra = ea[Wn];
            (Xn >= Pn && Xn <= Un || isNaN(Xn)) && (ra >= ta && ra <= na || isNaN(ra)) && (Nn[Rn++] = Gn), Gn++;
          }
          zn = !0;
        }
      }
      if (!zn)
        if (Dn === 1)
          for (var Wn = 0; Wn < Ln; Wn++) {
            var aa = Cn.getRawIndex(Wn), Xn = Hn[In[0]][aa];
            (Xn >= Pn && Xn <= Un || isNaN(Xn)) && (Nn[Rn++] = aa);
          }
        else
          for (var Wn = 0; Wn < Ln; Wn++) {
            for (var ia = !0, aa = Cn.getRawIndex(Wn), Aa = 0; Aa < Dn; Aa++) {
              var sa = In[Aa], Xn = Hn[sa][aa];
              (Xn < nr[sa][0] || Xn > nr[sa][1]) && (ia = !1);
            }
            ia && (Nn[Rn++] = Cn.getRawIndex(Wn));
          }
      return Rn < Ln && (Cn._indices = Nn), Cn._count = Rn, Cn._extent = [], Cn._updateGetRawIdx(), Cn;
    }, _n.prototype.map = function(nr, Cn) {
      var Bn = this.clone(nr);
      return this._updateDims(Bn, nr, Cn), Bn;
    }, _n.prototype.modify = function(nr, Cn) {
      this._updateDims(this, nr, Cn);
    }, _n.prototype._updateDims = function(nr, Cn, Bn) {
      for (var In = nr._chunks, Dn = [], Ln = Cn.length, $n = nr.count(), Nn = [], Rn = nr._rawExtent, Fn = 0; Fn < Cn.length; Fn++)
        Rn[Cn[Fn]] = getInitialExtent();
      for (var Pn = 0; Pn < $n; Pn++) {
        for (var Un = nr.getRawIndex(Pn), Hn = 0; Hn < Ln; Hn++)
          Nn[Hn] = In[Cn[Hn]][Un];
        Nn[Ln] = Pn;
        var zn = Bn && Bn.apply(null, Nn);
        if (zn != null) {
          typeof zn != "object" && (Dn[0] = zn, zn = Dn);
          for (var Fn = 0; Fn < zn.length; Fn++) {
            var Gn = Cn[Fn], Yn = zn[Fn], Wn = Rn[Gn], Xn = In[Gn];
            Xn && (Xn[Un] = Yn), Yn < Wn[0] && (Wn[0] = Yn), Yn > Wn[1] && (Wn[1] = Yn);
          }
        }
      }
    }, _n.prototype.lttbDownSample = function(nr, Cn) {
      var Bn = this.clone([nr], !0), In = Bn._chunks, Dn = In[nr], Ln = this.count(), $n = 0, Nn = Math.floor(1 / Cn), Rn = this.getRawIndex(0), Fn, Pn, Un, Hn = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(Ln / Nn) + 2) * 2, Ln));
      Hn[$n++] = Rn;
      for (var zn = 1; zn < Ln - 1; zn += Nn) {
        for (var Gn = Math.min(zn + Nn, Ln - 1), Yn = Math.min(zn + Nn * 2, Ln), Wn = (Yn + Gn) / 2, Xn = 0, ea = Gn; ea < Yn; ea++) {
          var ta = this.getRawIndex(ea), na = Dn[ta];
          isNaN(na) || (Xn += na);
        }
        Xn /= Yn - Gn;
        var ra = zn, aa = Math.min(zn + Nn, Ln), ia = zn - 1, Aa = Dn[Rn];
        Fn = -1, Un = ra;
        for (var sa = -1, oa = 0, ea = ra; ea < aa; ea++) {
          var ta = this.getRawIndex(ea), na = Dn[ta];
          if (isNaN(na)) {
            oa++, sa < 0 && (sa = ta);
            continue;
          }
          Pn = Math.abs((ia - Wn) * (na - Aa) - (ia - ea) * (Xn - Aa)), Pn > Fn && (Fn = Pn, Un = ta);
        }
        oa > 0 && oa < aa - ra && (Hn[$n++] = Math.min(sa, Un), Un = Math.max(sa, Un)), Hn[$n++] = Un, Rn = Un;
      }
      return Hn[$n++] = this.getRawIndex(Ln - 1), Bn._count = $n, Bn._indices = Hn, Bn.getRawIndex = this._getRawIdx, Bn;
    }, _n.prototype.minmaxDownSample = function(nr, Cn) {
      for (var Bn = this.clone([nr], !0), In = Bn._chunks, Dn = Math.floor(1 / Cn), Ln = In[nr], $n = this.count(), Nn = new (getIndicesCtor(this._rawCount))(Math.ceil($n / Dn) * 2), Rn = 0, Fn = 0; Fn < $n; Fn += Dn) {
        var Pn = Fn, Un = Ln[this.getRawIndex(Pn)], Hn = Fn, zn = Ln[this.getRawIndex(Hn)], Gn = Dn;
        Fn + Dn > $n && (Gn = $n - Fn);
        for (var Yn = 0; Yn < Gn; Yn++) {
          var Wn = this.getRawIndex(Fn + Yn), Xn = Ln[Wn];
          Xn < Un && (Un = Xn, Pn = Fn + Yn), Xn > zn && (zn = Xn, Hn = Fn + Yn);
        }
        var ea = this.getRawIndex(Pn), ta = this.getRawIndex(Hn);
        Pn < Hn ? (Nn[Rn++] = ea, Nn[Rn++] = ta) : (Nn[Rn++] = ta, Nn[Rn++] = ea);
      }
      return Bn._count = Rn, Bn._indices = Nn, Bn._updateGetRawIdx(), Bn;
    }, _n.prototype.downSample = function(nr, Cn, Bn, In) {
      for (var Dn = this.clone([nr], !0), Ln = Dn._chunks, $n = [], Nn = Math.floor(1 / Cn), Rn = Ln[nr], Fn = this.count(), Pn = Dn._rawExtent[nr] = getInitialExtent(), Un = new (getIndicesCtor(this._rawCount))(Math.ceil(Fn / Nn)), Hn = 0, zn = 0; zn < Fn; zn += Nn) {
        Nn > Fn - zn && (Nn = Fn - zn, $n.length = Nn);
        for (var Gn = 0; Gn < Nn; Gn++) {
          var Yn = this.getRawIndex(zn + Gn);
          $n[Gn] = Rn[Yn];
        }
        var Wn = Bn($n), Xn = this.getRawIndex(Math.min(zn + In($n, Wn) || 0, Fn - 1));
        Rn[Xn] = Wn, Wn < Pn[0] && (Pn[0] = Wn), Wn > Pn[1] && (Pn[1] = Wn), Un[Hn++] = Xn;
      }
      return Dn._count = Hn, Dn._indices = Un, Dn._updateGetRawIdx(), Dn;
    }, _n.prototype.each = function(nr, Cn) {
      if (this._count)
        for (var Bn = nr.length, In = this._chunks, Dn = 0, Ln = this.count(); Dn < Ln; Dn++) {
          var $n = this.getRawIndex(Dn);
          switch (Bn) {
            case 0:
              Cn(Dn);
              break;
            case 1:
              Cn(In[nr[0]][$n], Dn);
              break;
            case 2:
              Cn(In[nr[0]][$n], In[nr[1]][$n], Dn);
              break;
            default:
              for (var Nn = 0, Rn = []; Nn < Bn; Nn++)
                Rn[Nn] = In[nr[Nn]][$n];
              Rn[Nn] = Dn, Cn.apply(null, Rn);
          }
        }
    }, _n.prototype.getDataExtent = function(nr) {
      var Cn = this._chunks[nr], Bn = getInitialExtent();
      if (!Cn)
        return Bn;
      var In = this.count(), Dn = !this._indices, Ln;
      if (Dn)
        return this._rawExtent[nr].slice();
      if (Ln = this._extent[nr], Ln)
        return Ln.slice();
      Ln = Bn;
      for (var $n = Ln[0], Nn = Ln[1], Rn = 0; Rn < In; Rn++) {
        var Fn = this.getRawIndex(Rn), Pn = Cn[Fn];
        Pn < $n && ($n = Pn), Pn > Nn && (Nn = Pn);
      }
      return Ln = [$n, Nn], this._extent[nr] = Ln, Ln;
    }, _n.prototype.getRawDataItem = function(nr) {
      var Cn = this.getRawIndex(nr);
      if (this._provider.persistent)
        return this._provider.getItem(Cn);
      for (var Bn = [], In = this._chunks, Dn = 0; Dn < In.length; Dn++)
        Bn.push(In[Dn][Cn]);
      return Bn;
    }, _n.prototype.clone = function(nr, Cn) {
      var Bn = new _n(), In = this._chunks, Dn = nr && reduce(nr, function($n, Nn) {
        return $n[Nn] = !0, $n;
      }, {});
      if (Dn)
        for (var Ln = 0; Ln < In.length; Ln++)
          Bn._chunks[Ln] = Dn[Ln] ? cloneChunk(In[Ln]) : In[Ln];
      else
        Bn._chunks = In;
      return this._copyCommonProps(Bn), Cn || (Bn._indices = this._cloneIndices()), Bn._updateGetRawIdx(), Bn;
    }, _n.prototype._copyCommonProps = function(nr) {
      nr._count = this._count, nr._rawCount = this._rawCount, nr._provider = this._provider, nr._dimensions = this._dimensions, nr._extent = clone$4(this._extent), nr._rawExtent = clone$4(this._rawExtent);
    }, _n.prototype._cloneIndices = function() {
      if (this._indices) {
        var nr = this._indices.constructor, Cn = void 0;
        if (nr === Array) {
          var Bn = this._indices.length;
          Cn = new nr(Bn);
          for (var In = 0; In < Bn; In++)
            Cn[In] = this._indices[In];
        } else
          Cn = new nr(this._indices);
        return Cn;
      }
      return null;
    }, _n.prototype._getRawIdxIdentity = function(nr) {
      return nr;
    }, _n.prototype._getRawIdx = function(nr) {
      return nr < this._count && nr >= 0 ? this._indices[nr] : -1;
    }, _n.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, _n.internalField = function() {
      function nr(Cn, Bn, In, Dn) {
        return parseDataValue(Cn[Dn], this._dimensions[Dn]);
      }
      defaultDimValueGetters = {
        arrayRows: nr,
        objectRows: function(Cn, Bn, In, Dn) {
          return parseDataValue(Cn[Bn], this._dimensions[Dn]);
        },
        keyedColumns: nr,
        original: function(Cn, Bn, In, Dn) {
          var Ln = Cn && (Cn.value == null ? Cn : Cn.value);
          return parseDataValue(Ln instanceof Array ? Ln[Dn] : Ln, this._dimensions[Dn]);
        },
        typedArray: function(Cn, Bn, In, Dn) {
          return Cn[Dn];
        }
      };
    }(), _n;
  }()
);
const DataStore$1 = DataStore;
var SourceManager = (
  /** @class */
  function() {
    function _n(nr) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = nr;
    }
    return _n.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, _n.prototype._setLocalSource = function(nr, Cn) {
      this._sourceList = nr, this._upstreamSignList = Cn, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, _n.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, _n.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, _n.prototype._createSource = function() {
      this._setLocalSource([], []);
      var nr = this._sourceHost, Cn = this._getUpstreamSourceManagers(), Bn = !!Cn.length, In, Dn;
      if (isSeries(nr)) {
        var Ln = nr, $n = void 0, Nn = void 0, Rn = void 0;
        if (Bn) {
          var Fn = Cn[0];
          Fn.prepareSource(), Rn = Fn.getSource(), $n = Rn.data, Nn = Rn.sourceFormat, Dn = [Fn._getVersionSign()];
        } else
          $n = Ln.get("data", !0), Nn = isTypedArray$2($n) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL, Dn = [];
        var Pn = this._getSourceMetaRawOption() || {}, Un = Rn && Rn.metaRawOption || {}, Hn = retrieve2(Pn.seriesLayoutBy, Un.seriesLayoutBy) || null, zn = retrieve2(Pn.sourceHeader, Un.sourceHeader), Gn = retrieve2(Pn.dimensions, Un.dimensions), Yn = Hn !== Un.seriesLayoutBy || !!zn != !!Un.sourceHeader || Gn;
        In = Yn ? [createSource($n, {
          seriesLayoutBy: Hn,
          sourceHeader: zn,
          dimensions: Gn
        }, Nn)] : [];
      } else {
        var Wn = nr;
        if (Bn) {
          var Xn = this._applyTransform(Cn);
          In = Xn.sourceList, Dn = Xn.upstreamSignList;
        } else {
          var ea = Wn.get("source", !0);
          In = [createSource(ea, this._getSourceMetaRawOption(), null)], Dn = [];
        }
      }
      process.env.NODE_ENV !== "production" && assert(In && Dn), this._setLocalSource(In, Dn);
    }, _n.prototype._applyTransform = function(nr) {
      var Cn = this._sourceHost, Bn = Cn.get("transform", !0), In = Cn.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && assert(In != null || Bn != null), In != null) {
        var Dn = "";
        nr.length !== 1 && (process.env.NODE_ENV !== "production" && (Dn = "When using `fromTransformResult`, there should be only one upstream dataset"), doThrow(Dn));
      }
      var Ln, $n = [], Nn = [];
      return each$f(nr, function(Rn) {
        Rn.prepareSource();
        var Fn = Rn.getSource(In || 0), Pn = "";
        In != null && !Fn && (process.env.NODE_ENV !== "production" && (Pn = "Can not retrieve result by `fromTransformResult`: " + In), doThrow(Pn)), $n.push(Fn), Nn.push(Rn._getVersionSign());
      }), Bn ? Ln = applyDataTransform(Bn, $n, {
        datasetIndex: Cn.componentIndex
      }) : In != null && (Ln = [cloneSourceShallow($n[0])]), {
        sourceList: Ln,
        upstreamSignList: Nn
      };
    }, _n.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var nr = this._getUpstreamSourceManagers(), Cn = 0; Cn < nr.length; Cn++) {
        var Bn = nr[Cn];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          Bn._isDirty() || this._upstreamSignList[Cn] !== Bn._getVersionSign()
        )
          return !0;
      }
    }, _n.prototype.getSource = function(nr) {
      nr = nr || 0;
      var Cn = this._sourceList[nr];
      if (!Cn) {
        var Bn = this._getUpstreamSourceManagers();
        return Bn[0] && Bn[0].getSource(nr);
      }
      return Cn;
    }, _n.prototype.getSharedDataStore = function(nr) {
      process.env.NODE_ENV !== "production" && assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
      var Cn = nr.makeStoreSchema();
      return this._innerGetDataStore(Cn.dimensions, nr.source, Cn.hash);
    }, _n.prototype._innerGetDataStore = function(nr, Cn, Bn) {
      var In = 0, Dn = this._storeList, Ln = Dn[In];
      Ln || (Ln = Dn[In] = {});
      var $n = Ln[Bn];
      if (!$n) {
        var Nn = this._getUpstreamSourceManagers()[0];
        isSeries(this._sourceHost) && Nn ? $n = Nn._innerGetDataStore(nr, Cn, Bn) : ($n = new DataStore$1(), $n.initData(new DefaultDataProvider(Cn, nr.length), nr)), Ln[Bn] = $n;
      }
      return $n;
    }, _n.prototype._getUpstreamSourceManagers = function() {
      var nr = this._sourceHost;
      if (isSeries(nr)) {
        var Cn = querySeriesUpstreamDatasetModel(nr);
        return Cn ? [Cn.getSourceManager()] : [];
      } else
        return map$1(queryDatasetUpstreamDatasetModels(nr), function(Bn) {
          return Bn.getSourceManager();
        });
    }, _n.prototype._getSourceMetaRawOption = function() {
      var nr = this._sourceHost, Cn, Bn, In;
      if (isSeries(nr))
        Cn = nr.get("seriesLayoutBy", !0), Bn = nr.get("sourceHeader", !0), In = nr.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var Dn = nr;
        Cn = Dn.get("seriesLayoutBy", !0), Bn = Dn.get("sourceHeader", !0), In = Dn.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: Cn,
        sourceHeader: Bn,
        dimensions: In
      };
    }, _n;
  }()
);
function disableTransformOptionMerge(_n) {
  var nr = _n.option.transform;
  nr && setAsPrimitive(_n.option.transform);
}
function isSeries(_n) {
  return _n.mainType === "series";
}
function doThrow(_n) {
  throw new Error(_n);
}
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipLineHeight(_n) {
  var nr = _n.lineHeight;
  return nr == null ? TOOLTIP_LINE_HEIGHT_CSS : "line-height:" + encodeHTML(nr + "") + "px";
}
function getTooltipTextStyle(_n, nr) {
  var Cn = _n.color || "#6e7079", Bn = _n.fontSize || 12, In = _n.fontWeight || "400", Dn = _n.color || "#464646", Ln = _n.fontSize || 14, $n = _n.fontWeight || "900";
  return nr === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + encodeHTML(Bn + "") + "px;color:" + encodeHTML(Cn) + ";font-weight:" + encodeHTML(In + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + encodeHTML(Ln + "") + "px;color:" + encodeHTML(Dn) + ";font-weight:" + encodeHTML($n + "")
  } : {
    nameStyle: {
      fontSize: Bn,
      fill: Cn,
      fontWeight: In
    },
    valueStyle: {
      fontSize: Ln,
      fill: Dn,
      fontWeight: $n
    }
  };
}
var HTML_GAPS = [0, 10, 20, 30], RICH_TEXT_GAPS = ["", `
`, `

`, `


`];
function createTooltipMarkup(_n, nr) {
  return nr.type = _n, nr;
}
function isSectionFragment(_n) {
  return _n.type === "section";
}
function getBuilder(_n) {
  return isSectionFragment(_n) ? buildSection : buildNameValue;
}
function getBlockGapLevel(_n) {
  if (isSectionFragment(_n)) {
    var nr = 0, Cn = _n.blocks.length, Bn = Cn > 1 || Cn > 0 && !_n.noHeader;
    return each$f(_n.blocks, function(In) {
      var Dn = getBlockGapLevel(In);
      Dn >= nr && (nr = Dn + +(Bn && // 0 always can not be readable gap level.
      (!Dn || isSectionFragment(In) && !In.noHeader)));
    }), nr;
  }
  return 0;
}
function buildSection(_n, nr, Cn, Bn) {
  var In = nr.noHeader, Dn = getGap(getBlockGapLevel(nr)), Ln = [], $n = nr.blocks || [];
  assert(!$n || isArray$4($n)), $n = $n || [];
  var Nn = _n.orderMode;
  if (nr.sortBlocks && Nn) {
    $n = $n.slice();
    var Rn = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (hasOwn(Rn, Nn)) {
      var Fn = new SortOrderComparator(Rn[Nn], null);
      $n.sort(function(Gn, Yn) {
        return Fn.evaluate(Gn.sortParam, Yn.sortParam);
      });
    } else
      Nn === "seriesDesc" && $n.reverse();
  }
  each$f($n, function(Gn, Yn) {
    var Wn = nr.valueFormatter, Xn = getBuilder(Gn)(
      // Inherit valueFormatter
      Wn ? extend(extend({}, _n), {
        valueFormatter: Wn
      }) : _n,
      Gn,
      Yn > 0 ? Dn.html : 0,
      Bn
    );
    Xn != null && Ln.push(Xn);
  });
  var Pn = _n.renderMode === "richText" ? Ln.join(Dn.richText) : wrapBlockHTML(Bn, Ln.join(""), In ? Cn : Dn.html);
  if (In)
    return Pn;
  var Un = makeValueReadable(nr.header, "ordinal", _n.useUTC), Hn = getTooltipTextStyle(Bn, _n.renderMode).nameStyle, zn = getTooltipLineHeight(Bn);
  return _n.renderMode === "richText" ? wrapInlineNameRichText(_n, Un, Hn) + Dn.richText + Pn : wrapBlockHTML(Bn, '<div style="' + Hn + ";" + zn + ';">' + encodeHTML(Un) + "</div>" + Pn, Cn);
}
function buildNameValue(_n, nr, Cn, Bn) {
  var In = _n.renderMode, Dn = nr.noName, Ln = nr.noValue, $n = !nr.markerType, Nn = nr.name, Rn = _n.useUTC, Fn = nr.valueFormatter || _n.valueFormatter || function(ta) {
    return ta = isArray$4(ta) ? ta : [ta], map$1(ta, function(na, ra) {
      return makeValueReadable(na, isArray$4(Hn) ? Hn[ra] : Hn, Rn);
    });
  };
  if (!(Dn && Ln)) {
    var Pn = $n ? "" : _n.markupStyleCreator.makeTooltipMarker(nr.markerType, nr.markerColor || "#333", In), Un = Dn ? "" : makeValueReadable(Nn, "ordinal", Rn), Hn = nr.valueType, zn = Ln ? [] : Fn(nr.value, nr.dataIndex), Gn = !$n || !Dn, Yn = !$n && Dn, Wn = getTooltipTextStyle(Bn, In), Xn = Wn.nameStyle, ea = Wn.valueStyle;
    return In === "richText" ? ($n ? "" : Pn) + (Dn ? "" : wrapInlineNameRichText(_n, Un, Xn)) + (Ln ? "" : wrapInlineValueRichText(_n, zn, Gn, Yn, ea)) : wrapBlockHTML(Bn, ($n ? "" : Pn) + (Dn ? "" : wrapInlineNameHTML(Un, !$n, Xn)) + (Ln ? "" : wrapInlineValueHTML(zn, Gn, Yn, ea)), Cn);
  }
}
function buildTooltipMarkup(_n, nr, Cn, Bn, In, Dn) {
  if (_n) {
    var Ln = getBuilder(_n), $n = {
      useUTC: In,
      renderMode: Cn,
      orderMode: Bn,
      markupStyleCreator: nr,
      valueFormatter: _n.valueFormatter
    };
    return Ln($n, _n, 0, Dn);
  }
}
function getGap(_n) {
  return {
    html: HTML_GAPS[_n],
    richText: RICH_TEXT_GAPS[_n]
  };
}
function wrapBlockHTML(_n, nr, Cn) {
  var Bn = '<div style="clear:both"></div>', In = "margin: " + Cn + "px 0 0", Dn = getTooltipLineHeight(_n);
  return '<div style="' + In + ";" + Dn + ';">' + nr + Bn + "</div>";
}
function wrapInlineNameHTML(_n, nr, Cn) {
  var Bn = nr ? "margin-left:2px" : "";
  return '<span style="' + Cn + ";" + Bn + '">' + encodeHTML(_n) + "</span>";
}
function wrapInlineValueHTML(_n, nr, Cn, Bn) {
  var In = Cn ? "10px" : "20px", Dn = nr ? "float:right;margin-left:" + In : "";
  return _n = isArray$4(_n) ? _n : [_n], '<span style="' + Dn + ";" + Bn + '">' + map$1(_n, function(Ln) {
    return encodeHTML(Ln);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(_n, nr, Cn) {
  return _n.markupStyleCreator.wrapRichTextStyle(nr, Cn);
}
function wrapInlineValueRichText(_n, nr, Cn, Bn, In) {
  var Dn = [In], Ln = Bn ? 10 : 20;
  return Cn && Dn.push({
    padding: [0, 0, 0, Ln],
    align: "right"
  }), _n.markupStyleCreator.wrapRichTextStyle(isArray$4(nr) ? nr.join("  ") : nr, Dn);
}
function retrieveVisualColorForTooltipMarker(_n, nr) {
  var Cn = _n.getData().getItemVisual(nr, "style"), Bn = Cn[_n.visualDrawType];
  return convertToColorString(Bn);
}
function getPaddingFromTooltipModel(_n, nr) {
  var Cn = _n.get("padding");
  return Cn ?? (nr === "richText" ? [8, 10] : 10);
}
var TooltipMarkupStyleCreator = (
  /** @class */
  function() {
    function _n() {
      this.richTextStyles = {}, this._nextStyleNameId = getRandomIdBase();
    }
    return _n.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, _n.prototype.makeTooltipMarker = function(nr, Cn, Bn) {
      var In = Bn === "richText" ? this._generateStyleName() : null, Dn = getTooltipMarker({
        color: Cn,
        type: nr,
        renderMode: Bn,
        markerId: In
      });
      return isString$1(Dn) ? Dn : (process.env.NODE_ENV !== "production" && assert(In), this.richTextStyles[In] = Dn.style, Dn.content);
    }, _n.prototype.wrapRichTextStyle = function(nr, Cn) {
      var Bn = {};
      isArray$4(Cn) ? each$f(Cn, function(Dn) {
        return extend(Bn, Dn);
      }) : extend(Bn, Cn);
      var In = this._generateStyleName();
      return this.richTextStyles[In] = Bn, "{" + In + "|" + nr + "}";
    }, _n;
  }()
);
function defaultSeriesFormatTooltip(_n) {
  var nr = _n.series, Cn = _n.dataIndex, Bn = _n.multipleSeries, In = nr.getData(), Dn = In.mapDimensionsAll("defaultedTooltip"), Ln = Dn.length, $n = nr.getRawValue(Cn), Nn = isArray$4($n), Rn = retrieveVisualColorForTooltipMarker(nr, Cn), Fn, Pn, Un, Hn;
  if (Ln > 1 || Nn && !Ln) {
    var zn = formatTooltipArrayValue($n, nr, Cn, Dn, Rn);
    Fn = zn.inlineValues, Pn = zn.inlineValueTypes, Un = zn.blocks, Hn = zn.inlineValues[0];
  } else if (Ln) {
    var Gn = In.getDimensionInfo(Dn[0]);
    Hn = Fn = retrieveRawValue(In, Cn, Dn[0]), Pn = Gn.type;
  } else
    Hn = Fn = Nn ? $n[0] : $n;
  var Yn = isNameSpecified(nr), Wn = Yn && nr.name || "", Xn = In.getName(Cn), ea = Bn ? Wn : Xn;
  return createTooltipMarkup("section", {
    header: Wn,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: Bn || !Yn,
    sortParam: Hn,
    blocks: [createTooltipMarkup("nameValue", {
      markerType: "item",
      markerColor: Rn,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: ea,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !trim$1(ea),
      value: Fn,
      valueType: Pn,
      dataIndex: Cn
    })].concat(Un || [])
  });
}
function formatTooltipArrayValue(_n, nr, Cn, Bn, In) {
  var Dn = nr.getData(), Ln = reduce(_n, function(Pn, Un, Hn) {
    var zn = Dn.getDimensionInfo(Hn);
    return Pn = Pn || zn && zn.tooltip !== !1 && zn.displayName != null;
  }, !1), $n = [], Nn = [], Rn = [];
  Bn.length ? each$f(Bn, function(Pn) {
    Fn(retrieveRawValue(Dn, Cn, Pn), Pn);
  }) : each$f(_n, Fn);
  function Fn(Pn, Un) {
    var Hn = Dn.getDimensionInfo(Un);
    !Hn || Hn.otherDims.tooltip === !1 || (Ln ? Rn.push(createTooltipMarkup("nameValue", {
      markerType: "subItem",
      markerColor: In,
      name: Hn.displayName,
      value: Pn,
      valueType: Hn.type
    })) : ($n.push(Pn), Nn.push(Hn.type)));
  }
  return {
    inlineValues: $n,
    inlineValueTypes: Nn,
    blocks: Rn
  };
}
var inner$k = makeInner();
function getSelectionKey(_n, nr) {
  return _n.getName(nr) || _n.getId(nr);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled", SeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn._selectedDataIndicesMap = {}, Cn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      this.seriesIndex = this.componentIndex, this.dataTask = createTask({
        count: dataTaskCount,
        reset: dataTaskReset
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(Cn, In);
      var Dn = inner$k(this).sourceManager = new SourceManager(this);
      Dn.prepareSource();
      var Ln = this.getInitialData(Cn, In);
      wrapData(Ln, this), this.dataTask.context.data = Ln, process.env.NODE_ENV !== "production" && assert(Ln, "getInitialData returned invalid data."), inner$k(this).dataBeforeProcessed = Ln, autoSeriesName(this), this._initSelectedMapFromData(Ln);
    }, nr.prototype.mergeDefaultAndTheme = function(Cn, Bn) {
      var In = fetchLayoutMode(this), Dn = In ? getLayoutParams(Cn) : {}, Ln = this.subType;
      ComponentModel$1.hasClass(Ln) && (Ln += "Series"), merge$1(Cn, Bn.getTheme().get(this.subType)), merge$1(Cn, this.getDefaultOption()), defaultEmphasis(Cn, "label", ["show"]), this.fillDataTextStyle(Cn.data), In && mergeLayoutParam(Cn, Dn, In);
    }, nr.prototype.mergeOption = function(Cn, Bn) {
      Cn = merge$1(this.option, Cn, !0), this.fillDataTextStyle(Cn.data);
      var In = fetchLayoutMode(this);
      In && mergeLayoutParam(this.option, Cn, In);
      var Dn = inner$k(this).sourceManager;
      Dn.dirty(), Dn.prepareSource();
      var Ln = this.getInitialData(Cn, Bn);
      wrapData(Ln, this), this.dataTask.dirty(), this.dataTask.context.data = Ln, inner$k(this).dataBeforeProcessed = Ln, autoSeriesName(this), this._initSelectedMapFromData(Ln);
    }, nr.prototype.fillDataTextStyle = function(Cn) {
      if (Cn && !isTypedArray$2(Cn))
        for (var Bn = ["show"], In = 0; In < Cn.length; In++)
          Cn[In] && Cn[In].label && defaultEmphasis(Cn[In], "label", Bn);
    }, nr.prototype.getInitialData = function(Cn, Bn) {
    }, nr.prototype.appendData = function(Cn) {
      var Bn = this.getRawData();
      Bn.appendData(Cn.data);
    }, nr.prototype.getData = function(Cn) {
      var Bn = getCurrentTask(this);
      if (Bn) {
        var In = Bn.context.data;
        return Cn == null || !In.getLinkedData ? In : In.getLinkedData(Cn);
      } else
        return inner$k(this).data;
    }, nr.prototype.getAllData = function() {
      var Cn = this.getData();
      return Cn && Cn.getLinkedDataAll ? Cn.getLinkedDataAll() : [{
        data: Cn
      }];
    }, nr.prototype.setData = function(Cn) {
      var Bn = getCurrentTask(this);
      if (Bn) {
        var In = Bn.context;
        In.outputData = Cn, Bn !== this.dataTask && (In.data = Cn);
      }
      inner$k(this).data = Cn;
    }, nr.prototype.getEncode = function() {
      var Cn = this.get("encode", !0);
      if (Cn)
        return createHashMap(Cn);
    }, nr.prototype.getSourceManager = function() {
      return inner$k(this).sourceManager;
    }, nr.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, nr.prototype.getRawData = function() {
      return inner$k(this).dataBeforeProcessed;
    }, nr.prototype.getColorBy = function() {
      var Cn = this.get("colorBy");
      return Cn || "series";
    }, nr.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, nr.prototype.getBaseAxis = function() {
      var Cn = this.coordinateSystem;
      return Cn && Cn.getBaseAxis && Cn.getBaseAxis();
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      return defaultSeriesFormatTooltip({
        series: this,
        dataIndex: Cn,
        multipleSeries: Bn
      });
    }, nr.prototype.isAnimationEnabled = function() {
      var Cn = this.ecModel;
      if (env$1.node && !(Cn && Cn.ssr))
        return !1;
      var Bn = this.getShallow("animation");
      return Bn && this.getData().count() > this.getShallow("animationThreshold") && (Bn = !1), !!Bn;
    }, nr.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, nr.prototype.getColorFromPalette = function(Cn, Bn, In) {
      var Dn = this.ecModel, Ln = PaletteMixin.prototype.getColorFromPalette.call(this, Cn, Bn, In);
      return Ln || (Ln = Dn.getColorFromPalette(Cn, Bn, In)), Ln;
    }, nr.prototype.coordDimToDataDim = function(Cn) {
      return this.getRawData().mapDimensionsAll(Cn);
    }, nr.prototype.getProgressive = function() {
      return this.get("progressive");
    }, nr.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, nr.prototype.select = function(Cn, Bn) {
      this._innerSelect(this.getData(Bn), Cn);
    }, nr.prototype.unselect = function(Cn, Bn) {
      var In = this.option.selectedMap;
      if (In) {
        var Dn = this.option.selectedMode, Ln = this.getData(Bn);
        if (Dn === "series" || In === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var $n = 0; $n < Cn.length; $n++) {
          var Nn = Cn[$n], Rn = getSelectionKey(Ln, Nn);
          In[Rn] = !1, this._selectedDataIndicesMap[Rn] = -1;
        }
      }
    }, nr.prototype.toggleSelect = function(Cn, Bn) {
      for (var In = [], Dn = 0; Dn < Cn.length; Dn++)
        In[0] = Cn[Dn], this.isSelected(Cn[Dn], Bn) ? this.unselect(In, Bn) : this.select(In, Bn);
    }, nr.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var Cn = this._selectedDataIndicesMap, Bn = keys(Cn), In = [], Dn = 0; Dn < Bn.length; Dn++) {
        var Ln = Cn[Bn[Dn]];
        Ln >= 0 && In.push(Ln);
      }
      return In;
    }, nr.prototype.isSelected = function(Cn, Bn) {
      var In = this.option.selectedMap;
      if (!In)
        return !1;
      var Dn = this.getData(Bn);
      return (In === "all" || In[getSelectionKey(Dn, Cn)]) && !Dn.getItemModel(Cn).get(["select", "disabled"]);
    }, nr.prototype.isUniversalTransitionEnabled = function() {
      if (this[SERIES_UNIVERSAL_TRANSITION_PROP])
        return !0;
      var Cn = this.option.universalTransition;
      return Cn ? Cn === !0 ? !0 : Cn && Cn.enabled : !1;
    }, nr.prototype._innerSelect = function(Cn, Bn) {
      var In, Dn, Ln = this.option, $n = Ln.selectedMode, Nn = Bn.length;
      if (!(!$n || !Nn)) {
        if ($n === "series")
          Ln.selectedMap = "all";
        else if ($n === "multiple") {
          isObject$6(Ln.selectedMap) || (Ln.selectedMap = {});
          for (var Rn = Ln.selectedMap, Fn = 0; Fn < Nn; Fn++) {
            var Pn = Bn[Fn], Un = getSelectionKey(Cn, Pn);
            Rn[Un] = !0, this._selectedDataIndicesMap[Un] = Cn.getRawIndex(Pn);
          }
        } else if ($n === "single" || $n === !0) {
          var Hn = Bn[Nn - 1], Un = getSelectionKey(Cn, Hn);
          Ln.selectedMap = (In = {}, In[Un] = !0, In), this._selectedDataIndicesMap = (Dn = {}, Dn[Un] = Cn.getRawIndex(Hn), Dn);
        }
      }
    }, nr.prototype._initSelectedMapFromData = function(Cn) {
      if (!this.option.selectedMap) {
        var Bn = [];
        Cn.hasItemOption && Cn.each(function(In) {
          var Dn = Cn.getRawDataItem(In);
          Dn && Dn.selected && Bn.push(In);
        }), Bn.length > 0 && this._innerSelect(Cn, Bn);
      }
    }, nr.registerClass = function(Cn) {
      return ComponentModel$1.registerClass(Cn);
    }, nr.protoInitialize = function() {
      var Cn = nr.prototype;
      Cn.type = "series.__base__", Cn.seriesIndex = 0, Cn.ignoreStyleOnData = !1, Cn.hasSymbolVisual = !1, Cn.defaultSymbol = "circle", Cn.visualStyleAccessPath = "itemStyle", Cn.visualDrawType = "fill";
    }(), nr;
  }(ComponentModel$1)
);
mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, ComponentModel$1);
function autoSeriesName(_n) {
  var nr = _n.name;
  isNameSpecified(_n) || (_n.name = getSeriesAutoName(_n) || nr);
}
function getSeriesAutoName(_n) {
  var nr = _n.getRawData(), Cn = nr.mapDimensionsAll("seriesName"), Bn = [];
  return each$f(Cn, function(In) {
    var Dn = nr.getDimensionInfo(In);
    Dn.displayName && Bn.push(Dn.displayName);
  }), Bn.join(" ");
}
function dataTaskCount(_n) {
  return _n.model.getRawData().count();
}
function dataTaskReset(_n) {
  var nr = _n.model;
  return nr.setData(nr.getRawData().cloneShallow()), dataTaskProgress;
}
function dataTaskProgress(_n, nr) {
  nr.outputData && _n.end > nr.outputData.count() && nr.model.getRawData().cloneShallow(nr.outputData);
}
function wrapData(_n, nr) {
  each$f(concatArray(_n.CHANGABLE_METHODS, _n.DOWNSAMPLE_METHODS), function(Cn) {
    _n.wrapMethod(Cn, curry$1(onDataChange, nr));
  });
}
function onDataChange(_n, nr) {
  var Cn = getCurrentTask(_n);
  return Cn && Cn.setOutputEnd((nr || this).count()), nr;
}
function getCurrentTask(_n) {
  var nr = (_n.ecModel || {}).scheduler, Cn = nr && nr.getPipeline(_n.uid);
  if (Cn) {
    var Bn = Cn.currentTask;
    if (Bn) {
      var In = Bn.agentStubMap;
      In && (Bn = In.get(_n.uid));
    }
    return Bn;
  }
}
const SeriesModel$1 = SeriesModel;
var ComponentView = (
  /** @class */
  function() {
    function _n() {
      this.group = new Group$4(), this.uid = getUID("viewComponent");
    }
    return _n.prototype.init = function(nr, Cn) {
    }, _n.prototype.render = function(nr, Cn, Bn, In) {
    }, _n.prototype.dispose = function(nr, Cn) {
    }, _n.prototype.updateView = function(nr, Cn, Bn, In) {
    }, _n.prototype.updateLayout = function(nr, Cn, Bn, In) {
    }, _n.prototype.updateVisual = function(nr, Cn, Bn, In) {
    }, _n.prototype.toggleBlurSeries = function(nr, Cn, Bn) {
    }, _n.prototype.eachRendered = function(nr) {
      var Cn = this.group;
      Cn && Cn.traverse(nr);
    }, _n;
  }()
);
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
const ComponentView$1 = ComponentView;
function createRenderPlanner() {
  var _n = makeInner();
  return function(nr) {
    var Cn = _n(nr), Bn = nr.pipelineContext, In = !!Cn.large, Dn = !!Cn.progressiveRender, Ln = Cn.large = !!(Bn && Bn.large), $n = Cn.progressiveRender = !!(Bn && Bn.progressiveRender);
    return (In !== Ln || Dn !== $n) && "reset";
  };
}
var inner$j = makeInner(), renderPlanner = createRenderPlanner(), ChartView = (
  /** @class */
  function() {
    function _n() {
      this.group = new Group$4(), this.uid = getUID("viewChart"), this.renderTask = createTask({
        plan: renderTaskPlan,
        reset: renderTaskReset
      }), this.renderTask.context = {
        view: this
      };
    }
    return _n.prototype.init = function(nr, Cn) {
    }, _n.prototype.render = function(nr, Cn, Bn, In) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, _n.prototype.highlight = function(nr, Cn, Bn, In) {
      var Dn = nr.getData(In && In.dataType);
      if (!Dn) {
        process.env.NODE_ENV !== "production" && error("Unknown dataType " + In.dataType);
        return;
      }
      toggleHighlight(Dn, In, "emphasis");
    }, _n.prototype.downplay = function(nr, Cn, Bn, In) {
      var Dn = nr.getData(In && In.dataType);
      if (!Dn) {
        process.env.NODE_ENV !== "production" && error("Unknown dataType " + In.dataType);
        return;
      }
      toggleHighlight(Dn, In, "normal");
    }, _n.prototype.remove = function(nr, Cn) {
      this.group.removeAll();
    }, _n.prototype.dispose = function(nr, Cn) {
    }, _n.prototype.updateView = function(nr, Cn, Bn, In) {
      this.render(nr, Cn, Bn, In);
    }, _n.prototype.updateLayout = function(nr, Cn, Bn, In) {
      this.render(nr, Cn, Bn, In);
    }, _n.prototype.updateVisual = function(nr, Cn, Bn, In) {
      this.render(nr, Cn, Bn, In);
    }, _n.prototype.eachRendered = function(nr) {
      traverseElements(this.group, nr);
    }, _n.markUpdateMethod = function(nr, Cn) {
      inner$j(nr).updateMethod = Cn;
    }, _n.protoInitialize = function() {
      var nr = _n.prototype;
      nr.type = "chart";
    }(), _n;
  }()
);
function elSetState(_n, nr, Cn) {
  _n && isHighDownDispatcher(_n) && (nr === "emphasis" ? enterEmphasis : leaveEmphasis)(_n, Cn);
}
function toggleHighlight(_n, nr, Cn) {
  var Bn = queryDataIndex(_n, nr), In = nr && nr.highlightKey != null ? getHighlightDigit(nr.highlightKey) : null;
  Bn != null ? each$f(normalizeToArray(Bn), function(Dn) {
    elSetState(_n.getItemGraphicEl(Dn), Cn, In);
  }) : _n.eachItemGraphicEl(function(Dn) {
    elSetState(Dn, Cn, In);
  });
}
enableClassExtend(ChartView, ["dispose"]);
enableClassManagement(ChartView);
function renderTaskPlan(_n) {
  return renderPlanner(_n.model);
}
function renderTaskReset(_n) {
  var nr = _n.model, Cn = _n.ecModel, Bn = _n.api, In = _n.payload, Dn = nr.pipelineContext.progressiveRender, Ln = _n.view, $n = In && inner$j(In).updateMethod, Nn = Dn ? "incrementalPrepareRender" : $n && Ln[$n] ? $n : "render";
  return Nn !== "render" && Ln[Nn](nr, Cn, Bn, In), progressMethodMap[Nn];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(_n, nr) {
      nr.view.incrementalRender(_n, nr.model, nr.ecModel, nr.api, nr.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(_n, nr) {
      nr.view.render(nr.model, nr.ecModel, nr.api, nr.payload);
    }
  }
};
const ChartView$1 = ChartView;
var ORIGIN_METHOD = "\0__throttleOriginMethod", RATE = "\0__throttleRate", THROTTLE_TYPE = "\0__throttleType";
function throttle(_n, nr, Cn) {
  var Bn, In = 0, Dn = 0, Ln = null, $n, Nn, Rn, Fn;
  nr = nr || 0;
  function Pn() {
    Dn = (/* @__PURE__ */ new Date()).getTime(), Ln = null, _n.apply(Nn, Rn || []);
  }
  var Un = function() {
    for (var Hn = [], zn = 0; zn < arguments.length; zn++)
      Hn[zn] = arguments[zn];
    Bn = (/* @__PURE__ */ new Date()).getTime(), Nn = this, Rn = Hn;
    var Gn = Fn || nr, Yn = Fn || Cn;
    Fn = null, $n = Bn - (Yn ? In : Dn) - Gn, clearTimeout(Ln), Yn ? Ln = setTimeout(Pn, Gn) : $n >= 0 ? Pn() : Ln = setTimeout(Pn, -$n), In = Bn;
  };
  return Un.clear = function() {
    Ln && (clearTimeout(Ln), Ln = null);
  }, Un.debounceNextCall = function(Hn) {
    Fn = Hn;
  }, Un;
}
function createOrUpdate(_n, nr, Cn, Bn) {
  var In = _n[nr];
  if (In) {
    var Dn = In[ORIGIN_METHOD] || In, Ln = In[THROTTLE_TYPE], $n = In[RATE];
    if ($n !== Cn || Ln !== Bn) {
      if (Cn == null || !Bn)
        return _n[nr] = Dn;
      In = _n[nr] = throttle(Dn, Cn, Bn === "debounce"), In[ORIGIN_METHOD] = Dn, In[THROTTLE_TYPE] = Bn, In[RATE] = Cn;
    }
    return In;
  }
}
function clear$1(_n, nr) {
  var Cn = _n[nr];
  Cn && Cn[ORIGIN_METHOD] && (Cn.clear && Cn.clear(), _n[nr] = Cn[ORIGIN_METHOD]);
}
var inner$i = makeInner(), defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, !0),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, !0)
}, defaultColorKey = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function getStyleMapper(_n, nr) {
  var Cn = _n.visualStyleMapper || defaultStyleMappers[nr];
  return Cn || (console.warn("Unknown style type '" + nr + "'."), defaultStyleMappers.itemStyle);
}
function getDefaultColorKey(_n, nr) {
  var Cn = _n.visualDrawType || defaultColorKey[nr];
  return Cn || (console.warn("Unknown style type '" + nr + "'."), "fill");
}
var seriesStyleTask = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(_n, nr) {
    var Cn = _n.getData(), Bn = _n.visualStyleAccessPath || "itemStyle", In = _n.getModel(Bn), Dn = getStyleMapper(_n, Bn), Ln = Dn(In), $n = In.getShallow("decal");
    $n && (Cn.setVisual("decal", $n), $n.dirty = !0);
    var Nn = getDefaultColorKey(_n, Bn), Rn = Ln[Nn], Fn = isFunction$1(Rn) ? Rn : null, Pn = Ln.fill === "auto" || Ln.stroke === "auto";
    if (!Ln[Nn] || Fn || Pn) {
      var Un = _n.getColorFromPalette(
        // TODO series count changed.
        _n.name,
        null,
        nr.getSeriesCount()
      );
      Ln[Nn] || (Ln[Nn] = Un, Cn.setVisual("colorFromPalette", !0)), Ln.fill = Ln.fill === "auto" || isFunction$1(Ln.fill) ? Un : Ln.fill, Ln.stroke = Ln.stroke === "auto" || isFunction$1(Ln.stroke) ? Un : Ln.stroke;
    }
    if (Cn.setVisual("style", Ln), Cn.setVisual("drawType", Nn), !nr.isSeriesFiltered(_n) && Fn)
      return Cn.setVisual("colorFromPalette", !1), {
        dataEach: function(Hn, zn) {
          var Gn = _n.getDataParams(zn), Yn = extend({}, Ln);
          Yn[Nn] = Fn(Gn), Hn.setItemVisual(zn, "style", Yn);
        }
      };
  }
}, sharedModel = new Model$1(), dataStyleTask = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(_n, nr) {
    if (!(_n.ignoreStyleOnData || nr.isSeriesFiltered(_n))) {
      var Cn = _n.getData(), Bn = _n.visualStyleAccessPath || "itemStyle", In = getStyleMapper(_n, Bn), Dn = Cn.getVisual("drawType");
      return {
        dataEach: Cn.hasItemOption ? function(Ln, $n) {
          var Nn = Ln.getRawDataItem($n);
          if (Nn && Nn[Bn]) {
            sharedModel.option = Nn[Bn];
            var Rn = In(sharedModel), Fn = Ln.ensureUniqueItemVisual($n, "style");
            extend(Fn, Rn), sharedModel.option.decal && (Ln.setItemVisual($n, "decal", sharedModel.option.decal), sharedModel.option.decal.dirty = !0), Dn in Rn && Ln.setItemVisual($n, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, dataColorPaletteTask = {
  performRawSeries: !0,
  overallReset: function(_n) {
    var nr = createHashMap();
    _n.eachSeries(function(Cn) {
      var Bn = Cn.getColorBy();
      if (!Cn.isColorBySeries()) {
        var In = Cn.type + "-" + Bn, Dn = nr.get(In);
        Dn || (Dn = {}, nr.set(In, Dn)), inner$i(Cn).scope = Dn;
      }
    }), _n.eachSeries(function(Cn) {
      if (!(Cn.isColorBySeries() || _n.isSeriesFiltered(Cn))) {
        var Bn = Cn.getRawData(), In = {}, Dn = Cn.getData(), Ln = inner$i(Cn).scope, $n = Cn.visualStyleAccessPath || "itemStyle", Nn = getDefaultColorKey(Cn, $n);
        Dn.each(function(Rn) {
          var Fn = Dn.getRawIndex(Rn);
          In[Fn] = Rn;
        }), Bn.each(function(Rn) {
          var Fn = In[Rn], Pn = Dn.getItemVisual(Fn, "colorFromPalette");
          if (Pn) {
            var Un = Dn.ensureUniqueItemVisual(Fn, "style"), Hn = Bn.getName(Rn) || Rn + "", zn = Bn.count();
            Un[Nn] = Cn.getColorFromPalette(Hn, Ln, zn);
          }
        });
      }
    });
  }
}, PI$5 = Math.PI;
function defaultLoading(_n, nr) {
  nr = nr || {}, defaults(nr, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: !0,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var Cn = new Group$4(), Bn = new Rect$3({
    style: {
      fill: nr.maskColor
    },
    zlevel: nr.zlevel,
    z: 1e4
  });
  Cn.add(Bn);
  var In = new ZRText$1({
    style: {
      text: nr.text,
      fill: nr.textColor,
      fontSize: nr.fontSize,
      fontWeight: nr.fontWeight,
      fontStyle: nr.fontStyle,
      fontFamily: nr.fontFamily
    },
    zlevel: nr.zlevel,
    z: 10001
  }), Dn = new Rect$3({
    style: {
      fill: "none"
    },
    textContent: In,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: nr.zlevel,
    z: 10001
  });
  Cn.add(Dn);
  var Ln;
  return nr.showSpinner && (Ln = new Arc$1({
    shape: {
      startAngle: -PI$5 / 2,
      endAngle: -PI$5 / 2 + 0.1,
      r: nr.spinnerRadius
    },
    style: {
      stroke: nr.color,
      lineCap: "round",
      lineWidth: nr.lineWidth
    },
    zlevel: nr.zlevel,
    z: 10001
  }), Ln.animateShape(!0).when(1e3, {
    endAngle: PI$5 * 3 / 2
  }).start("circularInOut"), Ln.animateShape(!0).when(1e3, {
    startAngle: PI$5 * 3 / 2
  }).delay(300).start("circularInOut"), Cn.add(Ln)), Cn.resize = function() {
    var $n = In.getBoundingRect().width, Nn = nr.showSpinner ? nr.spinnerRadius : 0, Rn = (_n.getWidth() - Nn * 2 - (nr.showSpinner && $n ? 10 : 0) - $n) / 2 - (nr.showSpinner && $n ? 0 : 5 + $n / 2) + (nr.showSpinner ? 0 : $n / 2) + ($n ? 0 : Nn), Fn = _n.getHeight() / 2;
    nr.showSpinner && Ln.setShape({
      cx: Rn,
      cy: Fn
    }), Dn.setShape({
      x: Rn - Nn,
      y: Fn - Nn,
      width: Nn * 2,
      height: Nn * 2
    }), Bn.setShape({
      x: 0,
      y: 0,
      width: _n.getWidth(),
      height: _n.getHeight()
    });
  }, Cn.resize(), Cn;
}
var Scheduler = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn, In) {
      this._stageTaskMap = createHashMap(), this.ecInstance = nr, this.api = Cn, Bn = this._dataProcessorHandlers = Bn.slice(), In = this._visualHandlers = In.slice(), this._allHandlers = Bn.concat(In);
    }
    return _n.prototype.restoreData = function(nr, Cn) {
      nr.restoreData(Cn), this._stageTaskMap.each(function(Bn) {
        var In = Bn.overallTask;
        In && In.dirty();
      });
    }, _n.prototype.getPerformArgs = function(nr, Cn) {
      if (nr.__pipeline) {
        var Bn = this._pipelineMap.get(nr.__pipeline.id), In = Bn.context, Dn = !Cn && Bn.progressiveEnabled && (!In || In.progressiveRender) && nr.__idxInPipeline > Bn.blockIndex, Ln = Dn ? Bn.step : null, $n = In && In.modDataCount, Nn = $n != null ? Math.ceil($n / Ln) : null;
        return {
          step: Ln,
          modBy: Nn,
          modDataCount: $n
        };
      }
    }, _n.prototype.getPipeline = function(nr) {
      return this._pipelineMap.get(nr);
    }, _n.prototype.updateStreamModes = function(nr, Cn) {
      var Bn = this._pipelineMap.get(nr.uid), In = nr.getData(), Dn = In.count(), Ln = Bn.progressiveEnabled && Cn.incrementalPrepareRender && Dn >= Bn.threshold, $n = nr.get("large") && Dn >= nr.get("largeThreshold"), Nn = nr.get("progressiveChunkMode") === "mod" ? Dn : null;
      nr.pipelineContext = Bn.context = {
        progressiveRender: Ln,
        modDataCount: Nn,
        large: $n
      };
    }, _n.prototype.restorePipelines = function(nr) {
      var Cn = this, Bn = Cn._pipelineMap = createHashMap();
      nr.eachSeries(function(In) {
        var Dn = In.getProgressive(), Ln = In.uid;
        Bn.set(Ln, {
          id: Ln,
          head: null,
          tail: null,
          threshold: In.getProgressiveThreshold(),
          progressiveEnabled: Dn && !(In.preventIncremental && In.preventIncremental()),
          blockIndex: -1,
          step: Math.round(Dn || 700),
          count: 0
        }), Cn._pipe(In, In.dataTask);
      });
    }, _n.prototype.prepareStageTasks = function() {
      var nr = this._stageTaskMap, Cn = this.api.getModel(), Bn = this.api;
      each$f(this._allHandlers, function(In) {
        var Dn = nr.get(In.uid) || nr.set(In.uid, {}), Ln = "";
        process.env.NODE_ENV !== "production" && (Ln = '"reset" and "overallReset" must not be both specified.'), assert(!(In.reset && In.overallReset), Ln), In.reset && this._createSeriesStageTask(In, Dn, Cn, Bn), In.overallReset && this._createOverallStageTask(In, Dn, Cn, Bn);
      }, this);
    }, _n.prototype.prepareView = function(nr, Cn, Bn, In) {
      var Dn = nr.renderTask, Ln = Dn.context;
      Ln.model = Cn, Ln.ecModel = Bn, Ln.api = In, Dn.__block = !nr.incrementalPrepareRender, this._pipe(Cn, Dn);
    }, _n.prototype.performDataProcessorTasks = function(nr, Cn) {
      this._performStageTasks(this._dataProcessorHandlers, nr, Cn, {
        block: !0
      });
    }, _n.prototype.performVisualTasks = function(nr, Cn, Bn) {
      this._performStageTasks(this._visualHandlers, nr, Cn, Bn);
    }, _n.prototype._performStageTasks = function(nr, Cn, Bn, In) {
      In = In || {};
      var Dn = !1, Ln = this;
      each$f(nr, function(Nn, Rn) {
        if (!(In.visualType && In.visualType !== Nn.visualType)) {
          var Fn = Ln._stageTaskMap.get(Nn.uid), Pn = Fn.seriesTaskMap, Un = Fn.overallTask;
          if (Un) {
            var Hn, zn = Un.agentStubMap;
            zn.each(function(Yn) {
              $n(In, Yn) && (Yn.dirty(), Hn = !0);
            }), Hn && Un.dirty(), Ln.updatePayload(Un, Bn);
            var Gn = Ln.getPerformArgs(Un, In.block);
            zn.each(function(Yn) {
              Yn.perform(Gn);
            }), Un.perform(Gn) && (Dn = !0);
          } else
            Pn && Pn.each(function(Yn, Wn) {
              $n(In, Yn) && Yn.dirty();
              var Xn = Ln.getPerformArgs(Yn, In.block);
              Xn.skip = !Nn.performRawSeries && Cn.isSeriesFiltered(Yn.context.model), Ln.updatePayload(Yn, Bn), Yn.perform(Xn) && (Dn = !0);
            });
        }
      });
      function $n(Nn, Rn) {
        return Nn.setDirty && (!Nn.dirtyMap || Nn.dirtyMap.get(Rn.__pipeline.id));
      }
      this.unfinished = Dn || this.unfinished;
    }, _n.prototype.performSeriesTasks = function(nr) {
      var Cn;
      nr.eachSeries(function(Bn) {
        Cn = Bn.dataTask.perform() || Cn;
      }), this.unfinished = Cn || this.unfinished;
    }, _n.prototype.plan = function() {
      this._pipelineMap.each(function(nr) {
        var Cn = nr.tail;
        do {
          if (Cn.__block) {
            nr.blockIndex = Cn.__idxInPipeline;
            break;
          }
          Cn = Cn.getUpstream();
        } while (Cn);
      });
    }, _n.prototype.updatePayload = function(nr, Cn) {
      Cn !== "remain" && (nr.context.payload = Cn);
    }, _n.prototype._createSeriesStageTask = function(nr, Cn, Bn, In) {
      var Dn = this, Ln = Cn.seriesTaskMap, $n = Cn.seriesTaskMap = createHashMap(), Nn = nr.seriesType, Rn = nr.getTargetSeries;
      nr.createOnAllSeries ? Bn.eachRawSeries(Fn) : Nn ? Bn.eachRawSeriesByType(Nn, Fn) : Rn && Rn(Bn, In).each(Fn);
      function Fn(Pn) {
        var Un = Pn.uid, Hn = $n.set(Un, Ln && Ln.get(Un) || createTask({
          plan: seriesTaskPlan,
          reset: seriesTaskReset,
          count: seriesTaskCount
        }));
        Hn.context = {
          model: Pn,
          ecModel: Bn,
          api: In,
          // PENDING: `useClearVisual` not used?
          useClearVisual: nr.isVisual && !nr.isLayout,
          plan: nr.plan,
          reset: nr.reset,
          scheduler: Dn
        }, Dn._pipe(Pn, Hn);
      }
    }, _n.prototype._createOverallStageTask = function(nr, Cn, Bn, In) {
      var Dn = this, Ln = Cn.overallTask = Cn.overallTask || createTask({
        reset: overallTaskReset
      });
      Ln.context = {
        ecModel: Bn,
        api: In,
        overallReset: nr.overallReset,
        scheduler: Dn
      };
      var $n = Ln.agentStubMap, Nn = Ln.agentStubMap = createHashMap(), Rn = nr.seriesType, Fn = nr.getTargetSeries, Pn = !0, Un = !1, Hn = "";
      process.env.NODE_ENV !== "production" && (Hn = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), assert(!nr.createOnAllSeries, Hn), Rn ? Bn.eachRawSeriesByType(Rn, zn) : Fn ? Fn(Bn, In).each(zn) : (Pn = !1, each$f(Bn.getSeries(), zn));
      function zn(Gn) {
        var Yn = Gn.uid, Wn = Nn.set(Yn, $n && $n.get(Yn) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (Un = !0, createTask({
          reset: stubReset,
          onDirty: stubOnDirty
        })));
        Wn.context = {
          model: Gn,
          overallProgress: Pn
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, Wn.agent = Ln, Wn.__block = Pn, Dn._pipe(Gn, Wn);
      }
      Un && Ln.dirty();
    }, _n.prototype._pipe = function(nr, Cn) {
      var Bn = nr.uid, In = this._pipelineMap.get(Bn);
      !In.head && (In.head = Cn), In.tail && In.tail.pipe(Cn), In.tail = Cn, Cn.__idxInPipeline = In.count++, Cn.__pipeline = In;
    }, _n.wrapStageHandler = function(nr, Cn) {
      return isFunction$1(nr) && (nr = {
        overallReset: nr,
        seriesType: detectSeriseType(nr)
      }), nr.uid = getUID("stageHandler"), Cn && (nr.visualType = Cn), nr;
    }, _n;
  }()
);
function overallTaskReset(_n) {
  _n.overallReset(_n.ecModel, _n.api, _n.payload);
}
function stubReset(_n) {
  return _n.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(_n) {
  return _n.plan ? _n.plan(_n.model, _n.ecModel, _n.api, _n.payload) : null;
}
function seriesTaskReset(_n) {
  _n.useClearVisual && _n.data.clearAllVisual();
  var nr = _n.resetDefines = normalizeToArray(_n.reset(_n.model, _n.ecModel, _n.api, _n.payload));
  return nr.length > 1 ? map$1(nr, function(Cn, Bn) {
    return makeSeriesTaskProgress(Bn);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(_n) {
  return function(nr, Cn) {
    var Bn = Cn.data, In = Cn.resetDefines[_n];
    if (In && In.dataEach)
      for (var Dn = nr.start; Dn < nr.end; Dn++)
        In.dataEach(Bn, Dn);
    else
      In && In.progress && In.progress(nr, Bn);
  };
}
function seriesTaskCount(_n) {
  return _n.data.count();
}
function detectSeriseType(_n) {
  seriesType = null;
  try {
    _n(ecModelMock, apiMock);
  } catch {
  }
  return seriesType;
}
var ecModelMock = {}, apiMock = {}, seriesType;
mockMethods(ecModelMock, GlobalModel$1);
mockMethods(apiMock, ExtensionAPI$1);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(_n) {
  seriesType = _n;
};
ecModelMock.eachComponent = function(_n) {
  _n.mainType === "series" && _n.subType && (seriesType = _n.subType);
};
function mockMethods(_n, nr) {
  for (var Cn in nr.prototype)
    _n[Cn] = noop$1;
}
const Scheduler$1 = Scheduler;
var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
const lightTheme = {
  color: colorAll,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
};
var contrastColor = "#B9B8CE", backgroundColor$1 = "#100C2A", axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
}, colorPalette = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], theme = {
  darkMode: !0,
  color: colorPalette,
  backgroundColor: backgroundColor$1,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    },
    pageTextStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: contrastColor
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: contrastColor
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    label: {
      color: contrastColor
    },
    controlStyle: {
      color: contrastColor,
      borderColor: contrastColor
    }
  },
  calendar: {
    itemStyle: {
      color: backgroundColor$1
    },
    dayLabel: {
      color: contrastColor
    },
    monthLabel: {
      color: contrastColor
    },
    yearLabel: {
      color: contrastColor
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      color: contrastColor
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: contrastColor
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  }
};
theme.categoryAxis.splitLine.show = !1;
const darkTheme = theme;
var ECEventProcessor = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.normalizeQuery = function(nr) {
      var Cn = {}, Bn = {}, In = {};
      if (isString$1(nr)) {
        var Dn = parseClassType(nr);
        Cn.mainType = Dn.main || null, Cn.subType = Dn.sub || null;
      } else {
        var Ln = ["Index", "Name", "Id"], $n = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        each$f(nr, function(Nn, Rn) {
          for (var Fn = !1, Pn = 0; Pn < Ln.length; Pn++) {
            var Un = Ln[Pn], Hn = Rn.lastIndexOf(Un);
            if (Hn > 0 && Hn === Rn.length - Un.length) {
              var zn = Rn.slice(0, Hn);
              zn !== "data" && (Cn.mainType = zn, Cn[Un.toLowerCase()] = Nn, Fn = !0);
            }
          }
          $n.hasOwnProperty(Rn) && (Bn[Rn] = Nn, Fn = !0), Fn || (In[Rn] = Nn);
        });
      }
      return {
        cptQuery: Cn,
        dataQuery: Bn,
        otherQuery: In
      };
    }, _n.prototype.filter = function(nr, Cn) {
      var Bn = this.eventInfo;
      if (!Bn)
        return !0;
      var In = Bn.targetEl, Dn = Bn.packedEvent, Ln = Bn.model, $n = Bn.view;
      if (!Ln || !$n)
        return !0;
      var Nn = Cn.cptQuery, Rn = Cn.dataQuery;
      return Fn(Nn, Ln, "mainType") && Fn(Nn, Ln, "subType") && Fn(Nn, Ln, "index", "componentIndex") && Fn(Nn, Ln, "name") && Fn(Nn, Ln, "id") && Fn(Rn, Dn, "name") && Fn(Rn, Dn, "dataIndex") && Fn(Rn, Dn, "dataType") && (!$n.filterForExposedEvent || $n.filterForExposedEvent(nr, Cn.otherQuery, In, Dn));
      function Fn(Pn, Un, Hn, zn) {
        return Pn[Hn] == null || Un[zn || Hn] === Pn[Hn];
      }
    }, _n.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, _n;
  }()
), SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]), seriesSymbolTask = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(_n, nr) {
    var Cn = _n.getData();
    if (_n.legendIcon && Cn.setVisual("legendIcon", _n.legendIcon), !_n.hasSymbolVisual)
      return;
    for (var Bn = {}, In = {}, Dn = !1, Ln = 0; Ln < SYMBOL_PROPS_WITH_CB.length; Ln++) {
      var $n = SYMBOL_PROPS_WITH_CB[Ln], Nn = _n.get($n);
      isFunction$1(Nn) ? (Dn = !0, In[$n] = Nn) : Bn[$n] = Nn;
    }
    if (Bn.symbol = Bn.symbol || _n.defaultSymbol, Cn.setVisual(extend({
      legendIcon: _n.legendIcon || Bn.symbol,
      symbolKeepAspect: _n.get("symbolKeepAspect")
    }, Bn)), nr.isSeriesFiltered(_n))
      return;
    var Rn = keys(In);
    function Fn(Pn, Un) {
      for (var Hn = _n.getRawValue(Un), zn = _n.getDataParams(Un), Gn = 0; Gn < Rn.length; Gn++) {
        var Yn = Rn[Gn];
        Pn.setItemVisual(Un, Yn, In[Yn](Hn, zn));
      }
    }
    return {
      dataEach: Dn ? Fn : null
    };
  }
}, dataSymbolTask = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(_n, nr) {
    if (!_n.hasSymbolVisual || nr.isSeriesFiltered(_n))
      return;
    var Cn = _n.getData();
    function Bn(In, Dn) {
      for (var Ln = In.getItemModel(Dn), $n = 0; $n < SYMBOL_PROPS.length; $n++) {
        var Nn = SYMBOL_PROPS[$n], Rn = Ln.getShallow(Nn, !0);
        Rn != null && In.setItemVisual(Dn, Nn, Rn);
      }
    }
    return {
      dataEach: Cn.hasItemOption ? Bn : null
    };
  }
};
function getItemVisualFromData(_n, nr, Cn) {
  switch (Cn) {
    case "color":
      var Bn = _n.getItemVisual(nr, "style");
      return Bn[_n.getVisual("drawType")];
    case "opacity":
      return _n.getItemVisual(nr, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return _n.getItemVisual(nr, Cn);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + Cn);
  }
}
function getVisualFromData(_n, nr) {
  switch (nr) {
    case "color":
      var Cn = _n.getVisual("style");
      return Cn[_n.getVisual("drawType")];
    case "opacity":
      return _n.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return _n.getVisual(nr);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + nr);
  }
}
function setItemVisualFromData(_n, nr, Cn, Bn) {
  switch (Cn) {
    case "color":
      var In = _n.ensureUniqueItemVisual(nr, "style");
      In[_n.getVisual("drawType")] = Bn, _n.setItemVisual(nr, "colorFromPalette", !1);
      break;
    case "opacity":
      _n.ensureUniqueItemVisual(nr, "style").opacity = Bn;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      _n.setItemVisual(nr, Cn, Bn);
      break;
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + Cn);
  }
}
function createLegacyDataSelectAction(_n, nr) {
  function Cn(Bn, In) {
    var Dn = [];
    return Bn.eachComponent({
      mainType: "series",
      subType: _n,
      query: In
    }, function(Ln) {
      Dn.push(Ln.seriesIndex);
    }), Dn;
  }
  each$f([[_n + "ToggleSelect", "toggleSelect"], [_n + "Select", "select"], [_n + "UnSelect", "unselect"]], function(Bn) {
    nr(Bn[0], function(In, Dn, Ln) {
      In = extend({}, In), process.env.NODE_ENV !== "production" && deprecateReplaceLog(In.type, Bn[1]), Ln.dispatchAction(extend(In, {
        type: Bn[1],
        seriesIndex: Cn(Dn, In)
      }));
    });
  });
}
function handleSeriesLegacySelectEvents(_n, nr, Cn, Bn, In) {
  var Dn = _n + nr;
  Cn.isSilent(Dn) || (process.env.NODE_ENV !== "production" && deprecateLog("event " + Dn + " is deprecated."), Bn.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(Ln) {
    for (var $n = Ln.seriesIndex, Nn = Ln.option.selectedMap, Rn = In.selected, Fn = 0; Fn < Rn.length; Fn++)
      if (Rn[Fn].seriesIndex === $n) {
        var Pn = Ln.getData(), Un = queryDataIndex(Pn, In.fromActionPayload);
        Cn.trigger(Dn, {
          type: Dn,
          seriesId: Ln.id,
          name: isArray$4(Un) ? Pn.getName(Un[0]) : Pn.getName(Un),
          selected: isString$1(Nn) ? Nn : extend({}, Nn)
        });
      }
  }));
}
function handleLegacySelectEvents(_n, nr, Cn) {
  _n.on("selectchanged", function(Bn) {
    var In = Cn.getModel();
    Bn.isFromClick ? (handleSeriesLegacySelectEvents("map", "selectchanged", nr, In, Bn), handleSeriesLegacySelectEvents("pie", "selectchanged", nr, In, Bn)) : Bn.fromAction === "select" ? (handleSeriesLegacySelectEvents("map", "selected", nr, In, Bn), handleSeriesLegacySelectEvents("pie", "selected", nr, In, Bn)) : Bn.fromAction === "unselect" && (handleSeriesLegacySelectEvents("map", "unselected", nr, In, Bn), handleSeriesLegacySelectEvents("pie", "unselected", nr, In, Bn));
  });
}
function findEventDispatcher(_n, nr, Cn) {
  for (var Bn; _n && !(nr(_n) && (Bn = _n, Cn)); )
    _n = _n.__hostTarget || _n.parent;
  return Bn;
}
var wmUniqueIndex = Math.round(Math.random() * 9), supportDefineProperty = typeof Object.defineProperty == "function", WeakMap = function() {
  function _n() {
    this._id = "__ec_inner_" + wmUniqueIndex++;
  }
  return _n.prototype.get = function(nr) {
    return this._guard(nr)[this._id];
  }, _n.prototype.set = function(nr, Cn) {
    var Bn = this._guard(nr);
    return supportDefineProperty ? Object.defineProperty(Bn, this._id, {
      value: Cn,
      enumerable: !1,
      configurable: !0
    }) : Bn[this._id] = Cn, this;
  }, _n.prototype.delete = function(nr) {
    return this.has(nr) ? (delete this._guard(nr)[this._id], !0) : !1;
  }, _n.prototype.has = function(nr) {
    return !!this._guard(nr)[this._id];
  }, _n.prototype._guard = function(nr) {
    if (nr !== Object(nr))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return nr;
  }, _n;
}();
const WeakMap$1 = WeakMap;
var Triangle = Path$1.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(_n, nr) {
    var Cn = nr.cx, Bn = nr.cy, In = nr.width / 2, Dn = nr.height / 2;
    _n.moveTo(Cn, Bn - Dn), _n.lineTo(Cn + In, Bn + Dn), _n.lineTo(Cn - In, Bn + Dn), _n.closePath();
  }
}), Diamond = Path$1.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(_n, nr) {
    var Cn = nr.cx, Bn = nr.cy, In = nr.width / 2, Dn = nr.height / 2;
    _n.moveTo(Cn, Bn - Dn), _n.lineTo(Cn + In, Bn), _n.lineTo(Cn, Bn + Dn), _n.lineTo(Cn - In, Bn), _n.closePath();
  }
}), Pin = Path$1.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(_n, nr) {
    var Cn = nr.x, Bn = nr.y, In = nr.width / 5 * 3, Dn = Math.max(In, nr.height), Ln = In / 2, $n = Ln * Ln / (Dn - Ln), Nn = Bn - Dn + Ln + $n, Rn = Math.asin($n / Ln), Fn = Math.cos(Rn) * Ln, Pn = Math.sin(Rn), Un = Math.cos(Rn), Hn = Ln * 0.6, zn = Ln * 0.7;
    _n.moveTo(Cn - Fn, Nn + $n), _n.arc(Cn, Nn, Ln, Math.PI - Rn, Math.PI * 2 + Rn), _n.bezierCurveTo(Cn + Fn - Pn * Hn, Nn + $n + Un * Hn, Cn, Bn - zn, Cn, Bn), _n.bezierCurveTo(Cn, Bn - zn, Cn - Fn + Pn * Hn, Nn + $n + Un * Hn, Cn - Fn, Nn + $n), _n.closePath();
  }
}), Arrow = Path$1.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(_n, nr) {
    var Cn = nr.height, Bn = nr.width, In = nr.x, Dn = nr.y, Ln = Bn / 3 * 2;
    _n.moveTo(In, Dn), _n.lineTo(In + Ln, Dn + Cn), _n.lineTo(In, Dn + Cn / 4 * 3), _n.lineTo(In - Ln, Dn + Cn), _n.lineTo(In, Dn), _n.closePath();
  }
}), symbolCtors = {
  line: Line$3,
  rect: Rect$3,
  roundRect: Rect$3,
  square: Rect$3,
  circle: Circle$1,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
}, symbolShapeMakers = {
  line: function(_n, nr, Cn, Bn, In) {
    In.x1 = _n, In.y1 = nr + Bn / 2, In.x2 = _n + Cn, In.y2 = nr + Bn / 2;
  },
  rect: function(_n, nr, Cn, Bn, In) {
    In.x = _n, In.y = nr, In.width = Cn, In.height = Bn;
  },
  roundRect: function(_n, nr, Cn, Bn, In) {
    In.x = _n, In.y = nr, In.width = Cn, In.height = Bn, In.r = Math.min(Cn, Bn) / 4;
  },
  square: function(_n, nr, Cn, Bn, In) {
    var Dn = Math.min(Cn, Bn);
    In.x = _n, In.y = nr, In.width = Dn, In.height = Dn;
  },
  circle: function(_n, nr, Cn, Bn, In) {
    In.cx = _n + Cn / 2, In.cy = nr + Bn / 2, In.r = Math.min(Cn, Bn) / 2;
  },
  diamond: function(_n, nr, Cn, Bn, In) {
    In.cx = _n + Cn / 2, In.cy = nr + Bn / 2, In.width = Cn, In.height = Bn;
  },
  pin: function(_n, nr, Cn, Bn, In) {
    In.x = _n + Cn / 2, In.y = nr + Bn / 2, In.width = Cn, In.height = Bn;
  },
  arrow: function(_n, nr, Cn, Bn, In) {
    In.x = _n + Cn / 2, In.y = nr + Bn / 2, In.width = Cn, In.height = Bn;
  },
  triangle: function(_n, nr, Cn, Bn, In) {
    In.cx = _n + Cn / 2, In.cy = nr + Bn / 2, In.width = Cn, In.height = Bn;
  }
}, symbolBuildProxies = {};
each$f(symbolCtors, function(_n, nr) {
  symbolBuildProxies[nr] = new _n();
});
var SymbolClz$1 = Path$1.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(_n, nr, Cn) {
    var Bn = calculateTextPosition(_n, nr, Cn), In = this.shape;
    return In && In.symbolType === "pin" && nr.position === "inside" && (Bn.y = Cn.y + Cn.height * 0.4), Bn;
  },
  buildPath: function(_n, nr, Cn) {
    var Bn = nr.symbolType;
    if (Bn !== "none") {
      var In = symbolBuildProxies[Bn];
      In || (Bn = "rect", In = symbolBuildProxies[Bn]), symbolShapeMakers[Bn](nr.x, nr.y, nr.width, nr.height, In.shape), In.buildPath(_n, In.shape, Cn);
    }
  }
});
function symbolPathSetColor(_n, nr) {
  if (this.type !== "image") {
    var Cn = this.style;
    this.__isEmptyBrush ? (Cn.stroke = _n, Cn.fill = nr || "#fff", Cn.lineWidth = 2) : this.shape.symbolType === "line" ? Cn.stroke = _n : Cn.fill = _n, this.markRedraw();
  }
}
function createSymbol$1(_n, nr, Cn, Bn, In, Dn, Ln) {
  var $n = _n.indexOf("empty") === 0;
  $n && (_n = _n.substr(5, 1).toLowerCase() + _n.substr(6));
  var Nn;
  return _n.indexOf("image://") === 0 ? Nn = makeImage(_n.slice(8), new BoundingRect$1(nr, Cn, Bn, In), Ln ? "center" : "cover") : _n.indexOf("path://") === 0 ? Nn = makePath(_n.slice(7), {}, new BoundingRect$1(nr, Cn, Bn, In), Ln ? "center" : "cover") : Nn = new SymbolClz$1({
    shape: {
      symbolType: _n,
      x: nr,
      y: Cn,
      width: Bn,
      height: In
    }
  }), Nn.__isEmptyBrush = $n, Nn.setColor = symbolPathSetColor, Dn && Nn.setColor(Dn), Nn;
}
function normalizeSymbolSize(_n) {
  return isArray$4(_n) || (_n = [+_n, +_n]), [_n[0] || 0, _n[1] || 0];
}
function normalizeSymbolOffset(_n, nr) {
  if (_n != null)
    return isArray$4(_n) || (_n = [_n, _n]), [parsePercent(_n[0], nr[0]) || 0, parsePercent(retrieve2(_n[1], _n[0]), nr[1]) || 0];
}
function isSafeNum(_n) {
  return isFinite(_n);
}
function createLinearGradient(_n, nr, Cn) {
  var Bn = nr.x == null ? 0 : nr.x, In = nr.x2 == null ? 1 : nr.x2, Dn = nr.y == null ? 0 : nr.y, Ln = nr.y2 == null ? 0 : nr.y2;
  nr.global || (Bn = Bn * Cn.width + Cn.x, In = In * Cn.width + Cn.x, Dn = Dn * Cn.height + Cn.y, Ln = Ln * Cn.height + Cn.y), Bn = isSafeNum(Bn) ? Bn : 0, In = isSafeNum(In) ? In : 1, Dn = isSafeNum(Dn) ? Dn : 0, Ln = isSafeNum(Ln) ? Ln : 0;
  var $n = _n.createLinearGradient(Bn, Dn, In, Ln);
  return $n;
}
function createRadialGradient(_n, nr, Cn) {
  var Bn = Cn.width, In = Cn.height, Dn = Math.min(Bn, In), Ln = nr.x == null ? 0.5 : nr.x, $n = nr.y == null ? 0.5 : nr.y, Nn = nr.r == null ? 0.5 : nr.r;
  nr.global || (Ln = Ln * Bn + Cn.x, $n = $n * In + Cn.y, Nn = Nn * Dn), Ln = isSafeNum(Ln) ? Ln : 0.5, $n = isSafeNum($n) ? $n : 0.5, Nn = Nn >= 0 && isSafeNum(Nn) ? Nn : 0.5;
  var Rn = _n.createRadialGradient(Ln, $n, 0, Ln, $n, Nn);
  return Rn;
}
function getCanvasGradient(_n, nr, Cn) {
  for (var Bn = nr.type === "radial" ? createRadialGradient(_n, nr, Cn) : createLinearGradient(_n, nr, Cn), In = nr.colorStops, Dn = 0; Dn < In.length; Dn++)
    Bn.addColorStop(In[Dn].offset, In[Dn].color);
  return Bn;
}
function isClipPathChanged(_n, nr) {
  if (_n === nr || !_n && !nr)
    return !1;
  if (!_n || !nr || _n.length !== nr.length)
    return !0;
  for (var Cn = 0; Cn < _n.length; Cn++)
    if (_n[Cn] !== nr[Cn])
      return !0;
  return !1;
}
function parseInt10(_n) {
  return parseInt(_n, 10);
}
function getSize$1(_n, nr, Cn) {
  var Bn = ["width", "height"][nr], In = ["clientWidth", "clientHeight"][nr], Dn = ["paddingLeft", "paddingTop"][nr], Ln = ["paddingRight", "paddingBottom"][nr];
  if (Cn[Bn] != null && Cn[Bn] !== "auto")
    return parseFloat(Cn[Bn]);
  var $n = document.defaultView.getComputedStyle(_n);
  return (_n[In] || parseInt10($n[Bn]) || parseInt10(_n.style[Bn])) - (parseInt10($n[Dn]) || 0) - (parseInt10($n[Ln]) || 0) | 0;
}
function normalizeLineDash(_n, nr) {
  return !_n || _n === "solid" || !(nr > 0) ? null : _n === "dashed" ? [4 * nr, 2 * nr] : _n === "dotted" ? [nr] : isNumber(_n) ? [_n] : isArray$4(_n) ? _n : null;
}
function getLineDash(_n) {
  var nr = _n.style, Cn = nr.lineDash && nr.lineWidth > 0 && normalizeLineDash(nr.lineDash, nr.lineWidth), Bn = nr.lineDashOffset;
  if (Cn) {
    var In = nr.strokeNoScale && _n.getLineScale ? _n.getLineScale() : 1;
    In && In !== 1 && (Cn = map$1(Cn, function(Dn) {
      return Dn / In;
    }), Bn /= In);
  }
  return [Cn, Bn];
}
var pathProxyForDraw = new PathProxy$1(!0);
function styleHasStroke(_n) {
  var nr = _n.stroke;
  return !(nr == null || nr === "none" || !(_n.lineWidth > 0));
}
function isValidStrokeFillStyle(_n) {
  return typeof _n == "string" && _n !== "none";
}
function styleHasFill(_n) {
  var nr = _n.fill;
  return nr != null && nr !== "none";
}
function doFillPath(_n, nr) {
  if (nr.fillOpacity != null && nr.fillOpacity !== 1) {
    var Cn = _n.globalAlpha;
    _n.globalAlpha = nr.fillOpacity * nr.opacity, _n.fill(), _n.globalAlpha = Cn;
  } else
    _n.fill();
}
function doStrokePath(_n, nr) {
  if (nr.strokeOpacity != null && nr.strokeOpacity !== 1) {
    var Cn = _n.globalAlpha;
    _n.globalAlpha = nr.strokeOpacity * nr.opacity, _n.stroke(), _n.globalAlpha = Cn;
  } else
    _n.stroke();
}
function createCanvasPattern(_n, nr, Cn) {
  var Bn = createOrUpdateImage(nr.image, nr.__image, Cn);
  if (isImageReady(Bn)) {
    var In = _n.createPattern(Bn, nr.repeat || "repeat");
    if (typeof DOMMatrix == "function" && In && In.setTransform) {
      var Dn = new DOMMatrix();
      Dn.translateSelf(nr.x || 0, nr.y || 0), Dn.rotateSelf(0, 0, (nr.rotation || 0) * RADIAN_TO_DEGREE), Dn.scaleSelf(nr.scaleX || 1, nr.scaleY || 1), In.setTransform(Dn);
    }
    return In;
  }
}
function brushPath(_n, nr, Cn, Bn) {
  var In, Dn = styleHasStroke(Cn), Ln = styleHasFill(Cn), $n = Cn.strokePercent, Nn = $n < 1, Rn = !nr.path;
  (!nr.silent || Nn) && Rn && nr.createPathProxy();
  var Fn = nr.path || pathProxyForDraw, Pn = nr.__dirty;
  if (!Bn) {
    var Un = Cn.fill, Hn = Cn.stroke, zn = Ln && !!Un.colorStops, Gn = Dn && !!Hn.colorStops, Yn = Ln && !!Un.image, Wn = Dn && !!Hn.image, Xn = void 0, ea = void 0, ta = void 0, na = void 0, ra = void 0;
    (zn || Gn) && (ra = nr.getBoundingRect()), zn && (Xn = Pn ? getCanvasGradient(_n, Un, ra) : nr.__canvasFillGradient, nr.__canvasFillGradient = Xn), Gn && (ea = Pn ? getCanvasGradient(_n, Hn, ra) : nr.__canvasStrokeGradient, nr.__canvasStrokeGradient = ea), Yn && (ta = Pn || !nr.__canvasFillPattern ? createCanvasPattern(_n, Un, nr) : nr.__canvasFillPattern, nr.__canvasFillPattern = ta), Wn && (na = Pn || !nr.__canvasStrokePattern ? createCanvasPattern(_n, Hn, nr) : nr.__canvasStrokePattern, nr.__canvasStrokePattern = ta), zn ? _n.fillStyle = Xn : Yn && (ta ? _n.fillStyle = ta : Ln = !1), Gn ? _n.strokeStyle = ea : Wn && (na ? _n.strokeStyle = na : Dn = !1);
  }
  var aa = nr.getGlobalScale();
  Fn.setScale(aa[0], aa[1], nr.segmentIgnoreThreshold);
  var ia, Aa;
  _n.setLineDash && Cn.lineDash && (In = getLineDash(nr), ia = In[0], Aa = In[1]);
  var sa = !0;
  (Rn || Pn & SHAPE_CHANGED_BIT) && (Fn.setDPR(_n.dpr), Nn ? Fn.setContext(null) : (Fn.setContext(_n), sa = !1), Fn.reset(), nr.buildPath(Fn, nr.shape, Bn), Fn.toStatic(), nr.pathUpdated()), sa && Fn.rebuildPath(_n, Nn ? $n : 1), ia && (_n.setLineDash(ia), _n.lineDashOffset = Aa), Bn || (Cn.strokeFirst ? (Dn && doStrokePath(_n, Cn), Ln && doFillPath(_n, Cn)) : (Ln && doFillPath(_n, Cn), Dn && doStrokePath(_n, Cn))), ia && _n.setLineDash([]);
}
function brushImage(_n, nr, Cn) {
  var Bn = nr.__image = createOrUpdateImage(Cn.image, nr.__image, nr, nr.onload);
  if (!(!Bn || !isImageReady(Bn))) {
    var In = Cn.x || 0, Dn = Cn.y || 0, Ln = nr.getWidth(), $n = nr.getHeight(), Nn = Bn.width / Bn.height;
    if (Ln == null && $n != null ? Ln = $n * Nn : $n == null && Ln != null ? $n = Ln / Nn : Ln == null && $n == null && (Ln = Bn.width, $n = Bn.height), Cn.sWidth && Cn.sHeight) {
      var Rn = Cn.sx || 0, Fn = Cn.sy || 0;
      _n.drawImage(Bn, Rn, Fn, Cn.sWidth, Cn.sHeight, In, Dn, Ln, $n);
    } else if (Cn.sx && Cn.sy) {
      var Rn = Cn.sx, Fn = Cn.sy, Pn = Ln - Rn, Un = $n - Fn;
      _n.drawImage(Bn, Rn, Fn, Pn, Un, In, Dn, Ln, $n);
    } else
      _n.drawImage(Bn, In, Dn, Ln, $n);
  }
}
function brushText(_n, nr, Cn) {
  var Bn, In = Cn.text;
  if (In != null && (In += ""), In) {
    _n.font = Cn.font || DEFAULT_FONT, _n.textAlign = Cn.textAlign, _n.textBaseline = Cn.textBaseline;
    var Dn = void 0, Ln = void 0;
    _n.setLineDash && Cn.lineDash && (Bn = getLineDash(nr), Dn = Bn[0], Ln = Bn[1]), Dn && (_n.setLineDash(Dn), _n.lineDashOffset = Ln), Cn.strokeFirst ? (styleHasStroke(Cn) && _n.strokeText(In, Cn.x, Cn.y), styleHasFill(Cn) && _n.fillText(In, Cn.x, Cn.y)) : (styleHasFill(Cn) && _n.fillText(In, Cn.x, Cn.y), styleHasStroke(Cn) && _n.strokeText(In, Cn.x, Cn.y)), Dn && _n.setLineDash([]);
  }
}
var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], STROKE_PROPS = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function bindCommonProps(_n, nr, Cn, Bn, In) {
  var Dn = !1;
  if (!Bn && (Cn = Cn || {}, nr === Cn))
    return !1;
  if (Bn || nr.opacity !== Cn.opacity) {
    flushPathDrawn(_n, In), Dn = !0;
    var Ln = Math.max(Math.min(nr.opacity, 1), 0);
    _n.globalAlpha = isNaN(Ln) ? DEFAULT_COMMON_STYLE.opacity : Ln;
  }
  (Bn || nr.blend !== Cn.blend) && (Dn || (flushPathDrawn(_n, In), Dn = !0), _n.globalCompositeOperation = nr.blend || DEFAULT_COMMON_STYLE.blend);
  for (var $n = 0; $n < SHADOW_NUMBER_PROPS.length; $n++) {
    var Nn = SHADOW_NUMBER_PROPS[$n];
    (Bn || nr[Nn] !== Cn[Nn]) && (Dn || (flushPathDrawn(_n, In), Dn = !0), _n[Nn] = _n.dpr * (nr[Nn] || 0));
  }
  return (Bn || nr.shadowColor !== Cn.shadowColor) && (Dn || (flushPathDrawn(_n, In), Dn = !0), _n.shadowColor = nr.shadowColor || DEFAULT_COMMON_STYLE.shadowColor), Dn;
}
function bindPathAndTextCommonStyle(_n, nr, Cn, Bn, In) {
  var Dn = getStyle(nr, In.inHover), Ln = Bn ? null : Cn && getStyle(Cn, In.inHover) || {};
  if (Dn === Ln)
    return !1;
  var $n = bindCommonProps(_n, Dn, Ln, Bn, In);
  if ((Bn || Dn.fill !== Ln.fill) && ($n || (flushPathDrawn(_n, In), $n = !0), isValidStrokeFillStyle(Dn.fill) && (_n.fillStyle = Dn.fill)), (Bn || Dn.stroke !== Ln.stroke) && ($n || (flushPathDrawn(_n, In), $n = !0), isValidStrokeFillStyle(Dn.stroke) && (_n.strokeStyle = Dn.stroke)), (Bn || Dn.opacity !== Ln.opacity) && ($n || (flushPathDrawn(_n, In), $n = !0), _n.globalAlpha = Dn.opacity == null ? 1 : Dn.opacity), nr.hasStroke()) {
    var Nn = Dn.lineWidth, Rn = Nn / (Dn.strokeNoScale && nr.getLineScale ? nr.getLineScale() : 1);
    _n.lineWidth !== Rn && ($n || (flushPathDrawn(_n, In), $n = !0), _n.lineWidth = Rn);
  }
  for (var Fn = 0; Fn < STROKE_PROPS.length; Fn++) {
    var Pn = STROKE_PROPS[Fn], Un = Pn[0];
    (Bn || Dn[Un] !== Ln[Un]) && ($n || (flushPathDrawn(_n, In), $n = !0), _n[Un] = Dn[Un] || Pn[1]);
  }
  return $n;
}
function bindImageStyle(_n, nr, Cn, Bn, In) {
  return bindCommonProps(_n, getStyle(nr, In.inHover), Cn && getStyle(Cn, In.inHover), Bn, In);
}
function setContextTransform(_n, nr) {
  var Cn = nr.transform, Bn = _n.dpr || 1;
  Cn ? _n.setTransform(Bn * Cn[0], Bn * Cn[1], Bn * Cn[2], Bn * Cn[3], Bn * Cn[4], Bn * Cn[5]) : _n.setTransform(Bn, 0, 0, Bn, 0, 0);
}
function updateClipStatus(_n, nr, Cn) {
  for (var Bn = !1, In = 0; In < _n.length; In++) {
    var Dn = _n[In];
    Bn = Bn || Dn.isZeroArea(), setContextTransform(nr, Dn), nr.beginPath(), Dn.buildPath(nr, Dn.shape), nr.clip();
  }
  Cn.allClipped = Bn;
}
function isTransformChanged(_n, nr) {
  return _n && nr ? _n[0] !== nr[0] || _n[1] !== nr[1] || _n[2] !== nr[2] || _n[3] !== nr[3] || _n[4] !== nr[4] || _n[5] !== nr[5] : !(!_n && !nr);
}
var DRAW_TYPE_PATH = 1, DRAW_TYPE_IMAGE = 2, DRAW_TYPE_TEXT = 3, DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(_n) {
  var nr = styleHasFill(_n), Cn = styleHasStroke(_n);
  return !(_n.lineDash || !(+nr ^ +Cn) || nr && typeof _n.fill != "string" || Cn && typeof _n.stroke != "string" || _n.strokePercent < 1 || _n.strokeOpacity < 1 || _n.fillOpacity < 1);
}
function flushPathDrawn(_n, nr) {
  nr.batchFill && _n.fill(), nr.batchStroke && _n.stroke(), nr.batchFill = "", nr.batchStroke = "";
}
function getStyle(_n, nr) {
  return nr && _n.__hoverStyle || _n.style;
}
function brushSingle(_n, nr) {
  brush$1(_n, nr, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function brush$1(_n, nr, Cn, Bn) {
  var In = nr.transform;
  if (!nr.shouldBePainted(Cn.viewWidth, Cn.viewHeight, !1, !1)) {
    nr.__dirty &= ~REDRAW_BIT, nr.__isRendered = !1;
    return;
  }
  var Dn = nr.__clipPaths, Ln = Cn.prevElClipPaths, $n = !1, Nn = !1;
  if ((!Ln || isClipPathChanged(Dn, Ln)) && (Ln && Ln.length && (flushPathDrawn(_n, Cn), _n.restore(), Nn = $n = !0, Cn.prevElClipPaths = null, Cn.allClipped = !1, Cn.prevEl = null), Dn && Dn.length && (flushPathDrawn(_n, Cn), _n.save(), updateClipStatus(Dn, _n, Cn), $n = !0), Cn.prevElClipPaths = Dn), Cn.allClipped) {
    nr.__isRendered = !1;
    return;
  }
  nr.beforeBrush && nr.beforeBrush(), nr.innerBeforeBrush();
  var Rn = Cn.prevEl;
  Rn || (Nn = $n = !0);
  var Fn = nr instanceof Path$1 && nr.autoBatch && canPathBatch(nr.style);
  $n || isTransformChanged(In, Rn.transform) ? (flushPathDrawn(_n, Cn), setContextTransform(_n, nr)) : Fn || flushPathDrawn(_n, Cn);
  var Pn = getStyle(nr, Cn.inHover);
  nr instanceof Path$1 ? (Cn.lastDrawType !== DRAW_TYPE_PATH && (Nn = !0, Cn.lastDrawType = DRAW_TYPE_PATH), bindPathAndTextCommonStyle(_n, nr, Rn, Nn, Cn), (!Fn || !Cn.batchFill && !Cn.batchStroke) && _n.beginPath(), brushPath(_n, nr, Pn, Fn), Fn && (Cn.batchFill = Pn.fill || "", Cn.batchStroke = Pn.stroke || "")) : nr instanceof TSpan$1 ? (Cn.lastDrawType !== DRAW_TYPE_TEXT && (Nn = !0, Cn.lastDrawType = DRAW_TYPE_TEXT), bindPathAndTextCommonStyle(_n, nr, Rn, Nn, Cn), brushText(_n, nr, Pn)) : nr instanceof ZRImage$1 ? (Cn.lastDrawType !== DRAW_TYPE_IMAGE && (Nn = !0, Cn.lastDrawType = DRAW_TYPE_IMAGE), bindImageStyle(_n, nr, Rn, Nn, Cn), brushImage(_n, nr, Pn)) : nr.getTemporalDisplayables && (Cn.lastDrawType !== DRAW_TYPE_INCREMENTAL && (Nn = !0, Cn.lastDrawType = DRAW_TYPE_INCREMENTAL), brushIncremental(_n, nr, Cn)), Fn && Bn && flushPathDrawn(_n, Cn), nr.innerAfterBrush(), nr.afterBrush && nr.afterBrush(), Cn.prevEl = nr, nr.__dirty = 0, nr.__isRendered = !0;
}
function brushIncremental(_n, nr, Cn) {
  var Bn = nr.getDisplayables(), In = nr.getTemporalDisplayables();
  _n.save();
  var Dn = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: Cn.viewWidth,
    viewHeight: Cn.viewHeight,
    inHover: Cn.inHover
  }, Ln, $n;
  for (Ln = nr.getCursor(), $n = Bn.length; Ln < $n; Ln++) {
    var Nn = Bn[Ln];
    Nn.beforeBrush && Nn.beforeBrush(), Nn.innerBeforeBrush(), brush$1(_n, Nn, Dn, Ln === $n - 1), Nn.innerAfterBrush(), Nn.afterBrush && Nn.afterBrush(), Dn.prevEl = Nn;
  }
  for (var Rn = 0, Fn = In.length; Rn < Fn; Rn++) {
    var Nn = In[Rn];
    Nn.beforeBrush && Nn.beforeBrush(), Nn.innerBeforeBrush(), brush$1(_n, Nn, Dn, Rn === Fn - 1), Nn.innerAfterBrush(), Nn.afterBrush && Nn.afterBrush(), Dn.prevEl = Nn;
  }
  nr.clearTemporalDisplayables(), nr.notClear = !0, _n.restore();
}
var decalMap = new WeakMap$1(), decalCache = new LRU$1(100), decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function createOrUpdatePatternFromDecal(_n, nr) {
  if (_n === "none")
    return null;
  var Cn = nr.getDevicePixelRatio(), Bn = nr.getZr(), In = Bn.painter.type === "svg";
  _n.dirty && decalMap.delete(_n);
  var Dn = decalMap.get(_n);
  if (Dn)
    return Dn;
  var Ln = defaults(_n, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  Ln.backgroundColor === "none" && (Ln.backgroundColor = null);
  var $n = {
    repeat: "repeat"
  };
  return Nn($n), $n.rotation = Ln.rotation, $n.scaleX = $n.scaleY = In ? 1 : 1 / Cn, decalMap.set(_n, $n), _n.dirty = !1, $n;
  function Nn(Rn) {
    for (var Fn = [Cn], Pn = !0, Un = 0; Un < decalKeys.length; ++Un) {
      var Hn = Ln[decalKeys[Un]];
      if (Hn != null && !isArray$4(Hn) && !isString$1(Hn) && !isNumber(Hn) && typeof Hn != "boolean") {
        Pn = !1;
        break;
      }
      Fn.push(Hn);
    }
    var zn;
    if (Pn) {
      zn = Fn.join(",") + (In ? "-svg" : "");
      var Gn = decalCache.get(zn);
      Gn && (In ? Rn.svgElement = Gn : Rn.image = Gn);
    }
    var Yn = normalizeDashArrayX(Ln.dashArrayX), Wn = normalizeDashArrayY(Ln.dashArrayY), Xn = normalizeSymbolArray(Ln.symbol), ea = getLineBlockLengthX(Yn), ta = getLineBlockLengthY(Wn), na = !In && platformApi.createCanvas(), ra = In && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, aa = Aa(), ia;
    na && (na.width = aa.width * Cn, na.height = aa.height * Cn, ia = na.getContext("2d")), sa(), Pn && decalCache.put(zn, na || ra), Rn.image = na, Rn.svgElement = ra, Rn.svgWidth = aa.width, Rn.svgHeight = aa.height;
    function Aa() {
      for (var oa = 1, la = 0, ua = ea.length; la < ua; ++la)
        oa = getLeastCommonMultiple(oa, ea[la]);
      for (var ca = 1, la = 0, ua = Xn.length; la < ua; ++la)
        ca = getLeastCommonMultiple(ca, Xn[la].length);
      oa *= ca;
      var fa = ta * ea.length * Xn.length;
      if (process.env.NODE_ENV !== "production") {
        var ha = function(pa) {
          console.warn("Calculated decal size is greater than " + pa + " due to decal option settings so " + pa + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + pa + " to be larger to avoid incontinuity.");
        };
        oa > Ln.maxTileWidth && ha("maxTileWidth"), fa > Ln.maxTileHeight && ha("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(oa, Ln.maxTileWidth)),
        height: Math.max(1, Math.min(fa, Ln.maxTileHeight))
      };
    }
    function sa() {
      ia && (ia.clearRect(0, 0, na.width, na.height), Ln.backgroundColor && (ia.fillStyle = Ln.backgroundColor, ia.fillRect(0, 0, na.width, na.height)));
      for (var oa = 0, la = 0; la < Wn.length; ++la)
        oa += Wn[la];
      if (oa <= 0)
        return;
      for (var ua = -ta, ca = 0, fa = 0, ha = 0; ua < aa.height; ) {
        if (ca % 2 === 0) {
          for (var pa = fa / 2 % Xn.length, ya = 0, da = 0, Ca = 0; ya < aa.width * 2; ) {
            for (var ma = 0, la = 0; la < Yn[ha].length; ++la)
              ma += Yn[ha][la];
            if (ma <= 0)
              break;
            if (da % 2 === 0) {
              var va = (1 - Ln.symbolSize) * 0.5, ga = ya + Yn[ha][da] * va, xa = ua + Wn[ca] * va, wa = Yn[ha][da] * Ln.symbolSize, ba = Wn[ca] * Ln.symbolSize, Ta = Ca / 2 % Xn[pa].length;
              Sa(ga, xa, wa, ba, Xn[pa][Ta]);
            }
            ya += Yn[ha][da], ++Ca, ++da, da === Yn[ha].length && (da = 0);
          }
          ++ha, ha === Yn.length && (ha = 0);
        }
        ua += Wn[ca], ++fa, ++ca, ca === Wn.length && (ca = 0);
      }
      function Sa(Ea, Ia, Ba, Ma, La) {
        var Da = In ? 1 : Cn, Na = createSymbol$1(La, Ea * Da, Ia * Da, Ba * Da, Ma * Da, Ln.color, Ln.symbolKeepAspect);
        if (In) {
          var $a = Bn.painter.renderOneToVNode(Na);
          $a && ra.children.push($a);
        } else
          brushSingle(ia, Na);
      }
    }
  }
}
function normalizeSymbolArray(_n) {
  if (!_n || _n.length === 0)
    return [["rect"]];
  if (isString$1(_n))
    return [[_n]];
  for (var nr = !0, Cn = 0; Cn < _n.length; ++Cn)
    if (!isString$1(_n[Cn])) {
      nr = !1;
      break;
    }
  if (nr)
    return normalizeSymbolArray([_n]);
  for (var Bn = [], Cn = 0; Cn < _n.length; ++Cn)
    isString$1(_n[Cn]) ? Bn.push([_n[Cn]]) : Bn.push(_n[Cn]);
  return Bn;
}
function normalizeDashArrayX(_n) {
  if (!_n || _n.length === 0)
    return [[0, 0]];
  if (isNumber(_n)) {
    var nr = Math.ceil(_n);
    return [[nr, nr]];
  }
  for (var Cn = !0, Bn = 0; Bn < _n.length; ++Bn)
    if (!isNumber(_n[Bn])) {
      Cn = !1;
      break;
    }
  if (Cn)
    return normalizeDashArrayX([_n]);
  for (var In = [], Bn = 0; Bn < _n.length; ++Bn)
    if (isNumber(_n[Bn])) {
      var nr = Math.ceil(_n[Bn]);
      In.push([nr, nr]);
    } else {
      var nr = map$1(_n[Bn], function($n) {
        return Math.ceil($n);
      });
      nr.length % 2 === 1 ? In.push(nr.concat(nr)) : In.push(nr);
    }
  return In;
}
function normalizeDashArrayY(_n) {
  if (!_n || typeof _n == "object" && _n.length === 0)
    return [0, 0];
  if (isNumber(_n)) {
    var nr = Math.ceil(_n);
    return [nr, nr];
  }
  var Cn = map$1(_n, function(Bn) {
    return Math.ceil(Bn);
  });
  return _n.length % 2 ? Cn.concat(Cn) : Cn;
}
function getLineBlockLengthX(_n) {
  return map$1(_n, function(nr) {
    return getLineBlockLengthY(nr);
  });
}
function getLineBlockLengthY(_n) {
  for (var nr = 0, Cn = 0; Cn < _n.length; ++Cn)
    nr += _n[Cn];
  return _n.length % 2 === 1 ? nr * 2 : nr;
}
function decalVisual(_n, nr) {
  _n.eachRawSeries(function(Cn) {
    if (!_n.isSeriesFiltered(Cn)) {
      var Bn = Cn.getData();
      Bn.hasItemVisual() && Bn.each(function(Ln) {
        var $n = Bn.getItemVisual(Ln, "decal");
        if ($n) {
          var Nn = Bn.ensureUniqueItemVisual(Ln, "style");
          Nn.decal = createOrUpdatePatternFromDecal($n, nr);
        }
      });
      var In = Bn.getVisual("decal");
      if (In) {
        var Dn = Bn.getVisual("style");
        Dn.decal = createOrUpdatePatternFromDecal(In, nr);
      }
    }
  });
}
var lifecycle = new Eventful$1();
const lifecycle$1 = lifecycle;
var implsStore = {};
function registerImpl(_n, nr) {
  process.env.NODE_ENV !== "production" && implsStore[_n] && error("Already has an implementation of " + _n + "."), implsStore[_n] = nr;
}
function getImpl(_n) {
  return process.env.NODE_ENV !== "production" && (implsStore[_n] || error("Implementation of " + _n + " doesn't exists.")), implsStore[_n];
}
var version$2 = "5.6.0", dependencies = {
  zrender: "5.6.1"
}, TEST_FRAME_REMAIN_TIME = 1, PRIORITY_PROCESSOR_SERIES_FILTER = 800, PRIORITY_PROCESSOR_DATASTACK = 900, PRIORITY_PROCESSOR_FILTER = 1e3, PRIORITY_PROCESSOR_DEFAULT = 2e3, PRIORITY_PROCESSOR_STATISTIC = 5e3, PRIORITY_VISUAL_LAYOUT = 1e3, PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100, PRIORITY_VISUAL_GLOBAL = 2e3, PRIORITY_VISUAL_CHART = 3e3, PRIORITY_VISUAL_COMPONENT = 4e3, PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500, PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600, PRIORITY_VISUAL_BRUSH = 5e3, PRIORITY_VISUAL_ARIA = 6e3, PRIORITY_VISUAL_DECAL = 7e3, PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
}, IN_MAIN_PROCESS_KEY = "__flagInMainProcess", PENDING_UPDATE = "__pendingUpdate", STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus", ACTION_REG = /^[a-zA-Z0-9_]+$/, CONNECT_STATUS_KEY = "__connectUpdateStatus", CONNECT_STATUS_PENDING = 0, CONNECT_STATUS_UPDATING = 1, CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(_n) {
  return function() {
    for (var nr = [], Cn = 0; Cn < arguments.length; Cn++)
      nr[Cn] = arguments[Cn];
    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }
    return toLowercaseNameAndCallEventful(this, _n, nr);
  };
}
function createRegisterEventWithLowercaseMessageCenter(_n) {
  return function() {
    for (var nr = [], Cn = 0; Cn < arguments.length; Cn++)
      nr[Cn] = arguments[Cn];
    return toLowercaseNameAndCallEventful(this, _n, nr);
  };
}
function toLowercaseNameAndCallEventful(_n, nr, Cn) {
  return Cn[0] = Cn[0] && Cn[0].toLowerCase(), Eventful$1.prototype[nr].apply(_n, Cn);
}
var MessageCenter = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr;
  }(Eventful$1)
), messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare, prepareView, updateDirectly, updateMethods, doConvertPixel, updateStreamModes, doDispatchAction, flushPendingActions, triggerUpdatedEvent, bindRenderedEvent, bindMouseEvent, render, renderComponents, renderSeries, createExtensionAPI, enableConnect, markStatusToUpdate, applyChangedStates, ECharts = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In) {
      var Dn = _n.call(this, new ECEventProcessor()) || this;
      Dn._chartsViews = [], Dn._chartsMap = {}, Dn._componentsViews = [], Dn._componentsMap = {}, Dn._pendingActions = [], In = In || {}, isString$1(Bn) && (Bn = themeStorage[Bn]), Dn._dom = Cn;
      var Ln = "canvas", $n = "auto", Nn = !1;
      if (process.env.NODE_ENV !== "production") {
        var Rn = (
          /* eslint-disable-next-line */
          env$1.hasGlobalWindow ? window : global
        );
        Rn && (Ln = retrieve2(Rn.__ECHARTS__DEFAULT__RENDERER__, Ln), $n = retrieve2(Rn.__ECHARTS__DEFAULT__COARSE_POINTER, $n), Nn = retrieve2(Rn.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, Nn));
      }
      In.ssr && registerSSRDataGetter(function(Hn) {
        var zn = getECData(Hn), Gn = zn.dataIndex;
        if (Gn != null) {
          var Yn = createHashMap();
          return Yn.set("series_index", zn.seriesIndex), Yn.set("data_index", Gn), zn.ssrType && Yn.set("ssr_type", zn.ssrType), Yn;
        }
      });
      var Fn = Dn._zr = init$2(Cn, {
        renderer: In.renderer || Ln,
        devicePixelRatio: In.devicePixelRatio,
        width: In.width,
        height: In.height,
        ssr: In.ssr,
        useDirtyRect: retrieve2(In.useDirtyRect, Nn),
        useCoarsePointer: retrieve2(In.useCoarsePointer, $n),
        pointerSize: In.pointerSize
      });
      Dn._ssr = In.ssr, Dn._throttledZrFlush = throttle(bind$1(Fn.flush, Fn), 17), Bn = clone$4(Bn), Bn && globalBackwardCompat(Bn, !0), Dn._theme = Bn, Dn._locale = createLocaleObject(In.locale || SYSTEM_LANG), Dn._coordSysMgr = new CoordinateSystem();
      var Pn = Dn._api = createExtensionAPI(Dn);
      function Un(Hn, zn) {
        return Hn.__prio - zn.__prio;
      }
      return sort$2(visualFuncs, Un), sort$2(dataProcessorFuncs, Un), Dn._scheduler = new Scheduler$1(Dn, Pn, dataProcessorFuncs, visualFuncs), Dn._messageCenter = new MessageCenter(), Dn._initEvents(), Dn.resize = bind$1(Dn.resize, Dn), Fn.animation.on("frame", Dn._onframe, Dn), bindRenderedEvent(Fn, Dn), bindMouseEvent(Fn, Dn), setAsPrimitive(Dn), Dn;
    }
    return nr.prototype._onframe = function() {
      if (!this._disposed) {
        applyChangedStates(this);
        var Cn = this._scheduler;
        if (this[PENDING_UPDATE]) {
          var Bn = this[PENDING_UPDATE].silent;
          this[IN_MAIN_PROCESS_KEY] = !0;
          try {
            prepare(this), updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
          } catch (Nn) {
            throw this[IN_MAIN_PROCESS_KEY] = !1, this[PENDING_UPDATE] = null, Nn;
          }
          this._zr.flush(), this[IN_MAIN_PROCESS_KEY] = !1, this[PENDING_UPDATE] = null, flushPendingActions.call(this, Bn), triggerUpdatedEvent.call(this, Bn);
        } else if (Cn.unfinished) {
          var In = TEST_FRAME_REMAIN_TIME, Dn = this._model, Ln = this._api;
          Cn.unfinished = !1;
          do {
            var $n = +/* @__PURE__ */ new Date();
            Cn.performSeriesTasks(Dn), Cn.performDataProcessorTasks(Dn), updateStreamModes(this, Dn), Cn.performVisualTasks(Dn), renderSeries(this, this._model, Ln, "remain", {}), In -= +/* @__PURE__ */ new Date() - $n;
          } while (In > 0 && Cn.unfinished);
          Cn.unfinished || this._zr.flush();
        }
      }
    }, nr.prototype.getDom = function() {
      return this._dom;
    }, nr.prototype.getId = function() {
      return this.id;
    }, nr.prototype.getZr = function() {
      return this._zr;
    }, nr.prototype.isSSR = function() {
      return this._ssr;
    }, nr.prototype.setOption = function(Cn, Bn, In) {
      if (this[IN_MAIN_PROCESS_KEY]) {
        process.env.NODE_ENV !== "production" && error("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var Dn, Ln, $n;
      if (isObject$6(Bn) && (In = Bn.lazyUpdate, Dn = Bn.silent, Ln = Bn.replaceMerge, $n = Bn.transition, Bn = Bn.notMerge), this[IN_MAIN_PROCESS_KEY] = !0, !this._model || Bn) {
        var Nn = new OptionManager$1(this._api), Rn = this._theme, Fn = this._model = new GlobalModel$1();
        Fn.scheduler = this._scheduler, Fn.ssr = this._ssr, Fn.init(null, null, null, Rn, this._locale, Nn);
      }
      this._model.setOption(Cn, {
        replaceMerge: Ln
      }, optionPreprocessorFuncs);
      var Pn = {
        seriesTransition: $n,
        optionChanged: !0
      };
      if (In)
        this[PENDING_UPDATE] = {
          silent: Dn,
          updateParams: Pn
        }, this[IN_MAIN_PROCESS_KEY] = !1, this.getZr().wakeUp();
      else {
        try {
          prepare(this), updateMethods.update.call(this, null, Pn);
        } catch (Un) {
          throw this[PENDING_UPDATE] = null, this[IN_MAIN_PROCESS_KEY] = !1, Un;
        }
        this._ssr || this._zr.flush(), this[PENDING_UPDATE] = null, this[IN_MAIN_PROCESS_KEY] = !1, flushPendingActions.call(this, Dn), triggerUpdatedEvent.call(this, Dn);
      }
    }, nr.prototype.setTheme = function() {
      deprecateLog("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    }, nr.prototype.getModel = function() {
      return this._model;
    }, nr.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, nr.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, nr.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, nr.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || env$1.hasGlobalWindow && window.devicePixelRatio || 1;
    }, nr.prototype.getRenderedCanvas = function(Cn) {
      return process.env.NODE_ENV !== "production" && deprecateReplaceLog("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(Cn);
    }, nr.prototype.renderToCanvas = function(Cn) {
      Cn = Cn || {};
      var Bn = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && Bn.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return Bn.getRenderedCanvas({
        backgroundColor: Cn.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: Cn.pixelRatio || this.getDevicePixelRatio()
      });
    }, nr.prototype.renderToSVGString = function(Cn) {
      Cn = Cn || {};
      var Bn = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && Bn.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return Bn.renderToString({
        useViewBox: Cn.useViewBox
      });
    }, nr.prototype.getSvgDataURL = function() {
      if (env$1.svgSupported) {
        var Cn = this._zr, Bn = Cn.storage.getDisplayList();
        return each$f(Bn, function(In) {
          In.stopAnimation(null, !0);
        }), Cn.painter.toDataURL();
      }
    }, nr.prototype.getDataURL = function(Cn) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      Cn = Cn || {};
      var Bn = Cn.excludeComponents, In = this._model, Dn = [], Ln = this;
      each$f(Bn, function(Nn) {
        In.eachComponent({
          mainType: Nn
        }, function(Rn) {
          var Fn = Ln._componentsMap[Rn.__viewId];
          Fn.group.ignore || (Dn.push(Fn), Fn.group.ignore = !0);
        });
      });
      var $n = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(Cn).toDataURL("image/" + (Cn && Cn.type || "png"));
      return each$f(Dn, function(Nn) {
        Nn.group.ignore = !1;
      }), $n;
    }, nr.prototype.getConnectedDataURL = function(Cn) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var Bn = Cn.type === "svg", In = this.group, Dn = Math.min, Ln = Math.max, $n = 1 / 0;
      if (connectedGroups[In]) {
        var Nn = $n, Rn = $n, Fn = -$n, Pn = -$n, Un = [], Hn = Cn && Cn.pixelRatio || this.getDevicePixelRatio();
        each$f(instances, function(ea, ta) {
          if (ea.group === In) {
            var na = Bn ? ea.getZr().painter.getSvgDom().innerHTML : ea.renderToCanvas(clone$4(Cn)), ra = ea.getDom().getBoundingClientRect();
            Nn = Dn(ra.left, Nn), Rn = Dn(ra.top, Rn), Fn = Ln(ra.right, Fn), Pn = Ln(ra.bottom, Pn), Un.push({
              dom: na,
              left: ra.left,
              top: ra.top
            });
          }
        }), Nn *= Hn, Rn *= Hn, Fn *= Hn, Pn *= Hn;
        var zn = Fn - Nn, Gn = Pn - Rn, Yn = platformApi.createCanvas(), Wn = init$2(Yn, {
          renderer: Bn ? "svg" : "canvas"
        });
        if (Wn.resize({
          width: zn,
          height: Gn
        }), Bn) {
          var Xn = "";
          return each$f(Un, function(ea) {
            var ta = ea.left - Nn, na = ea.top - Rn;
            Xn += '<g transform="translate(' + ta + "," + na + ')">' + ea.dom + "</g>";
          }), Wn.painter.getSvgRoot().innerHTML = Xn, Cn.connectedBackgroundColor && Wn.painter.setBackgroundColor(Cn.connectedBackgroundColor), Wn.refreshImmediately(), Wn.painter.toDataURL();
        } else
          return Cn.connectedBackgroundColor && Wn.add(new Rect$3({
            shape: {
              x: 0,
              y: 0,
              width: zn,
              height: Gn
            },
            style: {
              fill: Cn.connectedBackgroundColor
            }
          })), each$f(Un, function(ea) {
            var ta = new ZRImage$1({
              style: {
                x: ea.left * Hn - Nn,
                y: ea.top * Hn - Rn,
                image: ea.dom
              }
            });
            Wn.add(ta);
          }), Wn.refreshImmediately(), Yn.toDataURL("image/" + (Cn && Cn.type || "png"));
      } else
        return this.getDataURL(Cn);
    }, nr.prototype.convertToPixel = function(Cn, Bn) {
      return doConvertPixel(this, "convertToPixel", Cn, Bn);
    }, nr.prototype.convertFromPixel = function(Cn, Bn) {
      return doConvertPixel(this, "convertFromPixel", Cn, Bn);
    }, nr.prototype.containPixel = function(Cn, Bn) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var In = this._model, Dn, Ln = parseFinder$1(In, Cn);
      return each$f(Ln, function($n, Nn) {
        Nn.indexOf("Models") >= 0 && each$f($n, function(Rn) {
          var Fn = Rn.coordinateSystem;
          if (Fn && Fn.containPoint)
            Dn = Dn || !!Fn.containPoint(Bn);
          else if (Nn === "seriesModels") {
            var Pn = this._chartsMap[Rn.__viewId];
            Pn && Pn.containPoint ? Dn = Dn || Pn.containPoint(Bn, Rn) : process.env.NODE_ENV !== "production" && warn(Nn + ": " + (Pn ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && warn(Nn + ": containPoint is not supported");
        }, this);
      }, this), !!Dn;
    }, nr.prototype.getVisual = function(Cn, Bn) {
      var In = this._model, Dn = parseFinder$1(In, Cn, {
        defaultMainType: "series"
      }), Ln = Dn.seriesModel;
      process.env.NODE_ENV !== "production" && (Ln || warn("There is no specified series model"));
      var $n = Ln.getData(), Nn = Dn.hasOwnProperty("dataIndexInside") ? Dn.dataIndexInside : Dn.hasOwnProperty("dataIndex") ? $n.indexOfRawIndex(Dn.dataIndex) : null;
      return Nn != null ? getItemVisualFromData($n, Nn, Bn) : getVisualFromData($n, Bn);
    }, nr.prototype.getViewOfComponentModel = function(Cn) {
      return this._componentsMap[Cn.__viewId];
    }, nr.prototype.getViewOfSeriesModel = function(Cn) {
      return this._chartsMap[Cn.__viewId];
    }, nr.prototype._initEvents = function() {
      var Cn = this;
      each$f(MOUSE_EVENT_NAMES, function(Bn) {
        var In = function(Dn) {
          var Ln = Cn.getModel(), $n = Dn.target, Nn, Rn = Bn === "globalout";
          if (Rn ? Nn = {} : $n && findEventDispatcher($n, function(zn) {
            var Gn = getECData(zn);
            if (Gn && Gn.dataIndex != null) {
              var Yn = Gn.dataModel || Ln.getSeriesByIndex(Gn.seriesIndex);
              return Nn = Yn && Yn.getDataParams(Gn.dataIndex, Gn.dataType, $n) || {}, !0;
            } else if (Gn.eventData)
              return Nn = extend({}, Gn.eventData), !0;
          }, !0), Nn) {
            var Fn = Nn.componentType, Pn = Nn.componentIndex;
            (Fn === "markLine" || Fn === "markPoint" || Fn === "markArea") && (Fn = "series", Pn = Nn.seriesIndex);
            var Un = Fn && Pn != null && Ln.getComponent(Fn, Pn), Hn = Un && Cn[Un.mainType === "series" ? "_chartsMap" : "_componentsMap"][Un.__viewId];
            process.env.NODE_ENV !== "production" && !Rn && !(Un && Hn) && warn("model or view can not be found by params"), Nn.event = Dn, Nn.type = Bn, Cn._$eventProcessor.eventInfo = {
              targetEl: $n,
              packedEvent: Nn,
              model: Un,
              view: Hn
            }, Cn.trigger(Bn, Nn);
          }
        };
        In.zrEventfulCallAtLast = !0, Cn._zr.on(Bn, In, Cn);
      }), each$f(eventActionMap, function(Bn, In) {
        Cn._messageCenter.on(In, function(Dn) {
          this.trigger(In, Dn);
        }, Cn);
      }), each$f(["selectchanged"], function(Bn) {
        Cn._messageCenter.on(Bn, function(In) {
          this.trigger(Bn, In);
        }, Cn);
      }), handleLegacySelectEvents(this._messageCenter, this, this._api);
    }, nr.prototype.isDisposed = function() {
      return this._disposed;
    }, nr.prototype.clear = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, nr.prototype.dispose = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._disposed = !0;
      var Cn = this.getDom();
      Cn && setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
      var Bn = this, In = Bn._api, Dn = Bn._model;
      each$f(Bn._componentsViews, function(Ln) {
        Ln.dispose(Dn, In);
      }), each$f(Bn._chartsViews, function(Ln) {
        Ln.dispose(Dn, In);
      }), Bn._zr.dispose(), Bn._dom = Bn._model = Bn._chartsMap = Bn._componentsMap = Bn._chartsViews = Bn._componentsViews = Bn._scheduler = Bn._api = Bn._zr = Bn._throttledZrFlush = Bn._theme = Bn._coordSysMgr = Bn._messageCenter = null, delete instances[Bn.id];
    }, nr.prototype.resize = function(Cn) {
      if (this[IN_MAIN_PROCESS_KEY]) {
        process.env.NODE_ENV !== "production" && error("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._zr.resize(Cn);
      var Bn = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!Bn) {
        var In = Bn.resetOption("media"), Dn = Cn && Cn.silent;
        this[PENDING_UPDATE] && (Dn == null && (Dn = this[PENDING_UPDATE].silent), In = !0, this[PENDING_UPDATE] = null), this[IN_MAIN_PROCESS_KEY] = !0;
        try {
          In && prepare(this), updateMethods.update.call(this, {
            type: "resize",
            animation: extend({
              // Disable animation
              duration: 0
            }, Cn && Cn.animation)
          });
        } catch (Ln) {
          throw this[IN_MAIN_PROCESS_KEY] = !1, Ln;
        }
        this[IN_MAIN_PROCESS_KEY] = !1, flushPendingActions.call(this, Dn), triggerUpdatedEvent.call(this, Dn);
      }
    }, nr.prototype.showLoading = function(Cn, Bn) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (isObject$6(Cn) && (Bn = Cn, Cn = ""), Cn = Cn || "default", this.hideLoading(), !loadingEffects[Cn]) {
        process.env.NODE_ENV !== "production" && warn("Loading effects " + Cn + " not exists.");
        return;
      }
      var In = loadingEffects[Cn](this._api, Bn), Dn = this._zr;
      this._loadingFX = In, Dn.add(In);
    }, nr.prototype.hideLoading = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, nr.prototype.makeActionFromEvent = function(Cn) {
      var Bn = extend({}, Cn);
      return Bn.type = eventActionMap[Cn.type], Bn;
    }, nr.prototype.dispatchAction = function(Cn, Bn) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (isObject$6(Bn) || (Bn = {
        silent: !!Bn
      }), !!actions[Cn.type] && this._model) {
        if (this[IN_MAIN_PROCESS_KEY]) {
          this._pendingActions.push(Cn);
          return;
        }
        var In = Bn.silent;
        doDispatchAction.call(this, Cn, In);
        var Dn = Bn.flush;
        Dn ? this._zr.flush() : Dn !== !1 && env$1.browser.weChat && this._throttledZrFlush(), flushPendingActions.call(this, In), triggerUpdatedEvent.call(this, In);
      }
    }, nr.prototype.updateLabelLayout = function() {
      lifecycle$1.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, nr.prototype.appendData = function(Cn) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var Bn = Cn.seriesIndex, In = this.getModel(), Dn = In.getSeriesByIndex(Bn);
      process.env.NODE_ENV !== "production" && assert(Cn.data && Dn), Dn.appendData(Cn), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, nr.internalField = function() {
      prepare = function(Pn) {
        var Un = Pn._scheduler;
        Un.restorePipelines(Pn._model), Un.prepareStageTasks(), prepareView(Pn, !0), prepareView(Pn, !1), Un.plan();
      }, prepareView = function(Pn, Un) {
        for (var Hn = Pn._model, zn = Pn._scheduler, Gn = Un ? Pn._componentsViews : Pn._chartsViews, Yn = Un ? Pn._componentsMap : Pn._chartsMap, Wn = Pn._zr, Xn = Pn._api, ea = 0; ea < Gn.length; ea++)
          Gn[ea].__alive = !1;
        Un ? Hn.eachComponent(function(ra, aa) {
          ra !== "series" && ta(aa);
        }) : Hn.eachSeries(ta);
        function ta(ra) {
          var aa = ra.__requireNewView;
          ra.__requireNewView = !1;
          var ia = "_ec_" + ra.id + "_" + ra.type, Aa = !aa && Yn[ia];
          if (!Aa) {
            var sa = parseClassType(ra.type), oa = Un ? ComponentView$1.getClass(sa.main, sa.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              ChartView$1.getClass(sa.sub)
            );
            process.env.NODE_ENV !== "production" && assert(oa, sa.sub + " does not exist."), Aa = new oa(), Aa.init(Hn, Xn), Yn[ia] = Aa, Gn.push(Aa), Wn.add(Aa.group);
          }
          ra.__viewId = Aa.__id = ia, Aa.__alive = !0, Aa.__model = ra, Aa.group.__ecComponentInfo = {
            mainType: ra.mainType,
            index: ra.componentIndex
          }, !Un && zn.prepareView(Aa, ra, Hn, Xn);
        }
        for (var ea = 0; ea < Gn.length; ) {
          var na = Gn[ea];
          na.__alive ? ea++ : (!Un && na.renderTask.dispose(), Wn.remove(na.group), na.dispose(Hn, Xn), Gn.splice(ea, 1), Yn[na.__id] === na && delete Yn[na.__id], na.__id = na.group.__ecComponentInfo = null);
        }
      }, updateDirectly = function(Pn, Un, Hn, zn, Gn) {
        var Yn = Pn._model;
        if (Yn.setUpdatePayload(Hn), !zn) {
          each$f([].concat(Pn._componentsViews).concat(Pn._chartsViews), na);
          return;
        }
        var Wn = {};
        Wn[zn + "Id"] = Hn[zn + "Id"], Wn[zn + "Index"] = Hn[zn + "Index"], Wn[zn + "Name"] = Hn[zn + "Name"];
        var Xn = {
          mainType: zn,
          query: Wn
        };
        Gn && (Xn.subType = Gn);
        var ea = Hn.excludeSeriesId, ta;
        ea != null && (ta = createHashMap(), each$f(normalizeToArray(ea), function(ra) {
          var aa = convertOptionIdName(ra, null);
          aa != null && ta.set(aa, !0);
        })), Yn && Yn.eachComponent(Xn, function(ra) {
          var aa = ta && ta.get(ra.id) != null;
          if (!aa)
            if (isHighDownPayload(Hn))
              if (ra instanceof SeriesModel$1)
                Hn.type === HIGHLIGHT_ACTION_TYPE && !Hn.notBlur && !ra.get(["emphasis", "disabled"]) && blurSeriesFromHighlightPayload(ra, Hn, Pn._api);
              else {
                var ia = findComponentHighDownDispatchers(ra.mainType, ra.componentIndex, Hn.name, Pn._api), Aa = ia.focusSelf, sa = ia.dispatchers;
                Hn.type === HIGHLIGHT_ACTION_TYPE && Aa && !Hn.notBlur && blurComponent(ra.mainType, ra.componentIndex, Pn._api), sa && each$f(sa, function(oa) {
                  Hn.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(oa) : leaveEmphasis(oa);
                });
              }
            else
              isSelectChangePayload(Hn) && ra instanceof SeriesModel$1 && (toggleSelectionFromPayload(ra, Hn, Pn._api), updateSeriesElementSelection(ra), markStatusToUpdate(Pn));
        }, Pn), Yn && Yn.eachComponent(Xn, function(ra) {
          var aa = ta && ta.get(ra.id) != null;
          aa || na(Pn[zn === "series" ? "_chartsMap" : "_componentsMap"][ra.__viewId]);
        }, Pn);
        function na(ra) {
          ra && ra.__alive && ra[Un] && ra[Un](ra.__model, Yn, Pn._api, Hn);
        }
      }, updateMethods = {
        prepareAndUpdate: function(Pn) {
          prepare(this), updateMethods.update.call(this, Pn, {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: Pn.newOption != null
          });
        },
        update: function(Pn, Un) {
          var Hn = this._model, zn = this._api, Gn = this._zr, Yn = this._coordSysMgr, Wn = this._scheduler;
          if (Hn) {
            Hn.setUpdatePayload(Pn), Wn.restoreData(Hn, Pn), Wn.performSeriesTasks(Hn), Yn.create(Hn, zn), Wn.performDataProcessorTasks(Hn, Pn), updateStreamModes(this, Hn), Yn.update(Hn, zn), Cn(Hn), Wn.performVisualTasks(Hn, Pn), render(this, Hn, zn, Pn, Un);
            var Xn = Hn.get("backgroundColor") || "transparent", ea = Hn.get("darkMode");
            Gn.setBackgroundColor(Xn), ea != null && ea !== "auto" && Gn.setDarkMode(ea), lifecycle$1.trigger("afterupdate", Hn, zn);
          }
        },
        updateTransform: function(Pn) {
          var Un = this, Hn = this._model, zn = this._api;
          if (Hn) {
            Hn.setUpdatePayload(Pn);
            var Gn = [];
            Hn.eachComponent(function(Wn, Xn) {
              if (Wn !== "series") {
                var ea = Un.getViewOfComponentModel(Xn);
                if (ea && ea.__alive)
                  if (ea.updateTransform) {
                    var ta = ea.updateTransform(Xn, Hn, zn, Pn);
                    ta && ta.update && Gn.push(ea);
                  } else
                    Gn.push(ea);
              }
            });
            var Yn = createHashMap();
            Hn.eachSeries(function(Wn) {
              var Xn = Un._chartsMap[Wn.__viewId];
              if (Xn.updateTransform) {
                var ea = Xn.updateTransform(Wn, Hn, zn, Pn);
                ea && ea.update && Yn.set(Wn.uid, 1);
              } else
                Yn.set(Wn.uid, 1);
            }), Cn(Hn), this._scheduler.performVisualTasks(Hn, Pn, {
              setDirty: !0,
              dirtyMap: Yn
            }), renderSeries(this, Hn, zn, Pn, {}, Yn), lifecycle$1.trigger("afterupdate", Hn, zn);
          }
        },
        updateView: function(Pn) {
          var Un = this._model;
          Un && (Un.setUpdatePayload(Pn), ChartView$1.markUpdateMethod(Pn, "updateView"), Cn(Un), this._scheduler.performVisualTasks(Un, Pn, {
            setDirty: !0
          }), render(this, Un, this._api, Pn, {}), lifecycle$1.trigger("afterupdate", Un, this._api));
        },
        updateVisual: function(Pn) {
          var Un = this, Hn = this._model;
          Hn && (Hn.setUpdatePayload(Pn), Hn.eachSeries(function(zn) {
            zn.getData().clearAllVisual();
          }), ChartView$1.markUpdateMethod(Pn, "updateVisual"), Cn(Hn), this._scheduler.performVisualTasks(Hn, Pn, {
            visualType: "visual",
            setDirty: !0
          }), Hn.eachComponent(function(zn, Gn) {
            if (zn !== "series") {
              var Yn = Un.getViewOfComponentModel(Gn);
              Yn && Yn.__alive && Yn.updateVisual(Gn, Hn, Un._api, Pn);
            }
          }), Hn.eachSeries(function(zn) {
            var Gn = Un._chartsMap[zn.__viewId];
            Gn.updateVisual(zn, Hn, Un._api, Pn);
          }), lifecycle$1.trigger("afterupdate", Hn, this._api));
        },
        updateLayout: function(Pn) {
          updateMethods.update.call(this, Pn);
        }
      }, doConvertPixel = function(Pn, Un, Hn, zn) {
        if (Pn._disposed) {
          disposedWarning(Pn.id);
          return;
        }
        for (var Gn = Pn._model, Yn = Pn._coordSysMgr.getCoordinateSystems(), Wn, Xn = parseFinder$1(Gn, Hn), ea = 0; ea < Yn.length; ea++) {
          var ta = Yn[ea];
          if (ta[Un] && (Wn = ta[Un](Gn, Xn, zn)) != null)
            return Wn;
        }
        process.env.NODE_ENV !== "production" && warn("No coordinate system that supports " + Un + " found by the given finder.");
      }, updateStreamModes = function(Pn, Un) {
        var Hn = Pn._chartsMap, zn = Pn._scheduler;
        Un.eachSeries(function(Gn) {
          zn.updateStreamModes(Gn, Hn[Gn.__viewId]);
        });
      }, doDispatchAction = function(Pn, Un) {
        var Hn = this, zn = this.getModel(), Gn = Pn.type, Yn = Pn.escapeConnect, Wn = actions[Gn], Xn = Wn.actionInfo, ea = (Xn.update || "update").split(":"), ta = ea.pop(), na = ea[0] != null && parseClassType(ea[0]);
        this[IN_MAIN_PROCESS_KEY] = !0;
        var ra = [Pn], aa = !1;
        Pn.batch && (aa = !0, ra = map$1(Pn.batch, function(ca) {
          return ca = defaults(extend({}, ca), Pn), ca.batch = null, ca;
        }));
        var ia = [], Aa, sa = isSelectChangePayload(Pn), oa = isHighDownPayload(Pn);
        if (oa && allLeaveBlur(this._api), each$f(ra, function(ca) {
          if (Aa = Wn.action(ca, Hn._model, Hn._api), Aa = Aa || extend({}, ca), Aa.type = Xn.event || Aa.type, ia.push(Aa), oa) {
            var fa = preParseFinder(Pn), ha = fa.queryOptionMap, pa = fa.mainTypeSpecified, ya = pa ? ha.keys()[0] : "series";
            updateDirectly(Hn, ta, ca, ya), markStatusToUpdate(Hn);
          } else
            sa ? (updateDirectly(Hn, ta, ca, "series"), markStatusToUpdate(Hn)) : na && updateDirectly(Hn, ta, ca, na.main, na.sub);
        }), ta !== "none" && !oa && !sa && !na)
          try {
            this[PENDING_UPDATE] ? (prepare(this), updateMethods.update.call(this, Pn), this[PENDING_UPDATE] = null) : updateMethods[ta].call(this, Pn);
          } catch (ca) {
            throw this[IN_MAIN_PROCESS_KEY] = !1, ca;
          }
        if (aa ? Aa = {
          type: Xn.event || Gn,
          escapeConnect: Yn,
          batch: ia
        } : Aa = ia[0], this[IN_MAIN_PROCESS_KEY] = !1, !Un) {
          var la = this._messageCenter;
          if (la.trigger(Aa.type, Aa), sa) {
            var ua = {
              type: "selectchanged",
              escapeConnect: Yn,
              selected: getAllSelectedIndices(zn),
              isFromClick: Pn.isFromClick || !1,
              fromAction: Pn.type,
              fromActionPayload: Pn
            };
            la.trigger(ua.type, ua);
          }
        }
      }, flushPendingActions = function(Pn) {
        for (var Un = this._pendingActions; Un.length; ) {
          var Hn = Un.shift();
          doDispatchAction.call(this, Hn, Pn);
        }
      }, triggerUpdatedEvent = function(Pn) {
        !Pn && this.trigger("updated");
      }, bindRenderedEvent = function(Pn, Un) {
        Pn.on("rendered", function(Hn) {
          Un.trigger("rendered", Hn), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          Pn.animation.isFinished() && !Un[PENDING_UPDATE] && !Un._scheduler.unfinished && !Un._pendingActions.length && Un.trigger("finished");
        });
      }, bindMouseEvent = function(Pn, Un) {
        Pn.on("mouseover", function(Hn) {
          var zn = Hn.target, Gn = findEventDispatcher(zn, isHighDownDispatcher);
          Gn && (handleGlobalMouseOverForHighDown(Gn, Hn, Un._api), markStatusToUpdate(Un));
        }).on("mouseout", function(Hn) {
          var zn = Hn.target, Gn = findEventDispatcher(zn, isHighDownDispatcher);
          Gn && (handleGlobalMouseOutForHighDown(Gn, Hn, Un._api), markStatusToUpdate(Un));
        }).on("click", function(Hn) {
          var zn = Hn.target, Gn = findEventDispatcher(zn, function(Xn) {
            return getECData(Xn).dataIndex != null;
          }, !0);
          if (Gn) {
            var Yn = Gn.selected ? "unselect" : "select", Wn = getECData(Gn);
            Un._api.dispatchAction({
              type: Yn,
              dataType: Wn.dataType,
              dataIndexInside: Wn.dataIndex,
              seriesIndex: Wn.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function Cn(Pn) {
        Pn.clearColorPalette(), Pn.eachSeries(function(Un) {
          Un.clearColorPalette();
        });
      }
      function Bn(Pn) {
        var Un = [], Hn = [], zn = !1;
        if (Pn.eachComponent(function(Xn, ea) {
          var ta = ea.get("zlevel") || 0, na = ea.get("z") || 0, ra = ea.getZLevelKey();
          zn = zn || !!ra, (Xn === "series" ? Hn : Un).push({
            zlevel: ta,
            z: na,
            idx: ea.componentIndex,
            type: Xn,
            key: ra
          });
        }), zn) {
          var Gn = Un.concat(Hn), Yn, Wn;
          sort$2(Gn, function(Xn, ea) {
            return Xn.zlevel === ea.zlevel ? Xn.z - ea.z : Xn.zlevel - ea.zlevel;
          }), each$f(Gn, function(Xn) {
            var ea = Pn.getComponent(Xn.type, Xn.idx), ta = Xn.zlevel, na = Xn.key;
            Yn != null && (ta = Math.max(Yn, ta)), na ? (ta === Yn && na !== Wn && ta++, Wn = na) : Wn && (ta === Yn && ta++, Wn = ""), Yn = ta, ea.setZLevel(ta);
          });
        }
      }
      render = function(Pn, Un, Hn, zn, Gn) {
        Bn(Un), renderComponents(Pn, Un, Hn, zn, Gn), each$f(Pn._chartsViews, function(Yn) {
          Yn.__alive = !1;
        }), renderSeries(Pn, Un, Hn, zn, Gn), each$f(Pn._chartsViews, function(Yn) {
          Yn.__alive || Yn.remove(Un, Hn);
        });
      }, renderComponents = function(Pn, Un, Hn, zn, Gn, Yn) {
        each$f(Yn || Pn._componentsViews, function(Wn) {
          var Xn = Wn.__model;
          Rn(Xn, Wn), Wn.render(Xn, Un, Hn, zn), $n(Xn, Wn), Fn(Xn, Wn);
        });
      }, renderSeries = function(Pn, Un, Hn, zn, Gn, Yn) {
        var Wn = Pn._scheduler;
        Gn = extend(Gn || {}, {
          updatedSeries: Un.getSeries()
        }), lifecycle$1.trigger("series:beforeupdate", Un, Hn, Gn);
        var Xn = !1;
        Un.eachSeries(function(ea) {
          var ta = Pn._chartsMap[ea.__viewId];
          ta.__alive = !0;
          var na = ta.renderTask;
          Wn.updatePayload(na, zn), Rn(ea, ta), Yn && Yn.get(ea.uid) && na.dirty(), na.perform(Wn.getPerformArgs(na)) && (Xn = !0), ta.group.silent = !!ea.get("silent"), Ln(ea, ta), updateSeriesElementSelection(ea);
        }), Wn.unfinished = Xn || Wn.unfinished, lifecycle$1.trigger("series:layoutlabels", Un, Hn, Gn), lifecycle$1.trigger("series:transition", Un, Hn, Gn), Un.eachSeries(function(ea) {
          var ta = Pn._chartsMap[ea.__viewId];
          $n(ea, ta), Fn(ea, ta);
        }), Dn(Pn, Un), lifecycle$1.trigger("series:afterupdate", Un, Hn, Gn);
      }, markStatusToUpdate = function(Pn) {
        Pn[STATUS_NEEDS_UPDATE_KEY] = !0, Pn.getZr().wakeUp();
      }, applyChangedStates = function(Pn) {
        Pn[STATUS_NEEDS_UPDATE_KEY] && (Pn.getZr().storage.traverse(function(Un) {
          isElementRemoved(Un) || In(Un);
        }), Pn[STATUS_NEEDS_UPDATE_KEY] = !1);
      };
      function In(Pn) {
        for (var Un = [], Hn = Pn.currentStates, zn = 0; zn < Hn.length; zn++) {
          var Gn = Hn[zn];
          Gn === "emphasis" || Gn === "blur" || Gn === "select" || Un.push(Gn);
        }
        Pn.selected && Pn.states.select && Un.push("select"), Pn.hoverState === HOVER_STATE_EMPHASIS && Pn.states.emphasis ? Un.push("emphasis") : Pn.hoverState === HOVER_STATE_BLUR && Pn.states.blur && Un.push("blur"), Pn.useStates(Un);
      }
      function Dn(Pn, Un) {
        var Hn = Pn._zr, zn = Hn.storage, Gn = 0;
        zn.traverse(function(Yn) {
          Yn.isGroup || Gn++;
        }), Gn > Un.get("hoverLayerThreshold") && !env$1.node && !env$1.worker && Un.eachSeries(function(Yn) {
          if (!Yn.preventUsingHoverLayer) {
            var Wn = Pn._chartsMap[Yn.__viewId];
            Wn.__alive && Wn.eachRendered(function(Xn) {
              Xn.states.emphasis && (Xn.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function Ln(Pn, Un) {
        var Hn = Pn.get("blendMode") || null;
        Un.eachRendered(function(zn) {
          zn.isGroup || (zn.style.blend = Hn);
        });
      }
      function $n(Pn, Un) {
        if (!Pn.preventAutoZ) {
          var Hn = Pn.get("z") || 0, zn = Pn.get("zlevel") || 0;
          Un.eachRendered(function(Gn) {
            return Nn(Gn, Hn, zn, -1 / 0), !0;
          });
        }
      }
      function Nn(Pn, Un, Hn, zn) {
        var Gn = Pn.getTextContent(), Yn = Pn.getTextGuideLine(), Wn = Pn.isGroup;
        if (Wn)
          for (var Xn = Pn.childrenRef(), ea = 0; ea < Xn.length; ea++)
            zn = Math.max(Nn(Xn[ea], Un, Hn, zn), zn);
        else
          Pn.z = Un, Pn.zlevel = Hn, zn = Math.max(Pn.z2, zn);
        if (Gn && (Gn.z = Un, Gn.zlevel = Hn, isFinite(zn) && (Gn.z2 = zn + 2)), Yn) {
          var ta = Pn.textGuideLineConfig;
          Yn.z = Un, Yn.zlevel = Hn, isFinite(zn) && (Yn.z2 = zn + (ta && ta.showAbove ? 1 : -1));
        }
        return zn;
      }
      function Rn(Pn, Un) {
        Un.eachRendered(function(Hn) {
          if (!isElementRemoved(Hn)) {
            var zn = Hn.getTextContent(), Gn = Hn.getTextGuideLine();
            Hn.stateTransition && (Hn.stateTransition = null), zn && zn.stateTransition && (zn.stateTransition = null), Gn && Gn.stateTransition && (Gn.stateTransition = null), Hn.hasState() ? (Hn.prevStates = Hn.currentStates, Hn.clearStates()) : Hn.prevStates && (Hn.prevStates = null);
          }
        });
      }
      function Fn(Pn, Un) {
        var Hn = Pn.getModel("stateAnimation"), zn = Pn.isAnimationEnabled(), Gn = Hn.get("duration"), Yn = Gn > 0 ? {
          duration: Gn,
          delay: Hn.get("delay"),
          easing: Hn.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        Un.eachRendered(function(Wn) {
          if (Wn.states && Wn.states.emphasis) {
            if (isElementRemoved(Wn))
              return;
            if (Wn instanceof Path$1 && savePathStates(Wn), Wn.__dirty) {
              var Xn = Wn.prevStates;
              Xn && Wn.useStates(Xn);
            }
            if (zn) {
              Wn.stateTransition = Yn;
              var ea = Wn.getTextContent(), ta = Wn.getTextGuideLine();
              ea && (ea.stateTransition = Yn), ta && (ta.stateTransition = Yn);
            }
            Wn.__dirty && In(Wn);
          }
        });
      }
      createExtensionAPI = function(Pn) {
        return new /** @class */
        (function(Un) {
          __extends$2(Hn, Un);
          function Hn() {
            return Un !== null && Un.apply(this, arguments) || this;
          }
          return Hn.prototype.getCoordinateSystems = function() {
            return Pn._coordSysMgr.getCoordinateSystems();
          }, Hn.prototype.getComponentByElement = function(zn) {
            for (; zn; ) {
              var Gn = zn.__ecComponentInfo;
              if (Gn != null)
                return Pn._model.getComponent(Gn.mainType, Gn.index);
              zn = zn.parent;
            }
          }, Hn.prototype.enterEmphasis = function(zn, Gn) {
            enterEmphasis(zn, Gn), markStatusToUpdate(Pn);
          }, Hn.prototype.leaveEmphasis = function(zn, Gn) {
            leaveEmphasis(zn, Gn), markStatusToUpdate(Pn);
          }, Hn.prototype.enterBlur = function(zn) {
            enterBlur(zn), markStatusToUpdate(Pn);
          }, Hn.prototype.leaveBlur = function(zn) {
            leaveBlur(zn), markStatusToUpdate(Pn);
          }, Hn.prototype.enterSelect = function(zn) {
            enterSelect(zn), markStatusToUpdate(Pn);
          }, Hn.prototype.leaveSelect = function(zn) {
            leaveSelect(zn), markStatusToUpdate(Pn);
          }, Hn.prototype.getModel = function() {
            return Pn.getModel();
          }, Hn.prototype.getViewOfComponentModel = function(zn) {
            return Pn.getViewOfComponentModel(zn);
          }, Hn.prototype.getViewOfSeriesModel = function(zn) {
            return Pn.getViewOfSeriesModel(zn);
          }, Hn;
        }(ExtensionAPI$1))(Pn);
      }, enableConnect = function(Pn) {
        function Un(Hn, zn) {
          for (var Gn = 0; Gn < Hn.length; Gn++) {
            var Yn = Hn[Gn];
            Yn[CONNECT_STATUS_KEY] = zn;
          }
        }
        each$f(eventActionMap, function(Hn, zn) {
          Pn._messageCenter.on(zn, function(Gn) {
            if (connectedGroups[Pn.group] && Pn[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
              if (Gn && Gn.escapeConnect)
                return;
              var Yn = Pn.makeActionFromEvent(Gn), Wn = [];
              each$f(instances, function(Xn) {
                Xn !== Pn && Xn.group === Pn.group && Wn.push(Xn);
              }), Un(Wn, CONNECT_STATUS_PENDING), each$f(Wn, function(Xn) {
                Xn[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING && Xn.dispatchAction(Yn);
              }), Un(Wn, CONNECT_STATUS_UPDATED);
            }
          });
        });
      };
    }(), nr;
  }(Eventful$1)
), echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
echartsProto.one = function(_n, nr, Cn) {
  var Bn = this;
  deprecateLog("ECharts#one is deprecated.");
  function In() {
    for (var Dn = [], Ln = 0; Ln < arguments.length; Ln++)
      Dn[Ln] = arguments[Ln];
    nr && nr.apply && nr.apply(this, Dn), Bn.off(_n, In);
  }
  this.on.call(this, _n, In, Cn);
};
var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function disposedWarning(_n) {
  process.env.NODE_ENV !== "production" && warn("Instance " + _n + " has been disposed");
}
var actions = {}, eventActionMap = {}, dataProcessorFuncs = [], optionPreprocessorFuncs = [], visualFuncs = [], themeStorage = {}, loadingEffects = {}, instances = {}, connectedGroups = {}, idBase = +/* @__PURE__ */ new Date() - 0, groupIdBase = +/* @__PURE__ */ new Date() - 0, DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function init$1(_n, nr, Cn) {
  var Bn = !(Cn && Cn.ssr);
  if (Bn) {
    if (process.env.NODE_ENV !== "production" && !_n)
      throw new Error("Initialize failed: invalid dom.");
    var In = getInstanceByDom(_n);
    if (In)
      return process.env.NODE_ENV !== "production" && warn("There is a chart instance already initialized on the dom."), In;
    process.env.NODE_ENV !== "production" && isDom(_n) && _n.nodeName.toUpperCase() !== "CANVAS" && (!_n.clientWidth && (!Cn || Cn.width == null) || !_n.clientHeight && (!Cn || Cn.height == null)) && warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var Dn = new ECharts(_n, nr, Cn);
  return Dn.id = "ec_" + idBase++, instances[Dn.id] = Dn, Bn && setAttribute(_n, DOM_ATTRIBUTE_KEY, Dn.id), enableConnect(Dn), lifecycle$1.trigger("afterinit", Dn), Dn;
}
function connect(_n) {
  if (isArray$4(_n)) {
    var nr = _n;
    _n = null, each$f(nr, function(Cn) {
      Cn.group != null && (_n = Cn.group);
    }), _n = _n || "g_" + groupIdBase++, each$f(nr, function(Cn) {
      Cn.group = _n;
    });
  }
  return connectedGroups[_n] = !0, _n;
}
function disconnect(_n) {
  connectedGroups[_n] = !1;
}
var disConnect = disconnect;
function dispose(_n) {
  isString$1(_n) ? _n = instances[_n] : _n instanceof ECharts || (_n = getInstanceByDom(_n)), _n instanceof ECharts && !_n.isDisposed() && _n.dispose();
}
function getInstanceByDom(_n) {
  return instances[getAttribute(_n, DOM_ATTRIBUTE_KEY)];
}
function getInstanceById(_n) {
  return instances[_n];
}
function registerTheme(_n, nr) {
  themeStorage[_n] = nr;
}
function registerPreprocessor(_n) {
  indexOf(optionPreprocessorFuncs, _n) < 0 && optionPreprocessorFuncs.push(_n);
}
function registerProcessor(_n, nr) {
  normalizeRegister(dataProcessorFuncs, _n, nr, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(_n) {
  registerUpdateLifecycle("afterinit", _n);
}
function registerPostUpdate(_n) {
  registerUpdateLifecycle("afterupdate", _n);
}
function registerUpdateLifecycle(_n, nr) {
  lifecycle$1.on(_n, nr);
}
function registerAction(_n, nr, Cn) {
  isFunction$1(nr) && (Cn = nr, nr = "");
  var Bn = isObject$6(_n) ? _n.type : [_n, _n = {
    event: nr
  }][0];
  _n.event = (_n.event || Bn).toLowerCase(), nr = _n.event, !eventActionMap[nr] && (assert(ACTION_REG.test(Bn) && ACTION_REG.test(nr)), actions[Bn] || (actions[Bn] = {
    action: Cn,
    actionInfo: _n
  }), eventActionMap[nr] = Bn);
}
function registerCoordinateSystem(_n, nr) {
  CoordinateSystem.register(_n, nr);
}
function getCoordinateSystemDimensions(_n) {
  var nr = CoordinateSystem.get(_n);
  if (nr)
    return nr.getDimensionsInfo ? nr.getDimensionsInfo() : nr.dimensions.slice();
}
function registerLayout(_n, nr) {
  normalizeRegister(visualFuncs, _n, nr, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(_n, nr) {
  normalizeRegister(visualFuncs, _n, nr, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(_n, nr, Cn, Bn, In) {
  if ((isFunction$1(nr) || isObject$6(nr)) && (Cn = nr, nr = Bn), process.env.NODE_ENV !== "production") {
    if (isNaN(nr) || nr == null)
      throw new Error("Illegal priority");
    each$f(_n, function(Ln) {
      assert(Ln.__raw !== Cn);
    });
  }
  if (!(indexOf(registeredTasks, Cn) >= 0)) {
    registeredTasks.push(Cn);
    var Dn = Scheduler$1.wrapStageHandler(Cn, In);
    Dn.__prio = nr, Dn.__raw = Cn, _n.push(Dn);
  }
}
function registerLoading(_n, nr) {
  loadingEffects[_n] = nr;
}
function setCanvasCreator(_n) {
  process.env.NODE_ENV !== "production" && deprecateLog("setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead."), setPlatformAPI({
    createCanvas: _n
  });
}
function registerMap$1(_n, nr, Cn) {
  var Bn = getImpl("registerMap");
  Bn && Bn(_n, nr, Cn);
}
function getMap(_n) {
  var nr = getImpl("getMap");
  return nr && nr(_n);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack$1);
registerLoading("default", defaultLoading);
registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop$1);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop$1);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_ACTION_TYPE,
  update: SELECT_ACTION_TYPE
}, noop$1);
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: UNSELECT_ACTION_TYPE,
  update: UNSELECT_ACTION_TYPE
}, noop$1);
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: TOGGLE_SELECT_ACTION_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE
}, noop$1);
registerTheme("light", lightTheme);
registerTheme("dark", darkTheme);
var dataTool = {};
function dataIndexMapValueLength(_n) {
  return _n == null ? 0 : _n.length || 1;
}
function defaultKeyGetter(_n) {
  return _n;
}
var DataDiffer = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn, In, Dn, Ln) {
      this._old = nr, this._new = Cn, this._oldKeyGetter = Bn || defaultKeyGetter, this._newKeyGetter = In || defaultKeyGetter, this.context = Dn, this._diffModeMultiple = Ln === "multiple";
    }
    return _n.prototype.add = function(nr) {
      return this._add = nr, this;
    }, _n.prototype.update = function(nr) {
      return this._update = nr, this;
    }, _n.prototype.updateManyToOne = function(nr) {
      return this._updateManyToOne = nr, this;
    }, _n.prototype.updateOneToMany = function(nr) {
      return this._updateOneToMany = nr, this;
    }, _n.prototype.updateManyToMany = function(nr) {
      return this._updateManyToMany = nr, this;
    }, _n.prototype.remove = function(nr) {
      return this._remove = nr, this;
    }, _n.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, _n.prototype._executeOneToOne = function() {
      var nr = this._old, Cn = this._new, Bn = {}, In = new Array(nr.length), Dn = new Array(Cn.length);
      this._initIndexMap(nr, null, In, "_oldKeyGetter"), this._initIndexMap(Cn, Bn, Dn, "_newKeyGetter");
      for (var Ln = 0; Ln < nr.length; Ln++) {
        var $n = In[Ln], Nn = Bn[$n], Rn = dataIndexMapValueLength(Nn);
        if (Rn > 1) {
          var Fn = Nn.shift();
          Nn.length === 1 && (Bn[$n] = Nn[0]), this._update && this._update(Fn, Ln);
        } else
          Rn === 1 ? (Bn[$n] = null, this._update && this._update(Nn, Ln)) : this._remove && this._remove(Ln);
      }
      this._performRestAdd(Dn, Bn);
    }, _n.prototype._executeMultiple = function() {
      var nr = this._old, Cn = this._new, Bn = {}, In = {}, Dn = [], Ln = [];
      this._initIndexMap(nr, Bn, Dn, "_oldKeyGetter"), this._initIndexMap(Cn, In, Ln, "_newKeyGetter");
      for (var $n = 0; $n < Dn.length; $n++) {
        var Nn = Dn[$n], Rn = Bn[Nn], Fn = In[Nn], Pn = dataIndexMapValueLength(Rn), Un = dataIndexMapValueLength(Fn);
        if (Pn > 1 && Un === 1)
          this._updateManyToOne && this._updateManyToOne(Fn, Rn), In[Nn] = null;
        else if (Pn === 1 && Un > 1)
          this._updateOneToMany && this._updateOneToMany(Fn, Rn), In[Nn] = null;
        else if (Pn === 1 && Un === 1)
          this._update && this._update(Fn, Rn), In[Nn] = null;
        else if (Pn > 1 && Un > 1)
          this._updateManyToMany && this._updateManyToMany(Fn, Rn), In[Nn] = null;
        else if (Pn > 1)
          for (var Hn = 0; Hn < Pn; Hn++)
            this._remove && this._remove(Rn[Hn]);
        else
          this._remove && this._remove(Rn);
      }
      this._performRestAdd(Ln, In);
    }, _n.prototype._performRestAdd = function(nr, Cn) {
      for (var Bn = 0; Bn < nr.length; Bn++) {
        var In = nr[Bn], Dn = Cn[In], Ln = dataIndexMapValueLength(Dn);
        if (Ln > 1)
          for (var $n = 0; $n < Ln; $n++)
            this._add && this._add(Dn[$n]);
        else
          Ln === 1 && this._add && this._add(Dn);
        Cn[In] = null;
      }
    }, _n.prototype._initIndexMap = function(nr, Cn, Bn, In) {
      for (var Dn = this._diffModeMultiple, Ln = 0; Ln < nr.length; Ln++) {
        var $n = "_ec_" + this[In](nr[Ln], Ln);
        if (Dn || (Bn[Ln] = $n), !!Cn) {
          var Nn = Cn[$n], Rn = dataIndexMapValueLength(Nn);
          Rn === 0 ? (Cn[$n] = Ln, Dn && Bn.push($n)) : Rn === 1 ? Cn[$n] = [Nn, Ln] : Nn.push(Ln);
        }
      }
    }, _n;
  }()
);
const DataDiffer$1 = DataDiffer;
var DimensionUserOuput = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this._encode = nr, this._schema = Cn;
    }
    return _n.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, _n.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, _n;
  }()
);
function summarizeDimensions(_n, nr) {
  var Cn = {}, Bn = Cn.encode = {}, In = createHashMap(), Dn = [], Ln = [], $n = {};
  each$f(_n.dimensions, function(Un) {
    var Hn = _n.getDimensionInfo(Un), zn = Hn.coordDim;
    if (zn) {
      process.env.NODE_ENV !== "production" && assert(VISUAL_DIMENSIONS.get(zn) == null);
      var Gn = Hn.coordDimIndex;
      getOrCreateEncodeArr(Bn, zn)[Gn] = Un, Hn.isExtraCoord || (In.set(zn, 1), mayLabelDimType(Hn.type) && (Dn[0] = Un), getOrCreateEncodeArr($n, zn)[Gn] = _n.getDimensionIndex(Hn.name)), Hn.defaultTooltip && Ln.push(Un);
    }
    VISUAL_DIMENSIONS.each(function(Yn, Wn) {
      var Xn = getOrCreateEncodeArr(Bn, Wn), ea = Hn.otherDims[Wn];
      ea != null && ea !== !1 && (Xn[ea] = Hn.name);
    });
  });
  var Nn = [], Rn = {};
  In.each(function(Un, Hn) {
    var zn = Bn[Hn];
    Rn[Hn] = zn[0], Nn = Nn.concat(zn);
  }), Cn.dataDimsOnCoord = Nn, Cn.dataDimIndicesOnCoord = map$1(Nn, function(Un) {
    return _n.getDimensionInfo(Un).storeDimIndex;
  }), Cn.encodeFirstDimNotExtra = Rn;
  var Fn = Bn.label;
  Fn && Fn.length && (Dn = Fn.slice());
  var Pn = Bn.tooltip;
  return Pn && Pn.length ? Ln = Pn.slice() : Ln.length || (Ln = Dn.slice()), Bn.defaultedLabel = Dn, Bn.defaultedTooltip = Ln, Cn.userOutput = new DimensionUserOuput($n, nr), Cn;
}
function getOrCreateEncodeArr(_n, nr) {
  return _n.hasOwnProperty(nr) || (_n[nr] = []), _n[nr];
}
function getDimensionTypeByAxis(_n) {
  return _n === "category" ? "ordinal" : _n === "time" ? "time" : "float";
}
function mayLabelDimType(_n) {
  return !(_n === "ordinal" || _n === "time");
}
var SeriesDimensionDefine = (
  /** @class */
  function() {
    function _n(nr) {
      this.otherDims = {}, nr != null && extend(this, nr);
    }
    return _n;
  }()
);
const SeriesDimensionDefine$1 = SeriesDimensionDefine;
var inner$h = makeInner(), dimTypeShort = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, SeriesDataSchema = (
  /** @class */
  function() {
    function _n(nr) {
      this.dimensions = nr.dimensions, this._dimOmitted = nr.dimensionOmitted, this.source = nr.source, this._fullDimCount = nr.fullDimensionCount, this._updateDimOmitted(nr.dimensionOmitted);
    }
    return _n.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, _n.prototype._updateDimOmitted = function(nr) {
      this._dimOmitted = nr, nr && (this._dimNameMap || (this._dimNameMap = ensureSourceDimNameMap(this.source)));
    }, _n.prototype.getSourceDimensionIndex = function(nr) {
      return retrieve2(this._dimNameMap.get(nr), -1);
    }, _n.prototype.getSourceDimension = function(nr) {
      var Cn = this.source.dimensionsDefine;
      if (Cn)
        return Cn[nr];
    }, _n.prototype.makeStoreSchema = function() {
      for (var nr = this._fullDimCount, Cn = shouldRetrieveDataByName(this.source), Bn = !shouldOmitUnusedDimensions(nr), In = "", Dn = [], Ln = 0, $n = 0; Ln < nr; Ln++) {
        var Nn = void 0, Rn = void 0, Fn = void 0, Pn = this.dimensions[$n];
        if (Pn && Pn.storeDimIndex === Ln)
          Nn = Cn ? Pn.name : null, Rn = Pn.type, Fn = Pn.ordinalMeta, $n++;
        else {
          var Un = this.getSourceDimension(Ln);
          Un && (Nn = Cn ? Un.name : null, Rn = Un.type);
        }
        Dn.push({
          property: Nn,
          type: Rn,
          ordinalMeta: Fn
        }), Cn && Nn != null && (!Pn || !Pn.isCalculationCoord) && (In += Bn ? Nn.replace(/\`/g, "`1").replace(/\$/g, "`2") : Nn), In += "$", In += dimTypeShort[Rn] || "f", Fn && (In += Fn.uid), In += "$";
      }
      var Hn = this.source, zn = [Hn.seriesLayoutBy, Hn.startIndex, In].join("$$");
      return {
        dimensions: Dn,
        hash: zn
      };
    }, _n.prototype.makeOutputDimensionNames = function() {
      for (var nr = [], Cn = 0, Bn = 0; Cn < this._fullDimCount; Cn++) {
        var In = void 0, Dn = this.dimensions[Bn];
        if (Dn && Dn.storeDimIndex === Cn)
          Dn.isCalculationCoord || (In = Dn.name), Bn++;
        else {
          var Ln = this.getSourceDimension(Cn);
          Ln && (In = Ln.name);
        }
        nr.push(In);
      }
      return nr;
    }, _n.prototype.appendCalculationDimension = function(nr) {
      this.dimensions.push(nr), nr.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, _n;
  }()
);
function isSeriesDataSchema(_n) {
  return _n instanceof SeriesDataSchema;
}
function createDimNameMap(_n) {
  for (var nr = createHashMap(), Cn = 0; Cn < (_n || []).length; Cn++) {
    var Bn = _n[Cn], In = isObject$6(Bn) ? Bn.name : Bn;
    In != null && nr.get(In) == null && nr.set(In, Cn);
  }
  return nr;
}
function ensureSourceDimNameMap(_n) {
  var nr = inner$h(_n);
  return nr.dimNameMap || (nr.dimNameMap = createDimNameMap(_n.dimensionsDefine));
}
function shouldOmitUnusedDimensions(_n) {
  return _n > 30;
}
var isObject$4 = isObject$6, map = map$1, CtorInt32Array = typeof Int32Array > "u" ? Array : Int32Array, ID_PREFIX = "e\0\0", INDEX_NOT_FOUND = -1, TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], CLONE_PROPERTIES = ["_approximateExtent"], prepareInvertedIndex, getId, getIdNameFromStore, normalizeDimensions, transferProperties, cloneListForMapAndSample, makeIdFromName, SeriesData = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
      var Bn, In = !1;
      isSeriesDataSchema(nr) ? (Bn = nr.dimensions, this._dimOmitted = nr.isDimensionOmitted(), this._schema = nr) : (In = !0, Bn = nr), Bn = Bn || ["x", "y"];
      for (var Dn = {}, Ln = [], $n = {}, Nn = !1, Rn = {}, Fn = 0; Fn < Bn.length; Fn++) {
        var Pn = Bn[Fn], Un = isString$1(Pn) ? new SeriesDimensionDefine$1({
          name: Pn
        }) : Pn instanceof SeriesDimensionDefine$1 ? Pn : new SeriesDimensionDefine$1(Pn), Hn = Un.name;
        Un.type = Un.type || "float", Un.coordDim || (Un.coordDim = Hn, Un.coordDimIndex = 0);
        var zn = Un.otherDims = Un.otherDims || {};
        Ln.push(Hn), Dn[Hn] = Un, Rn[Hn] != null && (Nn = !0), Un.createInvertedIndices && ($n[Hn] = []), zn.itemName === 0 && (this._nameDimIdx = Fn), zn.itemId === 0 && (this._idDimIdx = Fn), process.env.NODE_ENV !== "production" && assert(In || Un.storeDimIndex >= 0), In && (Un.storeDimIndex = Fn);
      }
      if (this.dimensions = Ln, this._dimInfos = Dn, this._initGetDimensionInfo(Nn), this.hostModel = Cn, this._invertedIndicesMap = $n, this._dimOmitted) {
        var Gn = this._dimIdxToName = createHashMap();
        each$f(Ln, function(Yn) {
          Gn.set(Dn[Yn].storeDimIndex, Yn);
        });
      }
    }
    return _n.prototype.getDimension = function(nr) {
      var Cn = this._recognizeDimIndex(nr);
      if (Cn == null)
        return nr;
      if (Cn = nr, !this._dimOmitted)
        return this.dimensions[Cn];
      var Bn = this._dimIdxToName.get(Cn);
      if (Bn != null)
        return Bn;
      var In = this._schema.getSourceDimension(Cn);
      if (In)
        return In.name;
    }, _n.prototype.getDimensionIndex = function(nr) {
      var Cn = this._recognizeDimIndex(nr);
      if (Cn != null)
        return Cn;
      if (nr == null)
        return -1;
      var Bn = this._getDimInfo(nr);
      return Bn ? Bn.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(nr) : -1;
    }, _n.prototype._recognizeDimIndex = function(nr) {
      if (isNumber(nr) || nr != null && !isNaN(nr) && !this._getDimInfo(nr) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(nr) < 0))
        return +nr;
    }, _n.prototype._getStoreDimIndex = function(nr) {
      var Cn = this.getDimensionIndex(nr);
      if (process.env.NODE_ENV !== "production" && Cn == null)
        throw new Error("Unknown dimension " + nr);
      return Cn;
    }, _n.prototype.getDimensionInfo = function(nr) {
      return this._getDimInfo(this.getDimension(nr));
    }, _n.prototype._initGetDimensionInfo = function(nr) {
      var Cn = this._dimInfos;
      this._getDimInfo = nr ? function(Bn) {
        return Cn.hasOwnProperty(Bn) ? Cn[Bn] : void 0;
      } : function(Bn) {
        return Cn[Bn];
      };
    }, _n.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, _n.prototype.mapDimension = function(nr, Cn) {
      var Bn = this._dimSummary;
      if (Cn == null)
        return Bn.encodeFirstDimNotExtra[nr];
      var In = Bn.encode[nr];
      return In ? In[Cn] : null;
    }, _n.prototype.mapDimensionsAll = function(nr) {
      var Cn = this._dimSummary, Bn = Cn.encode[nr];
      return (Bn || []).slice();
    }, _n.prototype.getStore = function() {
      return this._store;
    }, _n.prototype.initData = function(nr, Cn, Bn) {
      var In = this, Dn;
      if (nr instanceof DataStore$1 && (Dn = nr), !Dn) {
        var Ln = this.dimensions, $n = isSourceInstance(nr) || isArrayLike$1(nr) ? new DefaultDataProvider(nr, Ln.length) : nr;
        Dn = new DataStore$1();
        var Nn = map(Ln, function(Rn) {
          return {
            type: In._dimInfos[Rn].type,
            property: Rn
          };
        });
        Dn.initData($n, Nn, Bn);
      }
      this._store = Dn, this._nameList = (Cn || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, Dn.count()), this._dimSummary = summarizeDimensions(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, _n.prototype.appendData = function(nr) {
      var Cn = this._store.appendData(nr);
      this._doInit(Cn[0], Cn[1]);
    }, _n.prototype.appendValues = function(nr, Cn) {
      var Bn = this._store.appendValues(nr, Cn && Cn.length), In = Bn.start, Dn = Bn.end, Ln = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), Cn)
        for (var $n = In; $n < Dn; $n++) {
          var Nn = $n - In;
          this._nameList[$n] = Cn[Nn], Ln && makeIdFromName(this, $n);
        }
    }, _n.prototype._updateOrdinalMeta = function() {
      for (var nr = this._store, Cn = this.dimensions, Bn = 0; Bn < Cn.length; Bn++) {
        var In = this._dimInfos[Cn[Bn]];
        In.ordinalMeta && nr.collectOrdinalMeta(In.storeDimIndex, In.ordinalMeta);
      }
    }, _n.prototype._shouldMakeIdFromName = function() {
      var nr = this._store.getProvider();
      return this._idDimIdx == null && nr.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !nr.fillStorage;
    }, _n.prototype._doInit = function(nr, Cn) {
      if (!(nr >= Cn)) {
        var Bn = this._store, In = Bn.getProvider();
        this._updateOrdinalMeta();
        var Dn = this._nameList, Ln = this._idList, $n = In.getSource().sourceFormat, Nn = $n === SOURCE_FORMAT_ORIGINAL;
        if (Nn && !In.pure)
          for (var Rn = [], Fn = nr; Fn < Cn; Fn++) {
            var Pn = In.getItem(Fn, Rn);
            if (!this.hasItemOption && isDataItemOption(Pn) && (this.hasItemOption = !0), Pn) {
              var Un = Pn.name;
              Dn[Fn] == null && Un != null && (Dn[Fn] = convertOptionIdName(Un, null));
              var Hn = Pn.id;
              Ln[Fn] == null && Hn != null && (Ln[Fn] = convertOptionIdName(Hn, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var Fn = nr; Fn < Cn; Fn++)
            makeIdFromName(this, Fn);
        prepareInvertedIndex(this);
      }
    }, _n.prototype.getApproximateExtent = function(nr) {
      return this._approximateExtent[nr] || this._store.getDataExtent(this._getStoreDimIndex(nr));
    }, _n.prototype.setApproximateExtent = function(nr, Cn) {
      Cn = this.getDimension(Cn), this._approximateExtent[Cn] = nr.slice();
    }, _n.prototype.getCalculationInfo = function(nr) {
      return this._calculationInfo[nr];
    }, _n.prototype.setCalculationInfo = function(nr, Cn) {
      isObject$4(nr) ? extend(this._calculationInfo, nr) : this._calculationInfo[nr] = Cn;
    }, _n.prototype.getName = function(nr) {
      var Cn = this.getRawIndex(nr), Bn = this._nameList[Cn];
      return Bn == null && this._nameDimIdx != null && (Bn = getIdNameFromStore(this, this._nameDimIdx, Cn)), Bn == null && (Bn = ""), Bn;
    }, _n.prototype._getCategory = function(nr, Cn) {
      var Bn = this._store.get(nr, Cn), In = this._store.getOrdinalMeta(nr);
      return In ? In.categories[Bn] : Bn;
    }, _n.prototype.getId = function(nr) {
      return getId(this, this.getRawIndex(nr));
    }, _n.prototype.count = function() {
      return this._store.count();
    }, _n.prototype.get = function(nr, Cn) {
      var Bn = this._store, In = this._dimInfos[nr];
      if (In)
        return Bn.get(In.storeDimIndex, Cn);
    }, _n.prototype.getByRawIndex = function(nr, Cn) {
      var Bn = this._store, In = this._dimInfos[nr];
      if (In)
        return Bn.getByRawIndex(In.storeDimIndex, Cn);
    }, _n.prototype.getIndices = function() {
      return this._store.getIndices();
    }, _n.prototype.getDataExtent = function(nr) {
      return this._store.getDataExtent(this._getStoreDimIndex(nr));
    }, _n.prototype.getSum = function(nr) {
      return this._store.getSum(this._getStoreDimIndex(nr));
    }, _n.prototype.getMedian = function(nr) {
      return this._store.getMedian(this._getStoreDimIndex(nr));
    }, _n.prototype.getValues = function(nr, Cn) {
      var Bn = this, In = this._store;
      return isArray$4(nr) ? In.getValues(map(nr, function(Dn) {
        return Bn._getStoreDimIndex(Dn);
      }), Cn) : In.getValues(nr);
    }, _n.prototype.hasValue = function(nr) {
      for (var Cn = this._dimSummary.dataDimIndicesOnCoord, Bn = 0, In = Cn.length; Bn < In; Bn++)
        if (isNaN(this._store.get(Cn[Bn], nr)))
          return !1;
      return !0;
    }, _n.prototype.indexOfName = function(nr) {
      for (var Cn = 0, Bn = this._store.count(); Cn < Bn; Cn++)
        if (this.getName(Cn) === nr)
          return Cn;
      return -1;
    }, _n.prototype.getRawIndex = function(nr) {
      return this._store.getRawIndex(nr);
    }, _n.prototype.indexOfRawIndex = function(nr) {
      return this._store.indexOfRawIndex(nr);
    }, _n.prototype.rawIndexOf = function(nr, Cn) {
      var Bn = nr && this._invertedIndicesMap[nr];
      if (process.env.NODE_ENV !== "production" && !Bn)
        throw new Error("Do not supported yet");
      var In = Bn && Bn[Cn];
      return In == null || isNaN(In) ? INDEX_NOT_FOUND : In;
    }, _n.prototype.indicesOfNearest = function(nr, Cn, Bn) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(nr), Cn, Bn);
    }, _n.prototype.each = function(nr, Cn, Bn) {
      isFunction$1(nr) && (Bn = Cn, Cn = nr, nr = []);
      var In = Bn || this, Dn = map(normalizeDimensions(nr), this._getStoreDimIndex, this);
      this._store.each(Dn, In ? bind$1(Cn, In) : Cn);
    }, _n.prototype.filterSelf = function(nr, Cn, Bn) {
      isFunction$1(nr) && (Bn = Cn, Cn = nr, nr = []);
      var In = Bn || this, Dn = map(normalizeDimensions(nr), this._getStoreDimIndex, this);
      return this._store = this._store.filter(Dn, In ? bind$1(Cn, In) : Cn), this;
    }, _n.prototype.selectRange = function(nr) {
      var Cn = this, Bn = {}, In = keys(nr);
      return each$f(In, function(Dn) {
        var Ln = Cn._getStoreDimIndex(Dn);
        Bn[Ln] = nr[Dn];
      }), this._store = this._store.selectRange(Bn), this;
    }, _n.prototype.mapArray = function(nr, Cn, Bn) {
      isFunction$1(nr) && (Bn = Cn, Cn = nr, nr = []), Bn = Bn || this;
      var In = [];
      return this.each(nr, function() {
        In.push(Cn && Cn.apply(this, arguments));
      }, Bn), In;
    }, _n.prototype.map = function(nr, Cn, Bn, In) {
      var Dn = Bn || In || this, Ln = map(normalizeDimensions(nr), this._getStoreDimIndex, this), $n = cloneListForMapAndSample(this);
      return $n._store = this._store.map(Ln, Dn ? bind$1(Cn, Dn) : Cn), $n;
    }, _n.prototype.modify = function(nr, Cn, Bn, In) {
      var Dn = this, Ln = Bn || In || this;
      process.env.NODE_ENV !== "production" && each$f(normalizeDimensions(nr), function(Nn) {
        var Rn = Dn.getDimensionInfo(Nn);
        Rn.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var $n = map(normalizeDimensions(nr), this._getStoreDimIndex, this);
      this._store.modify($n, Ln ? bind$1(Cn, Ln) : Cn);
    }, _n.prototype.downSample = function(nr, Cn, Bn, In) {
      var Dn = cloneListForMapAndSample(this);
      return Dn._store = this._store.downSample(this._getStoreDimIndex(nr), Cn, Bn, In), Dn;
    }, _n.prototype.minmaxDownSample = function(nr, Cn) {
      var Bn = cloneListForMapAndSample(this);
      return Bn._store = this._store.minmaxDownSample(this._getStoreDimIndex(nr), Cn), Bn;
    }, _n.prototype.lttbDownSample = function(nr, Cn) {
      var Bn = cloneListForMapAndSample(this);
      return Bn._store = this._store.lttbDownSample(this._getStoreDimIndex(nr), Cn), Bn;
    }, _n.prototype.getRawDataItem = function(nr) {
      return this._store.getRawDataItem(nr);
    }, _n.prototype.getItemModel = function(nr) {
      var Cn = this.hostModel, Bn = this.getRawDataItem(nr);
      return new Model$1(Bn, Cn, Cn && Cn.ecModel);
    }, _n.prototype.diff = function(nr) {
      var Cn = this;
      return new DataDiffer$1(nr ? nr.getStore().getIndices() : [], this.getStore().getIndices(), function(Bn) {
        return getId(nr, Bn);
      }, function(Bn) {
        return getId(Cn, Bn);
      });
    }, _n.prototype.getVisual = function(nr) {
      var Cn = this._visual;
      return Cn && Cn[nr];
    }, _n.prototype.setVisual = function(nr, Cn) {
      this._visual = this._visual || {}, isObject$4(nr) ? extend(this._visual, nr) : this._visual[nr] = Cn;
    }, _n.prototype.getItemVisual = function(nr, Cn) {
      var Bn = this._itemVisuals[nr], In = Bn && Bn[Cn];
      return In ?? this.getVisual(Cn);
    }, _n.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, _n.prototype.ensureUniqueItemVisual = function(nr, Cn) {
      var Bn = this._itemVisuals, In = Bn[nr];
      In || (In = Bn[nr] = {});
      var Dn = In[Cn];
      return Dn == null && (Dn = this.getVisual(Cn), isArray$4(Dn) ? Dn = Dn.slice() : isObject$4(Dn) && (Dn = extend({}, Dn)), In[Cn] = Dn), Dn;
    }, _n.prototype.setItemVisual = function(nr, Cn, Bn) {
      var In = this._itemVisuals[nr] || {};
      this._itemVisuals[nr] = In, isObject$4(Cn) ? extend(In, Cn) : In[Cn] = Bn;
    }, _n.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, _n.prototype.setLayout = function(nr, Cn) {
      isObject$4(nr) ? extend(this._layout, nr) : this._layout[nr] = Cn;
    }, _n.prototype.getLayout = function(nr) {
      return this._layout[nr];
    }, _n.prototype.getItemLayout = function(nr) {
      return this._itemLayouts[nr];
    }, _n.prototype.setItemLayout = function(nr, Cn, Bn) {
      this._itemLayouts[nr] = Bn ? extend(this._itemLayouts[nr] || {}, Cn) : Cn;
    }, _n.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, _n.prototype.setItemGraphicEl = function(nr, Cn) {
      var Bn = this.hostModel && this.hostModel.seriesIndex;
      setCommonECData(Bn, this.dataType, nr, Cn), this._graphicEls[nr] = Cn;
    }, _n.prototype.getItemGraphicEl = function(nr) {
      return this._graphicEls[nr];
    }, _n.prototype.eachItemGraphicEl = function(nr, Cn) {
      each$f(this._graphicEls, function(Bn, In) {
        Bn && nr && nr.call(Cn, Bn, In);
      });
    }, _n.prototype.cloneShallow = function(nr) {
      return nr || (nr = new _n(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel)), transferProperties(nr, this), nr._store = this._store, nr;
    }, _n.prototype.wrapMethod = function(nr, Cn) {
      var Bn = this[nr];
      isFunction$1(Bn) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(nr), this[nr] = function() {
        var In = Bn.apply(this, arguments);
        return Cn.apply(this, [In].concat(slice(arguments)));
      });
    }, _n.internalField = function() {
      prepareInvertedIndex = function(nr) {
        var Cn = nr._invertedIndicesMap;
        each$f(Cn, function(Bn, In) {
          var Dn = nr._dimInfos[In], Ln = Dn.ordinalMeta, $n = nr._store;
          if (Ln) {
            Bn = Cn[In] = new CtorInt32Array(Ln.categories.length);
            for (var Nn = 0; Nn < Bn.length; Nn++)
              Bn[Nn] = INDEX_NOT_FOUND;
            for (var Nn = 0; Nn < $n.count(); Nn++)
              Bn[$n.get(Dn.storeDimIndex, Nn)] = Nn;
          }
        });
      }, getIdNameFromStore = function(nr, Cn, Bn) {
        return convertOptionIdName(nr._getCategory(Cn, Bn), null);
      }, getId = function(nr, Cn) {
        var Bn = nr._idList[Cn];
        return Bn == null && nr._idDimIdx != null && (Bn = getIdNameFromStore(nr, nr._idDimIdx, Cn)), Bn == null && (Bn = ID_PREFIX + Cn), Bn;
      }, normalizeDimensions = function(nr) {
        return isArray$4(nr) || (nr = nr != null ? [nr] : []), nr;
      }, cloneListForMapAndSample = function(nr) {
        var Cn = new _n(nr._schema ? nr._schema : map(nr.dimensions, nr._getDimInfo, nr), nr.hostModel);
        return transferProperties(Cn, nr), Cn;
      }, transferProperties = function(nr, Cn) {
        each$f(TRANSFERABLE_PROPERTIES.concat(Cn.__wrappedMethods || []), function(Bn) {
          Cn.hasOwnProperty(Bn) && (nr[Bn] = Cn[Bn]);
        }), nr.__wrappedMethods = Cn.__wrappedMethods, each$f(CLONE_PROPERTIES, function(Bn) {
          nr[Bn] = clone$4(Cn[Bn]);
        }), nr._calculationInfo = extend({}, Cn._calculationInfo);
      }, makeIdFromName = function(nr, Cn) {
        var Bn = nr._nameList, In = nr._idList, Dn = nr._nameDimIdx, Ln = nr._idDimIdx, $n = Bn[Cn], Nn = In[Cn];
        if ($n == null && Dn != null && (Bn[Cn] = $n = getIdNameFromStore(nr, Dn, Cn)), Nn == null && Ln != null && (In[Cn] = Nn = getIdNameFromStore(nr, Ln, Cn)), Nn == null && $n != null) {
          var Rn = nr._nameRepeatCount, Fn = Rn[$n] = (Rn[$n] || 0) + 1;
          Nn = $n, Fn > 1 && (Nn += "__ec__" + Fn), In[Cn] = Nn;
        }
      };
    }(), _n;
  }()
);
const SeriesData$1 = SeriesData;
function createDimensions(_n, nr) {
  return prepareSeriesDataSchema(_n, nr).dimensions;
}
function prepareSeriesDataSchema(_n, nr) {
  isSourceInstance(_n) || (_n = createSourceFromSeriesDataOption(_n)), nr = nr || {};
  var Cn = nr.coordDimensions || [], Bn = nr.dimensionsDefine || _n.dimensionsDefine || [], In = createHashMap(), Dn = [], Ln = getDimCount(_n, Cn, Bn, nr.dimensionsCount), $n = nr.canOmitUnusedDimensions && shouldOmitUnusedDimensions(Ln), Nn = Bn === _n.dimensionsDefine, Rn = Nn ? ensureSourceDimNameMap(_n) : createDimNameMap(Bn), Fn = nr.encodeDefine;
  !Fn && nr.encodeDefaulter && (Fn = nr.encodeDefaulter(_n, Ln));
  for (var Pn = createHashMap(Fn), Un = new CtorInt32Array$1(Ln), Hn = 0; Hn < Un.length; Hn++)
    Un[Hn] = -1;
  function zn(Aa) {
    var sa = Un[Aa];
    if (sa < 0) {
      var oa = Bn[Aa], la = isObject$6(oa) ? oa : {
        name: oa
      }, ua = new SeriesDimensionDefine$1(), ca = la.name;
      ca != null && Rn.get(ca) != null && (ua.name = ua.displayName = ca), la.type != null && (ua.type = la.type), la.displayName != null && (ua.displayName = la.displayName);
      var fa = Dn.length;
      return Un[Aa] = fa, ua.storeDimIndex = Aa, Dn.push(ua), ua;
    }
    return Dn[sa];
  }
  if (!$n)
    for (var Hn = 0; Hn < Ln; Hn++)
      zn(Hn);
  Pn.each(function(Aa, sa) {
    var oa = normalizeToArray(Aa).slice();
    if (oa.length === 1 && !isString$1(oa[0]) && oa[0] < 0) {
      Pn.set(sa, !1);
      return;
    }
    var la = Pn.set(sa, []);
    each$f(oa, function(ua, ca) {
      var fa = isString$1(ua) ? Rn.get(ua) : ua;
      fa != null && fa < Ln && (la[ca] = fa, Yn(zn(fa), sa, ca));
    });
  });
  var Gn = 0;
  each$f(Cn, function(Aa) {
    var sa, oa, la, ua;
    if (isString$1(Aa))
      sa = Aa, ua = {};
    else {
      ua = Aa, sa = ua.name;
      var ca = ua.ordinalMeta;
      ua.ordinalMeta = null, ua = extend({}, ua), ua.ordinalMeta = ca, oa = ua.dimsDef, la = ua.otherDims, ua.name = ua.coordDim = ua.coordDimIndex = ua.dimsDef = ua.otherDims = null;
    }
    var fa = Pn.get(sa);
    if (fa !== !1) {
      if (fa = normalizeToArray(fa), !fa.length)
        for (var ha = 0; ha < (oa && oa.length || 1); ha++) {
          for (; Gn < Ln && zn(Gn).coordDim != null; )
            Gn++;
          Gn < Ln && fa.push(Gn++);
        }
      each$f(fa, function(pa, ya) {
        var da = zn(pa);
        if (Nn && ua.type != null && (da.type = ua.type), Yn(defaults(da, ua), sa, ya), da.name == null && oa) {
          var Ca = oa[ya];
          !isObject$6(Ca) && (Ca = {
            name: Ca
          }), da.name = da.displayName = Ca.name, da.defaultTooltip = Ca.defaultTooltip;
        }
        la && defaults(da.otherDims, la);
      });
    }
  });
  function Yn(Aa, sa, oa) {
    VISUAL_DIMENSIONS.get(sa) != null ? Aa.otherDims[sa] = oa : (Aa.coordDim = sa, Aa.coordDimIndex = oa, In.set(sa, !0));
  }
  var Wn = nr.generateCoord, Xn = nr.generateCoordCount, ea = Xn != null;
  Xn = Wn ? Xn || 1 : 0;
  var ta = Wn || "value";
  function na(Aa) {
    Aa.name == null && (Aa.name = Aa.coordDim);
  }
  if ($n)
    each$f(Dn, function(Aa) {
      na(Aa);
    }), Dn.sort(function(Aa, sa) {
      return Aa.storeDimIndex - sa.storeDimIndex;
    });
  else
    for (var ra = 0; ra < Ln; ra++) {
      var aa = zn(ra), ia = aa.coordDim;
      ia == null && (aa.coordDim = genCoordDimName(ta, In, ea), aa.coordDimIndex = 0, (!Wn || Xn <= 0) && (aa.isExtraCoord = !0), Xn--), na(aa), aa.type == null && (guessOrdinal(_n, ra) === BE_ORDINAL.Must || aa.isExtraCoord && (aa.otherDims.itemName != null || aa.otherDims.seriesName != null)) && (aa.type = "ordinal");
    }
  return removeDuplication(Dn), new SeriesDataSchema({
    source: _n,
    dimensions: Dn,
    fullDimensionCount: Ln,
    dimensionOmitted: $n
  });
}
function removeDuplication(_n) {
  for (var nr = createHashMap(), Cn = 0; Cn < _n.length; Cn++) {
    var Bn = _n[Cn], In = Bn.name, Dn = nr.get(In) || 0;
    Dn > 0 && (Bn.name = In + (Dn - 1)), Dn++, nr.set(In, Dn);
  }
}
function getDimCount(_n, nr, Cn, Bn) {
  var In = Math.max(_n.dimensionsDetectedCount || 1, nr.length, Cn.length, Bn || 0);
  return each$f(nr, function(Dn) {
    var Ln;
    isObject$6(Dn) && (Ln = Dn.dimsDef) && (In = Math.max(In, Ln.length));
  }), In;
}
function genCoordDimName(_n, nr, Cn) {
  if (Cn || nr.hasKey(_n)) {
    for (var Bn = 0; nr.hasKey(_n + Bn); )
      Bn++;
    _n += Bn;
  }
  return nr.set(_n, !0), _n;
}
var CoordSysInfo = (
  /** @class */
  function() {
    function _n(nr) {
      this.coordSysDims = [], this.axisMap = createHashMap(), this.categoryAxisMap = createHashMap(), this.coordSysName = nr;
    }
    return _n;
  }()
);
function getCoordSysInfoBySeries(_n) {
  var nr = _n.get("coordinateSystem"), Cn = new CoordSysInfo(nr), Bn = fetchers[nr];
  if (Bn)
    return Bn(_n, Cn, Cn.axisMap, Cn.categoryAxisMap), Cn;
}
var fetchers = {
  cartesian2d: function(_n, nr, Cn, Bn) {
    var In = _n.getReferringComponents("xAxis", SINGLE_REFERRING).models[0], Dn = _n.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!In)
        throw new Error('xAxis "' + retrieve(_n.get("xAxisIndex"), _n.get("xAxisId"), 0) + '" not found');
      if (!Dn)
        throw new Error('yAxis "' + retrieve(_n.get("xAxisIndex"), _n.get("yAxisId"), 0) + '" not found');
    }
    nr.coordSysDims = ["x", "y"], Cn.set("x", In), Cn.set("y", Dn), isCategory(In) && (Bn.set("x", In), nr.firstCategoryDimIndex = 0), isCategory(Dn) && (Bn.set("y", Dn), nr.firstCategoryDimIndex == null && (nr.firstCategoryDimIndex = 1));
  },
  singleAxis: function(_n, nr, Cn, Bn) {
    var In = _n.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    if (process.env.NODE_ENV !== "production" && !In)
      throw new Error("singleAxis should be specified.");
    nr.coordSysDims = ["single"], Cn.set("single", In), isCategory(In) && (Bn.set("single", In), nr.firstCategoryDimIndex = 0);
  },
  polar: function(_n, nr, Cn, Bn) {
    var In = _n.getReferringComponents("polar", SINGLE_REFERRING).models[0], Dn = In.findAxisModel("radiusAxis"), Ln = In.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!Ln)
        throw new Error("angleAxis option not found");
      if (!Dn)
        throw new Error("radiusAxis option not found");
    }
    nr.coordSysDims = ["radius", "angle"], Cn.set("radius", Dn), Cn.set("angle", Ln), isCategory(Dn) && (Bn.set("radius", Dn), nr.firstCategoryDimIndex = 0), isCategory(Ln) && (Bn.set("angle", Ln), nr.firstCategoryDimIndex == null && (nr.firstCategoryDimIndex = 1));
  },
  geo: function(_n, nr, Cn, Bn) {
    nr.coordSysDims = ["lng", "lat"];
  },
  parallel: function(_n, nr, Cn, Bn) {
    var In = _n.ecModel, Dn = In.getComponent("parallel", _n.get("parallelIndex")), Ln = nr.coordSysDims = Dn.dimensions.slice();
    each$f(Dn.parallelAxisIndex, function($n, Nn) {
      var Rn = In.getComponent("parallelAxis", $n), Fn = Ln[Nn];
      Cn.set(Fn, Rn), isCategory(Rn) && (Bn.set(Fn, Rn), nr.firstCategoryDimIndex == null && (nr.firstCategoryDimIndex = Nn));
    });
  }
};
function isCategory(_n) {
  return _n.get("type") === "category";
}
function enableDataStack(_n, nr, Cn) {
  Cn = Cn || {};
  var Bn = Cn.byIndex, In = Cn.stackedCoordDimension, Dn, Ln, $n;
  isLegacyDimensionsInput(nr) ? Dn = nr : (Ln = nr.schema, Dn = Ln.dimensions, $n = nr.store);
  var Nn = !!(_n && _n.get("stack")), Rn, Fn, Pn, Un;
  if (each$f(Dn, function(Xn, ea) {
    isString$1(Xn) && (Dn[ea] = Xn = {
      name: Xn
    }), Nn && !Xn.isExtraCoord && (!Bn && !Rn && Xn.ordinalMeta && (Rn = Xn), !Fn && Xn.type !== "ordinal" && Xn.type !== "time" && (!In || In === Xn.coordDim) && (Fn = Xn));
  }), Fn && !Bn && !Rn && (Bn = !0), Fn) {
    Pn = "__\0ecstackresult_" + _n.id, Un = "__\0ecstackedover_" + _n.id, Rn && (Rn.createInvertedIndices = !0);
    var Hn = Fn.coordDim, zn = Fn.type, Gn = 0;
    each$f(Dn, function(Xn) {
      Xn.coordDim === Hn && Gn++;
    });
    var Yn = {
      name: Pn,
      coordDim: Hn,
      coordDimIndex: Gn,
      type: zn,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: Dn.length
    }, Wn = {
      name: Un,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: Un,
      coordDimIndex: Gn + 1,
      type: zn,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: Dn.length + 1
    };
    Ln ? ($n && (Yn.storeDimIndex = $n.ensureCalculationDimension(Un, zn), Wn.storeDimIndex = $n.ensureCalculationDimension(Pn, zn)), Ln.appendCalculationDimension(Yn), Ln.appendCalculationDimension(Wn)) : (Dn.push(Yn), Dn.push(Wn));
  }
  return {
    stackedDimension: Fn && Fn.name,
    stackedByDimension: Rn && Rn.name,
    isStackedByIndex: Bn,
    stackedOverDimension: Un,
    stackResultDimension: Pn
  };
}
function isLegacyDimensionsInput(_n) {
  return !isSeriesDataSchema(_n.schema);
}
function isDimensionStacked(_n, nr) {
  return !!nr && nr === _n.getCalculationInfo("stackedDimension");
}
function getStackedDimension(_n, nr) {
  return isDimensionStacked(_n, nr) ? _n.getCalculationInfo("stackResultDimension") : nr;
}
function getCoordSysDimDefs(_n, nr) {
  var Cn = _n.get("coordinateSystem"), Bn = CoordinateSystem.get(Cn), In;
  return nr && nr.coordSysDims && (In = map$1(nr.coordSysDims, function(Dn) {
    var Ln = {
      name: Dn
    }, $n = nr.axisMap.get(Dn);
    if ($n) {
      var Nn = $n.get("type");
      Ln.type = getDimensionTypeByAxis(Nn);
    }
    return Ln;
  })), In || (In = Bn && (Bn.getDimensionsInfo ? Bn.getDimensionsInfo() : Bn.dimensions.slice()) || ["x", "y"]), In;
}
function injectOrdinalMeta(_n, nr, Cn) {
  var Bn, In;
  return Cn && each$f(_n, function(Dn, Ln) {
    var $n = Dn.coordDim, Nn = Cn.categoryAxisMap.get($n);
    Nn && (Bn == null && (Bn = Ln), Dn.ordinalMeta = Nn.getOrdinalMeta(), nr && (Dn.createInvertedIndices = !0)), Dn.otherDims.itemName != null && (In = !0);
  }), !In && Bn != null && (_n[Bn].otherDims.itemName = 0), Bn;
}
function createSeriesData(_n, nr, Cn) {
  Cn = Cn || {};
  var Bn = nr.getSourceManager(), In, Dn = !1;
  _n ? (Dn = !0, In = createSourceFromSeriesDataOption(_n)) : (In = Bn.getSource(), Dn = In.sourceFormat === SOURCE_FORMAT_ORIGINAL);
  var Ln = getCoordSysInfoBySeries(nr), $n = getCoordSysDimDefs(nr, Ln), Nn = Cn.useEncodeDefaulter, Rn = isFunction$1(Nn) ? Nn : Nn ? curry$1(makeSeriesEncodeForAxisCoordSys, $n, nr) : null, Fn = {
    coordDimensions: $n,
    generateCoord: Cn.generateCoord,
    encodeDefine: nr.getEncode(),
    encodeDefaulter: Rn,
    canOmitUnusedDimensions: !Dn
  }, Pn = prepareSeriesDataSchema(In, Fn), Un = injectOrdinalMeta(Pn.dimensions, Cn.createInvertedIndices, Ln), Hn = Dn ? null : Bn.getSharedDataStore(Pn), zn = enableDataStack(nr, {
    schema: Pn,
    store: Hn
  }), Gn = new SeriesData$1(Pn, nr);
  Gn.setCalculationInfo(zn);
  var Yn = Un != null && isNeedCompleteOrdinalData(In) ? function(Wn, Xn, ea, ta) {
    return ta === Un ? ea : this.defaultDimValueGetter(Wn, Xn, ea, ta);
  } : null;
  return Gn.hasItemOption = !1, Gn.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    Dn ? In : Hn,
    null,
    Yn
  ), Gn;
}
function isNeedCompleteOrdinalData(_n) {
  if (_n.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var nr = firstDataNotNull(_n.data || []);
    return !isArray$4(getDataItemValue(nr));
  }
}
function firstDataNotNull(_n) {
  for (var nr = 0; nr < _n.length && _n[nr] == null; )
    nr++;
  return _n[nr];
}
var Scale = (
  /** @class */
  function() {
    function _n(nr) {
      this._setting = nr || {}, this._extent = [1 / 0, -1 / 0];
    }
    return _n.prototype.getSetting = function(nr) {
      return this._setting[nr];
    }, _n.prototype.unionExtent = function(nr) {
      var Cn = this._extent;
      nr[0] < Cn[0] && (Cn[0] = nr[0]), nr[1] > Cn[1] && (Cn[1] = nr[1]);
    }, _n.prototype.unionExtentFromData = function(nr, Cn) {
      this.unionExtent(nr.getApproximateExtent(Cn));
    }, _n.prototype.getExtent = function() {
      return this._extent.slice();
    }, _n.prototype.setExtent = function(nr, Cn) {
      var Bn = this._extent;
      isNaN(nr) || (Bn[0] = nr), isNaN(Cn) || (Bn[1] = Cn);
    }, _n.prototype.isInExtentRange = function(nr) {
      return this._extent[0] <= nr && this._extent[1] >= nr;
    }, _n.prototype.isBlank = function() {
      return this._isBlank;
    }, _n.prototype.setBlank = function(nr) {
      this._isBlank = nr;
    }, _n;
  }()
);
enableClassManagement(Scale);
const Scale$1 = Scale;
var uidBase = 0, OrdinalMeta = (
  /** @class */
  function() {
    function _n(nr) {
      this.categories = nr.categories || [], this._needCollect = nr.needCollect, this._deduplication = nr.deduplication, this.uid = ++uidBase;
    }
    return _n.createByAxisModel = function(nr) {
      var Cn = nr.option, Bn = Cn.data, In = Bn && map$1(Bn, getName);
      return new _n({
        categories: In,
        needCollect: !In,
        // deduplication is default in axis.
        deduplication: Cn.dedplication !== !1
      });
    }, _n.prototype.getOrdinal = function(nr) {
      return this._getOrCreateMap().get(nr);
    }, _n.prototype.parseAndCollect = function(nr) {
      var Cn, Bn = this._needCollect;
      if (!isString$1(nr) && !Bn)
        return nr;
      if (Bn && !this._deduplication)
        return Cn = this.categories.length, this.categories[Cn] = nr, Cn;
      var In = this._getOrCreateMap();
      return Cn = In.get(nr), Cn == null && (Bn ? (Cn = this.categories.length, this.categories[Cn] = nr, In.set(nr, Cn)) : Cn = NaN), Cn;
    }, _n.prototype._getOrCreateMap = function() {
      return this._map || (this._map = createHashMap(this.categories));
    }, _n;
  }()
);
function getName(_n) {
  return isObject$6(_n) && _n.value != null ? _n.value : _n + "";
}
const OrdinalMeta$1 = OrdinalMeta;
function isValueNice(_n) {
  var nr = Math.pow(10, quantityExponent(Math.abs(_n))), Cn = Math.abs(_n / nr);
  return Cn === 0 || Cn === 1 || Cn === 2 || Cn === 3 || Cn === 5;
}
function isIntervalOrLogScale(_n) {
  return _n.type === "interval" || _n.type === "log";
}
function intervalScaleNiceTicks(_n, nr, Cn, Bn) {
  var In = {}, Dn = _n[1] - _n[0], Ln = In.interval = nice(Dn / nr, !0);
  Cn != null && Ln < Cn && (Ln = In.interval = Cn), Bn != null && Ln > Bn && (Ln = In.interval = Bn);
  var $n = In.intervalPrecision = getIntervalPrecision(Ln), Nn = In.niceTickExtent = [round$4(Math.ceil(_n[0] / Ln) * Ln, $n), round$4(Math.floor(_n[1] / Ln) * Ln, $n)];
  return fixExtent(Nn, _n), In;
}
function increaseInterval(_n) {
  var nr = Math.pow(10, quantityExponent(_n)), Cn = _n / nr;
  return Cn ? Cn === 2 ? Cn = 3 : Cn === 3 ? Cn = 5 : Cn *= 2 : Cn = 1, round$4(Cn * nr);
}
function getIntervalPrecision(_n) {
  return getPrecision(_n) + 2;
}
function clamp(_n, nr, Cn) {
  _n[nr] = Math.max(Math.min(_n[nr], Cn[1]), Cn[0]);
}
function fixExtent(_n, nr) {
  !isFinite(_n[0]) && (_n[0] = nr[0]), !isFinite(_n[1]) && (_n[1] = nr[1]), clamp(_n, 0, nr), clamp(_n, 1, nr), _n[0] > _n[1] && (_n[0] = _n[1]);
}
function contain$1(_n, nr) {
  return _n >= nr[0] && _n <= nr[1];
}
function normalize$2(_n, nr) {
  return nr[1] === nr[0] ? 0.5 : (_n - nr[0]) / (nr[1] - nr[0]);
}
function scale(_n, nr) {
  return _n * (nr[1] - nr[0]) + nr[0];
}
var OrdinalScale = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      Bn.type = "ordinal";
      var In = Bn.getSetting("ordinalMeta");
      return In || (In = new OrdinalMeta$1({})), isArray$4(In) && (In = new OrdinalMeta$1({
        categories: map$1(In, function(Dn) {
          return isObject$6(Dn) ? Dn.value : Dn;
        })
      })), Bn._ordinalMeta = In, Bn._extent = Bn.getSetting("extent") || [0, In.categories.length - 1], Bn;
    }
    return nr.prototype.parse = function(Cn) {
      return Cn == null ? NaN : isString$1(Cn) ? this._ordinalMeta.getOrdinal(Cn) : Math.round(Cn);
    }, nr.prototype.contain = function(Cn) {
      return Cn = this.parse(Cn), contain$1(Cn, this._extent) && this._ordinalMeta.categories[Cn] != null;
    }, nr.prototype.normalize = function(Cn) {
      return Cn = this._getTickNumber(this.parse(Cn)), normalize$2(Cn, this._extent);
    }, nr.prototype.scale = function(Cn) {
      return Cn = Math.round(scale(Cn, this._extent)), this.getRawOrdinalNumber(Cn);
    }, nr.prototype.getTicks = function() {
      for (var Cn = [], Bn = this._extent, In = Bn[0]; In <= Bn[1]; )
        Cn.push({
          value: In
        }), In++;
      return Cn;
    }, nr.prototype.getMinorTicks = function(Cn) {
    }, nr.prototype.setSortInfo = function(Cn) {
      if (Cn == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var Bn = Cn.ordinalNumbers, In = this._ordinalNumbersByTick = [], Dn = this._ticksByOrdinalNumber = [], Ln = 0, $n = this._ordinalMeta.categories.length, Nn = Math.min($n, Bn.length); Ln < Nn; ++Ln) {
        var Rn = Bn[Ln];
        In[Ln] = Rn, Dn[Rn] = Ln;
      }
      for (var Fn = 0; Ln < $n; ++Ln) {
        for (; Dn[Fn] != null; )
          Fn++;
        In.push(Fn), Dn[Fn] = Ln;
      }
    }, nr.prototype._getTickNumber = function(Cn) {
      var Bn = this._ticksByOrdinalNumber;
      return Bn && Cn >= 0 && Cn < Bn.length ? Bn[Cn] : Cn;
    }, nr.prototype.getRawOrdinalNumber = function(Cn) {
      var Bn = this._ordinalNumbersByTick;
      return Bn && Cn >= 0 && Cn < Bn.length ? Bn[Cn] : Cn;
    }, nr.prototype.getLabel = function(Cn) {
      if (!this.isBlank()) {
        var Bn = this.getRawOrdinalNumber(Cn.value), In = this._ordinalMeta.categories[Bn];
        return In == null ? "" : In + "";
      }
    }, nr.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, nr.prototype.unionExtentFromData = function(Cn, Bn) {
      this.unionExtent(Cn.getApproximateExtent(Bn));
    }, nr.prototype.isInExtentRange = function(Cn) {
      return Cn = this._getTickNumber(Cn), this._extent[0] <= Cn && this._extent[1] >= Cn;
    }, nr.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, nr.prototype.calcNiceTicks = function() {
    }, nr.prototype.calcNiceExtent = function() {
    }, nr.type = "ordinal", nr;
  }(Scale$1)
);
Scale$1.registerClass(OrdinalScale);
const OrdinalScale$1 = OrdinalScale;
var roundNumber = round$4, IntervalScale = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = "interval", Cn._interval = 0, Cn._intervalPrecision = 2, Cn;
    }
    return nr.prototype.parse = function(Cn) {
      return Cn;
    }, nr.prototype.contain = function(Cn) {
      return contain$1(Cn, this._extent);
    }, nr.prototype.normalize = function(Cn) {
      return normalize$2(Cn, this._extent);
    }, nr.prototype.scale = function(Cn) {
      return scale(Cn, this._extent);
    }, nr.prototype.setExtent = function(Cn, Bn) {
      var In = this._extent;
      isNaN(Cn) || (In[0] = parseFloat(Cn)), isNaN(Bn) || (In[1] = parseFloat(Bn));
    }, nr.prototype.unionExtent = function(Cn) {
      var Bn = this._extent;
      Cn[0] < Bn[0] && (Bn[0] = Cn[0]), Cn[1] > Bn[1] && (Bn[1] = Cn[1]), this.setExtent(Bn[0], Bn[1]);
    }, nr.prototype.getInterval = function() {
      return this._interval;
    }, nr.prototype.setInterval = function(Cn) {
      this._interval = Cn, this._niceExtent = this._extent.slice(), this._intervalPrecision = getIntervalPrecision(Cn);
    }, nr.prototype.getTicks = function(Cn) {
      var Bn = this._interval, In = this._extent, Dn = this._niceExtent, Ln = this._intervalPrecision, $n = [];
      if (!Bn)
        return $n;
      var Nn = 1e4;
      In[0] < Dn[0] && (Cn ? $n.push({
        value: roundNumber(Dn[0] - Bn, Ln)
      }) : $n.push({
        value: In[0]
      }));
      for (var Rn = Dn[0]; Rn <= Dn[1] && ($n.push({
        value: Rn
      }), Rn = roundNumber(Rn + Bn, Ln), Rn !== $n[$n.length - 1].value); )
        if ($n.length > Nn)
          return [];
      var Fn = $n.length ? $n[$n.length - 1].value : Dn[1];
      return In[1] > Fn && (Cn ? $n.push({
        value: roundNumber(Fn + Bn, Ln)
      }) : $n.push({
        value: In[1]
      })), $n;
    }, nr.prototype.getMinorTicks = function(Cn) {
      for (var Bn = this.getTicks(!0), In = [], Dn = this.getExtent(), Ln = 1; Ln < Bn.length; Ln++) {
        for (var $n = Bn[Ln], Nn = Bn[Ln - 1], Rn = 0, Fn = [], Pn = $n.value - Nn.value, Un = Pn / Cn; Rn < Cn - 1; ) {
          var Hn = roundNumber(Nn.value + (Rn + 1) * Un);
          Hn > Dn[0] && Hn < Dn[1] && Fn.push(Hn), Rn++;
        }
        In.push(Fn);
      }
      return In;
    }, nr.prototype.getLabel = function(Cn, Bn) {
      if (Cn == null)
        return "";
      var In = Bn && Bn.precision;
      In == null ? In = getPrecision(Cn.value) || 0 : In === "auto" && (In = this._intervalPrecision);
      var Dn = roundNumber(Cn.value, In, !0);
      return addCommas(Dn);
    }, nr.prototype.calcNiceTicks = function(Cn, Bn, In) {
      Cn = Cn || 5;
      var Dn = this._extent, Ln = Dn[1] - Dn[0];
      if (isFinite(Ln)) {
        Ln < 0 && (Ln = -Ln, Dn.reverse());
        var $n = intervalScaleNiceTicks(Dn, Cn, Bn, In);
        this._intervalPrecision = $n.intervalPrecision, this._interval = $n.interval, this._niceExtent = $n.niceTickExtent;
      }
    }, nr.prototype.calcNiceExtent = function(Cn) {
      var Bn = this._extent;
      if (Bn[0] === Bn[1])
        if (Bn[0] !== 0) {
          var In = Math.abs(Bn[0]);
          Cn.fixMax || (Bn[1] += In / 2), Bn[0] -= In / 2;
        } else
          Bn[1] = 1;
      var Dn = Bn[1] - Bn[0];
      isFinite(Dn) || (Bn[0] = 0, Bn[1] = 1), this.calcNiceTicks(Cn.splitNumber, Cn.minInterval, Cn.maxInterval);
      var Ln = this._interval;
      Cn.fixMin || (Bn[0] = roundNumber(Math.floor(Bn[0] / Ln) * Ln)), Cn.fixMax || (Bn[1] = roundNumber(Math.ceil(Bn[1] / Ln) * Ln));
    }, nr.prototype.setNiceExtent = function(Cn, Bn) {
      this._niceExtent = [Cn, Bn];
    }, nr.type = "interval", nr;
  }(Scale$1)
);
Scale$1.registerClass(IntervalScale);
const IntervalScale$1 = IntervalScale;
var supportFloat32Array = typeof Float32Array < "u", Float32ArrayCtor = supportFloat32Array ? Float32Array : Array;
function createFloat32Array(_n) {
  return isArray$4(_n) ? supportFloat32Array ? new Float32Array(_n) : _n : new Float32ArrayCtor(_n);
}
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId$1(_n) {
  return _n.get("stack") || STACK_PREFIX + _n.seriesIndex;
}
function getAxisKey$1(_n) {
  return _n.dim + _n.index;
}
function getLayoutOnAxis(_n) {
  var nr = [], Cn = _n.axis, Bn = "axis0";
  if (Cn.type === "category") {
    for (var In = Cn.getBandWidth(), Dn = 0; Dn < _n.count; Dn++)
      nr.push(defaults({
        bandWidth: In,
        axisKey: Bn,
        stackId: STACK_PREFIX + Dn
      }, _n));
    for (var Ln = doCalBarWidthAndOffset(nr), $n = [], Dn = 0; Dn < _n.count; Dn++) {
      var Nn = Ln[Bn][STACK_PREFIX + Dn];
      Nn.offsetCenter = Nn.offset + Nn.width / 2, $n.push(Nn);
    }
    return $n;
  }
}
function prepareLayoutBarSeries(_n, nr) {
  var Cn = [];
  return nr.eachSeriesByType(_n, function(Bn) {
    isOnCartesian(Bn) && Cn.push(Bn);
  }), Cn;
}
function getValueAxesMinGaps(_n) {
  var nr = {};
  each$f(_n, function(Nn) {
    var Rn = Nn.coordinateSystem, Fn = Rn.getBaseAxis();
    if (!(Fn.type !== "time" && Fn.type !== "value"))
      for (var Pn = Nn.getData(), Un = Fn.dim + "_" + Fn.index, Hn = Pn.getDimensionIndex(Pn.mapDimension(Fn.dim)), zn = Pn.getStore(), Gn = 0, Yn = zn.count(); Gn < Yn; ++Gn) {
        var Wn = zn.get(Hn, Gn);
        nr[Un] ? nr[Un].push(Wn) : nr[Un] = [Wn];
      }
  });
  var Cn = {};
  for (var Bn in nr)
    if (nr.hasOwnProperty(Bn)) {
      var In = nr[Bn];
      if (In) {
        In.sort(function(Nn, Rn) {
          return Nn - Rn;
        });
        for (var Dn = null, Ln = 1; Ln < In.length; ++Ln) {
          var $n = In[Ln] - In[Ln - 1];
          $n > 0 && (Dn = Dn === null ? $n : Math.min(Dn, $n));
        }
        Cn[Bn] = Dn;
      }
    }
  return Cn;
}
function makeColumnLayout(_n) {
  var nr = getValueAxesMinGaps(_n), Cn = [];
  return each$f(_n, function(Bn) {
    var In = Bn.coordinateSystem, Dn = In.getBaseAxis(), Ln = Dn.getExtent(), $n;
    if (Dn.type === "category")
      $n = Dn.getBandWidth();
    else if (Dn.type === "value" || Dn.type === "time") {
      var Nn = Dn.dim + "_" + Dn.index, Rn = nr[Nn], Fn = Math.abs(Ln[1] - Ln[0]), Pn = Dn.scale.getExtent(), Un = Math.abs(Pn[1] - Pn[0]);
      $n = Rn ? Fn / Un * Rn : Fn;
    } else {
      var Hn = Bn.getData();
      $n = Math.abs(Ln[1] - Ln[0]) / Hn.count();
    }
    var zn = parsePercent(Bn.get("barWidth"), $n), Gn = parsePercent(Bn.get("barMaxWidth"), $n), Yn = parsePercent(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      Bn.get("barMinWidth") || (isInLargeMode(Bn) ? 0.5 : 1),
      $n
    ), Wn = Bn.get("barGap"), Xn = Bn.get("barCategoryGap");
    Cn.push({
      bandWidth: $n,
      barWidth: zn,
      barMaxWidth: Gn,
      barMinWidth: Yn,
      barGap: Wn,
      barCategoryGap: Xn,
      axisKey: getAxisKey$1(Dn),
      stackId: getSeriesStackId$1(Bn)
    });
  }), doCalBarWidthAndOffset(Cn);
}
function doCalBarWidthAndOffset(_n) {
  var nr = {};
  each$f(_n, function(Bn, In) {
    var Dn = Bn.axisKey, Ln = Bn.bandWidth, $n = nr[Dn] || {
      bandWidth: Ln,
      remainedWidth: Ln,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    }, Nn = $n.stacks;
    nr[Dn] = $n;
    var Rn = Bn.stackId;
    Nn[Rn] || $n.autoWidthCount++, Nn[Rn] = Nn[Rn] || {
      width: 0,
      maxWidth: 0
    };
    var Fn = Bn.barWidth;
    Fn && !Nn[Rn].width && (Nn[Rn].width = Fn, Fn = Math.min($n.remainedWidth, Fn), $n.remainedWidth -= Fn);
    var Pn = Bn.barMaxWidth;
    Pn && (Nn[Rn].maxWidth = Pn);
    var Un = Bn.barMinWidth;
    Un && (Nn[Rn].minWidth = Un);
    var Hn = Bn.barGap;
    Hn != null && ($n.gap = Hn);
    var zn = Bn.barCategoryGap;
    zn != null && ($n.categoryGap = zn);
  });
  var Cn = {};
  return each$f(nr, function(Bn, In) {
    Cn[In] = {};
    var Dn = Bn.stacks, Ln = Bn.bandWidth, $n = Bn.categoryGap;
    if ($n == null) {
      var Nn = keys(Dn).length;
      $n = Math.max(35 - Nn * 4, 15) + "%";
    }
    var Rn = parsePercent($n, Ln), Fn = parsePercent(Bn.gap, 1), Pn = Bn.remainedWidth, Un = Bn.autoWidthCount, Hn = (Pn - Rn) / (Un + (Un - 1) * Fn);
    Hn = Math.max(Hn, 0), each$f(Dn, function(Wn) {
      var Xn = Wn.maxWidth, ea = Wn.minWidth;
      if (Wn.width) {
        var ta = Wn.width;
        Xn && (ta = Math.min(ta, Xn)), ea && (ta = Math.max(ta, ea)), Wn.width = ta, Pn -= ta + Fn * ta, Un--;
      } else {
        var ta = Hn;
        Xn && Xn < ta && (ta = Math.min(Xn, Pn)), ea && ea > ta && (ta = ea), ta !== Hn && (Wn.width = ta, Pn -= ta + Fn * ta, Un--);
      }
    }), Hn = (Pn - Rn) / (Un + (Un - 1) * Fn), Hn = Math.max(Hn, 0);
    var zn = 0, Gn;
    each$f(Dn, function(Wn, Xn) {
      Wn.width || (Wn.width = Hn), Gn = Wn, zn += Wn.width * (1 + Fn);
    }), Gn && (zn -= Gn.width * Fn);
    var Yn = -zn / 2;
    each$f(Dn, function(Wn, Xn) {
      Cn[In][Xn] = Cn[In][Xn] || {
        bandWidth: Ln,
        offset: Yn,
        width: Wn.width
      }, Yn += Wn.width * (1 + Fn);
    });
  }), Cn;
}
function retrieveColumnLayout(_n, nr, Cn) {
  if (_n && nr) {
    var Bn = _n[getAxisKey$1(nr)];
    return Bn != null && Cn != null ? Bn[getSeriesStackId$1(Cn)] : Bn;
  }
}
function layout$3(_n, nr) {
  var Cn = prepareLayoutBarSeries(_n, nr), Bn = makeColumnLayout(Cn);
  each$f(Cn, function(In) {
    var Dn = In.getData(), Ln = In.coordinateSystem, $n = Ln.getBaseAxis(), Nn = getSeriesStackId$1(In), Rn = Bn[getAxisKey$1($n)][Nn], Fn = Rn.offset, Pn = Rn.width;
    Dn.setLayout({
      bandWidth: Rn.bandWidth,
      offset: Fn,
      size: Pn
    });
  });
}
function createProgressiveLayout(_n) {
  return {
    seriesType: _n,
    plan: createRenderPlanner(),
    reset: function(nr) {
      if (isOnCartesian(nr)) {
        var Cn = nr.getData(), Bn = nr.coordinateSystem, In = Bn.getBaseAxis(), Dn = Bn.getOtherAxis(In), Ln = Cn.getDimensionIndex(Cn.mapDimension(Dn.dim)), $n = Cn.getDimensionIndex(Cn.mapDimension(In.dim)), Nn = nr.get("showBackground", !0), Rn = Cn.mapDimension(Dn.dim), Fn = Cn.getCalculationInfo("stackResultDimension"), Pn = isDimensionStacked(Cn, Rn) && !!Cn.getCalculationInfo("stackedOnSeries"), Un = Dn.isHorizontal(), Hn = getValueAxisStart(In, Dn), zn = isInLargeMode(nr), Gn = nr.get("barMinHeight") || 0, Yn = Fn && Cn.getDimensionIndex(Fn), Wn = Cn.getLayout("size"), Xn = Cn.getLayout("offset");
        return {
          progress: function(ea, ta) {
            for (var na = ea.count, ra = zn && createFloat32Array(na * 3), aa = zn && Nn && createFloat32Array(na * 3), ia = zn && createFloat32Array(na), Aa = Bn.master.getRect(), sa = Un ? Aa.width : Aa.height, oa, la = ta.getStore(), ua = 0; (oa = ea.next()) != null; ) {
              var ca = la.get(Pn ? Yn : Ln, oa), fa = la.get($n, oa), ha = Hn, pa = void 0;
              Pn && (pa = +ca - la.get(Ln, oa));
              var ya = void 0, da = void 0, Ca = void 0, ma = void 0;
              if (Un) {
                var va = Bn.dataToPoint([ca, fa]);
                if (Pn) {
                  var ga = Bn.dataToPoint([pa, fa]);
                  ha = ga[0];
                }
                ya = ha, da = va[1] + Xn, Ca = va[0] - ha, ma = Wn, Math.abs(Ca) < Gn && (Ca = (Ca < 0 ? -1 : 1) * Gn);
              } else {
                var va = Bn.dataToPoint([fa, ca]);
                if (Pn) {
                  var ga = Bn.dataToPoint([fa, pa]);
                  ha = ga[1];
                }
                ya = va[0] + Xn, da = ha, Ca = Wn, ma = va[1] - ha, Math.abs(ma) < Gn && (ma = (ma <= 0 ? -1 : 1) * Gn);
              }
              zn ? (ra[ua] = ya, ra[ua + 1] = da, ra[ua + 2] = Un ? Ca : ma, aa && (aa[ua] = Un ? Aa.x : ya, aa[ua + 1] = Un ? da : Aa.y, aa[ua + 2] = sa), ia[oa] = oa) : ta.setItemLayout(oa, {
                x: ya,
                y: da,
                width: Ca,
                height: ma
              }), ua += 3;
            }
            zn && ta.setLayout({
              largePoints: ra,
              largeDataIndices: ia,
              largeBackgroundPoints: aa,
              valueAxisHorizontal: Un
            });
          }
        };
      }
    }
  };
}
function isOnCartesian(_n) {
  return _n.coordinateSystem && _n.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(_n) {
  return _n.pipelineContext && _n.pipelineContext.large;
}
function getValueAxisStart(_n, nr) {
  var Cn = nr.model.get("startValue");
  return Cn || (Cn = 0), nr.toGlobalCoord(nr.dataToCoord(nr.type === "log" ? Cn > 0 ? Cn : 1 : Cn));
}
var bisect = function(_n, nr, Cn, Bn) {
  for (; Cn < Bn; ) {
    var In = Cn + Bn >>> 1;
    _n[In][1] < nr ? Cn = In + 1 : Bn = In;
  }
  return Cn;
}, TimeScale = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "time", Bn;
    }
    return nr.prototype.getLabel = function(Cn) {
      var Bn = this.getSetting("useUTC");
      return format$1(Cn.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, Bn, this.getSetting("locale"));
    }, nr.prototype.getFormattedLabel = function(Cn, Bn, In) {
      var Dn = this.getSetting("useUTC"), Ln = this.getSetting("locale");
      return leveledFormat(Cn, Bn, In, Ln, Dn);
    }, nr.prototype.getTicks = function() {
      var Cn = this._interval, Bn = this._extent, In = [];
      if (!Cn)
        return In;
      In.push({
        value: Bn[0],
        level: 0
      });
      var Dn = this.getSetting("useUTC"), Ln = getIntervalTicks(this._minLevelUnit, this._approxInterval, Dn, Bn);
      return In = In.concat(Ln), In.push({
        value: Bn[1],
        level: 0
      }), In;
    }, nr.prototype.calcNiceExtent = function(Cn) {
      var Bn = this._extent;
      if (Bn[0] === Bn[1] && (Bn[0] -= ONE_DAY, Bn[1] += ONE_DAY), Bn[1] === -1 / 0 && Bn[0] === 1 / 0) {
        var In = /* @__PURE__ */ new Date();
        Bn[1] = +new Date(In.getFullYear(), In.getMonth(), In.getDate()), Bn[0] = Bn[1] - ONE_DAY;
      }
      this.calcNiceTicks(Cn.splitNumber, Cn.minInterval, Cn.maxInterval);
    }, nr.prototype.calcNiceTicks = function(Cn, Bn, In) {
      Cn = Cn || 10;
      var Dn = this._extent, Ln = Dn[1] - Dn[0];
      this._approxInterval = Ln / Cn, Bn != null && this._approxInterval < Bn && (this._approxInterval = Bn), In != null && this._approxInterval > In && (this._approxInterval = In);
      var $n = scaleIntervals.length, Nn = Math.min(bisect(scaleIntervals, this._approxInterval, 0, $n), $n - 1);
      this._interval = scaleIntervals[Nn][1], this._minLevelUnit = scaleIntervals[Math.max(Nn - 1, 0)][0];
    }, nr.prototype.parse = function(Cn) {
      return isNumber(Cn) ? Cn : +parseDate(Cn);
    }, nr.prototype.contain = function(Cn) {
      return contain$1(this.parse(Cn), this._extent);
    }, nr.prototype.normalize = function(Cn) {
      return normalize$2(this.parse(Cn), this._extent);
    }, nr.prototype.scale = function(Cn) {
      return scale(Cn, this._extent);
    }, nr.type = "time", nr;
  }(IntervalScale$1)
), scaleIntervals = [
  // Format                           interval
  ["second", ONE_SECOND],
  ["minute", ONE_MINUTE],
  ["hour", ONE_HOUR],
  ["quarter-day", ONE_HOUR * 6],
  ["half-day", ONE_HOUR * 12],
  ["day", ONE_DAY * 1.2],
  ["half-week", ONE_DAY * 3.5],
  ["week", ONE_DAY * 7],
  ["month", ONE_DAY * 31],
  ["quarter", ONE_DAY * 95],
  ["half-year", ONE_YEAR / 2],
  ["year", ONE_YEAR]
  // 1Y
];
function isUnitValueSame(_n, nr, Cn, Bn) {
  var In = parseDate(nr), Dn = parseDate(Cn), Ln = function(zn) {
    return getUnitValue(In, zn, Bn) === getUnitValue(Dn, zn, Bn);
  }, $n = function() {
    return Ln("year");
  }, Nn = function() {
    return $n() && Ln("month");
  }, Rn = function() {
    return Nn() && Ln("day");
  }, Fn = function() {
    return Rn() && Ln("hour");
  }, Pn = function() {
    return Fn() && Ln("minute");
  }, Un = function() {
    return Pn() && Ln("second");
  }, Hn = function() {
    return Un() && Ln("millisecond");
  };
  switch (_n) {
    case "year":
      return $n();
    case "month":
      return Nn();
    case "day":
      return Rn();
    case "hour":
      return Fn();
    case "minute":
      return Pn();
    case "second":
      return Un();
    case "millisecond":
      return Hn();
  }
}
function getDateInterval(_n, nr) {
  return _n /= ONE_DAY, _n > 16 ? 16 : _n > 7.5 ? 7 : _n > 3.5 ? 4 : _n > 1.5 ? 2 : 1;
}
function getMonthInterval(_n) {
  var nr = 30 * ONE_DAY;
  return _n /= nr, _n > 6 ? 6 : _n > 3 ? 3 : _n > 2 ? 2 : 1;
}
function getHourInterval(_n) {
  return _n /= ONE_HOUR, _n > 12 ? 12 : _n > 6 ? 6 : _n > 3.5 ? 4 : _n > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(_n, nr) {
  return _n /= nr ? ONE_MINUTE : ONE_SECOND, _n > 30 ? 30 : _n > 20 ? 20 : _n > 15 ? 15 : _n > 10 ? 10 : _n > 5 ? 5 : _n > 2 ? 2 : 1;
}
function getMillisecondsInterval(_n) {
  return nice(_n, !0);
}
function getFirstTimestampOfUnit(_n, nr, Cn) {
  var Bn = new Date(_n);
  switch (getPrimaryTimeUnit(nr)) {
    case "year":
    case "month":
      Bn[monthSetterName(Cn)](0);
    case "day":
      Bn[dateSetterName(Cn)](1);
    case "hour":
      Bn[hoursSetterName(Cn)](0);
    case "minute":
      Bn[minutesSetterName(Cn)](0);
    case "second":
      Bn[secondsSetterName(Cn)](0), Bn[millisecondsSetterName(Cn)](0);
  }
  return Bn.getTime();
}
function getIntervalTicks(_n, nr, Cn, Bn) {
  var In = 1e4, Dn = timeUnits, Ln = 0;
  function $n(sa, oa, la, ua, ca, fa, ha) {
    for (var pa = new Date(oa), ya = oa, da = pa[ua](); ya < la && ya <= Bn[1]; )
      ha.push({
        value: ya
      }), da += sa, pa[ca](da), ya = pa.getTime();
    ha.push({
      value: ya,
      notAdd: !0
    });
  }
  function Nn(sa, oa, la) {
    var ua = [], ca = !oa.length;
    if (!isUnitValueSame(getPrimaryTimeUnit(sa), Bn[0], Bn[1], Cn)) {
      ca && (oa = [{
        // TODO Optimize. Not include so may ticks.
        value: getFirstTimestampOfUnit(new Date(Bn[0]), sa, Cn)
      }, {
        value: Bn[1]
      }]);
      for (var fa = 0; fa < oa.length - 1; fa++) {
        var ha = oa[fa].value, pa = oa[fa + 1].value;
        if (ha !== pa) {
          var ya = void 0, da = void 0, Ca = void 0, ma = !1;
          switch (sa) {
            case "year":
              ya = Math.max(1, Math.round(nr / ONE_DAY / 365)), da = fullYearGetterName(Cn), Ca = fullYearSetterName(Cn);
              break;
            case "half-year":
            case "quarter":
            case "month":
              ya = getMonthInterval(nr), da = monthGetterName(Cn), Ca = monthSetterName(Cn);
              break;
            case "week":
            case "half-week":
            case "day":
              ya = getDateInterval(nr), da = dateGetterName(Cn), Ca = dateSetterName(Cn), ma = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              ya = getHourInterval(nr), da = hoursGetterName(Cn), Ca = hoursSetterName(Cn);
              break;
            case "minute":
              ya = getMinutesAndSecondsInterval(nr, !0), da = minutesGetterName(Cn), Ca = minutesSetterName(Cn);
              break;
            case "second":
              ya = getMinutesAndSecondsInterval(nr, !1), da = secondsGetterName(Cn), Ca = secondsSetterName(Cn);
              break;
            case "millisecond":
              ya = getMillisecondsInterval(nr), da = millisecondsGetterName(Cn), Ca = millisecondsSetterName(Cn);
              break;
          }
          $n(ya, ha, pa, da, Ca, ma, ua), sa === "year" && la.length > 1 && fa === 0 && la.unshift({
            value: la[0].value - ya
          });
        }
      }
      for (var fa = 0; fa < ua.length; fa++)
        la.push(ua[fa]);
      return ua;
    }
  }
  for (var Rn = [], Fn = [], Pn = 0, Un = 0, Hn = 0; Hn < Dn.length && Ln++ < In; ++Hn) {
    var zn = getPrimaryTimeUnit(Dn[Hn]);
    if (isPrimaryTimeUnit(Dn[Hn])) {
      Nn(Dn[Hn], Rn[Rn.length - 1] || [], Fn);
      var Gn = Dn[Hn + 1] ? getPrimaryTimeUnit(Dn[Hn + 1]) : null;
      if (zn !== Gn) {
        if (Fn.length) {
          Un = Pn, Fn.sort(function(sa, oa) {
            return sa.value - oa.value;
          });
          for (var Yn = [], Wn = 0; Wn < Fn.length; ++Wn) {
            var Xn = Fn[Wn].value;
            (Wn === 0 || Fn[Wn - 1].value !== Xn) && (Yn.push(Fn[Wn]), Xn >= Bn[0] && Xn <= Bn[1] && Pn++);
          }
          var ea = (Bn[1] - Bn[0]) / nr;
          if (Pn > ea * 1.5 && Un > ea / 1.5 || (Rn.push(Yn), Pn > ea || _n === Dn[Hn]))
            break;
        }
        Fn = [];
      }
    }
  }
  process.env.NODE_ENV !== "production" && Ln >= In && warn("Exceed safe limit.");
  for (var ta = filter(map$1(Rn, function(sa) {
    return filter(sa, function(oa) {
      return oa.value >= Bn[0] && oa.value <= Bn[1] && !oa.notAdd;
    });
  }), function(sa) {
    return sa.length > 0;
  }), na = [], ra = ta.length - 1, Hn = 0; Hn < ta.length; ++Hn)
    for (var aa = ta[Hn], ia = 0; ia < aa.length; ++ia)
      na.push({
        value: aa[ia].value,
        level: ra - Hn
      });
  na.sort(function(sa, oa) {
    return sa.value - oa.value;
  });
  for (var Aa = [], Hn = 0; Hn < na.length; ++Hn)
    (Hn === 0 || na[Hn].value !== na[Hn - 1].value) && Aa.push(na[Hn]);
  return Aa;
}
Scale$1.registerClass(TimeScale);
const TimeScale$1 = TimeScale;
var scaleProto = Scale$1.prototype, intervalScaleProto = IntervalScale$1.prototype, roundingErrorFix = round$4, mathFloor$1 = Math.floor, mathCeil$1 = Math.ceil, mathPow$1 = Math.pow, mathLog$1 = Math.log, LogScale = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = "log", Cn.base = 10, Cn._originalScale = new IntervalScale$1(), Cn._interval = 0, Cn;
    }
    return nr.prototype.getTicks = function(Cn) {
      var Bn = this._originalScale, In = this._extent, Dn = Bn.getExtent(), Ln = intervalScaleProto.getTicks.call(this, Cn);
      return map$1(Ln, function($n) {
        var Nn = $n.value, Rn = round$4(mathPow$1(this.base, Nn));
        return Rn = Nn === In[0] && this._fixMin ? fixRoundingError(Rn, Dn[0]) : Rn, Rn = Nn === In[1] && this._fixMax ? fixRoundingError(Rn, Dn[1]) : Rn, {
          value: Rn
        };
      }, this);
    }, nr.prototype.setExtent = function(Cn, Bn) {
      var In = mathLog$1(this.base);
      Cn = mathLog$1(Math.max(0, Cn)) / In, Bn = mathLog$1(Math.max(0, Bn)) / In, intervalScaleProto.setExtent.call(this, Cn, Bn);
    }, nr.prototype.getExtent = function() {
      var Cn = this.base, Bn = scaleProto.getExtent.call(this);
      Bn[0] = mathPow$1(Cn, Bn[0]), Bn[1] = mathPow$1(Cn, Bn[1]);
      var In = this._originalScale, Dn = In.getExtent();
      return this._fixMin && (Bn[0] = fixRoundingError(Bn[0], Dn[0])), this._fixMax && (Bn[1] = fixRoundingError(Bn[1], Dn[1])), Bn;
    }, nr.prototype.unionExtent = function(Cn) {
      this._originalScale.unionExtent(Cn);
      var Bn = this.base;
      Cn[0] = mathLog$1(Cn[0]) / mathLog$1(Bn), Cn[1] = mathLog$1(Cn[1]) / mathLog$1(Bn), scaleProto.unionExtent.call(this, Cn);
    }, nr.prototype.unionExtentFromData = function(Cn, Bn) {
      this.unionExtent(Cn.getApproximateExtent(Bn));
    }, nr.prototype.calcNiceTicks = function(Cn) {
      Cn = Cn || 10;
      var Bn = this._extent, In = Bn[1] - Bn[0];
      if (!(In === 1 / 0 || In <= 0)) {
        var Dn = quantity(In), Ln = Cn / In * Dn;
        for (Ln <= 0.5 && (Dn *= 10); !isNaN(Dn) && Math.abs(Dn) < 1 && Math.abs(Dn) > 0; )
          Dn *= 10;
        var $n = [round$4(mathCeil$1(Bn[0] / Dn) * Dn), round$4(mathFloor$1(Bn[1] / Dn) * Dn)];
        this._interval = Dn, this._niceExtent = $n;
      }
    }, nr.prototype.calcNiceExtent = function(Cn) {
      intervalScaleProto.calcNiceExtent.call(this, Cn), this._fixMin = Cn.fixMin, this._fixMax = Cn.fixMax;
    }, nr.prototype.parse = function(Cn) {
      return Cn;
    }, nr.prototype.contain = function(Cn) {
      return Cn = mathLog$1(Cn) / mathLog$1(this.base), contain$1(Cn, this._extent);
    }, nr.prototype.normalize = function(Cn) {
      return Cn = mathLog$1(Cn) / mathLog$1(this.base), normalize$2(Cn, this._extent);
    }, nr.prototype.scale = function(Cn) {
      return Cn = scale(Cn, this._extent), mathPow$1(this.base, Cn);
    }, nr.type = "log", nr;
  }(Scale$1)
), proto = LogScale.prototype;
proto.getMinorTicks = intervalScaleProto.getMinorTicks;
proto.getLabel = intervalScaleProto.getLabel;
function fixRoundingError(_n, nr) {
  return roundingErrorFix(_n, getPrecision(nr));
}
Scale$1.registerClass(LogScale);
const LogScale$1 = LogScale;
var ScaleRawExtentInfo = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this._prepareParams(nr, Cn, Bn);
    }
    return _n.prototype._prepareParams = function(nr, Cn, Bn) {
      Bn[1] < Bn[0] && (Bn = [NaN, NaN]), this._dataMin = Bn[0], this._dataMax = Bn[1];
      var In = this._isOrdinal = nr.type === "ordinal";
      this._needCrossZero = nr.type === "interval" && Cn.getNeedCrossZero && Cn.getNeedCrossZero();
      var Dn = Cn.get("min", !0);
      Dn == null && (Dn = Cn.get("startValue", !0));
      var Ln = this._modelMinRaw = Dn;
      isFunction$1(Ln) ? this._modelMinNum = parseAxisModelMinMax(nr, Ln({
        min: Bn[0],
        max: Bn[1]
      })) : Ln !== "dataMin" && (this._modelMinNum = parseAxisModelMinMax(nr, Ln));
      var $n = this._modelMaxRaw = Cn.get("max", !0);
      if (isFunction$1($n) ? this._modelMaxNum = parseAxisModelMinMax(nr, $n({
        min: Bn[0],
        max: Bn[1]
      })) : $n !== "dataMax" && (this._modelMaxNum = parseAxisModelMinMax(nr, $n)), In)
        this._axisDataLen = Cn.getCategories().length;
      else {
        var Nn = Cn.get("boundaryGap"), Rn = isArray$4(Nn) ? Nn : [Nn || 0, Nn || 0];
        typeof Rn[0] == "boolean" || typeof Rn[1] == "boolean" ? (process.env.NODE_ENV !== "production" && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [parsePercent$1(Rn[0], 1), parsePercent$1(Rn[1], 1)];
      }
    }, _n.prototype.calculate = function() {
      var nr = this._isOrdinal, Cn = this._dataMin, Bn = this._dataMax, In = this._axisDataLen, Dn = this._boundaryGapInner, Ln = nr ? null : Bn - Cn || Math.abs(Cn), $n = this._modelMinRaw === "dataMin" ? Cn : this._modelMinNum, Nn = this._modelMaxRaw === "dataMax" ? Bn : this._modelMaxNum, Rn = $n != null, Fn = Nn != null;
      $n == null && ($n = nr ? In ? 0 : NaN : Cn - Dn[0] * Ln), Nn == null && (Nn = nr ? In ? In - 1 : NaN : Bn + Dn[1] * Ln), ($n == null || !isFinite($n)) && ($n = NaN), (Nn == null || !isFinite(Nn)) && (Nn = NaN);
      var Pn = eqNaN($n) || eqNaN(Nn) || nr && !In;
      this._needCrossZero && ($n > 0 && Nn > 0 && !Rn && ($n = 0), $n < 0 && Nn < 0 && !Fn && (Nn = 0));
      var Un = this._determinedMin, Hn = this._determinedMax;
      return Un != null && ($n = Un, Rn = !0), Hn != null && (Nn = Hn, Fn = !0), {
        min: $n,
        max: Nn,
        minFixed: Rn,
        maxFixed: Fn,
        isBlank: Pn
      };
    }, _n.prototype.modifyDataMinMax = function(nr, Cn) {
      process.env.NODE_ENV !== "production" && assert(!this.frozen), this[DATA_MIN_MAX_ATTR[nr]] = Cn;
    }, _n.prototype.setDeterminedMinMax = function(nr, Cn) {
      var Bn = DETERMINED_MIN_MAX_ATTR[nr];
      process.env.NODE_ENV !== "production" && assert(!this.frozen && this[Bn] == null), this[Bn] = Cn;
    }, _n.prototype.freeze = function() {
      this.frozen = !0;
    }, _n;
  }()
), DETERMINED_MIN_MAX_ATTR = {
  min: "_determinedMin",
  max: "_determinedMax"
}, DATA_MIN_MAX_ATTR = {
  min: "_dataMin",
  max: "_dataMax"
};
function ensureScaleRawExtentInfo(_n, nr, Cn) {
  var Bn = _n.rawExtentInfo;
  return Bn || (Bn = new ScaleRawExtentInfo(_n, nr, Cn), _n.rawExtentInfo = Bn, Bn);
}
function parseAxisModelMinMax(_n, nr) {
  return nr == null ? null : eqNaN(nr) ? NaN : _n.parse(nr);
}
function getScaleExtent(_n, nr) {
  var Cn = _n.type, Bn = ensureScaleRawExtentInfo(_n, nr, _n.getExtent()).calculate();
  _n.setBlank(Bn.isBlank);
  var In = Bn.min, Dn = Bn.max, Ln = nr.ecModel;
  if (Ln && Cn === "time") {
    var $n = prepareLayoutBarSeries("bar", Ln), Nn = !1;
    if (each$f($n, function(Pn) {
      Nn = Nn || Pn.getBaseAxis() === nr.axis;
    }), Nn) {
      var Rn = makeColumnLayout($n), Fn = adjustScaleForOverflow(In, Dn, nr, Rn);
      In = Fn.min, Dn = Fn.max;
    }
  }
  return {
    extent: [In, Dn],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: Bn.minFixed,
    fixMax: Bn.maxFixed
  };
}
function adjustScaleForOverflow(_n, nr, Cn, Bn) {
  var In = Cn.axis.getExtent(), Dn = Math.abs(In[1] - In[0]), Ln = retrieveColumnLayout(Bn, Cn.axis);
  if (Ln === void 0)
    return {
      min: _n,
      max: nr
    };
  var $n = 1 / 0;
  each$f(Ln, function(Hn) {
    $n = Math.min(Hn.offset, $n);
  });
  var Nn = -1 / 0;
  each$f(Ln, function(Hn) {
    Nn = Math.max(Hn.offset + Hn.width, Nn);
  }), $n = Math.abs($n), Nn = Math.abs(Nn);
  var Rn = $n + Nn, Fn = nr - _n, Pn = 1 - ($n + Nn) / Dn, Un = Fn / Pn - Fn;
  return nr += Un * (Nn / Rn), _n -= Un * ($n / Rn), {
    min: _n,
    max: nr
  };
}
function niceScaleExtent(_n, nr) {
  var Cn = nr, Bn = getScaleExtent(_n, Cn), In = Bn.extent, Dn = Cn.get("splitNumber");
  _n instanceof LogScale$1 && (_n.base = Cn.get("logBase"));
  var Ln = _n.type, $n = Cn.get("interval"), Nn = Ln === "interval" || Ln === "time";
  _n.setExtent(In[0], In[1]), _n.calcNiceExtent({
    splitNumber: Dn,
    fixMin: Bn.fixMin,
    fixMax: Bn.fixMax,
    minInterval: Nn ? Cn.get("minInterval") : null,
    maxInterval: Nn ? Cn.get("maxInterval") : null
  }), $n != null && _n.setInterval && _n.setInterval($n);
}
function createScaleByModel$1(_n, nr) {
  if (nr = nr || _n.get("type"), nr)
    switch (nr) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: _n.getOrdinalMeta ? _n.getOrdinalMeta() : _n.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new TimeScale$1({
          locale: _n.ecModel.getLocaleModel(),
          useUTC: _n.ecModel.get("useUTC")
        });
      default:
        return new (Scale$1.getClass(nr) || IntervalScale$1)();
    }
}
function ifAxisCrossZero(_n) {
  var nr = _n.scale.getExtent(), Cn = nr[0], Bn = nr[1];
  return !(Cn > 0 && Bn > 0 || Cn < 0 && Bn < 0);
}
function makeLabelFormatter(_n) {
  var nr = _n.getLabelModel().get("formatter"), Cn = _n.type === "category" ? _n.scale.getExtent()[0] : null;
  return _n.scale.type === "time" ? function(Bn) {
    return function(In, Dn) {
      return _n.scale.getFormattedLabel(In, Dn, Bn);
    };
  }(nr) : isString$1(nr) ? function(Bn) {
    return function(In) {
      var Dn = _n.scale.getLabel(In), Ln = Bn.replace("{value}", Dn ?? "");
      return Ln;
    };
  }(nr) : isFunction$1(nr) ? function(Bn) {
    return function(In, Dn) {
      return Cn != null && (Dn = In.value - Cn), Bn(getAxisRawValue(_n, In), Dn, In.level != null ? {
        level: In.level
      } : null);
    };
  }(nr) : function(Bn) {
    return _n.scale.getLabel(Bn);
  };
}
function getAxisRawValue(_n, nr) {
  return _n.type === "category" ? _n.scale.getLabel(nr) : nr.value;
}
function estimateLabelUnionRect(_n) {
  var nr = _n.model, Cn = _n.scale;
  if (!(!nr.get(["axisLabel", "show"]) || Cn.isBlank())) {
    var Bn, In, Dn = Cn.getExtent();
    Cn instanceof OrdinalScale$1 ? In = Cn.count() : (Bn = Cn.getTicks(), In = Bn.length);
    var Ln = _n.getLabelModel(), $n = makeLabelFormatter(_n), Nn, Rn = 1;
    In > 40 && (Rn = Math.ceil(In / 40));
    for (var Fn = 0; Fn < In; Fn += Rn) {
      var Pn = Bn ? Bn[Fn] : {
        value: Dn[0] + Fn
      }, Un = $n(Pn, Fn), Hn = Ln.getTextRect(Un), zn = rotateTextRect(Hn, Ln.get("rotate") || 0);
      Nn ? Nn.union(zn) : Nn = zn;
    }
    return Nn;
  }
}
function rotateTextRect(_n, nr) {
  var Cn = nr * Math.PI / 180, Bn = _n.width, In = _n.height, Dn = Bn * Math.abs(Math.cos(Cn)) + Math.abs(In * Math.sin(Cn)), Ln = Bn * Math.abs(Math.sin(Cn)) + Math.abs(In * Math.cos(Cn)), $n = new BoundingRect$1(_n.x, _n.y, Dn, Ln);
  return $n;
}
function getOptionCategoryInterval(_n) {
  var nr = _n.get("interval");
  return nr ?? "auto";
}
function shouldShowAllLabels(_n) {
  return _n.type === "category" && getOptionCategoryInterval(_n.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(_n, nr) {
  var Cn = {};
  return each$f(_n.mapDimensionsAll(nr), function(Bn) {
    Cn[getStackedDimension(_n, Bn)] = !0;
  }), keys(Cn);
}
function unionAxisExtentFromData(_n, nr, Cn) {
  nr && each$f(getDataDimensionsOnAxis(nr, Cn), function(Bn) {
    var In = nr.getApproximateExtent(Bn);
    In[0] < _n[0] && (_n[0] = In[0]), In[1] > _n[1] && (_n[1] = In[1]);
  });
}
var AxisModelCommonMixin = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.getNeedCrossZero = function() {
      var nr = this.option;
      return !nr.scale;
    }, _n.prototype.getCoordSysModel = function() {
    }, _n;
  }()
);
function createList$2(_n) {
  return createSeriesData(null, _n);
}
var dataStack = {
  isDimensionStacked,
  enableDataStack,
  getStackedDimension
};
function createScale(_n, nr) {
  var Cn = nr;
  nr instanceof Model$1 || (Cn = new Model$1(nr));
  var Bn = createScaleByModel$1(Cn);
  return Bn.setExtent(_n[0], _n[1]), niceScaleExtent(Bn, Cn), Bn;
}
function mixinAxisModelCommonMethods(_n) {
  mixin(_n, AxisModelCommonMixin);
}
function createTextStyle(_n, nr) {
  return nr = nr || {}, createTextStyle$1(_n, null, null, nr.state !== "normal");
}
const helper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createDimensions,
  createList: createList$2,
  createScale,
  createSymbol: createSymbol$1,
  createTextStyle,
  dataStack,
  enableHoverEmphasis,
  getECData,
  getLayoutRect: getLayoutRect$1,
  mixinAxisModelCommonMethods
}, Symbol.toStringTag, { value: "Module" }));
var extensions = [], extensionRegisters = {
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerVisual,
  registerTransform,
  registerLoading,
  registerMap: registerMap$1,
  registerImpl,
  PRIORITY,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(_n) {
    ComponentModel$1.registerClass(_n);
  },
  registerComponentView: function(_n) {
    ComponentView$1.registerClass(_n);
  },
  registerSeriesModel: function(_n) {
    SeriesModel$1.registerClass(_n);
  },
  registerChartView: function(_n) {
    ChartView$1.registerClass(_n);
  },
  registerSubTypeDefaulter: function(_n, nr) {
    ComponentModel$1.registerSubTypeDefaulter(_n, nr);
  },
  registerPainter: function(_n, nr) {
    registerPainter(_n, nr);
  }
};
function use(_n) {
  if (isArray$4(_n)) {
    each$f(_n, function(nr) {
      use(nr);
    });
    return;
  }
  indexOf(extensions, _n) >= 0 || (extensions.push(_n), isFunction$1(_n) && (_n = {
    install: _n
  }), _n.install(extensionRegisters));
}
var EPSILON = 1e-8;
function isAroundEqual(_n, nr) {
  return Math.abs(_n - nr) < EPSILON;
}
function contain(_n, nr, Cn) {
  var Bn = 0, In = _n[0];
  if (!In)
    return !1;
  for (var Dn = 1; Dn < _n.length; Dn++) {
    var Ln = _n[Dn];
    Bn += windingLine(In[0], In[1], Ln[0], Ln[1], nr, Cn), In = Ln;
  }
  var $n = _n[0];
  return (!isAroundEqual(In[0], $n[0]) || !isAroundEqual(In[1], $n[1])) && (Bn += windingLine(In[0], In[1], $n[0], $n[1], nr, Cn)), Bn !== 0;
}
var TMP_TRANSFORM = [];
function transformPoints(_n, nr) {
  for (var Cn = 0; Cn < _n.length; Cn++)
    applyTransform$1(_n[Cn], _n[Cn], nr);
}
function updateBBoxFromPoints(_n, nr, Cn, Bn) {
  for (var In = 0; In < _n.length; In++) {
    var Dn = _n[In];
    Bn && (Dn = Bn.project(Dn)), Dn && isFinite(Dn[0]) && isFinite(Dn[1]) && (min$2(nr, nr, Dn), max$3(Cn, Cn, Dn));
  }
}
function centroid$1(_n) {
  for (var nr = 0, Cn = 0, Bn = 0, In = _n.length, Dn = _n[In - 1][0], Ln = _n[In - 1][1], $n = 0; $n < In; $n++) {
    var Nn = _n[$n][0], Rn = _n[$n][1], Fn = Dn * Rn - Nn * Ln;
    nr += Fn, Cn += (Dn + Nn) * Fn, Bn += (Ln + Rn) * Fn, Dn = Nn, Ln = Rn;
  }
  return nr ? [Cn / nr / 3, Bn / nr / 3, nr] : [_n[0][0] || 0, _n[0][1] || 0];
}
var Region = (
  /** @class */
  function() {
    function _n(nr) {
      this.name = nr;
    }
    return _n.prototype.setCenter = function(nr) {
      this._center = nr;
    }, _n.prototype.getCenter = function() {
      var nr = this._center;
      return nr || (nr = this._center = this.calcCenter()), nr;
    }, _n;
  }()
), GeoJSONPolygonGeometry = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.type = "polygon", this.exterior = nr, this.interiors = Cn;
    }
    return _n;
  }()
), GeoJSONLineStringGeometry = (
  /** @class */
  function() {
    function _n(nr) {
      this.type = "linestring", this.points = nr;
    }
    return _n;
  }()
), GeoJSONRegion = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In) {
      var Dn = _n.call(this, Cn) || this;
      return Dn.type = "geoJSON", Dn.geometries = Bn, Dn._center = In && [In[0], In[1]], Dn;
    }
    return nr.prototype.calcCenter = function() {
      for (var Cn = this.geometries, Bn, In = 0, Dn = 0; Dn < Cn.length; Dn++) {
        var Ln = Cn[Dn], $n = Ln.exterior, Nn = $n && $n.length;
        Nn > In && (Bn = Ln, In = Nn);
      }
      if (Bn)
        return centroid$1(Bn.exterior);
      var Rn = this.getBoundingRect();
      return [Rn.x + Rn.width / 2, Rn.y + Rn.height / 2];
    }, nr.prototype.getBoundingRect = function(Cn) {
      var Bn = this._rect;
      if (Bn && !Cn)
        return Bn;
      var In = [1 / 0, 1 / 0], Dn = [-1 / 0, -1 / 0], Ln = this.geometries;
      return each$f(Ln, function($n) {
        $n.type === "polygon" ? updateBBoxFromPoints($n.exterior, In, Dn, Cn) : each$f($n.points, function(Nn) {
          updateBBoxFromPoints(Nn, In, Dn, Cn);
        });
      }), isFinite(In[0]) && isFinite(In[1]) && isFinite(Dn[0]) && isFinite(Dn[1]) || (In[0] = In[1] = Dn[0] = Dn[1] = 0), Bn = new BoundingRect$1(In[0], In[1], Dn[0] - In[0], Dn[1] - In[1]), Cn || (this._rect = Bn), Bn;
    }, nr.prototype.contain = function(Cn) {
      var Bn = this.getBoundingRect(), In = this.geometries;
      if (!Bn.contain(Cn[0], Cn[1]))
        return !1;
      e:
        for (var Dn = 0, Ln = In.length; Dn < Ln; Dn++) {
          var $n = In[Dn];
          if ($n.type === "polygon") {
            var Nn = $n.exterior, Rn = $n.interiors;
            if (contain(Nn, Cn[0], Cn[1])) {
              for (var Fn = 0; Fn < (Rn ? Rn.length : 0); Fn++)
                if (contain(Rn[Fn], Cn[0], Cn[1]))
                  continue e;
              return !0;
            }
          }
        }
      return !1;
    }, nr.prototype.transformTo = function(Cn, Bn, In, Dn) {
      var Ln = this.getBoundingRect(), $n = Ln.width / Ln.height;
      In ? Dn || (Dn = In / $n) : In = $n * Dn;
      for (var Nn = new BoundingRect$1(Cn, Bn, In, Dn), Rn = Ln.calculateTransform(Nn), Fn = this.geometries, Pn = 0; Pn < Fn.length; Pn++) {
        var Un = Fn[Pn];
        Un.type === "polygon" ? (transformPoints(Un.exterior, Rn), each$f(Un.interiors, function(Hn) {
          transformPoints(Hn, Rn);
        })) : each$f(Un.points, function(Hn) {
          transformPoints(Hn, Rn);
        });
      }
      Ln = this._rect, Ln.copy(Nn), this._center = [Ln.x + Ln.width / 2, Ln.y + Ln.height / 2];
    }, nr.prototype.cloneShallow = function(Cn) {
      Cn == null && (Cn = this.name);
      var Bn = new nr(Cn, this.geometries, this._center);
      return Bn._rect = this._rect, Bn.transformTo = null, Bn;
    }, nr;
  }(Region)
), GeoSVGRegion = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn) || this;
      return In.type = "geoSVG", In._elOnlyForCalculate = Bn, In;
    }
    return nr.prototype.calcCenter = function() {
      for (var Cn = this._elOnlyForCalculate, Bn = Cn.getBoundingRect(), In = [Bn.x + Bn.width / 2, Bn.y + Bn.height / 2], Dn = identity$1(TMP_TRANSFORM), Ln = Cn; Ln && !Ln.isGeoSVGGraphicRoot; )
        mul(Dn, Ln.getLocalTransform(), Dn), Ln = Ln.parent;
      return invert(Dn, Dn), applyTransform$1(In, In, Dn), In;
    }, nr;
  }(Region)
);
function decode$3(_n) {
  if (!_n.UTF8Encoding)
    return _n;
  var nr = _n, Cn = nr.UTF8Scale;
  Cn == null && (Cn = 1024);
  var Bn = nr.features;
  return each$f(Bn, function(In) {
    var Dn = In.geometry, Ln = Dn.encodeOffsets, $n = Dn.coordinates;
    if (Ln)
      switch (Dn.type) {
        case "LineString":
          Dn.coordinates = decodeRing($n, Ln, Cn);
          break;
        case "Polygon":
          decodeRings($n, Ln, Cn);
          break;
        case "MultiLineString":
          decodeRings($n, Ln, Cn);
          break;
        case "MultiPolygon":
          each$f($n, function(Nn, Rn) {
            return decodeRings(Nn, Ln[Rn], Cn);
          });
      }
  }), nr.UTF8Encoding = !1, nr;
}
function decodeRings(_n, nr, Cn) {
  for (var Bn = 0; Bn < _n.length; Bn++)
    _n[Bn] = decodeRing(_n[Bn], nr[Bn], Cn);
}
function decodeRing(_n, nr, Cn) {
  for (var Bn = [], In = nr[0], Dn = nr[1], Ln = 0; Ln < _n.length; Ln += 2) {
    var $n = _n.charCodeAt(Ln) - 64, Nn = _n.charCodeAt(Ln + 1) - 64;
    $n = $n >> 1 ^ -($n & 1), Nn = Nn >> 1 ^ -(Nn & 1), $n += In, Nn += Dn, In = $n, Dn = Nn, Bn.push([$n / Cn, Nn / Cn]);
  }
  return Bn;
}
function parseGeoJSON(_n, nr) {
  return _n = decode$3(_n), map$1(filter(_n.features, function(Cn) {
    return Cn.geometry && Cn.properties && Cn.geometry.coordinates.length > 0;
  }), function(Cn) {
    var Bn = Cn.properties, In = Cn.geometry, Dn = [];
    switch (In.type) {
      case "Polygon":
        var Ln = In.coordinates;
        Dn.push(new GeoJSONPolygonGeometry(Ln[0], Ln.slice(1)));
        break;
      case "MultiPolygon":
        each$f(In.coordinates, function(Nn) {
          Nn[0] && Dn.push(new GeoJSONPolygonGeometry(Nn[0], Nn.slice(1)));
        });
        break;
      case "LineString":
        Dn.push(new GeoJSONLineStringGeometry([In.coordinates]));
        break;
      case "MultiLineString":
        Dn.push(new GeoJSONLineStringGeometry(In.coordinates));
    }
    var $n = new GeoJSONRegion(Bn[nr || "name"], Dn, Bn.cp);
    return $n.properties = Bn, $n;
  });
}
const number = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2,
  asc: asc$2,
  getPercentWithPrecision,
  getPixelPrecision,
  getPrecision,
  getPrecisionSafe,
  isNumeric,
  isRadianAroundZero,
  linearMap: linearMap$2,
  nice,
  numericToNumber,
  parseDate,
  quantile,
  quantity,
  quantityExponent,
  reformIntervals,
  remRadian,
  round: round$4
}, Symbol.toStringTag, { value: "Module" })), time$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  format: format$1,
  parse: parseDate
}, Symbol.toStringTag, { value: "Module" })), graphic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: Arc$1,
  BezierCurve: BezierCurve$2,
  BoundingRect: BoundingRect$1,
  Circle: Circle$1,
  CompoundPath: CompoundPath$1,
  Ellipse: Ellipse$1,
  Group: Group$4,
  Image: ZRImage$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  Line: Line$3,
  LinearGradient: LinearGradient$1,
  Polygon: Polygon$1,
  Polyline: Polyline$3,
  RadialGradient: RadialGradient$1,
  Rect: Rect$3,
  Ring: Ring$1,
  Sector: Sector$1,
  Text: ZRText$1,
  clipPointsByRect,
  clipRectByRect,
  createIcon,
  extendPath,
  extendShape,
  getShapeClass,
  getTransform: getTransform$1,
  initProps,
  makeImage,
  makePath,
  mergePath,
  registerShape,
  resizePath,
  updateProps: updateProps$1
}, Symbol.toStringTag, { value: "Module" })), format = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCommas,
  capitalFirst,
  encodeHTML,
  formatTime,
  formatTpl,
  getTextRect,
  getTooltipMarker,
  normalizeCssArray,
  toCamelCase,
  truncateText
}, Symbol.toStringTag, { value: "Module" })), util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bind: bind$1,
  clone: clone$4,
  curry: curry$1,
  defaults,
  each: each$f,
  extend,
  filter,
  indexOf,
  inherits,
  isArray: isArray$4,
  isFunction: isFunction$1,
  isObject: isObject$6,
  isString: isString$1,
  map: map$1,
  merge: merge$1,
  reduce
}, Symbol.toStringTag, { value: "Module" }));
var inner$g = makeInner();
function tickValuesToNumbers(_n, nr) {
  var Cn = map$1(nr, function(Bn) {
    return _n.scale.parse(Bn);
  });
  return _n.type === "time" && Cn.length > 0 && (Cn.sort(), Cn.unshift(Cn[0]), Cn.push(Cn[Cn.length - 1])), Cn;
}
function createAxisLabels(_n) {
  var nr = _n.getLabelModel().get("customValues");
  if (nr) {
    var Cn = makeLabelFormatter(_n), Bn = _n.scale.getExtent(), In = tickValuesToNumbers(_n, nr), Dn = filter(In, function(Ln) {
      return Ln >= Bn[0] && Ln <= Bn[1];
    });
    return {
      labels: map$1(Dn, function(Ln) {
        var $n = {
          value: Ln
        };
        return {
          formattedLabel: Cn($n),
          rawLabel: _n.scale.getLabel($n),
          tickValue: Ln
        };
      })
    };
  }
  return _n.type === "category" ? makeCategoryLabels(_n) : makeRealNumberLabels(_n);
}
function createAxisTicks(_n, nr) {
  var Cn = _n.getTickModel().get("customValues");
  if (Cn) {
    var Bn = _n.scale.getExtent(), In = tickValuesToNumbers(_n, Cn);
    return {
      ticks: filter(In, function(Dn) {
        return Dn >= Bn[0] && Dn <= Bn[1];
      })
    };
  }
  return _n.type === "category" ? makeCategoryTicks(_n, nr) : {
    ticks: map$1(_n.scale.getTicks(), function(Dn) {
      return Dn.value;
    })
  };
}
function makeCategoryLabels(_n) {
  var nr = _n.getLabelModel(), Cn = makeCategoryLabelsActually(_n, nr);
  return !nr.get("show") || _n.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: Cn.labelCategoryInterval
  } : Cn;
}
function makeCategoryLabelsActually(_n, nr) {
  var Cn = getListCache(_n, "labels"), Bn = getOptionCategoryInterval(nr), In = listCacheGet$1(Cn, Bn);
  if (In)
    return In;
  var Dn, Ln;
  return isFunction$1(Bn) ? Dn = makeLabelsByCustomizedCategoryInterval(_n, Bn) : (Ln = Bn === "auto" ? makeAutoCategoryInterval(_n) : Bn, Dn = makeLabelsByNumericCategoryInterval(_n, Ln)), listCacheSet$1(Cn, Bn, {
    labels: Dn,
    labelCategoryInterval: Ln
  });
}
function makeCategoryTicks(_n, nr) {
  var Cn = getListCache(_n, "ticks"), Bn = getOptionCategoryInterval(nr), In = listCacheGet$1(Cn, Bn);
  if (In)
    return In;
  var Dn, Ln;
  if ((!nr.get("show") || _n.scale.isBlank()) && (Dn = []), isFunction$1(Bn))
    Dn = makeLabelsByCustomizedCategoryInterval(_n, Bn, !0);
  else if (Bn === "auto") {
    var $n = makeCategoryLabelsActually(_n, _n.getLabelModel());
    Ln = $n.labelCategoryInterval, Dn = map$1($n.labels, function(Nn) {
      return Nn.tickValue;
    });
  } else
    Ln = Bn, Dn = makeLabelsByNumericCategoryInterval(_n, Ln, !0);
  return listCacheSet$1(Cn, Bn, {
    ticks: Dn,
    tickCategoryInterval: Ln
  });
}
function makeRealNumberLabels(_n) {
  var nr = _n.scale.getTicks(), Cn = makeLabelFormatter(_n);
  return {
    labels: map$1(nr, function(Bn, In) {
      return {
        level: Bn.level,
        formattedLabel: Cn(Bn, In),
        rawLabel: _n.scale.getLabel(Bn),
        tickValue: Bn.value
      };
    })
  };
}
function getListCache(_n, nr) {
  return inner$g(_n)[nr] || (inner$g(_n)[nr] = []);
}
function listCacheGet$1(_n, nr) {
  for (var Cn = 0; Cn < _n.length; Cn++)
    if (_n[Cn].key === nr)
      return _n[Cn].value;
}
function listCacheSet$1(_n, nr, Cn) {
  return _n.push({
    key: nr,
    value: Cn
  }), Cn;
}
function makeAutoCategoryInterval(_n) {
  var nr = inner$g(_n).autoInterval;
  return nr ?? (inner$g(_n).autoInterval = _n.calculateCategoryInterval());
}
function calculateCategoryInterval(_n) {
  var nr = fetchAutoCategoryIntervalCalculationParams(_n), Cn = makeLabelFormatter(_n), Bn = (nr.axisRotate - nr.labelRotate) / 180 * Math.PI, In = _n.scale, Dn = In.getExtent(), Ln = In.count();
  if (Dn[1] - Dn[0] < 1)
    return 0;
  var $n = 1;
  Ln > 40 && ($n = Math.max(1, Math.floor(Ln / 40)));
  for (var Nn = Dn[0], Rn = _n.dataToCoord(Nn + 1) - _n.dataToCoord(Nn), Fn = Math.abs(Rn * Math.cos(Bn)), Pn = Math.abs(Rn * Math.sin(Bn)), Un = 0, Hn = 0; Nn <= Dn[1]; Nn += $n) {
    var zn = 0, Gn = 0, Yn = getBoundingRect(Cn({
      value: Nn
    }), nr.font, "center", "top");
    zn = Yn.width * 1.3, Gn = Yn.height * 1.3, Un = Math.max(Un, zn, 7), Hn = Math.max(Hn, Gn, 7);
  }
  var Wn = Un / Fn, Xn = Hn / Pn;
  isNaN(Wn) && (Wn = 1 / 0), isNaN(Xn) && (Xn = 1 / 0);
  var ea = Math.max(0, Math.floor(Math.min(Wn, Xn))), ta = inner$g(_n.model), na = _n.getExtent(), ra = ta.lastAutoInterval, aa = ta.lastTickCount;
  return ra != null && aa != null && Math.abs(ra - ea) <= 1 && Math.abs(aa - Ln) <= 1 && ra > ea && ta.axisExtent0 === na[0] && ta.axisExtent1 === na[1] ? ea = ra : (ta.lastTickCount = Ln, ta.lastAutoInterval = ea, ta.axisExtent0 = na[0], ta.axisExtent1 = na[1]), ea;
}
function fetchAutoCategoryIntervalCalculationParams(_n) {
  var nr = _n.getLabelModel();
  return {
    axisRotate: _n.getRotate ? _n.getRotate() : _n.isHorizontal && !_n.isHorizontal() ? 90 : 0,
    labelRotate: nr.get("rotate") || 0,
    font: nr.getFont()
  };
}
function makeLabelsByNumericCategoryInterval(_n, nr, Cn) {
  var Bn = makeLabelFormatter(_n), In = _n.scale, Dn = In.getExtent(), Ln = _n.getLabelModel(), $n = [], Nn = Math.max((nr || 0) + 1, 1), Rn = Dn[0], Fn = In.count();
  Rn !== 0 && Nn > 1 && Fn / Nn > 2 && (Rn = Math.round(Math.ceil(Rn / Nn) * Nn));
  var Pn = shouldShowAllLabels(_n), Un = Ln.get("showMinLabel") || Pn, Hn = Ln.get("showMaxLabel") || Pn;
  Un && Rn !== Dn[0] && Gn(Dn[0]);
  for (var zn = Rn; zn <= Dn[1]; zn += Nn)
    Gn(zn);
  Hn && zn - Nn !== Dn[1] && Gn(Dn[1]);
  function Gn(Yn) {
    var Wn = {
      value: Yn
    };
    $n.push(Cn ? Yn : {
      formattedLabel: Bn(Wn),
      rawLabel: In.getLabel(Wn),
      tickValue: Yn
    });
  }
  return $n;
}
function makeLabelsByCustomizedCategoryInterval(_n, nr, Cn) {
  var Bn = _n.scale, In = makeLabelFormatter(_n), Dn = [];
  return each$f(Bn.getTicks(), function(Ln) {
    var $n = Bn.getLabel(Ln), Nn = Ln.value;
    nr(Ln.value, $n) && Dn.push(Cn ? Nn : {
      formattedLabel: In(Ln),
      rawLabel: $n,
      tickValue: Nn
    });
  }), Dn;
}
var NORMALIZED_EXTENT = [0, 1], Axis = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.onBand = !1, this.inverse = !1, this.dim = nr, this.scale = Cn, this._extent = Bn || [0, 0];
    }
    return _n.prototype.contain = function(nr) {
      var Cn = this._extent, Bn = Math.min(Cn[0], Cn[1]), In = Math.max(Cn[0], Cn[1]);
      return nr >= Bn && nr <= In;
    }, _n.prototype.containData = function(nr) {
      return this.scale.contain(nr);
    }, _n.prototype.getExtent = function() {
      return this._extent.slice();
    }, _n.prototype.getPixelPrecision = function(nr) {
      return getPixelPrecision(nr || this.scale.getExtent(), this._extent);
    }, _n.prototype.setExtent = function(nr, Cn) {
      var Bn = this._extent;
      Bn[0] = nr, Bn[1] = Cn;
    }, _n.prototype.dataToCoord = function(nr, Cn) {
      var Bn = this._extent, In = this.scale;
      return nr = In.normalize(nr), this.onBand && In.type === "ordinal" && (Bn = Bn.slice(), fixExtentWithBands(Bn, In.count())), linearMap$2(nr, NORMALIZED_EXTENT, Bn, Cn);
    }, _n.prototype.coordToData = function(nr, Cn) {
      var Bn = this._extent, In = this.scale;
      this.onBand && In.type === "ordinal" && (Bn = Bn.slice(), fixExtentWithBands(Bn, In.count()));
      var Dn = linearMap$2(nr, Bn, NORMALIZED_EXTENT, Cn);
      return this.scale.scale(Dn);
    }, _n.prototype.pointToData = function(nr, Cn) {
    }, _n.prototype.getTicksCoords = function(nr) {
      nr = nr || {};
      var Cn = nr.tickModel || this.getTickModel(), Bn = createAxisTicks(this, Cn), In = Bn.ticks, Dn = map$1(In, function($n) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber($n) : $n),
          tickValue: $n
        };
      }, this), Ln = Cn.get("alignWithLabel");
      return fixOnBandTicksCoords(this, Dn, Ln, nr.clamp), Dn;
    }, _n.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var nr = this.model.getModel("minorTick"), Cn = nr.get("splitNumber");
      Cn > 0 && Cn < 100 || (Cn = 5);
      var Bn = this.scale.getMinorTicks(Cn), In = map$1(Bn, function(Dn) {
        return map$1(Dn, function(Ln) {
          return {
            coord: this.dataToCoord(Ln),
            tickValue: Ln
          };
        }, this);
      }, this);
      return In;
    }, _n.prototype.getViewLabels = function() {
      return createAxisLabels(this).labels;
    }, _n.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, _n.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, _n.prototype.getBandWidth = function() {
      var nr = this._extent, Cn = this.scale.getExtent(), Bn = Cn[1] - Cn[0] + (this.onBand ? 1 : 0);
      Bn === 0 && (Bn = 1);
      var In = Math.abs(nr[1] - nr[0]);
      return Math.abs(In) / Bn;
    }, _n.prototype.calculateCategoryInterval = function() {
      return calculateCategoryInterval(this);
    }, _n;
  }()
);
function fixExtentWithBands(_n, nr) {
  var Cn = _n[1] - _n[0], Bn = nr, In = Cn / Bn / 2;
  _n[0] += In, _n[1] -= In;
}
function fixOnBandTicksCoords(_n, nr, Cn, Bn) {
  var In = nr.length;
  if (!_n.onBand || Cn || !In)
    return;
  var Dn = _n.getExtent(), Ln, $n;
  if (In === 1)
    nr[0].coord = Dn[0], Ln = nr[1] = {
      coord: Dn[1],
      tickValue: nr[0].tickValue
    };
  else {
    var Nn = nr[In - 1].tickValue - nr[0].tickValue, Rn = (nr[In - 1].coord - nr[0].coord) / Nn;
    each$f(nr, function(Hn) {
      Hn.coord -= Rn / 2;
    });
    var Fn = _n.scale.getExtent();
    $n = 1 + Fn[1] - nr[In - 1].tickValue, Ln = {
      coord: nr[In - 1].coord + Rn * $n,
      tickValue: Fn[1] + 1
    }, nr.push(Ln);
  }
  var Pn = Dn[0] > Dn[1];
  Un(nr[0].coord, Dn[0]) && (Bn ? nr[0].coord = Dn[0] : nr.shift()), Bn && Un(Dn[0], nr[0].coord) && nr.unshift({
    coord: Dn[0]
  }), Un(Dn[1], Ln.coord) && (Bn ? Ln.coord = Dn[1] : nr.pop()), Bn && Un(Ln.coord, Dn[1]) && nr.push({
    coord: Dn[1]
  });
  function Un(Hn, zn) {
    return Hn = round$4(Hn), zn = round$4(zn), Pn ? Hn > zn : Hn < zn;
  }
}
const Axis$1 = Axis;
function extendComponentModel(_n) {
  var nr = ComponentModel$1.extend(_n);
  return ComponentModel$1.registerClass(nr), nr;
}
function extendComponentView(_n) {
  var nr = ComponentView$1.extend(_n);
  return ComponentView$1.registerClass(nr), nr;
}
function extendSeriesModel(_n) {
  var nr = SeriesModel$1.extend(_n);
  return SeriesModel$1.registerClass(nr), nr;
}
function extendChartView(_n) {
  var nr = ChartView$1.extend(_n);
  return ChartView$1.registerClass(nr), nr;
}
var PI2$2 = Math.PI * 2, CMD$1 = PathProxy$1.CMD, DEFAULT_SEARCH_SPACE = ["top", "right", "bottom", "left"];
function getCandidateAnchor(_n, nr, Cn, Bn, In) {
  var Dn = Cn.width, Ln = Cn.height;
  switch (_n) {
    case "top":
      Bn.set(Cn.x + Dn / 2, Cn.y - nr), In.set(0, -1);
      break;
    case "bottom":
      Bn.set(Cn.x + Dn / 2, Cn.y + Ln + nr), In.set(0, 1);
      break;
    case "left":
      Bn.set(Cn.x - nr, Cn.y + Ln / 2), In.set(-1, 0);
      break;
    case "right":
      Bn.set(Cn.x + Dn + nr, Cn.y + Ln / 2), In.set(1, 0);
      break;
  }
}
function projectPointToArc(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
  Ln -= _n, $n -= nr;
  var Rn = Math.sqrt(Ln * Ln + $n * $n);
  Ln /= Rn, $n /= Rn;
  var Fn = Ln * Cn + _n, Pn = $n * Cn + nr;
  if (Math.abs(Bn - In) % PI2$2 < 1e-4)
    return Nn[0] = Fn, Nn[1] = Pn, Rn - Cn;
  if (Dn) {
    var Un = Bn;
    Bn = normalizeRadian(In), In = normalizeRadian(Un);
  } else
    Bn = normalizeRadian(Bn), In = normalizeRadian(In);
  Bn > In && (In += PI2$2);
  var Hn = Math.atan2($n, Ln);
  if (Hn < 0 && (Hn += PI2$2), Hn >= Bn && Hn <= In || Hn + PI2$2 >= Bn && Hn + PI2$2 <= In)
    return Nn[0] = Fn, Nn[1] = Pn, Rn - Cn;
  var zn = Cn * Math.cos(Bn) + _n, Gn = Cn * Math.sin(Bn) + nr, Yn = Cn * Math.cos(In) + _n, Wn = Cn * Math.sin(In) + nr, Xn = (zn - Ln) * (zn - Ln) + (Gn - $n) * (Gn - $n), ea = (Yn - Ln) * (Yn - Ln) + (Wn - $n) * (Wn - $n);
  return Xn < ea ? (Nn[0] = zn, Nn[1] = Gn, Math.sqrt(Xn)) : (Nn[0] = Yn, Nn[1] = Wn, Math.sqrt(ea));
}
function projectPointToLine(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  var Nn = In - _n, Rn = Dn - nr, Fn = Cn - _n, Pn = Bn - nr, Un = Math.sqrt(Fn * Fn + Pn * Pn);
  Fn /= Un, Pn /= Un;
  var Hn = Nn * Fn + Rn * Pn, zn = Hn / Un;
  $n && (zn = Math.min(Math.max(zn, 0), 1)), zn *= Un;
  var Gn = Ln[0] = _n + zn * Fn, Yn = Ln[1] = nr + zn * Pn;
  return Math.sqrt((Gn - In) * (Gn - In) + (Yn - Dn) * (Yn - Dn));
}
function projectPointToRect(_n, nr, Cn, Bn, In, Dn, Ln) {
  Cn < 0 && (_n = _n + Cn, Cn = -Cn), Bn < 0 && (nr = nr + Bn, Bn = -Bn);
  var $n = _n + Cn, Nn = nr + Bn, Rn = Ln[0] = Math.min(Math.max(In, _n), $n), Fn = Ln[1] = Math.min(Math.max(Dn, nr), Nn);
  return Math.sqrt((Rn - In) * (Rn - In) + (Fn - Dn) * (Fn - Dn));
}
var tmpPt = [];
function nearestPointOnRect(_n, nr, Cn) {
  var Bn = projectPointToRect(nr.x, nr.y, nr.width, nr.height, _n.x, _n.y, tmpPt);
  return Cn.set(tmpPt[0], tmpPt[1]), Bn;
}
function nearestPointOnPath(_n, nr, Cn) {
  for (var Bn = 0, In = 0, Dn = 0, Ln = 0, $n, Nn, Rn = 1 / 0, Fn = nr.data, Pn = _n.x, Un = _n.y, Hn = 0; Hn < Fn.length; ) {
    var zn = Fn[Hn++];
    Hn === 1 && (Bn = Fn[Hn], In = Fn[Hn + 1], Dn = Bn, Ln = In);
    var Gn = Rn;
    switch (zn) {
      case CMD$1.M:
        Dn = Fn[Hn++], Ln = Fn[Hn++], Bn = Dn, In = Ln;
        break;
      case CMD$1.L:
        Gn = projectPointToLine(Bn, In, Fn[Hn], Fn[Hn + 1], Pn, Un, tmpPt, !0), Bn = Fn[Hn++], In = Fn[Hn++];
        break;
      case CMD$1.C:
        Gn = cubicProjectPoint(Bn, In, Fn[Hn++], Fn[Hn++], Fn[Hn++], Fn[Hn++], Fn[Hn], Fn[Hn + 1], Pn, Un, tmpPt), Bn = Fn[Hn++], In = Fn[Hn++];
        break;
      case CMD$1.Q:
        Gn = quadraticProjectPoint(Bn, In, Fn[Hn++], Fn[Hn++], Fn[Hn], Fn[Hn + 1], Pn, Un, tmpPt), Bn = Fn[Hn++], In = Fn[Hn++];
        break;
      case CMD$1.A:
        var Yn = Fn[Hn++], Wn = Fn[Hn++], Xn = Fn[Hn++], ea = Fn[Hn++], ta = Fn[Hn++], na = Fn[Hn++];
        Hn += 1;
        var ra = !!(1 - Fn[Hn++]);
        $n = Math.cos(ta) * Xn + Yn, Nn = Math.sin(ta) * ea + Wn, Hn <= 1 && (Dn = $n, Ln = Nn);
        var aa = (Pn - Yn) * ea / Xn + Yn;
        Gn = projectPointToArc(Yn, Wn, ea, ta, ta + na, ra, aa, Un, tmpPt), Bn = Math.cos(ta + na) * Xn + Yn, In = Math.sin(ta + na) * ea + Wn;
        break;
      case CMD$1.R:
        Dn = Bn = Fn[Hn++], Ln = In = Fn[Hn++];
        var ia = Fn[Hn++], Aa = Fn[Hn++];
        Gn = projectPointToRect(Dn, Ln, ia, Aa, Pn, Un, tmpPt);
        break;
      case CMD$1.Z:
        Gn = projectPointToLine(Bn, In, Dn, Ln, Pn, Un, tmpPt, !0), Bn = Dn, In = Ln;
        break;
    }
    Gn < Rn && (Rn = Gn, Cn.set(tmpPt[0], tmpPt[1]));
  }
  return Rn;
}
var pt0 = new Point$1(), pt1 = new Point$1(), pt2 = new Point$1(), dir = new Point$1(), dir2 = new Point$1();
function updateLabelLinePoints(_n, nr) {
  if (_n) {
    var Cn = _n.getTextGuideLine(), Bn = _n.getTextContent();
    if (Bn && Cn) {
      var In = _n.textGuideLineConfig || {}, Dn = [[0, 0], [0, 0], [0, 0]], Ln = In.candidates || DEFAULT_SEARCH_SPACE, $n = Bn.getBoundingRect().clone();
      $n.applyTransform(Bn.getComputedTransform());
      var Nn = 1 / 0, Rn = In.anchor, Fn = _n.getComputedTransform(), Pn = Fn && invert([], Fn), Un = nr.get("length2") || 0;
      Rn && pt2.copy(Rn);
      for (var Hn = 0; Hn < Ln.length; Hn++) {
        var zn = Ln[Hn];
        getCandidateAnchor(zn, 0, $n, pt0, dir), Point$1.scaleAndAdd(pt1, pt0, dir, Un), pt1.transform(Pn);
        var Gn = _n.getBoundingRect(), Yn = Rn ? Rn.distance(pt1) : _n instanceof Path$1 ? nearestPointOnPath(pt1, _n.path, pt2) : nearestPointOnRect(pt1, Gn, pt2);
        Yn < Nn && (Nn = Yn, pt1.transform(Fn), pt2.transform(Fn), pt2.toArray(Dn[0]), pt1.toArray(Dn[1]), pt0.toArray(Dn[2]));
      }
      limitTurnAngle(Dn, nr.get("minTurnAngle")), Cn.setShape({
        points: Dn
      });
    }
  }
}
var tmpArr = [], tmpProjPoint = new Point$1();
function limitTurnAngle(_n, nr) {
  if (nr <= 180 && nr > 0) {
    nr = nr / 180 * Math.PI, pt0.fromArray(_n[0]), pt1.fromArray(_n[1]), pt2.fromArray(_n[2]), Point$1.sub(dir, pt0, pt1), Point$1.sub(dir2, pt2, pt1);
    var Cn = dir.len(), Bn = dir2.len();
    if (!(Cn < 1e-3 || Bn < 1e-3)) {
      dir.scale(1 / Cn), dir2.scale(1 / Bn);
      var In = dir.dot(dir2), Dn = Math.cos(nr);
      if (Dn < In) {
        var Ln = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, !1);
        tmpProjPoint.fromArray(tmpArr), tmpProjPoint.scaleAndAdd(dir2, Ln / Math.tan(Math.PI - nr));
        var $n = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
        if (isNaN($n))
          return;
        $n < 0 ? Point$1.copy(tmpProjPoint, pt1) : $n > 1 && Point$1.copy(tmpProjPoint, pt2), tmpProjPoint.toArray(_n[1]);
      }
    }
  }
}
function limitSurfaceAngle(_n, nr, Cn) {
  if (Cn <= 180 && Cn > 0) {
    Cn = Cn / 180 * Math.PI, pt0.fromArray(_n[0]), pt1.fromArray(_n[1]), pt2.fromArray(_n[2]), Point$1.sub(dir, pt1, pt0), Point$1.sub(dir2, pt2, pt1);
    var Bn = dir.len(), In = dir2.len();
    if (!(Bn < 1e-3 || In < 1e-3)) {
      dir.scale(1 / Bn), dir2.scale(1 / In);
      var Dn = dir.dot(nr), Ln = Math.cos(Cn);
      if (Dn < Ln) {
        var $n = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, !1);
        tmpProjPoint.fromArray(tmpArr);
        var Nn = Math.PI / 2, Rn = Math.acos(dir2.dot(nr)), Fn = Nn + Rn - Cn;
        if (Fn >= Nn)
          Point$1.copy(tmpProjPoint, pt2);
        else {
          tmpProjPoint.scaleAndAdd(dir2, $n / Math.tan(Math.PI / 2 - Fn));
          var Pn = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
          if (isNaN(Pn))
            return;
          Pn < 0 ? Point$1.copy(tmpProjPoint, pt1) : Pn > 1 && Point$1.copy(tmpProjPoint, pt2);
        }
        tmpProjPoint.toArray(_n[1]);
      }
    }
  }
}
function setLabelLineState(_n, nr, Cn, Bn) {
  var In = Cn === "normal", Dn = In ? _n : _n.ensureState(Cn);
  Dn.ignore = nr;
  var Ln = Bn.get("smooth");
  Ln && Ln === !0 && (Ln = 0.3), Dn.shape = Dn.shape || {}, Ln > 0 && (Dn.shape.smooth = Ln);
  var $n = Bn.getModel("lineStyle").getLineStyle();
  In ? _n.useStyle($n) : Dn.style = $n;
}
function buildLabelLinePath(_n, nr) {
  var Cn = nr.smooth, Bn = nr.points;
  if (Bn)
    if (_n.moveTo(Bn[0][0], Bn[0][1]), Cn > 0 && Bn.length >= 3) {
      var In = dist$1(Bn[0], Bn[1]), Dn = dist$1(Bn[1], Bn[2]);
      if (!In || !Dn) {
        _n.lineTo(Bn[1][0], Bn[1][1]), _n.lineTo(Bn[2][0], Bn[2][1]);
        return;
      }
      var Ln = Math.min(In, Dn) * Cn, $n = lerp$2([], Bn[1], Bn[0], Ln / In), Nn = lerp$2([], Bn[1], Bn[2], Ln / Dn), Rn = lerp$2([], $n, Nn, 0.5);
      _n.bezierCurveTo($n[0], $n[1], $n[0], $n[1], Rn[0], Rn[1]), _n.bezierCurveTo(Nn[0], Nn[1], Nn[0], Nn[1], Bn[2][0], Bn[2][1]);
    } else
      for (var Fn = 1; Fn < Bn.length; Fn++)
        _n.lineTo(Bn[Fn][0], Bn[Fn][1]);
}
function setLabelLineStyle(_n, nr, Cn) {
  var Bn = _n.getTextGuideLine(), In = _n.getTextContent();
  if (!In) {
    Bn && _n.removeTextGuideLine();
    return;
  }
  for (var Dn = nr.normal, Ln = Dn.get("show"), $n = In.ignore, Nn = 0; Nn < DISPLAY_STATES.length; Nn++) {
    var Rn = DISPLAY_STATES[Nn], Fn = nr[Rn], Pn = Rn === "normal";
    if (Fn) {
      var Un = Fn.get("show"), Hn = Pn ? $n : retrieve2(In.states[Rn] && In.states[Rn].ignore, $n);
      if (Hn || !retrieve2(Un, Ln)) {
        var zn = Pn ? Bn : Bn && Bn.states[Rn];
        zn && (zn.ignore = !0), Bn && setLabelLineState(Bn, !0, Rn, Fn);
        continue;
      }
      Bn || (Bn = new Polyline$3(), _n.setTextGuideLine(Bn), !Pn && ($n || !Ln) && setLabelLineState(Bn, !0, "normal", nr.normal), _n.stateProxy && (Bn.stateProxy = _n.stateProxy)), setLabelLineState(Bn, !1, Rn, Fn);
    }
  }
  if (Bn) {
    defaults(Bn.style, Cn), Bn.style.fill = null;
    var Gn = Dn.get("showAbove"), Yn = _n.textGuideLineConfig = _n.textGuideLineConfig || {};
    Yn.showAbove = Gn || !1, Bn.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(_n, nr) {
  nr = nr || "labelLine";
  for (var Cn = {
    normal: _n.getModel(nr)
  }, Bn = 0; Bn < SPECIAL_STATES.length; Bn++) {
    var In = SPECIAL_STATES[Bn];
    Cn[In] = _n.getModel([In, nr]);
  }
  return Cn;
}
function prepareLayoutList(_n) {
  for (var nr = [], Cn = 0; Cn < _n.length; Cn++) {
    var Bn = _n[Cn];
    if (!Bn.defaultAttr.ignore) {
      var In = Bn.label, Dn = In.getComputedTransform(), Ln = In.getBoundingRect(), $n = !Dn || Dn[1] < 1e-5 && Dn[2] < 1e-5, Nn = In.style.margin || 0, Rn = Ln.clone();
      Rn.applyTransform(Dn), Rn.x -= Nn / 2, Rn.y -= Nn / 2, Rn.width += Nn, Rn.height += Nn;
      var Fn = $n ? new OrientedBoundingRect$1(Ln, Dn) : null;
      nr.push({
        label: In,
        labelLine: Bn.labelLine,
        rect: Rn,
        localRect: Ln,
        obb: Fn,
        priority: Bn.priority,
        defaultAttr: Bn.defaultAttr,
        layoutOption: Bn.computedLayoutOption,
        axisAligned: $n,
        transform: Dn
      });
    }
  }
  return nr;
}
function shiftLayout(_n, nr, Cn, Bn, In, Dn) {
  var Ln = _n.length;
  if (Ln < 2)
    return;
  _n.sort(function(ia, Aa) {
    return ia.rect[nr] - Aa.rect[nr];
  });
  for (var $n = 0, Nn, Rn = !1, Fn = 0, Pn = 0; Pn < Ln; Pn++) {
    var Un = _n[Pn], Hn = Un.rect;
    Nn = Hn[nr] - $n, Nn < 0 && (Hn[nr] -= Nn, Un.label[nr] -= Nn, Rn = !0);
    var zn = Math.max(-Nn, 0);
    Fn += zn, $n = Hn[nr] + Hn[Cn];
  }
  Fn > 0 && Dn && na(-Fn / Ln, 0, Ln);
  var Gn = _n[0], Yn = _n[Ln - 1], Wn, Xn;
  ea(), Wn < 0 && ra(-Wn, 0.8), Xn < 0 && ra(Xn, 0.8), ea(), ta(Wn, Xn, 1), ta(Xn, Wn, -1), ea(), Wn < 0 && aa(-Wn), Xn < 0 && aa(Xn);
  function ea() {
    Wn = Gn.rect[nr] - Bn, Xn = In - Yn.rect[nr] - Yn.rect[Cn];
  }
  function ta(ia, Aa, sa) {
    if (ia < 0) {
      var oa = Math.min(Aa, -ia);
      if (oa > 0) {
        na(oa * sa, 0, Ln);
        var la = oa + ia;
        la < 0 && ra(-la * sa, 1);
      } else
        ra(-ia * sa, 1);
    }
  }
  function na(ia, Aa, sa) {
    ia !== 0 && (Rn = !0);
    for (var oa = Aa; oa < sa; oa++) {
      var la = _n[oa], ua = la.rect;
      ua[nr] += ia, la.label[nr] += ia;
    }
  }
  function ra(ia, Aa) {
    for (var sa = [], oa = 0, la = 1; la < Ln; la++) {
      var ua = _n[la - 1].rect, ca = Math.max(_n[la].rect[nr] - ua[nr] - ua[Cn], 0);
      sa.push(ca), oa += ca;
    }
    if (oa) {
      var fa = Math.min(Math.abs(ia) / oa, Aa);
      if (ia > 0)
        for (var la = 0; la < Ln - 1; la++) {
          var ha = sa[la] * fa;
          na(ha, 0, la + 1);
        }
      else
        for (var la = Ln - 1; la > 0; la--) {
          var ha = sa[la - 1] * fa;
          na(-ha, la, Ln);
        }
    }
  }
  function aa(ia) {
    var Aa = ia < 0 ? -1 : 1;
    ia = Math.abs(ia);
    for (var sa = Math.ceil(ia / (Ln - 1)), oa = 0; oa < Ln - 1; oa++)
      if (Aa > 0 ? na(sa, 0, oa + 1) : na(-sa, Ln - oa - 1, Ln), ia -= sa, ia <= 0)
        return;
  }
  return Rn;
}
function shiftLayoutOnX(_n, nr, Cn, Bn) {
  return shiftLayout(_n, "x", "width", nr, Cn, Bn);
}
function shiftLayoutOnY(_n, nr, Cn, Bn) {
  return shiftLayout(_n, "y", "height", nr, Cn, Bn);
}
function hideOverlap(_n) {
  var nr = [];
  _n.sort(function(Gn, Yn) {
    return Yn.priority - Gn.priority;
  });
  var Cn = new BoundingRect$1(0, 0, 0, 0);
  function Bn(Gn) {
    if (!Gn.ignore) {
      var Yn = Gn.ensureState("emphasis");
      Yn.ignore == null && (Yn.ignore = !1);
    }
    Gn.ignore = !0;
  }
  for (var In = 0; In < _n.length; In++) {
    var Dn = _n[In], Ln = Dn.axisAligned, $n = Dn.localRect, Nn = Dn.transform, Rn = Dn.label, Fn = Dn.labelLine;
    Cn.copy(Dn.rect), Cn.width -= 0.1, Cn.height -= 0.1, Cn.x += 0.05, Cn.y += 0.05;
    for (var Pn = Dn.obb, Un = !1, Hn = 0; Hn < nr.length; Hn++) {
      var zn = nr[Hn];
      if (Cn.intersect(zn.rect)) {
        if (Ln && zn.axisAligned) {
          Un = !0;
          break;
        }
        if (zn.obb || (zn.obb = new OrientedBoundingRect$1(zn.localRect, zn.transform)), Pn || (Pn = new OrientedBoundingRect$1($n, Nn)), Pn.intersect(zn.obb)) {
          Un = !0;
          break;
        }
      }
    }
    Un ? (Bn(Rn), Fn && Bn(Fn)) : (Rn.attr("ignore", Dn.defaultAttr.ignore), Fn && Fn.attr("ignore", Dn.defaultAttr.labelGuideIgnore), nr.push(Dn));
  }
}
function cloneArr(_n) {
  if (_n) {
    for (var nr = [], Cn = 0; Cn < _n.length; Cn++)
      nr.push(_n[Cn].slice());
    return nr;
  }
}
function prepareLayoutCallbackParams(_n, nr) {
  var Cn = _n.label, Bn = nr && nr.getTextGuideLine();
  return {
    dataIndex: _n.dataIndex,
    dataType: _n.dataType,
    seriesIndex: _n.seriesModel.seriesIndex,
    text: _n.label.style.text,
    rect: _n.hostRect,
    labelRect: _n.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: Cn.style.align,
    verticalAlign: Cn.style.verticalAlign,
    labelLinePoints: cloneArr(Bn && Bn.shape.points)
  };
}
var LABEL_OPTION_TO_STYLE_KEYS = ["align", "verticalAlign", "width", "height", "fontSize"], dummyTransformable = new Transformable$1(), labelLayoutInnerStore = makeInner(), labelLineAnimationStore = makeInner();
function extendWithKeys(_n, nr, Cn) {
  for (var Bn = 0; Bn < Cn.length; Bn++) {
    var In = Cn[Bn];
    nr[In] != null && (_n[In] = nr[In]);
  }
}
var LABEL_LAYOUT_PROPS = ["x", "y", "rotation"], LabelManager = (
  /** @class */
  function() {
    function _n() {
      this._labelList = [], this._chartViewList = [];
    }
    return _n.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, _n.prototype._addLabel = function(nr, Cn, Bn, In, Dn) {
      var Ln = In.style, $n = In.__hostTarget, Nn = $n.textConfig || {}, Rn = In.getComputedTransform(), Fn = In.getBoundingRect().plain();
      BoundingRect$1.applyTransform(Fn, Fn, Rn), Rn ? dummyTransformable.setLocalTransform(Rn) : (dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0, dummyTransformable.scaleX = dummyTransformable.scaleY = 1), dummyTransformable.rotation = normalizeRadian(dummyTransformable.rotation);
      var Pn = In.__hostTarget, Un;
      if (Pn) {
        Un = Pn.getBoundingRect().plain();
        var Hn = Pn.getComputedTransform();
        BoundingRect$1.applyTransform(Un, Un, Hn);
      }
      var zn = Un && Pn.getTextGuideLine();
      this._labelList.push({
        label: In,
        labelLine: zn,
        seriesModel: Bn,
        dataIndex: nr,
        dataType: Cn,
        layoutOption: Dn,
        computedLayoutOption: null,
        rect: Fn,
        hostRect: Un,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: Un ? Un.width * Un.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: In.ignore,
          labelGuideIgnore: zn && zn.ignore,
          x: dummyTransformable.x,
          y: dummyTransformable.y,
          scaleX: dummyTransformable.scaleX,
          scaleY: dummyTransformable.scaleY,
          rotation: dummyTransformable.rotation,
          style: {
            x: Ln.x,
            y: Ln.y,
            align: Ln.align,
            verticalAlign: Ln.verticalAlign,
            width: Ln.width,
            height: Ln.height,
            fontSize: Ln.fontSize
          },
          cursor: In.cursor,
          attachedPos: Nn.position,
          attachedRot: Nn.rotation
        }
      });
    }, _n.prototype.addLabelsOfSeries = function(nr) {
      var Cn = this;
      this._chartViewList.push(nr);
      var Bn = nr.__model, In = Bn.get("labelLayout");
      (isFunction$1(In) || keys(In).length) && nr.group.traverse(function(Dn) {
        if (Dn.ignore)
          return !0;
        var Ln = Dn.getTextContent(), $n = getECData(Dn);
        Ln && !Ln.disableLabelLayout && Cn._addLabel($n.dataIndex, $n.dataType, Bn, Ln, In);
      });
    }, _n.prototype.updateLayoutConfig = function(nr) {
      var Cn = nr.getWidth(), Bn = nr.getHeight();
      function In(ea, ta) {
        return function() {
          updateLabelLinePoints(ea, ta);
        };
      }
      for (var Dn = 0; Dn < this._labelList.length; Dn++) {
        var Ln = this._labelList[Dn], $n = Ln.label, Nn = $n.__hostTarget, Rn = Ln.defaultAttr, Fn = void 0;
        isFunction$1(Ln.layoutOption) ? Fn = Ln.layoutOption(prepareLayoutCallbackParams(Ln, Nn)) : Fn = Ln.layoutOption, Fn = Fn || {}, Ln.computedLayoutOption = Fn;
        var Pn = Math.PI / 180;
        Nn && Nn.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: Fn.x != null || Fn.y != null ? null : Rn.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: Fn.rotate != null ? Fn.rotate * Pn : Rn.attachedRot,
          offset: [Fn.dx || 0, Fn.dy || 0]
        });
        var Un = !1;
        if (Fn.x != null ? ($n.x = parsePercent(Fn.x, Cn), $n.setStyle("x", 0), Un = !0) : ($n.x = Rn.x, $n.setStyle("x", Rn.style.x)), Fn.y != null ? ($n.y = parsePercent(Fn.y, Bn), $n.setStyle("y", 0), Un = !0) : ($n.y = Rn.y, $n.setStyle("y", Rn.style.y)), Fn.labelLinePoints) {
          var Hn = Nn.getTextGuideLine();
          Hn && (Hn.setShape({
            points: Fn.labelLinePoints
          }), Un = !1);
        }
        var zn = labelLayoutInnerStore($n);
        zn.needsUpdateLabelLine = Un, $n.rotation = Fn.rotate != null ? Fn.rotate * Pn : Rn.rotation, $n.scaleX = Rn.scaleX, $n.scaleY = Rn.scaleY;
        for (var Gn = 0; Gn < LABEL_OPTION_TO_STYLE_KEYS.length; Gn++) {
          var Yn = LABEL_OPTION_TO_STYLE_KEYS[Gn];
          $n.setStyle(Yn, Fn[Yn] != null ? Fn[Yn] : Rn.style[Yn]);
        }
        if (Fn.draggable) {
          if ($n.draggable = !0, $n.cursor = "move", Nn) {
            var Wn = Ln.seriesModel;
            if (Ln.dataIndex != null) {
              var Xn = Ln.seriesModel.getData(Ln.dataType);
              Wn = Xn.getItemModel(Ln.dataIndex);
            }
            $n.on("drag", In(Nn, Wn.getModel("labelLine")));
          }
        } else
          $n.off("drag"), $n.cursor = Rn.cursor;
      }
    }, _n.prototype.layout = function(nr) {
      var Cn = nr.getWidth(), Bn = nr.getHeight(), In = prepareLayoutList(this._labelList), Dn = filter(In, function(Nn) {
        return Nn.layoutOption.moveOverlap === "shiftX";
      }), Ln = filter(In, function(Nn) {
        return Nn.layoutOption.moveOverlap === "shiftY";
      });
      shiftLayoutOnX(Dn, 0, Cn), shiftLayoutOnY(Ln, 0, Bn);
      var $n = filter(In, function(Nn) {
        return Nn.layoutOption.hideOverlap;
      });
      hideOverlap($n);
    }, _n.prototype.processLabelsOverall = function() {
      var nr = this;
      each$f(this._chartViewList, function(Cn) {
        var Bn = Cn.__model, In = Cn.ignoreLabelLineUpdate, Dn = Bn.isAnimationEnabled();
        Cn.group.traverse(function(Ln) {
          if (Ln.ignore && !Ln.forceLabelAnimation)
            return !0;
          var $n = !In, Nn = Ln.getTextContent();
          !$n && Nn && ($n = labelLayoutInnerStore(Nn).needsUpdateLabelLine), $n && nr._updateLabelLine(Ln, Bn), Dn && nr._animateLabels(Ln, Bn);
        });
      });
    }, _n.prototype._updateLabelLine = function(nr, Cn) {
      var Bn = nr.getTextContent(), In = getECData(nr), Dn = In.dataIndex;
      if (Bn && Dn != null) {
        var Ln = Cn.getData(In.dataType), $n = Ln.getItemModel(Dn), Nn = {}, Rn = Ln.getItemVisual(Dn, "style");
        if (Rn) {
          var Fn = Ln.getVisual("drawType");
          Nn.stroke = Rn[Fn];
        }
        var Pn = $n.getModel("labelLine");
        setLabelLineStyle(nr, getLabelLineStatesModels($n), Nn), updateLabelLinePoints(nr, Pn);
      }
    }, _n.prototype._animateLabels = function(nr, Cn) {
      var Bn = nr.getTextContent(), In = nr.getTextGuideLine();
      if (Bn && (nr.forceLabelAnimation || !Bn.ignore && !Bn.invisible && !nr.disableLabelAnimation && !isElementRemoved(nr))) {
        var Dn = labelLayoutInnerStore(Bn), Ln = Dn.oldLayout, $n = getECData(nr), Nn = $n.dataIndex, Rn = {
          x: Bn.x,
          y: Bn.y,
          rotation: Bn.rotation
        }, Fn = Cn.getData($n.dataType);
        if (Ln) {
          Bn.attr(Ln);
          var Un = nr.prevStates;
          Un && (indexOf(Un, "select") >= 0 && Bn.attr(Dn.oldLayoutSelect), indexOf(Un, "emphasis") >= 0 && Bn.attr(Dn.oldLayoutEmphasis)), updateProps$1(Bn, Rn, Cn, Nn);
        } else if (Bn.attr(Rn), !labelInner(Bn).valueAnimation) {
          var Pn = retrieve2(Bn.style.opacity, 1);
          Bn.style.opacity = 0, initProps(Bn, {
            style: {
              opacity: Pn
            }
          }, Cn, Nn);
        }
        if (Dn.oldLayout = Rn, Bn.states.select) {
          var Hn = Dn.oldLayoutSelect = {};
          extendWithKeys(Hn, Rn, LABEL_LAYOUT_PROPS), extendWithKeys(Hn, Bn.states.select, LABEL_LAYOUT_PROPS);
        }
        if (Bn.states.emphasis) {
          var zn = Dn.oldLayoutEmphasis = {};
          extendWithKeys(zn, Rn, LABEL_LAYOUT_PROPS), extendWithKeys(zn, Bn.states.emphasis, LABEL_LAYOUT_PROPS);
        }
        animateLabelValue(Bn, Nn, Fn, Cn, Cn);
      }
      if (In && !In.ignore && !In.invisible) {
        var Dn = labelLineAnimationStore(In), Ln = Dn.oldLayout, Gn = {
          points: In.shape.points
        };
        Ln ? (In.attr({
          shape: Ln
        }), updateProps$1(In, {
          shape: Gn
        }, Cn)) : (In.setShape(Gn), In.style.strokePercent = 0, initProps(In, {
          style: {
            strokePercent: 1
          }
        }, Cn)), Dn.oldLayout = Gn;
      }
    }, _n;
  }()
);
const LabelManager$1 = LabelManager;
var getLabelManager = makeInner();
function installLabelLayout(_n) {
  _n.registerUpdateLifecycle("series:beforeupdate", function(nr, Cn, Bn) {
    var In = getLabelManager(Cn).labelManager;
    In || (In = getLabelManager(Cn).labelManager = new LabelManager$1()), In.clearLabels();
  }), _n.registerUpdateLifecycle("series:layoutlabels", function(nr, Cn, Bn) {
    var In = getLabelManager(Cn).labelManager;
    Bn.updatedSeries.forEach(function(Dn) {
      In.addLabelsOfSeries(Cn.getViewOfSeriesModel(Dn));
    }), In.updateLayoutConfig(Cn), In.layout(Cn), In.processLabelsOverall();
  });
}
function getSketchColorRgba(_n) {
  return _n ? `rgba(${parseInt(_n.red * 255)}, ${parseInt(_n.green * 255)}, ${parseInt(_n.blue * 255)}, ${_n.alpha})` : "rgba(0, 0, 0, 1)";
}
const getUUID$1 = (_n = 6) => "dms_" + Number(Math.random().toString().substring(2, _n) + Date.now()).toString(32), color$d = [
  "#5470c6",
  "#91cc75",
  "#fac858",
  "#ee6666",
  "#73c0de",
  "#3ba272",
  "#fc8452",
  "#9a60b4",
  "#ea7ccc"
], name$b = "暗淡", customed = {
  color: color$d,
  name: name$b
}, color$c = [
  "#4992ff",
  "#7cffb2",
  "#fddd60",
  "#ff6e76",
  "#58d9f9",
  "#05c091",
  "#ff8a45",
  "#8d48e3",
  "#dd79ff"
], name$a = "明亮", dark = {
  color: color$c,
  name: name$a
}, color$b = [
  "#fc97af",
  "#87f7cf",
  "#f7f494",
  "#72ccff",
  "#f7c5a0",
  "#d4a4eb",
  "#d2f5a6",
  "#76f2f2"
], name$9 = "粉青", chalk = {
  color: color$b,
  name: name$9
}, color$a = [
  "#893448",
  "#d95850",
  "#eb8146",
  "#ffb248",
  "#f2d643",
  "#ebdba4"
], name$8 = "橘红", essos = {
  color: color$a,
  name: name$8
}, color$9 = [
  "#2ec7c9",
  "#b6a2de",
  "#5ab1ef",
  "#ffb980",
  "#d87a80",
  "#8d98b3",
  "#e5cf0d",
  "#97b552",
  "#95706d",
  "#dc69aa",
  "#07a2a4",
  "#9a7fd1",
  "#588dd5",
  "#f5994e",
  "#c05050",
  "#59678c",
  "#c9ab00",
  "#7eb00a",
  "#6f5553",
  "#c14089"
], name$7 = "马卡龙", macarons = {
  color: color$9,
  name: name$7
}, color$8 = [
  "#9b8bba",
  "#e098c7",
  "#8fd3e8",
  "#71669e",
  "#cc70af",
  "#7cb4cc"
], name$6 = "深紫", purplePassion = {
  color: color$8,
  name: name$6
}, color$7 = [
  "#e01f54",
  "#5e4ea5",
  "#f5e8c8",
  "#b8d2c7",
  "#c6b38e",
  "#a4d8c2",
  "#f3d999",
  "#d3758f",
  "#dcc392",
  "#2e4783",
  "#82b6e9",
  "#ff6347",
  "#a092f1",
  "#0a915d",
  "#eaf889",
  "#6699FF",
  "#ff6666",
  "#3cb371",
  "#d5b158",
  "#38b6b6"
], name$5 = "罗马红", roma = {
  color: color$7,
  name: name$5
}, color$6 = [
  "#c12e34",
  "#e6b600",
  "#0098d9",
  "#2b821d",
  "#005eaa",
  "#339ca8",
  "#cda819",
  "#32a487"
], name$4 = "深色", shine = {
  color: color$6,
  name: name$4
}, color$5 = [
  "#d87c7c",
  "#919e8b",
  "#d7ab82",
  "#6e7074",
  "#61a0a8",
  "#efa18d",
  "#787464",
  "#cc7e63",
  "#724e58",
  "#4b565b"
], name$3 = "复古", vintage = {
  color: color$5,
  name: name$3
}, color$4 = [
  "#3fb1e3",
  "#6be6c1",
  "#626c91",
  "#a0a7e6",
  "#c4ebad",
  "#96dee8"
], name$2 = "蓝绿", walden = {
  color: color$4,
  name: name$2
}, color$3 = [
  "#516b91",
  "#59c4e6",
  "#edafda",
  "#93b7e3",
  "#a5e7f0",
  "#cbb0e3"
], name$1 = "灰粉", westeros = {
  color: color$3,
  name: name$1
}, color$2 = [
  "#4ea397",
  "#22c3aa",
  "#7bd9a5",
  "#d0648a",
  "#f58db2",
  "#f2b3c9"
], name = "青草", wonderland = {
  color: color$2,
  name
}, title = {
  show: !0,
  textStyle: {
    color: "#BFBFBF",
    fontSize: 18
  },
  subtextStyle: {
    color: "#A2A2A2",
    fontSize: 14
  }
}, xAxis = {
  show: !0,
  name: "",
  nameGap: 15,
  offset: 0,
  nameTextStyle: {
    color: "#B9B8CE",
    fontSize: 12
  },
  inverse: !1,
  axisPointer: {
    show: !0,
    value: 0,
    label: {
      show: !0,
      backgroundColor: "#7581BD",
      color: "#fff",
      fontSize: 12,
      lineHeight: 16
    },
    handle: {
      show: !1,
      color: "rgb(148, 148, 148)",
      size: 25,
      margin: 40
    }
  },
  axisLabel: {
    show: !0,
    fontSize: 12,
    color: "#B9B8CE",
    rotate: 0,
    interval: 0,
    width: 50,
    overflow: "truncate"
  },
  position: "bottom",
  axisLine: {
    show: !0,
    lineStyle: {
      color: "#B9B8CE",
      width: 1
    },
    onZero: !0
  },
  axisTick: {
    show: !0,
    length: 5
  },
  splitLine: {
    show: !1,
    lineStyle: {
      color: "#484753",
      width: 1,
      type: "solid"
    }
  }
}, yAxis = {
  show: !0,
  name: "",
  nameGap: 15,
  offset: 0,
  nameTextStyle: {
    padding: [
      0,
      0,
      0,
      0
    ],
    color: "#B9B8CE",
    fontSize: 12
  },
  inverse: !1,
  axisLabel: {
    show: !0,
    fontSize: 12,
    color: "#B9B8CE",
    rotate: 0
  },
  position: "left",
  axisLine: {
    show: !0,
    lineStyle: {
      color: "#B9B8CE",
      width: 1
    },
    onZero: !0
  },
  axisTick: {
    show: !0,
    length: 5
  },
  splitLine: {
    show: !1,
    lineStyle: {
      color: "#484753",
      width: 1,
      type: "solid"
    }
  }
}, legend = {
  show: !0,
  type: "plain",
  top: "5%",
  textStyle: {
    color: "#B9B8CE"
  }
}, grid = {
  show: !1,
  containLabel: !1,
  left: "10%",
  top: "60",
  right: "10%",
  bottom: "60",
  backgroundColor: "rgba(255,255,255,1)",
  borderColor: "",
  borderWidth: 1
}, tooltip = {
  show: !0,
  triggerOn: "mousemove",
  alwaysShowContent: !1,
  trigger: "axis",
  axisPointer: {
    type: "line",
    snap: !0,
    lineStyle: {
      color: "rgb(148, 148, 148)",
      width: 1,
      type: "dashed"
    },
    crossStyle: {
      color: "rgb(148, 148, 148)",
      width: 1,
      type: "dashed"
    },
    shadowStyle: {
      color: "rgba(150,150,150,0.3)",
      shadowBlur: 10,
      shadowColor: "rgba(0,0,0,0.3)",
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    }
  },
  backgroundColor: "#fff",
  textStyle: {
    color: "#000",
    fontStyle: "normal",
    fontWeight: "normal",
    fontSize: 12
  }
}, themeJson = {
  title,
  xAxis,
  yAxis,
  legend,
  grid,
  tooltip
}, chartColors = {
  dark,
  customed,
  macarons,
  walden,
  purplePassion,
  vintage,
  chalk,
  westeros,
  wonderland,
  essos,
  shine,
  roma
}, defaultTheme = "dark", globalThemeJson = { ...themeJson, dataset: null, renderer: "svg" };
var BaseEvent = /* @__PURE__ */ ((_n) => (_n.ON_CLICK = "click", _n.ON_DBL_CLICK = "dblclick", _n.ON_MOUSE_MOVE = "mousemove", _n.ON_MOUSE_ENTER = "mouseenter", _n.ON_MOUSE_LEAVE = "mouseleave", _n))(BaseEvent || {}), EventLife = /* @__PURE__ */ ((_n) => (_n.VNODE_MOUNTED = "vnodeMounted", _n.VNODE_BEFORE_MOUNT = "vnodeBeforeMount", _n))(EventLife || {});
const actionTypeList = [
  { value: "show", label: "显示" },
  { value: "hide", label: "隐藏" },
  { value: "translate", label: "平移" },
  { value: "toggle", label: "显隐切换" },
  { value: "requestData", label: "请求数据" },
  { value: "submitForm", label: "提交表单" },
  { value: "toCanvasPage", label: "跳转大屏页面" },
  { value: "toLink", label: "跳转新地址" },
  // { value: "animate", label: '设置动画' },
  // { value: "transform", label: '变换动画' },
  { value: "playTheatreStudio", label: "播放帧动画" },
  { value: "pauseTheatreStudio", label: "暂停帧动画" },
  { value: "executionMethod", label: "执行方法" },
  { value: "logOutWay", label: "退出登录" }
];
var ChartFrameEnum = /* @__PURE__ */ ((_n) => (_n.ECHARTS = "echarts", _n.NAIVE_UI = "naiveUI", _n.COMMON = "common", _n.STATIC = "static", _n))(ChartFrameEnum || {});
const BlendModeEnumList = [
  { label: "正常", value: "normal" },
  { label: "正片叠底", value: "multiply" },
  { label: "叠加", value: "overlay" },
  { label: "滤色", value: "screen" },
  { label: "变暗", value: "darken" },
  { label: "变亮", value: "lighten" },
  { label: "颜色减淡", value: "color-dodge" },
  { label: "颜色加深", value: "color-burn;" },
  { label: "强光", value: "hard-light" },
  { label: "柔光", value: "soft-light" },
  { label: "差值", value: "difference" },
  { label: "排除", value: "exclusion" },
  { label: "色相", value: "hue" },
  { label: "饱和度", value: "saturation" },
  { label: "颜色", value: "color" },
  { label: "亮度", value: "luminosity" }
];
var FetchComFlagType = /* @__PURE__ */ ((_n) => (_n[_n.VIEW = 0] = "VIEW", _n[_n.CONFIG = 1] = "CONFIG", _n))(FetchComFlagType || {});
const requestConfig = {
  dataFrom: 0,
  // 数据来源 0 数据接口 1 数据容器（数据集）
  fromIds: [],
  // 存放数据容器数据集ID
  requestDataType: RequestDataTypeEnum.STATIC,
  requestHttpType: RequestHttpEnum.GET,
  requestUrl: "",
  firstAutoRequest: !0,
  requestInterval: void 0,
  requestIntervalUnit: RequestHttpIntervalEnum.SECOND,
  requestContentType: RequestContentTypeEnum.DEFAULT,
  requestParamsBodyType: RequestBodyEnum.NONE,
  requestSQLContent: {
    sql: "select * from  where"
  },
  requestParams: {
    Body: {
      "form-data": [],
      "x-www-form-urlencoded": [],
      json: [],
      jsonStr: "",
      xml: ""
    },
    Header: [{
      key: "",
      value: "",
      valueType: ValueTypeEnum.COUSTOM
    }],
    Params: {
      path: [],
      // 路径变量
      query: [{
        key: "",
        value: "",
        valueType: ValueTypeEnum.COUSTOM
      }]
      // 参数
    }
  },
  isBackend: !1
}, events = {
  baseEvent: {
    [BaseEvent.ON_CLICK]: {
      open: !0,
      customFunction: void 0,
      linkComponents: [],
      arguments: {},
      // 回调参数
      action: []
      // 交互动作
    },
    [BaseEvent.ON_DBL_CLICK]: {
      open: !1,
      customFunction: void 0,
      linkComponents: [],
      arguments: {},
      // 回调参数
      action: []
      // 交互动作
    },
    [BaseEvent.ON_MOUSE_MOVE]: {
      open: !1,
      customFunction: void 0,
      linkComponents: [],
      arguments: {},
      // 回调参数
      action: []
      // 交互动作
    },
    [BaseEvent.ON_MOUSE_ENTER]: {
      open: !1,
      customFunction: void 0,
      linkComponents: [],
      arguments: {},
      // 回调参数
      action: []
      // 交互动作
    },
    [BaseEvent.ON_MOUSE_LEAVE]: {
      open: !1,
      customFunction: void 0,
      linkComponents: [],
      arguments: {},
      // 回调参数
      action: []
      // 交互动作
    }
  },
  advancedEvents: {
    [EventLife.VNODE_BEFORE_MOUNT]: {
      open: !1,
      customFunction: void 0,
      arguments: {},
      // 回调参数
      action: []
      // 交互动作
    },
    [EventLife.VNODE_MOUNTED]: {
      open: !1,
      customFunction: void 0,
      arguments: {},
      // 回调参数
      action: []
      // 交互动作
    }
  },
  interactEvents: []
};
class PublicConfigClass {
  constructor() {
    Ra(this, "id", getUUID$1());
    Ra(this, "setAuth", !1);
    Ra(this, "hasGrant", !0);
    Ra(this, "isGroup", !1);
    // 是否是容器组件
    Ra(this, "isContainer", !1);
    // 基本信息
    Ra(this, "attr", { ...chartInitConfig, zIndex: -1 });
    // 基本样式
    Ra(this, "styles", {
      // 使用滤镜
      filterShow: !1,
      // 色相
      hueRotate: 0,
      // 饱和度
      saturate: 1,
      // 对比度
      contrast: 1,
      // 亮度
      brightness: 1,
      // 透明
      opacity: 1,
      // 旋转
      rotateZ: 0,
      rotateX: 0,
      rotateY: 0,
      // 倾斜
      skewX: 0,
      skewY: 0,
      // 混合模式
      blendMode: "normal",
      // 动画
      animations: []
    });
    // 预览
    Ra(this, "preview", {
      overFlowHidden: !1
    });
    // 状态
    Ra(this, "status", {
      lock: !1,
      hide: !1
    });
    // 请求
    Ra(this, "request", cloneDeep(requestConfig));
    // 接口数据回调
    Ra(this, "callback", {
      type: "link",
      // link 链接地址 page 大屏id components 组件
      condition: [],
      url: "",
      pageId: "",
      //大屏id,
      componentId: ""
      // 大屏组件id
    });
    Ra(this, "auth", []);
    //权限控制显示隐藏
    // 数据过滤
    Ra(this, "filter", []);
    // 事件
    Ra(this, "events", cloneDeep(events));
  }
}
class PublicGroupConfigClass extends PublicConfigClass {
  constructor() {
    super(...arguments);
    // 成组
    Ra(this, "isGroup", !0);
    // 容器
    Ra(this, "isContainer", !1);
    // 名称
    Ra(this, "chartConfig", {
      key: "group",
      chartKey: "group",
      conKey: "group",
      category: "group",
      categoryName: "group",
      package: "group",
      chartFrame: ChartFrameEnum.COMMON,
      title: groupTitle,
      image: ""
    });
    // 组成员列表
    Ra(this, "groupList", []);
    // ---- 原有 ---
    // key
    Ra(this, "key", "group");
    // 配置
    Ra(this, "option", {});
    // 标识
    Ra(this, "id", getUUID$1());
    // 基本信息
    Ra(this, "attr", {
      w: 0,
      h: 0,
      x: 0,
      y: 0,
      offsetX: 0,
      offsetY: 0,
      zIndex: -1,
      openScroll: !1,
      overflow: "visible",
      style: {
        backgroundImage: "",
        fit: "cover",
        backgroundColor: "",
        borderWidth: [0, 0, 0, 0],
        borderRadius: [0, 0, 0, 0],
        borderColor: "rgba(55, 106, 245, 1)",
        //边框颜色
        borderStyle: "solid",
        boxShadow: [0, 0, 0, 0, "rgba(0, 0, 0, .1)", "outset"]
      }
    });
    // 状态
    Ra(this, "status", {
      lock: !1,
      hide: !1
    });
    // 事件
    Ra(this, "events", {
      baseEvent: {
        [BaseEvent.ON_CLICK]: {
          open: !0,
          customFunction: void 0,
          arguments: {},
          linkComponents: [],
          action: []
        },
        [BaseEvent.ON_DBL_CLICK]: {
          open: !1,
          customFunction: void 0,
          arguments: {},
          linkComponents: [],
          action: []
        },
        [BaseEvent.ON_MOUSE_ENTER]: {
          open: !1,
          customFunction: void 0,
          arguments: {},
          linkComponents: [],
          action: []
        },
        [BaseEvent.ON_MOUSE_LEAVE]: {
          open: !1,
          customFunction: void 0,
          arguments: {},
          linkComponents: [],
          action: []
        }
      },
      customEvents: void 0,
      advancedEvents: {
        [EventLife.VNODE_MOUNTED]: {
          open: !1,
          customFunction: void 0,
          arguments: {},
          action: []
        },
        [EventLife.VNODE_BEFORE_MOUNT]: {
          open: !1,
          customFunction: void 0,
          arguments: {},
          action: []
        }
      },
      interactEvents: []
    });
    Ra(this, "auth", []);
  }
}
const useImportDesign = (_n, nr) => {
  const Cn = ref(), Bn = new PublicConfigClass(), In = new PublicGroupConfigClass(), Dn = (Pn, Un) => (Pn.forEach((Hn) => {
    if (Hn._class === "group" || Hn._class === "shapeGroup" || Hn._class === "artboard") {
      const zn = cloneDeep(In);
      if (zn.key = "group", zn.id = getUUID$1(), zn.attr.x = Hn.frame.x, zn.attr.y = Hn.frame.y, zn.attr.w = Hn.frame.width, zn.attr.h = Hn.frame.height, zn.chartConfig.title = Hn.name, Hn.layers) {
        const Gn = Hn.layers.filter((Yn) => Yn._class !== "group" && Yn._class !== "shapeGroup" && Yn._class !== "artboard");
        if (Gn && Gn.length > 0) {
          const Yn = [];
          let Wn = !1;
          if (Gn.forEach((Xn) => {
            Xn.hasClippingMask && (Wn = Xn.hasClippingMask);
          }), Gn.forEach((Xn) => {
            Wn && Yn.push({
              clippingMaskMode: Xn.clippingMaskMode,
              hasClippingMask: Xn.hasClippingMask,
              points: Xn.points,
              frame: Xn.frame,
              isVisible: Xn.isVisible,
              style: Xn.style,
              _class: Xn._class
            });
          }), Yn.length > 0) {
            const Xn = cloneDeep(Bn);
            Xn.id = getUUID$1(), Xn.key = "ShapeGroup", Xn.attr.x = 0, Xn.attr.y = 0, Xn.attr.w = Hn.frame.width, Xn.attr.h = Hn.frame.height, Xn.chartConfig.title = Hn.name, Xn.option.dataset = {
              layers: Yn,
              inGorup: !0
            }, zn.groupList = [Xn], zn.groupList = [Xn], Un.push(zn);
          } else
            Dn(Gn, zn.groupList), Un.push(zn);
        }
      }
    } else {
      let zn = cloneDeep(Bn);
      zn.id = getUUID$1(), zn.attr.x = Hn.frame.x, zn.attr.y = Hn.frame.y, zn.attr.w = Hn.frame.width, zn.attr.h = Hn.frame.height, Hn._class === "text" ? (zn.key = "TextCommon", zn.chartConfig.title = Hn.name, zn.option.dataset.text = Hn.attributedString.string, zn.option.fontColor = getSketchColorRgba(Hn.style.textStyle.encodedAttributes.MSAttributedStringColorAttribute), Hn.style.textStyle.encodedAttributes.MSAttributedStringFontAttribute && Hn.style.textStyle.encodedAttributes.MSAttributedStringFontAttribute.attributes ? (zn.option.fontSize = Hn.style.textStyle.encodedAttributes.MSAttributedStringFontAttribute.attributes.size || 16, zn.option.fontFamily = Hn.style.textStyle.encodedAttributes.MSAttributedStringFontAttribute.attributes.name) : zn.option.fontSize = 16, Un.push(zn)) : (Hn._class === "shapePath" || Hn._class === "rectangle") && (zn.key = "ShapePath", zn.chartConfig.title = Hn.name, zn.option.dataset = {
        points: Hn.points,
        style: Hn.style
      }, Un.push(zn));
    }
  }), Un);
  let Ln = [];
  const $n = (Pn, Un) => (Pn.forEach(async (Hn) => {
    if (Hn.name || (Hn.name = Un.name ? Un.name : Hn._class), Hn.isVisible === void 0 || Hn.isVisible) {
      const zn = cloneDeep(Hn);
      Hn._class === "group" || Hn._class === "shapeGroup" || Hn._class === "artboard" ? (Un && (Un._class === "group" || Hn._class === "shapeGroup" || Hn._class === "artboard") && (zn.frame.x = zn.frame.x + Un.frame.x, zn.frame.y = zn.frame.y + Un.frame.y), Ln.push(zn), await $n(zn.layers, zn)) : Un || Ln.push(zn);
    }
  }), Ln), Nn = async (Pn) => {
    const Un = Pn.layers[0], Hn = {
      editCanvasConfig: nr.editCanvasConfig,
      componentList: [],
      requestGlobalConfig: nr.requestGlobalConfig
    };
    if (Un) {
      Hn.editCanvasConfig.width = Un.frame.width, Hn.editCanvasConfig.height = Un.frame.height, Un.style.fills && Un.style.fills[0] && Un.style.fills[0].color && (Hn.editCanvasConfig.background = getSketchColorRgba(Un.style.fills[0].color)), Ln = [], console.log(Un);
      const zn = await $n(Un.layers);
      zn && (Hn.componentList = Dn(zn, []));
    }
    return Hn;
  };
  return {
    importDesignFileList: Cn,
    importDesignRequest: (Pn) => {
      const { file: Un } = Pn;
      nextTick(() => {
        if (Un) {
          const Hn = ElLoading.service({
            lock: !0,
            text: "正在导入中...",
            background: "rgba(255, 255, 255, 0.3)"
          });
          uploadDesign(_n.screenId, Un).then((zn) => {
            const { code: Gn, data: Yn } = zn, Wn = JSON.parse(Yn);
            Hn.close(), Gn === 200 && ElMessageBox.confirm(
              "请选择导入方式：",
              "提示",
              {
                distinguishCancelAndClose: !0,
                confirmButtonText: "新增（可撤回）",
                cancelButtonText: "覆盖（不可撤回）"
              }
            ).then(async () => {
              try {
                const Xn = ElLoading.service({ lock: !0, text: "正在导入中...", background: "rgba(255, 255, 255, 0.3)" }), ea = await Nn(Wn);
                Xn.close(), window.$message.success("导入成功！");
              } catch (Xn) {
                console.log(Xn), window.$message.error("组件导入失败，请检查文件完整性!");
              }
            }).catch(async () => {
              try {
                const Xn = ElLoading.service({ lock: !0, text: "正在导入中...", background: "rgba(255, 255, 255, 0.3)" }), ea = await Nn(Wn);
                Xn.close(), window.$message.success("导入成功！");
              } catch {
                window.$message.error("组件导入失败，请检查文件完整性!");
              }
            });
          });
        } else
          ElMessage.error("导入失败，请检查数据或联系管理员！");
      });
    },
    importDesignBeforeUpload: (Pn) => (Cn.value = [], Pn.name.indexOf(".sketch") === -1 ? (ElMessage.warning("仅支持上传 【sketch】 格式文件，请重新上传！"), !1) : !0)
  };
};
var EditCanvasTypeEnum = /* @__PURE__ */ ((_n) => (_n.EDIT_LAYOUT_DOM = "editLayoutDom", _n.EDIT_CONTENT_DOM = "editContentDom", _n.OFFSET = "offset", _n.SCALE = "scale", _n.USER_SCALE = "userScale", _n.LOCK_SCALE = "lockScale", _n.IS_CREATE = "isCreate", _n.IS_DRAG = "isDrag", _n.IS_SELECT = "isSelect", _n.IS_CODE_EDIT = "isCodeEdit", _n))(EditCanvasTypeEnum || {}), EditCanvasConfigEnum = /* @__PURE__ */ ((_n) => (_n.HAS_PERMS = "hasPerms", _n.CHECK_LOGIN = "checkLogin", _n.SET_AUTH = "setAuth", _n.PC_PAGE_ID = "pcPageId", _n.APP_PAGE_ID = "appPageId", _n.PROJECT_NAME = "projectName", _n.PROJECT_SUMMARY = "projectSummary", _n.PHOTO = "photo", _n.WIDTH = "width", _n.HEIGHT = "height", _n.CHART_THEME_COLOR = "chartThemeColor", _n.CHART_CUSTOM_THEME_COLOR_INFO = "chartCustomThemeColorInfo", _n.CHART_THEME_SETTING = "chartThemeSetting", _n.BACKGROUND = "background", _n.BACKGROUND_IMAGE = "backgroundImage", _n.BACKGROUND_FIT = "backgroundFit", _n.SELECT_COLOR = "selectColor", _n.PREVIEW_SCALE_TYPE = "previewScaleType", _n.NEED_LOGIN = "needLogin", _n.LOGIN_PAGE_ID = "loginPageId", _n.GROUPID = "groupId", _n.NODEID = "nodeId", _n.APPID = "appId", _n.ID = "id", _n.GLOBAL_VAR_LIST = "globalVarList", _n.CUSTOM_URL = "customUrl", _n))(EditCanvasConfigEnum || {}), ChartEditStoreEnum = /* @__PURE__ */ ((_n) => (_n.GLOBAL_EVENT = "globalEvent", _n.EDIT_RANGE = "editRange", _n.EDIT_CANVAS = "editCanvas", _n.RIGHT_MENU_SHOW = "rightMenuShow", _n.MOUSE_POSITION = "mousePosition", _n.TARGET_CHART = "targetChart", _n.RECORD_CHART = "recordChart", _n.EDIT_CANVAS_CONFIG = "editCanvasConfig", _n.REQUEST_GLOBAL_CONFIG = "requestGlobalConfig", _n.COMPONENT_LIST = "componentList", _n))(ChartEditStoreEnum || {});
const setComponentPosition = (_n, nr, Cn) => {
  nr && (_n.attr.x = nr), Cn && (_n.attr.y = Cn);
}, getUUID = (_n = 6) => "dms_" + Number(Math.random().toString().substring(2, _n) + Date.now()).toString(32);
var MouseEventButton = /* @__PURE__ */ ((_n) => (_n[_n.LEFT = 1] = "LEFT", _n[_n.RIGHT = 2] = "RIGHT", _n))(MouseEventButton || {}), DragKeyEnum = /* @__PURE__ */ ((_n) => (_n.DRAG_KEY = "ChartData", _n))(DragKeyEnum || {}), MenuEnum = /* @__PURE__ */ ((_n) => (_n.ARROW_UP = "up", _n.ARROW_RIGHT = "right", _n.ARROW_DOWN = "down", _n.ARROW_LEFT = "left", _n.DELETE = "delete", _n.COPY = "copy", _n.CUT = "cut", _n.PARSE = "parse", _n.TOP = "top", _n.BOTTOM = "bottom", _n.UP = "up", _n.DOWN = "down", _n.CLEAR = "clear", _n.GROUP = "group", _n.UN_GROUP = "unGroup", _n.BACK = "back", _n.FORWORD = "forward", _n.SAVE = "save", _n.LOCK = "lock", _n.UNLOCK = "unLock", _n.HIDE = "hide", _n.SHOW = "show", _n.TEMPLATE = "template", _n.REMOVEGROUP = "removeGroup", _n.ALL = "all", _n))(MenuEnum || {}), WinKeyboard = /* @__PURE__ */ ((_n) => (_n.CTRL = "ctrl", _n.SHIFT = "shift", _n.ALT = " alt", _n.CTRL_SOURCE_KEY = "control", _n.SHIFT_SOURCE_KEY = "shift", _n.ALT_SOURCE_KEY = "alt", _n.SPACE = "Space", _n))(WinKeyboard || {}), MacKeyboard = /* @__PURE__ */ ((_n) => (_n.CTRL = "⌘", _n.SHIFT = "⇧", _n.ALT = "⌥", _n.CTRL_SOURCE_KEY = "⌘", _n.SHIFT_SOURCE_KEY = "⇧", _n.ALT_SOURCE_KEY = "⌥", _n.SPACE = "Space", _n))(MacKeyboard || {});
function isString(_n) {
  return typeof _n == "string";
}
function isArray$3(_n) {
  return Array.isArray(_n);
}
var ToolsStatusEnum = /* @__PURE__ */ ((_n) => (_n.DOCK = "dock", _n.ASIDE = "aside", _n))(ToolsStatusEnum || {}), SettingStoreEnums = /* @__PURE__ */ ((_n) => (_n.HIDE_PACKAGE_ONE_CATEGORY = "hidePackageOneCategory", _n.CHANGE_LANG_RELOAD = "changeLangReload", _n.ASIDE_ALL_COLLAPSED = "asideAllCollapsed", _n.CHART_MOVE_DISTANCE = "chartMoveDistance", _n.CHART_ALIGN_RANGE = "chartAlignRange", _n.CHART_TOOLS_STATUS = "chartToolsStatus", _n.CHART_TOOLS_STATUS_HIDE = "chartToolsStatusHide", _n))(SettingStoreEnums || {});
const systemSetting = {
  // 侧边栏折叠是否隐藏全部
  [SettingStoreEnums.ASIDE_ALL_COLLAPSED]: !0,
  // 拖拽页面左侧表单分类只有一项的时候是否隐藏
  [SettingStoreEnums.HIDE_PACKAGE_ONE_CATEGORY]: !0,
  // 切换语言是否进行路由刷新
  [SettingStoreEnums.CHANGE_LANG_RELOAD]: !1,
  // 图表移动时按方向键移动的距离
  [SettingStoreEnums.CHART_MOVE_DISTANCE]: 5,
  // 图表拖拽时的吸附距离（px）
  [SettingStoreEnums.CHART_ALIGN_RANGE]: 10,
  // 图表工具栏状态（侧边工具状态）
  [SettingStoreEnums.CHART_TOOLS_STATUS]: ToolsStatusEnum.ASIDE,
  // 图表工具栏状态隐藏（刚开始不隐藏）
  [SettingStoreEnums.CHART_TOOLS_STATUS_HIDE]: !1
}, useSettingStore = defineStore("useSettingStore", {
  persist: !0,
  state: () => systemSetting,
  getters: {
    getHidePackageOneCategory() {
      return this.hidePackageOneCategory;
    },
    getChangeLangReload() {
      return this.changeLangReload;
    },
    getAsideAllCollapsed() {
      return this.asideAllCollapsed;
    },
    getAsideCollapsedWidth() {
      return this.asideAllCollapsed ? 0 : asideCollapsedWidth;
    },
    getChartMoveDistance() {
      return this.chartMoveDistance;
    },
    getChartAlignRange() {
      return this.chartAlignRange;
    },
    getChartToolsStatus() {
      return this.chartToolsStatus;
    },
    getChartToolsStatusHide() {
      return this.chartToolsStatusHide;
    }
  },
  actions: {
    setItem(_n, nr) {
      this.$patch((Cn) => {
        Cn[_n] = nr;
      });
    }
  }
}), layoutStore = useLayoutStore(), historyStore = useHistoryStore(), settingStore = useSettingStore(), useChartEditStore = defineStore("chartEditStore", {
  state: () => ({
    // 画布属性
    editCanvas: {
      // 编辑区域 Dom
      editLayoutDom: null,
      editContentDom: null,
      // 偏移量
      offset: 20,
      // 系统控制缩放
      scale: 1,
      // 用户控制的缩放
      userScale: 1,
      // 锁定缩放
      lockScale: !1,
      // 初始化
      isCreate: !1,
      // 拖拽中
      isDrag: !1,
      // 框选中
      isSelect: !1,
      // 代码编辑中
      isCodeEdit: !1
    },
    // 右键菜单
    rightMenuShow: !1,
    // 模板
    templateShow: !1,
    templateContentJson: {},
    // 鼠标定位
    mousePosition: {
      startX: 0,
      startY: 0,
      x: 0,
      y: 0
    },
    // 目标图表
    targetChart: {
      hoverId: void 0,
      selectId: []
    },
    // 记录临时数据（复制等）
    recordChart: void 0,
    // 画布属性（需存储给后端）
    editCanvasConfig: {
      hasPerms: !0,
      checkLogin: !0,
      publishStatus: 0,
      // 发布状态
      globalVarList: [],
      // 全局变量
      // 项目名称
      projectName: "",
      setAuth: !1,
      projectSummary: "",
      photo: "",
      // 默认宽度
      width: 1920,
      // 默认高度
      height: 1080,
      // 启用滤镜
      filterShow: !1,
      // 色相
      hueRotate: 0,
      // 饱和度
      saturate: 1,
      // 对比度
      contrast: 1,
      // 亮度
      brightness: 1,
      // 透明度
      opacity: 1,
      // 变换（暂不更改）
      rotateZ: 0,
      rotateX: 0,
      rotateY: 0,
      skewX: 0,
      skewY: 0,
      // 混合模式
      blendMode: "normal",
      // 默认背景色
      background: "rgba(255,255,255,1)",
      backgroundImage: void 0,
      backgroundFit: "cover",
      // 是否使用纯颜色
      selectColor: !0,
      // chart 主题色
      chartThemeColor: defaultTheme,
      // 自定义颜色列表
      chartCustomThemeColorInfo: void 0,
      // 全局配置
      chartThemeSetting: globalThemeJson,
      // 适配方式
      previewScaleType,
      // 大屏是否需要登录
      needLogin: 0,
      loginPageId: void 0,
      // 登录跳转大屏页面
      pcPageId: void 0,
      appPageId: void 0,
      groupId: 0,
      // 分组id
      id: 0,
      // 大屏id
      nodeId: 0,
      // 节点id
      customUrl: ""
      // 自定义url
    },
    globalEvent: {
      onMounted: {
        open: !1,
        customFunction: void 0,
        eventName: "页面挂载完成",
        arguments: {},
        action: []
      },
      onUnmounted: {
        open: !1,
        customFunction: void 0,
        eventName: "页面销毁完成",
        arguments: {},
        action: []
      }
    },
    // 数据请求处理（需存储给后端）
    requestGlobalConfig: {
      requestDataPond: [],
      requestOriginUrl: "",
      requestInterval: 30,
      requestIntervalUnit: RequestHttpIntervalEnum.SECOND,
      requestParams: {
        Body: {
          "form-data": [],
          "x-www-form-urlencoded": [],
          json: [],
          jsonStr: "",
          xml: ""
        },
        Header: [],
        Params: {
          path: [],
          // 路径变量
          query: []
          // 参数
        }
      }
    },
    // 图表数组（需存储给后端）
    componentList: []
  }),
  getters: {
    getMousePosition() {
      return this.mousePosition;
    },
    getRightMenuShow() {
      return this.rightMenuShow;
    },
    getTemplateShow() {
      return this.templateShow;
    },
    getEditCanvas() {
      return this.editCanvas;
    },
    getGlobalEvent() {
      return this.globalEvent;
    },
    getEditCanvasConfig() {
      return this.editCanvasConfig;
    },
    getTargetChart() {
      return this.targetChart;
    },
    getRecordChart() {
      return this.recordChart;
    },
    getRequestGlobalConfig() {
      return this.requestGlobalConfig;
    },
    getComponentList() {
      return this.componentList;
    },
    // 获取需要存储的数据项
    getStorageInfo() {
      return {
        [ChartEditStoreEnum.EDIT_CANVAS_CONFIG]: this.getEditCanvasConfig,
        [ChartEditStoreEnum.COMPONENT_LIST]: this.getComponentList,
        [ChartEditStoreEnum.GLOBAL_EVENT]: this.getGlobalEvent,
        [ChartEditStoreEnum.REQUEST_GLOBAL_CONFIG]: this.getRequestGlobalConfig
      };
    }
  },
  actions: {
    // * 设置 editCanvas 数据项
    setEditCanvas(_n, nr) {
      this.editCanvas[_n] = nr;
    },
    // 设置页面事件
    setGlobalEvent(_n, nr) {
      return this.globalEvent[_n] = nr;
    },
    // * 设置 editCanvasConfig（需保存后端） 数据项
    setEditCanvasConfig(_n, nr) {
      this.editCanvasConfig[_n] = nr;
    },
    // * 设置右键菜单
    setRightMenuShow(_n) {
      this.rightMenuShow = _n;
    },
    // * 设置目标数据 hover
    setTargetHoverChart(_n) {
      this.targetChart.hoverId = _n;
    },
    // * 设置目标数据 select
    setTargetSelectChart(_n, nr = !1, Cn) {
      if (this.targetChart.clickType = Cn, !this.targetChart.selectId.find((Bn) => Bn === _n)) {
        if (!_n) {
          this.targetChart.selectId = [];
          return;
        }
        if (layoutStore.setAppPage(!1), nr) {
          if (isString(_n)) {
            this.targetChart.selectId.push(_n);
            return;
          }
          if (isArray$3(_n)) {
            this.targetChart.selectId.push(..._n);
            return;
          }
        } else {
          if (isString(_n)) {
            this.targetChart.selectId = [_n];
            return;
          }
          if (isArray$3(_n)) {
            this.targetChart.selectId = _n;
            return;
          }
        }
      }
    },
    // * 设置记录数据
    setRecordChart(_n) {
      this.recordChart = cloneDeep(_n);
    },
    // * 设置鼠标位置
    setMousePosition(_n, nr, Cn, Bn) {
      _n && (this.mousePosition.x = _n), nr && (this.mousePosition.y = nr), Cn && (this.mousePosition.startX = Cn), Bn && (this.mousePosition.startY = Bn);
    },
    // * 找到目标 id 数据的下标位置，id可为父级或子集数组（无则返回-1）
    fetchTargetIndex(_n) {
      const nr = _n || this.getTargetChart.selectId.length && this.getTargetChart.selectId[0] || void 0;
      if (!nr)
        return -1;
      const Cn = this.componentList.findIndex((Bn) => Bn.id === nr);
      if (Cn !== -1)
        return Cn;
      {
        const Bn = this.getComponentList.length;
        for (let In = 0; In < Bn; In++)
          if (this.getComponentList[In].isGroup || this.getComponentList[In].isTemplate) {
            for (const Dn of this.getComponentList[In].groupList)
              if (Dn.id === nr)
                return In;
          } else if (this.getComponentList[In].key === "Page")
            for (const Dn of this.getComponentList[In].componentList) {
              if (Dn.id === nr)
                return In;
              if (Dn.isGroup || Dn.isTemplate) {
                for (const Ln of Dn.groupList)
                  if (Ln.id === nr)
                    return In;
              }
            }
      }
      return -1;
    },
    // * 统一格式化处理入参 id
    idPreFormat(_n) {
      const nr = [];
      return _n ? (isString(_n) && nr.push(_n), isArray$3(_n) && nr.push(..._n), nr) : (nr.push(...this.getTargetChart.selectId), nr);
    },
    /**
     * * 新增组件列表
     * @param componentInstance 新图表实例
     * @param isHead 是否头部插入
     * @param isHistory 是否进行记录
     * @returns
     */
    addComponentList(_n, nr = !1, Cn = !1) {
      if (_n instanceof Array) {
        _n.forEach((Bn) => {
          this.addComponentList(Bn, nr, Cn);
        });
        return;
      }
      if (Cn && (_n instanceof Array ? historyStore.createAddHistory(_n) : historyStore.createAddHistory([_n])), nr) {
        this.componentList.unshift(_n);
        return;
      }
      this.componentList.push(_n);
    },
    getComponentById(_n) {
      const nr = (Cn) => {
        for (let Bn = 0; Bn < Cn.length; Bn++) {
          const In = Cn[Bn];
          if (In.id === _n)
            return In;
          if (In.groupList)
            return nr(In.groupList);
          if (In.componentList)
            return nr(In.componentList);
        }
      };
      return nr(this.getComponentList);
    },
    // * 删除组件
    removeComponentList(_n, nr = !0) {
      try {
        const Cn = this.idPreFormat(_n), Bn = [];
        if (!Cn.length)
          return;
        Cn.forEach((In) => {
          const Dn = this.fetchTargetIndex(In);
          if (Dn !== -1)
            if (this.getComponentList[Dn].id === In)
              Bn.push(this.getComponentList[Dn]), this.componentList.splice(Dn, 1);
            else {
              const Ln = this.getComponentList[Dn], $n = Ln.groupList.findIndex((Nn) => Nn.id === In);
              Bn.push(this.getComponentList[Dn]), Ln.groupList.splice($n, 1);
            }
        }), nr && historyStore.createDeleteHistory(Bn);
        return;
      } catch (Cn) {
        console.log(Cn);
      }
    },
    // * 重置组件位置
    resetComponentPosition(_n, nr) {
      const Cn = this.fetchTargetIndex(_n.id);
      if (Cn > -1) {
        const Bn = this.getComponentList[Cn];
        nr ? Bn.attr = Object.assign(Bn.attr, {
          x: _n.attr.x + _n.attr.offsetX,
          y: _n.attr.y + _n.attr.offsetY
        }) : Bn.attr = Object.assign(Bn.attr, {
          x: _n.attr.x,
          y: _n.attr.y
        });
      }
    },
    // * 移动组件
    moveComponentList(_n) {
      historyStore.createMoveHistory(_n);
    },
    // * 更新组件列表某一项的值
    updateComponentList(_n, nr) {
      _n < 1 && _n > this.getComponentList.length || (this.componentList[_n] = nr);
    },
    // * 设置页面样式属性
    setPageStyle(_n, nr) {
      const Cn = this.getEditCanvas.editContentDom;
      Cn && (Cn.style[_n] = nr);
    },
    // * 移动组件列表层级位置到两端
    setBothEnds(_n = !1, nr = !0) {
      try {
        if (this.getTargetChart.selectId.length > 1)
          return;
        const Cn = this.getComponentList.length;
        if (Cn < 2)
          return;
        const Bn = this.fetchTargetIndex(), In = this.getComponentList[Bn];
        if (Bn !== -1) {
          let Dn = this.getTargetChart.selectId[0], Ln = -1;
          if (In.groupList && (Ln = In.groupList.findIndex((Nn) => Nn.id === Dn)), In.id === Dn) {
            if (_n && Bn === 0 || !_n && Bn === Cn - 1)
              return;
          } else {
            const Nn = In.groupList.length;
            if (_n && Ln === 0 || !_n && Ln === Nn - 1)
              return;
            _n ? In.groupList.unshift(cloneDeep(In.groupList[Ln])) : In.groupList.push(cloneDeep(In.groupList[Ln])), In.groupList.splice(_n ? Ln + 1 : Ln, 1);
          }
          const $n = (Nn, Rn) => {
            const Fn = cloneDeep(Nn);
            return Fn.attr.zIndex = Rn, Fn;
          };
          nr && historyStore.createLayerHistory(
            [$n(In, Bn)],
            _n ? HistoryActionTypeEnum.BOTTOM : HistoryActionTypeEnum.TOP
          ), In.id === Dn && (this.addComponentList(In, _n), this.getComponentList.splice(_n ? Bn + 1 : Bn, 1));
          return;
        }
      } catch {
      }
    },
    // * 置顶
    setTop(_n = !0) {
      this.setBothEnds(!1, _n);
    },
    // * 置底
    setBottom(_n = !0) {
      this.setBothEnds(!0, _n);
    },
    // * 设置为模板
    setTemplate() {
      const _n = this.fetchTargetIndex(), nr = cloneDeep(this.getComponentList[_n]);
      nr.id = getUUID(), nr.isGroup && nr.groupList.forEach((Cn) => {
        Cn.id = getUUID();
      }), this.templateContentJson = nr, this.templateShow = !0;
    },
    //取消模板
    closeTemplate() {
      this.templateShow = !1;
    },
    // * 上移/下移互换图表位置
    wrap(_n = !1, nr = !0) {
      try {
        if (this.getTargetChart.selectId.length > 1)
          return;
        const Cn = this.getComponentList.length;
        if (Cn < 2)
          return;
        const Bn = this.fetchTargetIndex();
        if (Bn !== -1) {
          let In = this.getTargetChart.selectId[0];
          const Dn = this.getComponentList[Bn];
          let Ln = -1;
          if (Dn.groupList && (Ln = Dn.groupList.findIndex(($n) => $n.id === In)), Dn.id === In) {
            if (_n && Bn === 0 || !_n && Bn === Cn - 1)
              return;
          } else {
            const $n = Dn.groupList.length;
            if (_n && Ln === 0 || !_n && Ln === $n - 1)
              return;
          }
          if (Ln > -1) {
            const $n = _n ? Ln - 1 : Ln + 1, Nn = Dn.groupList[Ln], Rn = Dn.groupList[$n];
            nr && historyStore.createLayerHistory(
              [Nn],
              _n ? HistoryActionTypeEnum.DOWN : HistoryActionTypeEnum.UP
            ), Dn.groupList[Ln] = Rn, Dn.groupList[$n] = Nn, this.updateComponentList(Bn, Dn);
            return;
          } else {
            const $n = _n ? Bn - 1 : Bn + 1, Nn = this.getComponentList[Bn], Rn = this.getComponentList[$n];
            nr && historyStore.createLayerHistory(
              [Nn],
              _n ? HistoryActionTypeEnum.DOWN : HistoryActionTypeEnum.UP
            ), this.updateComponentList(Bn, Rn), this.updateComponentList($n, Nn);
            return;
          }
        }
      } catch (Cn) {
        console.log("wrapcatch", Cn);
      }
    },
    // * 图层上移
    setUp(_n = !0) {
      this.wrap(!1, _n);
    },
    // * 图层下移
    setDown(_n = !0) {
      this.wrap(!0, _n);
    },
    // * 复制
    setCopy(_n = !1) {
      try {
        if (this.getTargetChart.selectId.length > 1 || document.getElementsByClassName("n-modal-body-wrapper").length)
          return;
        const nr = this.fetchTargetIndex();
        if (nr !== -1) {
          const Cn = {
            charts: this.getComponentList[nr],
            type: _n ? HistoryActionTypeEnum.CUT : HistoryActionTypeEnum.COPY
          };
          this.setRecordChart(Cn), ElMessage.success(_n ? "剪切图表成功" : "复制图表成功！");
        }
      } catch (nr) {
        console.log("copy", nr);
      }
    },
    // * 剪切
    setCut() {
      this.setCopy(!0);
    },
    // * 粘贴
    setParse() {
      try {
        const _n = this.getRecordChart;
        if (_n === void 0)
          return;
        const nr = (In) => (In = cloneDeep(In), In.attr.x = this.getMousePosition.x + 30, In.attr.y = this.getMousePosition.y + 30, In.id = getUUID(), In.isGroup && In.groupList.forEach((Dn) => {
          Dn.id = getUUID();
        }), In), Cn = _n.type === HistoryActionTypeEnum.CUT;
        (Array.isArray(_n.charts) ? _n.charts : [_n.charts]).forEach((In) => {
          this.addComponentList(nr(In), void 0, !0), Cn && (this.setTargetSelectChart(In.id), this.removeComponentList(void 0, !0));
        }), Cn && this.setRecordChart(void 0);
      } catch {
      }
    },
    // * 撤回/前进 目标处理
    setBackAndSetForwardHandle(_n, nr = !1) {
      if (_n.targetType === HistoryTargetTypeEnum.CANVAS) {
        this.editCanvas = _n.historyData[0];
        return;
      }
      this.setTargetSelectChart();
      let Cn = _n.historyData;
      isArray$3(Cn) && Cn.forEach((Yn) => {
        this.setTargetSelectChart(Yn.id, !0);
      });
      const Bn = _n.actionType === HistoryActionTypeEnum.ADD, In = _n.actionType === HistoryActionTypeEnum.DELETE;
      if (Bn || In) {
        if (Bn && nr || In && !nr) {
          Cn.forEach((Yn) => {
            this.addComponentList(Yn);
          });
          return;
        }
        Cn.forEach((Yn) => {
          this.removeComponentList(Yn.id, !1);
        });
        return;
      }
      if (_n.actionType === HistoryActionTypeEnum.MOVE) {
        Cn.forEach((Yn) => {
          this.resetComponentPosition(Yn, nr);
        });
        return;
      }
      const Ln = _n.actionType === HistoryActionTypeEnum.TOP, $n = _n.actionType === HistoryActionTypeEnum.BOTTOM;
      if (Ln || $n) {
        if (!nr) {
          Ln && this.getComponentList.pop(), $n && this.getComponentList.shift(), this.getComponentList.splice(Cn[0].attr.zIndex, 0, Cn[0]);
          return;
        }
        Ln && this.setTop(!1), $n && this.setBottom(!1);
      }
      const Nn = _n.actionType === HistoryActionTypeEnum.UP, Rn = _n.actionType === HistoryActionTypeEnum.DOWN;
      if (Nn || Rn) {
        if (Nn && nr || Rn && !nr) {
          this.setUp(!1);
          return;
        }
        this.setDown(!1);
        return;
      }
      const Fn = _n.actionType === HistoryActionTypeEnum.GROUP, Pn = _n.actionType === HistoryActionTypeEnum.UN_GROUP;
      if (Fn || Pn) {
        if (Fn && nr || Pn && !nr) {
          const Yn = [];
          Cn.length > 1 ? Cn.forEach((Wn) => {
            Yn.unshift(Wn.id);
          }) : Cn[0].groupList.forEach((Xn) => {
            Yn.unshift(Xn.id);
          }), this.setGroup(Yn, !1);
          return;
        }
        Cn.length > 1 ? this.setUnGroup([Cn[0].id], void 0, !1) : this.setUnGroup([Cn[0].groupList[0].id], void 0, !1);
        return;
      }
      const Un = _n.actionType === HistoryActionTypeEnum.LOCK, Hn = _n.actionType === HistoryActionTypeEnum.UNLOCK;
      if (Un || Hn) {
        if (Un && nr || Hn && !nr) {
          Cn.forEach((Yn) => {
            this.setLock(!Yn.status.lock, !1);
          });
          return;
        }
        Cn.forEach((Yn) => {
          this.setUnLock(!1);
        });
        return;
      }
      const zn = _n.actionType === HistoryActionTypeEnum.HIDE, Gn = _n.actionType === HistoryActionTypeEnum.SHOW;
      if (zn || Gn) {
        if (zn && nr || Gn && !nr) {
          Cn.forEach((Yn) => {
            this.setHide(!Yn.status.hide, !1);
          });
          return;
        }
        Cn.forEach((Yn) => {
          this.setShow(!1);
        });
        return;
      }
    },
    // * 撤回
    setBack() {
      try {
        const _n = historyStore.backAction();
        if (!_n)
          return;
        this.setBackAndSetForwardHandle(_n);
      } catch (_n) {
        console.log(_n);
      }
    },
    // * 前进
    setForward() {
      try {
        const _n = historyStore.forwardAction();
        if (!_n)
          return;
        this.setBackAndSetForwardHandle(_n, !0);
      } catch {
      }
    },
    // * 移动位置
    setMove(_n) {
      const nr = this.fetchTargetIndex();
      if (nr === -1)
        return;
      const Cn = this.getComponentList[nr].attr, Bn = settingStore.getChartMoveDistance;
      switch (_n) {
        case MenuEnum.ARROW_UP:
          Cn.y -= Bn;
          break;
        case MenuEnum.ARROW_RIGHT:
          Cn.x += Bn;
          break;
        case MenuEnum.ARROW_DOWN:
          Cn.y += Bn;
          break;
        case MenuEnum.ARROW_LEFT:
          Cn.x -= Bn;
          break;
      }
    },
    // * 创建分组
    setGroup(_n, nr = !0) {
      try {
        const Cn = this.idPreFormat(_n) || this.getTargetChart.selectId;
        if (Cn.length < 2)
          return;
        const Bn = new PublicGroupConfigClass(), In = {
          l: this.getEditCanvasConfig.width,
          t: this.getEditCanvasConfig.height,
          r: 0,
          b: 0
        }, Dn = [], Ln = [], $n = [];
        Cn.forEach((Nn) => {
          const Rn = this.fetchTargetIndex(Nn);
          Rn !== -1 && this.getComponentList[Rn].isGroup ? (Bn.id = Nn, Bn.chartConfig.title = this.getComponentList[Rn].chartConfig.title, this.setUnGroup(
            [Nn],
            (Fn) => {
              Fn.forEach((Pn) => {
                this.addComponentList(Pn), $n.push(Pn.id);
              });
            },
            !1
          )) : Rn !== -1 && $n.push(Nn);
        }), $n.forEach((Nn) => {
          const Rn = this.componentList.splice(this.fetchTargetIndex(Nn), 1)[0], { x: Fn, y: Pn, w: Un, h: Hn } = Rn.attr, { l: zn, t: Gn, r: Yn, b: Wn } = In;
          In.l = zn > Fn ? Fn : zn, In.t = Gn > Pn ? Pn : Gn, In.r = Yn < Fn + Un ? Fn + Un : Yn, In.b = Wn < Pn + Hn ? Pn + Hn : Wn, Dn.push(Rn), Ln.push(toRaw(Rn));
        }), nr && historyStore.createGroupHistory(Ln), Dn.forEach((Nn) => {
          Nn.attr.x = Nn.attr.x - In.l, Nn.attr.y = Nn.attr.y - In.t, Nn.innerGroup = !0, Bn.groupList.push(Nn);
        }), Bn.attr.x = In.l, Bn.attr.y = In.t, Bn.attr.w = In.r - In.l, Bn.attr.h = In.b - In.t, this.addComponentList(Bn), this.setTargetSelectChart(void 0);
      } catch {
        ElMessage.error("创建分组失败，请联系管理员！");
      }
    },
    // 移出分组
    setRemoveGroup(_n, nr, Cn = !0) {
      try {
        const Bn = _n || this.getTargetChart.selectId;
        if (Bn.length !== 1)
          return;
        const In = (Ln) => {
          const $n = this.getComponentList[Ln];
          $n.isGroup && (Cn && historyStore.createRemoveGroupHistory(cloneDeep([$n])), $n.groupList.forEach((Nn) => {
            Nn.id === Bn[0] && (Nn.attr.x = Nn.attr.x + $n.attr.x, Nn.attr.y = Nn.attr.y + $n.attr.y, Nn.innerGroup = !1, this.removeComponentList(Nn.id, !1), nr && nr($n.groupList), nr || this.addComponentList(Nn));
          }), this.setTargetSelectChart($n.id));
        }, Dn = this.fetchTargetIndex(Bn[0]);
        Dn !== -1 && In(Dn);
      } catch {
        ElMessage.error("移出分组失败，请联系管理员！");
      }
    },
    // * 解除分组
    setUnGroup(_n, nr, Cn = !0) {
      try {
        const Bn = _n || this.getTargetChart.selectId;
        if (Bn.length !== 1)
          return;
        const In = (Ln) => {
          const $n = this.getComponentList[Ln];
          $n.isGroup && (Cn && historyStore.createUnGroupHistory(cloneDeep([$n])), $n.groupList.forEach((Nn) => {
            Nn.attr.x = Nn.attr.x + $n.attr.x, Nn.attr.y = Nn.attr.y + $n.attr.y, Nn.innerGroup = !1, nr || this.addComponentList(Nn);
          }), this.setTargetSelectChart($n.id), this.removeComponentList($n.id, !1), nr && nr($n.groupList));
        }, Dn = this.fetchTargetIndex(Bn[0]);
        Dn !== -1 && In(Dn);
      } catch {
        ElMessage.error("解除分组失败，请联系管理员！");
      }
    },
    // * 锁定
    setLock(_n, nr = !0, Cn = !0) {
      try {
        const Bn = this.getComponentById(_n);
        Bn && (Bn.status.lock = nr, Cn && (nr ? historyStore.createLockHistory([Bn]) : historyStore.createUnLockHistory([Bn])), nr && this.setTargetSelectChart(void 0));
      } catch (Bn) {
        console.log("setLockcatch", Bn);
      }
    },
    // * 解除锁定
    setUnLock(_n, nr = !0) {
      this.setLock(_n, !1, nr);
    },
    // * 隐藏
    setHide(_n, nr = !0, Cn = !0) {
      try {
        const Bn = this.getComponentById(_n);
        Bn && (Bn.status.hide = nr, Cn && (nr ? historyStore.createHideHistory([Bn]) : historyStore.createShowHistory([Bn])), nr && this.setTargetSelectChart(void 0));
      } catch (Bn) {
        console.log("setHidecatch", Bn);
      }
    },
    // * 显示
    setShow(_n, nr = !0) {
      this.setHide(_n, !1, nr);
    },
    // ----------------
    // * 设置页面大小
    setPageSize(_n) {
      this.setPageStyle("height", `${this.editCanvasConfig.height * _n}px`), this.setPageStyle("width", `${this.editCanvasConfig.width * _n}px`);
    },
    // * 计算缩放
    computedScale() {
      const _n = this.getEditCanvas[EditCanvasTypeEnum.EDIT_LAYOUT_DOM];
      if (_n) {
        const nr = _n.clientWidth - 40, Cn = _n.clientHeight - 40, Bn = this.editCanvasConfig.width, In = this.editCanvasConfig.height, Dn = parseFloat((Bn / In).toFixed(5));
        if (parseFloat((nr / Cn).toFixed(5)) > Dn) {
          const $n = parseFloat((Cn * Dn / Bn).toFixed(5));
          this.setScale($n > 1 ? 1 : $n);
        } else {
          const $n = parseFloat((nr / Dn / In).toFixed(5));
          this.setScale($n > 1 ? 1 : $n);
        }
      } else
        ElMessage.warning("请先创建画布，再进行缩放");
    },
    // * 监听缩放
    listenerScale() {
      const _n = debounce$1(this.computedScale, 200);
      return _n(), window.addEventListener("resize", _n), () => {
        window.removeEventListener("resize", _n);
      };
    },
    /**
     * * 设置缩放
     * @param scale 0~1 number 缩放比例;
     * @param force boolean 强制缩放
     */
    setScale(_n, nr = !1) {
      (!this.getEditCanvas.lockScale || nr) && (this.getEditCanvas.userScale = _n, this.getEditCanvas.scale = _n);
    }
  }
});
ResultEnum.NOT_FOUND, ResultEnum.SERVER_FORBIDDEN, ResultEnum.SERVER_ERROR;
const accountId = window.heyCloudAccountId, get$1 = (_n, nr, Cn) => {
  let Bn = {
    "x-heycloud-account-id": accountId,
    "Content-Type": ContentTypeEnum.JSON
  };
  return Cn && (Bn = Object.assign(Bn, Cn)), axiosInstance({
    url: _n,
    method: RequestHttpEnum.GET,
    params: nr,
    headers: Bn
  });
}, post = (_n, nr, Cn) => {
  let Bn = {
    "x-heycloud-account-id": accountId,
    "Content-Type": ContentTypeEnum.JSON
  };
  return Cn && (Bn = Object.assign(Bn, Cn)), axiosInstance({
    url: _n,
    method: RequestHttpEnum.POST,
    data: nr,
    headers: Bn
  });
}, prefix = "javascript:", translateStr = (_n) => {
  if (typeof _n == "string")
    if (_n.startsWith(prefix)) {
      const nr = _n.split(prefix)[1];
      let Cn;
      try {
        Cn = new Function(`${nr}`)();
      } catch {
        window.$message.error("js内容解析有误！");
      }
      return Cn;
    } else
      return _n;
  for (const nr in _n)
    if (Object.prototype.hasOwnProperty.call(_n, nr)) {
      const Cn = _n[nr];
      _n[nr] = translateStr(Cn);
    }
  return _n;
}, customizeHttp = (_n, nr) => {
  if (!_n || !nr)
    return;
  const {
    // 全局请求源地址
    requestOriginUrl: Cn,
    // 全局请求内容
    requestParams: Bn
  } = nr, {
    // 请求地址
    requestUrl: In,
    // 普通 / sql
    requestContentType: Dn,
    // 获取数据的方式
    requestDataType: Ln,
    // 请求方式 get/post/del/put/patch
    requestHttpType: $n,
    // 请求体类型 none / form-data / x-www-form-urlencoded / json /xml
    requestParamsBodyType: Nn,
    // SQL 请求对象
    requestSQLContent: Rn,
    // 请求内容 params / cookie / header / body: 同 requestParamsBodyType
    requestParams: Fn
  } = _n;
  if (Ln === RequestDataTypeEnum.STATIC || !In)
    return;
  let Pn = {
    ...Bn.Header,
    ...Fn.Header
  };
  Pn = translateStr(Pn);
  let Un = {}, Hn = { ...Fn.Params };
  Hn = translateStr(Hn);
  let zn = new FormData();
  switch (Nn) {
    case RequestBodyEnum.NONE:
      break;
    case RequestBodyEnum.JSON:
      Pn["Content-Type"] = ContentTypeEnum.JSON, Un = translateStr(Fn.Body.json), typeof Un == "string" && (Un = JSON.parse(Un));
      break;
    case RequestBodyEnum.XML:
      Pn["Content-Type"] = ContentTypeEnum.XML, Un = translateStr(Fn.Body.xml);
      break;
    case RequestBodyEnum.X_WWW_FORM_URLENCODED: {
      Pn["Content-Type"] = ContentTypeEnum.FORM_URLENCODED;
      const Gn = Fn.Body["x-www-form-urlencoded"];
      for (const Yn in Gn)
        zn.set(Yn, translateStr(Gn[Yn]));
      Un = zn;
      break;
    }
    case RequestBodyEnum.FORM_DATA: {
      Pn["Content-Type"] = ContentTypeEnum.FORM_DATA;
      const Gn = Fn.Body["form-data"];
      for (const Yn in Gn)
        zn.set(Yn, translateStr(Gn[Yn]));
      Un = zn;
      break;
    }
  }
  Dn === RequestContentTypeEnum.SQL && (Pn["Content-Type"] = ContentTypeEnum.JSON, Un = Rn);
  try {
    const Gn = new Function("return `" + `${Cn}${In}`.trim() + "`")();
    return axiosInstance({
      url: Gn,
      method: $n,
      data: Un,
      params: Hn,
      headers: Pn
    });
  } catch {
    window.$message.error("URL地址格式有误！");
  }
};
function testConnect(_n) {
  return axiosInstance({
    url: "/dms/dataSource/testConnect",
    data: _n
  });
}
function getCurrentUserInfo(_n) {
  return get$1("/dms/user/currentUserInfo", null, _n);
}
function logout() {
  return get$1("/dms/logout");
}
defineStore("useUserStore", {
  state: () => ({
    token: "",
    userInfo: null
  }),
  getters: {
    getToken() {
      let _n = this.token;
      return _n || (_n = getLocalStorage("token")), _n;
    },
    getUserInfo() {
      return this.userInfo;
    }
  },
  actions: {
    setUserInfo(_n) {
      _n && setLocalStorage("userInfo", JSON.stringify(_n)), this.userInfo = _n;
    },
    setToken(_n) {
      setLocalStorage("token", _n), this.token = _n;
    },
    // 获取信息(用户昵称、头像、角色集合、权限集合)
    getInfo() {
      const _n = this;
      return new Promise((nr, Cn) => {
        getCurrentUserInfo().then((Bn) => {
          const { code: In, data: Dn, msg: Ln } = Bn;
          return Dn.roles || (Dn.roles = [{
            id: 1,
            name: "admin",
            remark: "拥有所有权限",
            createDate: null,
            modifyDate: null,
            projectId: 1,
            preset: 0,
            code: "admin",
            groupId: null,
            groupName: null,
            catalogId: null,
            hasPerms: !1,
            permsId: null,
            menu: []
          }]), In === 200 ? (_n.setToken(Dn.token), _n.userInfo = Dn, nr(Dn)) : (_n.resetToken(), resetRouter(), nr("登录过期，请重新登录"));
        }).catch((Bn) => (_n.resetToken(), resetRouter(), nr("登录过期，请重新登录")));
      });
    },
    resetToken() {
      this.userInfo = null, this.token = "", setLocalStorage("token", ""), clearLocalStorage(StorageEnum.DMS_LOGIN_INFO_STORE), localStorage.removeItem("token"), localStorage.removeItem("userInfo"), localStorage.removeItem("appCategoryId"), localStorage.removeItem("appExpandedKeys"), getLocalStorage("autoLogin") || (localStorage.removeItem("userName"), localStorage.removeItem("password"));
    },
    logout() {
      this.resetToken();
    }
  }
});
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(_n, nr) {
  if (_n === "__proto__" || _n === "constructor" && nr && typeof nr == "object" && "prototype" in nr) {
    warnKeyDropped(_n);
    return;
  }
  return nr;
}
function warnKeyDropped(_n) {
  console.warn(`[destr] Dropping "${_n}" key to prevent prototype pollution.`);
}
function destr(_n, nr = {}) {
  if (typeof _n != "string")
    return _n;
  if (_n[0] === '"' && _n[_n.length - 1] === '"' && _n.indexOf("\\") === -1)
    return _n.slice(1, -1);
  const Cn = _n.trim();
  if (Cn.length <= 9)
    switch (Cn.toLowerCase()) {
      case "true":
        return !0;
      case "false":
        return !1;
      case "undefined":
        return;
      case "null":
        return null;
      case "nan":
        return Number.NaN;
      case "infinity":
        return Number.POSITIVE_INFINITY;
      case "-infinity":
        return Number.NEGATIVE_INFINITY;
    }
  if (!JsonSigRx.test(_n)) {
    if (nr.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return _n;
  }
  try {
    if (suspectProtoRx.test(_n) || suspectConstructorRx.test(_n)) {
      if (nr.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(_n, jsonParseTransform);
    }
    return JSON.parse(_n);
  } catch (Bn) {
    if (nr.strict)
      throw Bn;
    return _n;
  }
}
function get(_n, nr) {
  if (_n == null)
    return;
  let Cn = _n;
  for (let Bn = 0; Bn < nr.length; Bn++) {
    if (Cn == null || Cn[nr[Bn]] == null)
      return;
    Cn = Cn[nr[Bn]];
  }
  return Cn;
}
function set(_n, nr, Cn) {
  if (Cn.length === 0)
    return nr;
  const Bn = Cn[0];
  return Cn.length > 1 && (nr = set(
    typeof _n != "object" || _n === null || !Object.prototype.hasOwnProperty.call(_n, Bn) ? Number.isInteger(Number(Cn[1])) ? [] : {} : _n[Bn],
    nr,
    Array.prototype.slice.call(Cn, 1)
  )), Number.isInteger(Number(Bn)) && Array.isArray(_n) ? _n.slice()[Bn] : Object.assign({}, _n, { [Bn]: nr });
}
function unset(_n, nr) {
  if (_n == null || nr.length === 0)
    return _n;
  if (nr.length === 1) {
    if (_n == null)
      return _n;
    if (Number.isInteger(nr[0]) && Array.isArray(_n))
      return Array.prototype.slice.call(_n, 0).splice(nr[0], 1);
    const Cn = {};
    for (const Bn in _n)
      Cn[Bn] = _n[Bn];
    return delete Cn[nr[0]], Cn;
  }
  if (_n[nr[0]] == null) {
    if (Number.isInteger(nr[0]) && Array.isArray(_n))
      return Array.prototype.concat.call([], _n);
    const Cn = {};
    for (const Bn in _n)
      Cn[Bn] = _n[Bn];
    return Cn;
  }
  return set(
    _n,
    unset(
      _n[nr[0]],
      Array.prototype.slice.call(nr, 1)
    ),
    [nr[0]]
  );
}
function deepPickUnsafe(_n, nr) {
  return nr.map((Cn) => Cn.split(".")).map((Cn) => [Cn, get(_n, Cn)]).filter((Cn) => Cn[1] !== void 0).reduce((Cn, Bn) => set(Cn, Bn[1], Bn[0]), {});
}
function deepOmitUnsafe(_n, nr) {
  return nr.map((Cn) => Cn.split(".")).reduce((Cn, Bn) => unset(Cn, Bn), _n);
}
function hydrateStore(_n, {
  storage: nr,
  serializer: Cn,
  key: Bn,
  debug: In,
  pick: Dn,
  omit: Ln,
  beforeHydrate: $n,
  afterHydrate: Nn
}, Rn, Fn = !0) {
  try {
    Fn && ($n == null || $n(Rn));
    const Pn = nr.getItem(Bn);
    if (Pn) {
      const Un = Cn.deserialize(Pn), Hn = Dn ? deepPickUnsafe(Un, Dn) : Un, zn = Ln ? deepOmitUnsafe(Hn, Ln) : Hn;
      _n.$patch(zn);
    }
    Fn && (Nn == null || Nn(Rn));
  } catch (Pn) {
    In && console.error("[pinia-plugin-persistedstate]", Pn);
  }
}
function persistState(_n, {
  storage: nr,
  serializer: Cn,
  key: Bn,
  debug: In,
  pick: Dn,
  omit: Ln
}) {
  try {
    const $n = Dn ? deepPickUnsafe(_n, Dn) : _n, Nn = Ln ? deepOmitUnsafe($n, Ln) : $n, Rn = Cn.serialize(Nn);
    nr.setItem(Bn, Rn);
  } catch ($n) {
    In && console.error("[pinia-plugin-persistedstate]", $n);
  }
}
function createPersistence(_n, nr, Cn) {
  const { pinia: Bn, store: In, options: { persist: Dn = Cn } } = _n;
  if (!Dn)
    return;
  if (!(In.$id in Bn.state.value)) {
    const Nn = Bn._s.get(In.$id.replace("__hot:", ""));
    Nn && Promise.resolve().then(() => Nn.$persist());
    return;
  }
  const $n = (Array.isArray(Dn) ? Dn : Dn === !0 ? [{}] : [Dn]).map(nr);
  In.$hydrate = ({ runHooks: Nn = !0 } = {}) => {
    $n.forEach((Rn) => {
      hydrateStore(In, Rn, _n, Nn);
    });
  }, In.$persist = () => {
    $n.forEach((Nn) => {
      persistState(In.$state, Nn);
    });
  }, $n.forEach((Nn) => {
    hydrateStore(In, Nn, _n), In.$subscribe(
      (Rn, Fn) => persistState(Fn, Nn),
      { detached: !0 }
    );
  });
}
function createPersistedState(_n = {}) {
  return function(nr) {
    createPersistence(
      nr,
      (Cn) => ({
        key: (_n.key ? _n.key : (Bn) => Bn)(Cn.key ?? nr.store.$id),
        debug: Cn.debug ?? _n.debug ?? !1,
        serializer: Cn.serializer ?? _n.serializer ?? {
          serialize: (Bn) => JSON.stringify(Bn),
          deserialize: (Bn) => destr(Bn)
        },
        storage: Cn.storage ?? _n.storage ?? window.localStorage,
        beforeHydrate: Cn.beforeHydrate,
        afterHydrate: Cn.afterHydrate,
        pick: Cn.pick,
        omit: Cn.omit
      }),
      _n.auto ?? !1
    );
  };
}
var src_default = createPersistedState();
const pinia = createPinia();
pinia.use(src_default);
const hasPermission = (_n, nr) => nr.meta && nr.meta.roles ? _n.some((Cn) => {
  var Bn;
  return ((Bn = nr.meta) == null ? void 0 : Bn.roles) !== void 0 ? nr.meta.roles.includes(Cn.id) : !0;
}) : !0, filterAsyncRoutes = (_n, nr) => {
  const Cn = [];
  return _n.forEach((Bn) => {
    const In = { ...Bn };
    hasPermission(nr, In) && (In.children && (In.children = filterAsyncRoutes(In.children, nr)), Cn.push(In));
  }), Cn;
};
defineStore("permission", () => {
  const _n = ref([]);
  function nr(Bn) {
    _n.value = constantRoutes.concat(Bn);
  }
  function Cn(Bn) {
    return new Promise((In, Dn) => {
      let Ln = filterAsyncRoutes(asyncRoutes, Bn);
      nr(Ln), In(Ln);
    });
  }
  return { routes: _n, setRoutes: nr, generateRoutes: Cn };
});
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(_n) {
  return _n && _n.__esModule && Object.prototype.hasOwnProperty.call(_n, "default") ? _n.default : _n;
}
function getAugmentedNamespace(_n) {
  if (_n.__esModule)
    return _n;
  var nr = _n.default;
  if (typeof nr == "function") {
    var Cn = function Bn() {
      return this instanceof Bn ? Reflect.construct(nr, arguments, this.constructor) : nr.apply(this, arguments);
    };
    Cn.prototype = nr.prototype;
  } else
    Cn = {};
  return Object.defineProperty(Cn, "__esModule", { value: !0 }), Object.keys(_n).forEach(function(Bn) {
    var In = Object.getOwnPropertyDescriptor(_n, Bn);
    Object.defineProperty(Cn, Bn, In.get ? In : {
      enumerable: !0,
      get: function() {
        return _n[Bn];
      }
    });
  }), Cn;
}
var nprogress$1 = { exports: {} };
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function(_n, nr) {
  (function(Cn, Bn) {
    _n.exports = Bn();
  })(commonjsGlobal, function() {
    var Cn = {};
    Cn.version = "0.2.0";
    var Bn = Cn.settings = {
      minimum: 0.08,
      easing: "ease",
      positionUsing: "",
      speed: 200,
      trickle: !0,
      trickleRate: 0.02,
      trickleSpeed: 800,
      showSpinner: !0,
      barSelector: '[role="bar"]',
      spinnerSelector: '[role="spinner"]',
      parent: "body",
      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    Cn.configure = function(zn) {
      var Gn, Yn;
      for (Gn in zn)
        Yn = zn[Gn], Yn !== void 0 && zn.hasOwnProperty(Gn) && (Bn[Gn] = Yn);
      return this;
    }, Cn.status = null, Cn.set = function(zn) {
      var Gn = Cn.isStarted();
      zn = In(zn, Bn.minimum, 1), Cn.status = zn === 1 ? null : zn;
      var Yn = Cn.render(!Gn), Wn = Yn.querySelector(Bn.barSelector), Xn = Bn.speed, ea = Bn.easing;
      return Yn.offsetWidth, $n(function(ta) {
        Bn.positionUsing === "" && (Bn.positionUsing = Cn.getPositioningCSS()), Nn(Wn, Ln(zn, Xn, ea)), zn === 1 ? (Nn(Yn, {
          transition: "none",
          opacity: 1
        }), Yn.offsetWidth, setTimeout(function() {
          Nn(Yn, {
            transition: "all " + Xn + "ms linear",
            opacity: 0
          }), setTimeout(function() {
            Cn.remove(), ta();
          }, Xn);
        }, Xn)) : setTimeout(ta, Xn);
      }), this;
    }, Cn.isStarted = function() {
      return typeof Cn.status == "number";
    }, Cn.start = function() {
      Cn.status || Cn.set(0);
      var zn = function() {
        setTimeout(function() {
          Cn.status && (Cn.trickle(), zn());
        }, Bn.trickleSpeed);
      };
      return Bn.trickle && zn(), this;
    }, Cn.done = function(zn) {
      return !zn && !Cn.status ? this : Cn.inc(0.3 + 0.5 * Math.random()).set(1);
    }, Cn.inc = function(zn) {
      var Gn = Cn.status;
      return Gn ? (typeof zn != "number" && (zn = (1 - Gn) * In(Math.random() * Gn, 0.1, 0.95)), Gn = In(Gn + zn, 0, 0.994), Cn.set(Gn)) : Cn.start();
    }, Cn.trickle = function() {
      return Cn.inc(Math.random() * Bn.trickleRate);
    }, function() {
      var zn = 0, Gn = 0;
      Cn.promise = function(Yn) {
        return !Yn || Yn.state() === "resolved" ? this : (Gn === 0 && Cn.start(), zn++, Gn++, Yn.always(function() {
          Gn--, Gn === 0 ? (zn = 0, Cn.done()) : Cn.set((zn - Gn) / zn);
        }), this);
      };
    }(), Cn.render = function(zn) {
      if (Cn.isRendered())
        return document.getElementById("nprogress");
      Fn(document.documentElement, "nprogress-busy");
      var Gn = document.createElement("div");
      Gn.id = "nprogress", Gn.innerHTML = Bn.template;
      var Yn = Gn.querySelector(Bn.barSelector), Wn = zn ? "-100" : Dn(Cn.status || 0), Xn = document.querySelector(Bn.parent), ea;
      return Nn(Yn, {
        transition: "all 0 linear",
        transform: "translate3d(" + Wn + "%,0,0)"
      }), Bn.showSpinner || (ea = Gn.querySelector(Bn.spinnerSelector), ea && Hn(ea)), Xn != document.body && Fn(Xn, "nprogress-custom-parent"), Xn.appendChild(Gn), Gn;
    }, Cn.remove = function() {
      Pn(document.documentElement, "nprogress-busy"), Pn(document.querySelector(Bn.parent), "nprogress-custom-parent");
      var zn = document.getElementById("nprogress");
      zn && Hn(zn);
    }, Cn.isRendered = function() {
      return !!document.getElementById("nprogress");
    }, Cn.getPositioningCSS = function() {
      var zn = document.body.style, Gn = "WebkitTransform" in zn ? "Webkit" : "MozTransform" in zn ? "Moz" : "msTransform" in zn ? "ms" : "OTransform" in zn ? "O" : "";
      return Gn + "Perspective" in zn ? "translate3d" : Gn + "Transform" in zn ? "translate" : "margin";
    };
    function In(zn, Gn, Yn) {
      return zn < Gn ? Gn : zn > Yn ? Yn : zn;
    }
    function Dn(zn) {
      return (-1 + zn) * 100;
    }
    function Ln(zn, Gn, Yn) {
      var Wn;
      return Bn.positionUsing === "translate3d" ? Wn = { transform: "translate3d(" + Dn(zn) + "%,0,0)" } : Bn.positionUsing === "translate" ? Wn = { transform: "translate(" + Dn(zn) + "%,0)" } : Wn = { "margin-left": Dn(zn) + "%" }, Wn.transition = "all " + Gn + "ms " + Yn, Wn;
    }
    var $n = function() {
      var zn = [];
      function Gn() {
        var Yn = zn.shift();
        Yn && Yn(Gn);
      }
      return function(Yn) {
        zn.push(Yn), zn.length == 1 && Gn();
      };
    }(), Nn = function() {
      var zn = ["Webkit", "O", "Moz", "ms"], Gn = {};
      function Yn(ta) {
        return ta.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(na, ra) {
          return ra.toUpperCase();
        });
      }
      function Wn(ta) {
        var na = document.body.style;
        if (ta in na)
          return ta;
        for (var ra = zn.length, aa = ta.charAt(0).toUpperCase() + ta.slice(1), ia; ra--; )
          if (ia = zn[ra] + aa, ia in na)
            return ia;
        return ta;
      }
      function Xn(ta) {
        return ta = Yn(ta), Gn[ta] || (Gn[ta] = Wn(ta));
      }
      function ea(ta, na, ra) {
        na = Xn(na), ta.style[na] = ra;
      }
      return function(ta, na) {
        var ra = arguments, aa, ia;
        if (ra.length == 2)
          for (aa in na)
            ia = na[aa], ia !== void 0 && na.hasOwnProperty(aa) && ea(ta, aa, ia);
        else
          ea(ta, ra[1], ra[2]);
      };
    }();
    function Rn(zn, Gn) {
      var Yn = typeof zn == "string" ? zn : Un(zn);
      return Yn.indexOf(" " + Gn + " ") >= 0;
    }
    function Fn(zn, Gn) {
      var Yn = Un(zn), Wn = Yn + Gn;
      Rn(Yn, Gn) || (zn.className = Wn.substring(1));
    }
    function Pn(zn, Gn) {
      var Yn = Un(zn), Wn;
      Rn(zn, Gn) && (Wn = Yn.replace(" " + Gn + " ", " "), zn.className = Wn.substring(1, Wn.length - 1));
    }
    function Un(zn) {
      return (" " + (zn.className || "") + " ").replace(/\s+/gi, " ");
    }
    function Hn(zn) {
      zn && zn.parentNode && zn.parentNode.removeChild(zn);
    }
    return Cn;
  });
})(nprogress$1);
var nprogressExports = nprogress$1.exports;
const NProgress = /* @__PURE__ */ getDefaultExportFromCjs(nprogressExports), nprogress = "";
NProgress.configure({ showSpinner: !1 });
const constantRoutes = [
  {
    path: "/",
    name: "Index",
    component: () => Promise.resolve().then(() => index$1),
    meta: { title: "" }
  },
  {
    path: "/widgets",
    name: "widgets",
    component: () => Promise.resolve().then(() => index$1),
    meta: { title: "" },
    props: {
      widgets: [{
        key: "Custom",
        name: "我的",
        widgetPackage: "MyWidget",
        id: 123,
        childList: [{
          category: "My",
          categoryIcon: "my",
          categoryName: "我的",
          id: 38,
          name: "自定义组件",
          widgetPackage: "MyWidget",
          widgets: [{
            type: 2,
            key: "RemoteAvatar",
            title: "远程头像组件",
            chartKey: "VRemoteAvatar",
            conKey: "VCRemoteAvatar",
            widgetKey: "RemoteAvatar",
            widgetPackage: "MyWidget",
            category: "My",
            categoryIcon: "my",
            categoryName: "我的",
            image: "index.png",
            chartFrame: "common",
            path: "/RemoteAvatar"
          }]
        }]
      }, {
        id: 1,
        name: "图表",
        icon: "chart",
        widgetPackage: "Charts",
        childList: [
          {
            id: 14,
            name: "柱状图",
            parentId: 1,
            category: "Bars",
            categoryName: "柱状图",
            categoryIcon: "icon-barchart",
            widgetPackage: "Charts",
            childList: null,
            widgets: [
              {
                id: 101,
                title: "柱状图",
                status: 1,
                version: null,
                groupId: 14,
                path: null,
                photo: null,
                preview: null,
                picture: null,
                icon: null,
                visible: null,
                uuid: null,
                userId: 108,
                userGroup: 1,
                createDate: 1730103056,
                modifyDate: 1730978420,
                active: 1,
                type: {
                  value: 1
                },
                widgetKey: "BarCommon",
                key: "BarCommon",
                chartKey: "VBarCommon",
                conKey: "VCBarCommon",
                category: "Bars",
                categoryName: "柱状图",
                categoryIcon: "icon-barchart",
                widgetPackage: "Charts",
                chartFrame: "echarts",
                image: "barchart_x.png",
                isTemplate: null
              },
              {
                id: 102,
                title: "柱状图-渐变色",
                status: 1,
                version: null,
                groupId: 14,
                path: null,
                photo: null,
                preview: null,
                picture: null,
                icon: null,
                visible: null,
                uuid: null,
                userId: 108,
                userGroup: 1,
                createDate: 1730103056,
                modifyDate: 1730978421,
                active: 1,
                type: {
                  value: 1
                },
                widgetKey: "BarGradients",
                chartKey: "VBarGradients",
                conKey: "VCBarGradients",
                category: "Bars",
                categoryName: "柱状图",
                categoryIcon: "icon-barchart",
                widgetPackage: "Charts",
                chartFrame: "echarts",
                image: "barchart_gradient.png",
                isTemplate: null
              },
              {
                id: 103,
                title: "柱状图-堆叠图",
                status: 1,
                version: null,
                groupId: 14,
                path: null,
                photo: null,
                preview: null,
                picture: null,
                icon: null,
                visible: null,
                uuid: null,
                userId: 108,
                userGroup: 1,
                createDate: 1730103056,
                modifyDate: 1731374044,
                active: 1,
                type: {
                  value: 1
                },
                widgetKey: "BarStacking",
                chartKey: "VBarStacking",
                conKey: "VCBarStacking",
                category: "Bars",
                categoryName: "柱状图",
                categoryIcon: "icon-barchart",
                widgetPackage: "Charts",
                chartFrame: "echarts",
                image: "barchart_stacking.png",
                isTemplate: null
              },
              {
                id: 104,
                title: "柱状图-对比图",
                status: 1,
                version: null,
                groupId: 14,
                path: null,
                photo: null,
                preview: null,
                picture: null,
                icon: null,
                visible: null,
                uuid: null,
                userId: 108,
                userGroup: 1,
                createDate: 1730103056,
                modifyDate: 1731374050,
                active: 1,
                type: {
                  value: 1
                },
                widgetKey: "BarComparison",
                chartKey: "VBarComparison",
                conKey: "VCBarComparison",
                category: "Bars",
                categoryName: "柱状图",
                categoryIcon: "icon-barchart",
                widgetPackage: "Charts",
                chartFrame: "echarts",
                image: "barchart_comparison.png",
                isTemplate: null
              },
              {
                id: 105,
                title: "横向柱状图",
                status: 1,
                version: null,
                groupId: 14,
                path: null,
                photo: null,
                preview: null,
                picture: null,
                icon: null,
                visible: null,
                uuid: null,
                userId: 108,
                userGroup: 1,
                createDate: 1730103056,
                modifyDate: 1731374055,
                active: 1,
                type: {
                  value: 1
                },
                widgetKey: "BarCrossrange",
                chartKey: "VBarCrossrange",
                conKey: "VCBarCrossrange",
                category: "Bars",
                categoryName: "柱状图",
                categoryIcon: "icon-barchart",
                widgetPackage: "Charts",
                chartFrame: "echarts",
                image: "bar_y.png",
                isTemplate: null
              },
              {
                id: 106,
                title: "柱状图-对称对比图",
                status: 1,
                version: null,
                groupId: 14,
                path: null,
                photo: null,
                preview: null,
                picture: null,
                icon: null,
                visible: null,
                uuid: null,
                userId: 108,
                userGroup: 1,
                createDate: 1730103056,
                modifyDate: 1731374066,
                active: 1,
                type: {
                  value: 1
                },
                widgetKey: "BarSymmetryComparison",
                chartKey: "VBarSymmetryComparison",
                conKey: "VCBarSymmetryComparison",
                category: "Bars",
                categoryName: "柱状图",
                categoryIcon: "icon-barchart",
                widgetPackage: "Charts",
                chartFrame: "echarts",
                image: "bar_symmetry_comparison.png",
                isTemplate: null
              },
              {
                id: 107,
                title: "胶囊柱图",
                status: 1,
                version: null,
                groupId: 14,
                path: null,
                photo: null,
                preview: null,
                picture: null,
                icon: null,
                visible: null,
                uuid: null,
                userId: 108,
                userGroup: 1,
                createDate: 1730103056,
                modifyDate: 1731374067,
                active: 1,
                type: {
                  value: 1
                },
                widgetKey: "CapsuleChart",
                chartKey: "VCapsuleChart",
                conKey: "VCCapsuleChart",
                category: "Bars",
                categoryName: "柱状图",
                categoryIcon: "icon-barchart",
                widgetPackage: "Charts",
                chartFrame: "common",
                image: "capsule.png",
                isTemplate: null
              }
            ]
          }
        ]
      }]
    }
  },
  {
    path: "/preview/:id(.*)*",
    name: "Preview",
    component: () => import("./wrapper-64c6d133.js"),
    meta: { title: "预览" }
  },
  {
    path: "/local/:id(.*)*",
    name: "LocalPreview",
    component: () => import("./wrapper-64c6d133.js"),
    meta: { title: "本地预览" }
  },
  {
    path: "/publish/:id(.*)*",
    name: "PublishPreview",
    component: () => import("./wrapper-64c6d133.js"),
    meta: { title: "发布预览" }
  }
], asyncRoutes = [], router = createRouter({
  history: createWebHashHistory(""),
  routes: constantRoutes,
  // 刷新时，滚动条位置还原
  scrollBehavior: () => ({ left: 0, top: 0 })
});
function resetRouter() {
  router.replace({ path: "/" });
}
const getQueryParams = (_n) => {
  const nr = new RegExp("(^|&)" + _n + "=([^&]*)(&|$)", "i");
  return ((window.location.href.split("?")[1] || "").match(nr) || [])[2];
}, fetchPathByName = (_n, nr) => {
  try {
    const Cn = router.resolve({ name: _n });
    return nr ? Cn[nr] : Cn;
  } catch {
    ElMessage.warning("查询路由信息失败，请联系管理员！");
  }
}, routerTurnByPath = (_n, nr, Cn, Bn) => {
  let In = "";
  if (nr != null && nr.length && (In = `${_n}/${nr.join("/")}`), Bn)
    return openNewWindow(In);
  if (In = In.replace("#", ""), Cn)
    return router.replace({
      path: In
    }), !1;
  router.push({
    path: In
  });
}, openNewWindow = (_n) => window.open(_n, "_blank"), isPreview = () => document.location.hash.includes("preview") || document.location.hash.includes("chart/publish") || document.location.pathname.includes("publish"), jumpPublishPage = (_n, nr) => {
  if (_n) {
    let Cn = getQueryParams("projectId");
    const Bn = localStorage.getItem("RouterMatching");
    let In = [];
    Bn && (In = JSON.parse(Bn));
    let Dn = In.findIndex((Ln) => Ln.id === nr);
    if (Dn > -1 && In[Dn].path) {
      let Ln = In[Dn].path;
      Ln[0] !== "/" && (Ln = "/" + Ln);
      let Nn = router.resolve({
        path: Ln
      }).href;
      Cn && (Nn += "?projectId=" + Cn), window.location.href = Nn;
    } else {
      const Ln = {
        name: "Preview",
        params: { id: nr }
      };
      Cn && (Ln.query = { projectId: Cn });
      const $n = router.resolve(Ln);
      window.location.href = $n.href;
    }
  } else {
    const Cn = fetchPathByName("Preview", "href");
    routerTurnByPath(Cn, [nr], !1, void 0);
  }
};
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(_n, nr) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Cn, Bn) {
    Cn.__proto__ = Bn;
  } || function(Cn, Bn) {
    for (var In in Bn)
      Object.prototype.hasOwnProperty.call(Bn, In) && (Cn[In] = Bn[In]);
  }, extendStatics(_n, nr);
};
function __extends$1(_n, nr) {
  if (typeof nr != "function" && nr !== null)
    throw new TypeError("Class extends value " + String(nr) + " is not a constructor or null");
  extendStatics(_n, nr);
  function Cn() {
    this.constructor = _n;
  }
  _n.prototype = nr === null ? Object.create(nr) : (Cn.prototype = nr.prototype, new Cn());
}
var __assign = function() {
  return __assign = Object.assign || function(nr) {
    for (var Cn, Bn = 1, In = arguments.length; Bn < In; Bn++) {
      Cn = arguments[Bn];
      for (var Dn in Cn)
        Object.prototype.hasOwnProperty.call(Cn, Dn) && (nr[Dn] = Cn[Dn]);
    }
    return nr;
  }, __assign.apply(this, arguments);
};
function __awaiter(_n, nr, Cn, Bn) {
  function In(Dn) {
    return Dn instanceof Cn ? Dn : new Cn(function(Ln) {
      Ln(Dn);
    });
  }
  return new (Cn || (Cn = Promise))(function(Dn, Ln) {
    function $n(Fn) {
      try {
        Rn(Bn.next(Fn));
      } catch (Pn) {
        Ln(Pn);
      }
    }
    function Nn(Fn) {
      try {
        Rn(Bn.throw(Fn));
      } catch (Pn) {
        Ln(Pn);
      }
    }
    function Rn(Fn) {
      Fn.done ? Dn(Fn.value) : In(Fn.value).then($n, Nn);
    }
    Rn((Bn = Bn.apply(_n, nr || [])).next());
  });
}
function __generator(_n, nr) {
  var Cn = { label: 0, sent: function() {
    if (Dn[0] & 1)
      throw Dn[1];
    return Dn[1];
  }, trys: [], ops: [] }, Bn, In, Dn, Ln;
  return Ln = { next: $n(0), throw: $n(1), return: $n(2) }, typeof Symbol == "function" && (Ln[Symbol.iterator] = function() {
    return this;
  }), Ln;
  function $n(Rn) {
    return function(Fn) {
      return Nn([Rn, Fn]);
    };
  }
  function Nn(Rn) {
    if (Bn)
      throw new TypeError("Generator is already executing.");
    for (; Cn; )
      try {
        if (Bn = 1, In && (Dn = Rn[0] & 2 ? In.return : Rn[0] ? In.throw || ((Dn = In.return) && Dn.call(In), 0) : In.next) && !(Dn = Dn.call(In, Rn[1])).done)
          return Dn;
        switch (In = 0, Dn && (Rn = [Rn[0] & 2, Dn.value]), Rn[0]) {
          case 0:
          case 1:
            Dn = Rn;
            break;
          case 4:
            return Cn.label++, { value: Rn[1], done: !1 };
          case 5:
            Cn.label++, In = Rn[1], Rn = [0];
            continue;
          case 7:
            Rn = Cn.ops.pop(), Cn.trys.pop();
            continue;
          default:
            if (Dn = Cn.trys, !(Dn = Dn.length > 0 && Dn[Dn.length - 1]) && (Rn[0] === 6 || Rn[0] === 2)) {
              Cn = 0;
              continue;
            }
            if (Rn[0] === 3 && (!Dn || Rn[1] > Dn[0] && Rn[1] < Dn[3])) {
              Cn.label = Rn[1];
              break;
            }
            if (Rn[0] === 6 && Cn.label < Dn[1]) {
              Cn.label = Dn[1], Dn = Rn;
              break;
            }
            if (Dn && Cn.label < Dn[2]) {
              Cn.label = Dn[2], Cn.ops.push(Rn);
              break;
            }
            Dn[2] && Cn.ops.pop(), Cn.trys.pop();
            continue;
        }
        Rn = nr.call(_n, Cn);
      } catch (Fn) {
        Rn = [6, Fn], In = 0;
      } finally {
        Bn = Dn = 0;
      }
    if (Rn[0] & 5)
      throw Rn[1];
    return { value: Rn[0] ? Rn[1] : void 0, done: !0 };
  }
}
function __spreadArray(_n, nr, Cn) {
  if (Cn || arguments.length === 2)
    for (var Bn = 0, In = nr.length, Dn; Bn < In; Bn++)
      (Dn || !(Bn in nr)) && (Dn || (Dn = Array.prototype.slice.call(nr, 0, Bn)), Dn[Bn] = nr[Bn]);
  return _n.concat(Dn || nr);
}
var Bounds = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn, In) {
      this.left = nr, this.top = Cn, this.width = Bn, this.height = In;
    }
    return _n.prototype.add = function(nr, Cn, Bn, In) {
      return new _n(this.left + nr, this.top + Cn, this.width + Bn, this.height + In);
    }, _n.fromClientRect = function(nr, Cn) {
      return new _n(Cn.left + nr.windowBounds.left, Cn.top + nr.windowBounds.top, Cn.width, Cn.height);
    }, _n.fromDOMRectList = function(nr, Cn) {
      var Bn = Array.from(Cn).find(function(In) {
        return In.width !== 0;
      });
      return Bn ? new _n(Bn.left + nr.windowBounds.left, Bn.top + nr.windowBounds.top, Bn.width, Bn.height) : _n.EMPTY;
    }, _n.EMPTY = new _n(0, 0, 0, 0), _n;
  }()
), parseBounds = function(_n, nr) {
  return Bounds.fromClientRect(_n, nr.getBoundingClientRect());
}, parseDocumentSize = function(_n) {
  var nr = _n.body, Cn = _n.documentElement;
  if (!nr || !Cn)
    throw new Error("Unable to get document size");
  var Bn = Math.max(Math.max(nr.scrollWidth, Cn.scrollWidth), Math.max(nr.offsetWidth, Cn.offsetWidth), Math.max(nr.clientWidth, Cn.clientWidth)), In = Math.max(Math.max(nr.scrollHeight, Cn.scrollHeight), Math.max(nr.offsetHeight, Cn.offsetHeight), Math.max(nr.clientHeight, Cn.clientHeight));
  return new Bounds(0, 0, Bn, In);
}, toCodePoints$1 = function(_n) {
  for (var nr = [], Cn = 0, Bn = _n.length; Cn < Bn; ) {
    var In = _n.charCodeAt(Cn++);
    if (In >= 55296 && In <= 56319 && Cn < Bn) {
      var Dn = _n.charCodeAt(Cn++);
      (Dn & 64512) === 56320 ? nr.push(((In & 1023) << 10) + (Dn & 1023) + 65536) : (nr.push(In), Cn--);
    } else
      nr.push(In);
  }
  return nr;
}, fromCodePoint$1 = function() {
  for (var _n = [], nr = 0; nr < arguments.length; nr++)
    _n[nr] = arguments[nr];
  if (String.fromCodePoint)
    return String.fromCodePoint.apply(String, _n);
  var Cn = _n.length;
  if (!Cn)
    return "";
  for (var Bn = [], In = -1, Dn = ""; ++In < Cn; ) {
    var Ln = _n[In];
    Ln <= 65535 ? Bn.push(Ln) : (Ln -= 65536, Bn.push((Ln >> 10) + 55296, Ln % 1024 + 56320)), (In + 1 === Cn || Bn.length > 16384) && (Dn += String.fromCharCode.apply(String, Bn), Bn.length = 0);
  }
  return Dn;
}, chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$2 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var i$2$1 = 0; i$2$1 < chars$2.length; i$2$1++)
  lookup$2[chars$2.charCodeAt(i$2$1)] = i$2$1;
var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$1$1 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++)
  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
var decode$1 = function(_n) {
  var nr = _n.length * 0.75, Cn = _n.length, Bn, In = 0, Dn, Ln, $n, Nn;
  _n[_n.length - 1] === "=" && (nr--, _n[_n.length - 2] === "=" && nr--);
  var Rn = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(nr) : new Array(nr), Fn = Array.isArray(Rn) ? Rn : new Uint8Array(Rn);
  for (Bn = 0; Bn < Cn; Bn += 4)
    Dn = lookup$1$1[_n.charCodeAt(Bn)], Ln = lookup$1$1[_n.charCodeAt(Bn + 1)], $n = lookup$1$1[_n.charCodeAt(Bn + 2)], Nn = lookup$1$1[_n.charCodeAt(Bn + 3)], Fn[In++] = Dn << 2 | Ln >> 4, Fn[In++] = (Ln & 15) << 4 | $n >> 2, Fn[In++] = ($n & 3) << 6 | Nn & 63;
  return Rn;
}, polyUint16Array$1 = function(_n) {
  for (var nr = _n.length, Cn = [], Bn = 0; Bn < nr; Bn += 2)
    Cn.push(_n[Bn + 1] << 8 | _n[Bn]);
  return Cn;
}, polyUint32Array$1 = function(_n) {
  for (var nr = _n.length, Cn = [], Bn = 0; Bn < nr; Bn += 4)
    Cn.push(_n[Bn + 3] << 24 | _n[Bn + 2] << 16 | _n[Bn + 1] << 8 | _n[Bn]);
  return Cn;
}, UTRIE2_SHIFT_2$1 = 5, UTRIE2_SHIFT_1$1 = 6 + 5, UTRIE2_INDEX_SHIFT$1 = 2, UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1, UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1, UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1, UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1, UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1, UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1, UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1, UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 32, UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1, UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1, UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1, UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1, slice16$1 = function(_n, nr, Cn) {
  return _n.slice ? _n.slice(nr, Cn) : new Uint16Array(Array.prototype.slice.call(_n, nr, Cn));
}, slice32$1 = function(_n, nr, Cn) {
  return _n.slice ? _n.slice(nr, Cn) : new Uint32Array(Array.prototype.slice.call(_n, nr, Cn));
}, createTrieFromBase64$1 = function(_n, nr) {
  var Cn = decode$1(_n), Bn = Array.isArray(Cn) ? polyUint32Array$1(Cn) : new Uint32Array(Cn), In = Array.isArray(Cn) ? polyUint16Array$1(Cn) : new Uint16Array(Cn), Dn = 24, Ln = slice16$1(In, Dn / 2, Bn[4] / 2), $n = Bn[5] === 2 ? slice16$1(In, (Dn + Bn[4]) / 2) : slice32$1(Bn, Math.ceil((Dn + Bn[4]) / 4));
  return new Trie$1(Bn[0], Bn[1], Bn[2], Bn[3], Ln, $n);
}, Trie$1 = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn, In, Dn, Ln) {
      this.initialValue = nr, this.errorValue = Cn, this.highStart = Bn, this.highValueIndex = In, this.index = Dn, this.data = Ln;
    }
    return _n.prototype.get = function(nr) {
      var Cn;
      if (nr >= 0) {
        if (nr < 55296 || nr > 56319 && nr <= 65535)
          return Cn = this.index[nr >> UTRIE2_SHIFT_2$1], Cn = (Cn << UTRIE2_INDEX_SHIFT$1) + (nr & UTRIE2_DATA_MASK$1), this.data[Cn];
        if (nr <= 65535)
          return Cn = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (nr - 55296 >> UTRIE2_SHIFT_2$1)], Cn = (Cn << UTRIE2_INDEX_SHIFT$1) + (nr & UTRIE2_DATA_MASK$1), this.data[Cn];
        if (nr < this.highStart)
          return Cn = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (nr >> UTRIE2_SHIFT_1$1), Cn = this.index[Cn], Cn += nr >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1, Cn = this.index[Cn], Cn = (Cn << UTRIE2_INDEX_SHIFT$1) + (nr & UTRIE2_DATA_MASK$1), this.data[Cn];
        if (nr <= 1114111)
          return this.data[this.highValueIndex];
      }
      return this.errorValue;
    }, _n;
  }()
), chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$3 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var i$3 = 0; i$3 < chars$3.length; i$3++)
  lookup$3[chars$3.charCodeAt(i$3)] = i$3;
var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==", LETTER_NUMBER_MODIFIER = 50, BK = 1, CR$1 = 2, LF$1 = 3, CM = 4, NL = 5, WJ = 7, ZW = 8, GL = 9, SP = 10, ZWJ$1 = 11, B2 = 12, BA = 13, BB = 14, HY = 15, CB = 16, CL = 17, CP = 18, EX = 19, IN = 20, NS = 21, OP = 22, QU = 23, IS = 24, NU = 25, PO = 26, PR = 27, SY = 28, AI = 29, AL = 30, CJ = 31, EB = 32, EM = 33, H2 = 34, H3 = 35, HL = 36, ID = 37, JL = 38, JV = 39, JT = 40, RI$1 = 41, SA = 42, XX = 43, ea_OP = [9001, 65288], BREAK_MANDATORY = "!", BREAK_NOT_ALLOWED$1 = "×", BREAK_ALLOWED$1 = "÷", UnicodeTrie$1 = createTrieFromBase64$1(base64$1), ALPHABETICS = [AL, HL], HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL], SPACE$1 = [SP, ZW], PREFIX_POSTFIX = [PR, PO], LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1), KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3], HYPHEN = [HY, BA], codePointsToCharacterClasses = function(_n, nr) {
  nr === void 0 && (nr = "strict");
  var Cn = [], Bn = [], In = [];
  return _n.forEach(function(Dn, Ln) {
    var $n = UnicodeTrie$1.get(Dn);
    if ($n > LETTER_NUMBER_MODIFIER ? (In.push(!0), $n -= LETTER_NUMBER_MODIFIER) : In.push(!1), ["normal", "auto", "loose"].indexOf(nr) !== -1 && [8208, 8211, 12316, 12448].indexOf(Dn) !== -1)
      return Bn.push(Ln), Cn.push(CB);
    if ($n === CM || $n === ZWJ$1) {
      if (Ln === 0)
        return Bn.push(Ln), Cn.push(AL);
      var Nn = Cn[Ln - 1];
      return LINE_BREAKS.indexOf(Nn) === -1 ? (Bn.push(Bn[Ln - 1]), Cn.push(Nn)) : (Bn.push(Ln), Cn.push(AL));
    }
    if (Bn.push(Ln), $n === CJ)
      return Cn.push(nr === "strict" ? NS : ID);
    if ($n === SA || $n === AI)
      return Cn.push(AL);
    if ($n === XX)
      return Dn >= 131072 && Dn <= 196605 || Dn >= 196608 && Dn <= 262141 ? Cn.push(ID) : Cn.push(AL);
    Cn.push($n);
  }), [Bn, Cn, In];
}, isAdjacentWithSpaceIgnored = function(_n, nr, Cn, Bn) {
  var In = Bn[Cn];
  if (Array.isArray(_n) ? _n.indexOf(In) !== -1 : _n === In)
    for (var Dn = Cn; Dn <= Bn.length; ) {
      Dn++;
      var Ln = Bn[Dn];
      if (Ln === nr)
        return !0;
      if (Ln !== SP)
        break;
    }
  if (In === SP)
    for (var Dn = Cn; Dn > 0; ) {
      Dn--;
      var $n = Bn[Dn];
      if (Array.isArray(_n) ? _n.indexOf($n) !== -1 : _n === $n)
        for (var Nn = Cn; Nn <= Bn.length; ) {
          Nn++;
          var Ln = Bn[Nn];
          if (Ln === nr)
            return !0;
          if (Ln !== SP)
            break;
        }
      if ($n !== SP)
        break;
    }
  return !1;
}, previousNonSpaceClassType = function(_n, nr) {
  for (var Cn = _n; Cn >= 0; ) {
    var Bn = nr[Cn];
    if (Bn === SP)
      Cn--;
    else
      return Bn;
  }
  return 0;
}, _lineBreakAtIndex = function(_n, nr, Cn, Bn, In) {
  if (Cn[Bn] === 0)
    return BREAK_NOT_ALLOWED$1;
  var Dn = Bn - 1;
  if (Array.isArray(In) && In[Dn] === !0)
    return BREAK_NOT_ALLOWED$1;
  var Ln = Dn - 1, $n = Dn + 1, Nn = nr[Dn], Rn = Ln >= 0 ? nr[Ln] : 0, Fn = nr[$n];
  if (Nn === CR$1 && Fn === LF$1)
    return BREAK_NOT_ALLOWED$1;
  if (HARD_LINE_BREAKS.indexOf(Nn) !== -1)
    return BREAK_MANDATORY;
  if (HARD_LINE_BREAKS.indexOf(Fn) !== -1 || SPACE$1.indexOf(Fn) !== -1)
    return BREAK_NOT_ALLOWED$1;
  if (previousNonSpaceClassType(Dn, nr) === ZW)
    return BREAK_ALLOWED$1;
  if (UnicodeTrie$1.get(_n[Dn]) === ZWJ$1 || (Nn === EB || Nn === EM) && UnicodeTrie$1.get(_n[$n]) === ZWJ$1 || Nn === WJ || Fn === WJ || Nn === GL || [SP, BA, HY].indexOf(Nn) === -1 && Fn === GL || [CL, CP, EX, IS, SY].indexOf(Fn) !== -1 || previousNonSpaceClassType(Dn, nr) === OP || isAdjacentWithSpaceIgnored(QU, OP, Dn, nr) || isAdjacentWithSpaceIgnored([CL, CP], NS, Dn, nr) || isAdjacentWithSpaceIgnored(B2, B2, Dn, nr))
    return BREAK_NOT_ALLOWED$1;
  if (Nn === SP)
    return BREAK_ALLOWED$1;
  if (Nn === QU || Fn === QU)
    return BREAK_NOT_ALLOWED$1;
  if (Fn === CB || Nn === CB)
    return BREAK_ALLOWED$1;
  if ([BA, HY, NS].indexOf(Fn) !== -1 || Nn === BB || Rn === HL && HYPHEN.indexOf(Nn) !== -1 || Nn === SY && Fn === HL || Fn === IN || ALPHABETICS.indexOf(Fn) !== -1 && Nn === NU || ALPHABETICS.indexOf(Nn) !== -1 && Fn === NU || Nn === PR && [ID, EB, EM].indexOf(Fn) !== -1 || [ID, EB, EM].indexOf(Nn) !== -1 && Fn === PO || ALPHABETICS.indexOf(Nn) !== -1 && PREFIX_POSTFIX.indexOf(Fn) !== -1 || PREFIX_POSTFIX.indexOf(Nn) !== -1 && ALPHABETICS.indexOf(Fn) !== -1 || // (PR | PO) × ( OP | HY )? NU
  [PR, PO].indexOf(Nn) !== -1 && (Fn === NU || [OP, HY].indexOf(Fn) !== -1 && nr[$n + 1] === NU) || // ( OP | HY ) × NU
  [OP, HY].indexOf(Nn) !== -1 && Fn === NU || // NU ×	(NU | SY | IS)
  Nn === NU && [NU, SY, IS].indexOf(Fn) !== -1)
    return BREAK_NOT_ALLOWED$1;
  if ([NU, SY, IS, CL, CP].indexOf(Fn) !== -1)
    for (var Pn = Dn; Pn >= 0; ) {
      var Un = nr[Pn];
      if (Un === NU)
        return BREAK_NOT_ALLOWED$1;
      if ([SY, IS].indexOf(Un) !== -1)
        Pn--;
      else
        break;
    }
  if ([PR, PO].indexOf(Fn) !== -1)
    for (var Pn = [CL, CP].indexOf(Nn) !== -1 ? Ln : Dn; Pn >= 0; ) {
      var Un = nr[Pn];
      if (Un === NU)
        return BREAK_NOT_ALLOWED$1;
      if ([SY, IS].indexOf(Un) !== -1)
        Pn--;
      else
        break;
    }
  if (JL === Nn && [JL, JV, H2, H3].indexOf(Fn) !== -1 || [JV, H2].indexOf(Nn) !== -1 && [JV, JT].indexOf(Fn) !== -1 || [JT, H3].indexOf(Nn) !== -1 && Fn === JT || KOREAN_SYLLABLE_BLOCK.indexOf(Nn) !== -1 && [IN, PO].indexOf(Fn) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(Fn) !== -1 && Nn === PR || ALPHABETICS.indexOf(Nn) !== -1 && ALPHABETICS.indexOf(Fn) !== -1 || Nn === IS && ALPHABETICS.indexOf(Fn) !== -1 || ALPHABETICS.concat(NU).indexOf(Nn) !== -1 && Fn === OP && ea_OP.indexOf(_n[$n]) === -1 || ALPHABETICS.concat(NU).indexOf(Fn) !== -1 && Nn === CP)
    return BREAK_NOT_ALLOWED$1;
  if (Nn === RI$1 && Fn === RI$1) {
    for (var Hn = Cn[Dn], zn = 1; Hn > 0 && (Hn--, nr[Hn] === RI$1); )
      zn++;
    if (zn % 2 !== 0)
      return BREAK_NOT_ALLOWED$1;
  }
  return Nn === EB && Fn === EM ? BREAK_NOT_ALLOWED$1 : BREAK_ALLOWED$1;
}, cssFormattedClasses = function(_n, nr) {
  nr || (nr = { lineBreak: "normal", wordBreak: "normal" });
  var Cn = codePointsToCharacterClasses(_n, nr.lineBreak), Bn = Cn[0], In = Cn[1], Dn = Cn[2];
  (nr.wordBreak === "break-all" || nr.wordBreak === "break-word") && (In = In.map(function($n) {
    return [NU, AL, SA].indexOf($n) !== -1 ? ID : $n;
  }));
  var Ln = nr.wordBreak === "keep-all" ? Dn.map(function($n, Nn) {
    return $n && _n[Nn] >= 19968 && _n[Nn] <= 40959;
  }) : void 0;
  return [Bn, In, Ln];
}, Break = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn, In) {
      this.codePoints = nr, this.required = Cn === BREAK_MANDATORY, this.start = Bn, this.end = In;
    }
    return _n.prototype.slice = function() {
      return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
    }, _n;
  }()
), LineBreaker = function(_n, nr) {
  var Cn = toCodePoints$1(_n), Bn = cssFormattedClasses(Cn, nr), In = Bn[0], Dn = Bn[1], Ln = Bn[2], $n = Cn.length, Nn = 0, Rn = 0;
  return {
    next: function() {
      if (Rn >= $n)
        return { done: !0, value: null };
      for (var Fn = BREAK_NOT_ALLOWED$1; Rn < $n && (Fn = _lineBreakAtIndex(Cn, Dn, In, ++Rn, Ln)) === BREAK_NOT_ALLOWED$1; )
        ;
      if (Fn !== BREAK_NOT_ALLOWED$1 || Rn === $n) {
        var Pn = new Break(Cn, Fn, Nn, Rn);
        return Nn = Rn, { value: Pn, done: !1 };
      }
      return { done: !0, value: null };
    }
  };
}, FLAG_UNRESTRICTED = 1, FLAG_ID = 2, FLAG_INTEGER = 4, FLAG_NUMBER = 8, LINE_FEED = 10, SOLIDUS = 47, REVERSE_SOLIDUS = 92, CHARACTER_TABULATION = 9, SPACE = 32, QUOTATION_MARK = 34, EQUALS_SIGN = 61, NUMBER_SIGN = 35, DOLLAR_SIGN = 36, PERCENTAGE_SIGN = 37, APOSTROPHE = 39, LEFT_PARENTHESIS = 40, RIGHT_PARENTHESIS = 41, LOW_LINE = 95, HYPHEN_MINUS = 45, EXCLAMATION_MARK = 33, LESS_THAN_SIGN = 60, GREATER_THAN_SIGN = 62, COMMERCIAL_AT = 64, LEFT_SQUARE_BRACKET = 91, RIGHT_SQUARE_BRACKET = 93, CIRCUMFLEX_ACCENT = 61, LEFT_CURLY_BRACKET = 123, QUESTION_MARK = 63, RIGHT_CURLY_BRACKET = 125, VERTICAL_LINE = 124, TILDE = 126, CONTROL = 128, REPLACEMENT_CHARACTER = 65533, ASTERISK = 42, PLUS_SIGN = 43, COMMA = 44, COLON = 58, SEMICOLON = 59, FULL_STOP = 46, NULL = 0, BACKSPACE = 8, LINE_TABULATION = 11, SHIFT_OUT = 14, INFORMATION_SEPARATOR_ONE = 31, DELETE = 127, EOF = -1, ZERO = 48, a$2 = 97, e$1 = 101, f$2 = 102, u$2 = 117, z$3 = 122, A$3 = 65, E$2 = 69, F$2 = 70, U$1 = 85, Z$1 = 90, isDigit = function(_n) {
  return _n >= ZERO && _n <= 57;
}, isSurrogateCodePoint = function(_n) {
  return _n >= 55296 && _n <= 57343;
}, isHex = function(_n) {
  return isDigit(_n) || _n >= A$3 && _n <= F$2 || _n >= a$2 && _n <= f$2;
}, isLowerCaseLetter = function(_n) {
  return _n >= a$2 && _n <= z$3;
}, isUpperCaseLetter = function(_n) {
  return _n >= A$3 && _n <= Z$1;
}, isLetter = function(_n) {
  return isLowerCaseLetter(_n) || isUpperCaseLetter(_n);
}, isNonASCIICodePoint = function(_n) {
  return _n >= CONTROL;
}, isWhiteSpace = function(_n) {
  return _n === LINE_FEED || _n === CHARACTER_TABULATION || _n === SPACE;
}, isNameStartCodePoint = function(_n) {
  return isLetter(_n) || isNonASCIICodePoint(_n) || _n === LOW_LINE;
}, isNameCodePoint = function(_n) {
  return isNameStartCodePoint(_n) || isDigit(_n) || _n === HYPHEN_MINUS;
}, isNonPrintableCodePoint = function(_n) {
  return _n >= NULL && _n <= BACKSPACE || _n === LINE_TABULATION || _n >= SHIFT_OUT && _n <= INFORMATION_SEPARATOR_ONE || _n === DELETE;
}, isValidEscape = function(_n, nr) {
  return _n !== REVERSE_SOLIDUS ? !1 : nr !== LINE_FEED;
}, isIdentifierStart = function(_n, nr, Cn) {
  return _n === HYPHEN_MINUS ? isNameStartCodePoint(nr) || isValidEscape(nr, Cn) : isNameStartCodePoint(_n) ? !0 : !!(_n === REVERSE_SOLIDUS && isValidEscape(_n, nr));
}, isNumberStart = function(_n, nr, Cn) {
  return _n === PLUS_SIGN || _n === HYPHEN_MINUS ? isDigit(nr) ? !0 : nr === FULL_STOP && isDigit(Cn) : isDigit(_n === FULL_STOP ? nr : _n);
}, stringToNumber = function(_n) {
  var nr = 0, Cn = 1;
  (_n[nr] === PLUS_SIGN || _n[nr] === HYPHEN_MINUS) && (_n[nr] === HYPHEN_MINUS && (Cn = -1), nr++);
  for (var Bn = []; isDigit(_n[nr]); )
    Bn.push(_n[nr++]);
  var In = Bn.length ? parseInt(fromCodePoint$1.apply(void 0, Bn), 10) : 0;
  _n[nr] === FULL_STOP && nr++;
  for (var Dn = []; isDigit(_n[nr]); )
    Dn.push(_n[nr++]);
  var Ln = Dn.length, $n = Ln ? parseInt(fromCodePoint$1.apply(void 0, Dn), 10) : 0;
  (_n[nr] === E$2 || _n[nr] === e$1) && nr++;
  var Nn = 1;
  (_n[nr] === PLUS_SIGN || _n[nr] === HYPHEN_MINUS) && (_n[nr] === HYPHEN_MINUS && (Nn = -1), nr++);
  for (var Rn = []; isDigit(_n[nr]); )
    Rn.push(_n[nr++]);
  var Fn = Rn.length ? parseInt(fromCodePoint$1.apply(void 0, Rn), 10) : 0;
  return Cn * (In + $n * Math.pow(10, -Ln)) * Math.pow(10, Nn * Fn);
}, LEFT_PARENTHESIS_TOKEN = {
  type: 2
  /* LEFT_PARENTHESIS_TOKEN */
}, RIGHT_PARENTHESIS_TOKEN = {
  type: 3
  /* RIGHT_PARENTHESIS_TOKEN */
}, COMMA_TOKEN = {
  type: 4
  /* COMMA_TOKEN */
}, SUFFIX_MATCH_TOKEN = {
  type: 13
  /* SUFFIX_MATCH_TOKEN */
}, PREFIX_MATCH_TOKEN = {
  type: 8
  /* PREFIX_MATCH_TOKEN */
}, COLUMN_TOKEN = {
  type: 21
  /* COLUMN_TOKEN */
}, DASH_MATCH_TOKEN = {
  type: 9
  /* DASH_MATCH_TOKEN */
}, INCLUDE_MATCH_TOKEN = {
  type: 10
  /* INCLUDE_MATCH_TOKEN */
}, LEFT_CURLY_BRACKET_TOKEN = {
  type: 11
  /* LEFT_CURLY_BRACKET_TOKEN */
}, RIGHT_CURLY_BRACKET_TOKEN = {
  type: 12
  /* RIGHT_CURLY_BRACKET_TOKEN */
}, SUBSTRING_MATCH_TOKEN = {
  type: 14
  /* SUBSTRING_MATCH_TOKEN */
}, BAD_URL_TOKEN = {
  type: 23
  /* BAD_URL_TOKEN */
}, BAD_STRING_TOKEN = {
  type: 1
  /* BAD_STRING_TOKEN */
}, CDO_TOKEN = {
  type: 25
  /* CDO_TOKEN */
}, CDC_TOKEN = {
  type: 24
  /* CDC_TOKEN */
}, COLON_TOKEN = {
  type: 26
  /* COLON_TOKEN */
}, SEMICOLON_TOKEN = {
  type: 27
  /* SEMICOLON_TOKEN */
}, LEFT_SQUARE_BRACKET_TOKEN = {
  type: 28
  /* LEFT_SQUARE_BRACKET_TOKEN */
}, RIGHT_SQUARE_BRACKET_TOKEN = {
  type: 29
  /* RIGHT_SQUARE_BRACKET_TOKEN */
}, WHITESPACE_TOKEN = {
  type: 31
  /* WHITESPACE_TOKEN */
}, EOF_TOKEN = {
  type: 32
  /* EOF_TOKEN */
}, Tokenizer = (
  /** @class */
  function() {
    function _n() {
      this._value = [];
    }
    return _n.prototype.write = function(nr) {
      this._value = this._value.concat(toCodePoints$1(nr));
    }, _n.prototype.read = function() {
      for (var nr = [], Cn = this.consumeToken(); Cn !== EOF_TOKEN; )
        nr.push(Cn), Cn = this.consumeToken();
      return nr;
    }, _n.prototype.consumeToken = function() {
      var nr = this.consumeCodePoint();
      switch (nr) {
        case QUOTATION_MARK:
          return this.consumeStringToken(QUOTATION_MARK);
        case NUMBER_SIGN:
          var Cn = this.peekCodePoint(0), Bn = this.peekCodePoint(1), In = this.peekCodePoint(2);
          if (isNameCodePoint(Cn) || isValidEscape(Bn, In)) {
            var Dn = isIdentifierStart(Cn, Bn, In) ? FLAG_ID : FLAG_UNRESTRICTED, Ln = this.consumeName();
            return { type: 5, value: Ln, flags: Dn };
          }
          break;
        case DOLLAR_SIGN:
          if (this.peekCodePoint(0) === EQUALS_SIGN)
            return this.consumeCodePoint(), SUFFIX_MATCH_TOKEN;
          break;
        case APOSTROPHE:
          return this.consumeStringToken(APOSTROPHE);
        case LEFT_PARENTHESIS:
          return LEFT_PARENTHESIS_TOKEN;
        case RIGHT_PARENTHESIS:
          return RIGHT_PARENTHESIS_TOKEN;
        case ASTERISK:
          if (this.peekCodePoint(0) === EQUALS_SIGN)
            return this.consumeCodePoint(), SUBSTRING_MATCH_TOKEN;
          break;
        case PLUS_SIGN:
          if (isNumberStart(nr, this.peekCodePoint(0), this.peekCodePoint(1)))
            return this.reconsumeCodePoint(nr), this.consumeNumericToken();
          break;
        case COMMA:
          return COMMA_TOKEN;
        case HYPHEN_MINUS:
          var $n = nr, Nn = this.peekCodePoint(0), Rn = this.peekCodePoint(1);
          if (isNumberStart($n, Nn, Rn))
            return this.reconsumeCodePoint(nr), this.consumeNumericToken();
          if (isIdentifierStart($n, Nn, Rn))
            return this.reconsumeCodePoint(nr), this.consumeIdentLikeToken();
          if (Nn === HYPHEN_MINUS && Rn === GREATER_THAN_SIGN)
            return this.consumeCodePoint(), this.consumeCodePoint(), CDC_TOKEN;
          break;
        case FULL_STOP:
          if (isNumberStart(nr, this.peekCodePoint(0), this.peekCodePoint(1)))
            return this.reconsumeCodePoint(nr), this.consumeNumericToken();
          break;
        case SOLIDUS:
          if (this.peekCodePoint(0) === ASTERISK)
            for (this.consumeCodePoint(); ; ) {
              var Fn = this.consumeCodePoint();
              if (Fn === ASTERISK && (Fn = this.consumeCodePoint(), Fn === SOLIDUS))
                return this.consumeToken();
              if (Fn === EOF)
                return this.consumeToken();
            }
          break;
        case COLON:
          return COLON_TOKEN;
        case SEMICOLON:
          return SEMICOLON_TOKEN;
        case LESS_THAN_SIGN:
          if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS)
            return this.consumeCodePoint(), this.consumeCodePoint(), CDO_TOKEN;
          break;
        case COMMERCIAL_AT:
          var Pn = this.peekCodePoint(0), Un = this.peekCodePoint(1), Hn = this.peekCodePoint(2);
          if (isIdentifierStart(Pn, Un, Hn)) {
            var Ln = this.consumeName();
            return { type: 7, value: Ln };
          }
          break;
        case LEFT_SQUARE_BRACKET:
          return LEFT_SQUARE_BRACKET_TOKEN;
        case REVERSE_SOLIDUS:
          if (isValidEscape(nr, this.peekCodePoint(0)))
            return this.reconsumeCodePoint(nr), this.consumeIdentLikeToken();
          break;
        case RIGHT_SQUARE_BRACKET:
          return RIGHT_SQUARE_BRACKET_TOKEN;
        case CIRCUMFLEX_ACCENT:
          if (this.peekCodePoint(0) === EQUALS_SIGN)
            return this.consumeCodePoint(), PREFIX_MATCH_TOKEN;
          break;
        case LEFT_CURLY_BRACKET:
          return LEFT_CURLY_BRACKET_TOKEN;
        case RIGHT_CURLY_BRACKET:
          return RIGHT_CURLY_BRACKET_TOKEN;
        case u$2:
        case U$1:
          var zn = this.peekCodePoint(0), Gn = this.peekCodePoint(1);
          return zn === PLUS_SIGN && (isHex(Gn) || Gn === QUESTION_MARK) && (this.consumeCodePoint(), this.consumeUnicodeRangeToken()), this.reconsumeCodePoint(nr), this.consumeIdentLikeToken();
        case VERTICAL_LINE:
          if (this.peekCodePoint(0) === EQUALS_SIGN)
            return this.consumeCodePoint(), DASH_MATCH_TOKEN;
          if (this.peekCodePoint(0) === VERTICAL_LINE)
            return this.consumeCodePoint(), COLUMN_TOKEN;
          break;
        case TILDE:
          if (this.peekCodePoint(0) === EQUALS_SIGN)
            return this.consumeCodePoint(), INCLUDE_MATCH_TOKEN;
          break;
        case EOF:
          return EOF_TOKEN;
      }
      return isWhiteSpace(nr) ? (this.consumeWhiteSpace(), WHITESPACE_TOKEN) : isDigit(nr) ? (this.reconsumeCodePoint(nr), this.consumeNumericToken()) : isNameStartCodePoint(nr) ? (this.reconsumeCodePoint(nr), this.consumeIdentLikeToken()) : { type: 6, value: fromCodePoint$1(nr) };
    }, _n.prototype.consumeCodePoint = function() {
      var nr = this._value.shift();
      return typeof nr > "u" ? -1 : nr;
    }, _n.prototype.reconsumeCodePoint = function(nr) {
      this._value.unshift(nr);
    }, _n.prototype.peekCodePoint = function(nr) {
      return nr >= this._value.length ? -1 : this._value[nr];
    }, _n.prototype.consumeUnicodeRangeToken = function() {
      for (var nr = [], Cn = this.consumeCodePoint(); isHex(Cn) && nr.length < 6; )
        nr.push(Cn), Cn = this.consumeCodePoint();
      for (var Bn = !1; Cn === QUESTION_MARK && nr.length < 6; )
        nr.push(Cn), Cn = this.consumeCodePoint(), Bn = !0;
      if (Bn) {
        var In = parseInt(fromCodePoint$1.apply(void 0, nr.map(function(Nn) {
          return Nn === QUESTION_MARK ? ZERO : Nn;
        })), 16), Dn = parseInt(fromCodePoint$1.apply(void 0, nr.map(function(Nn) {
          return Nn === QUESTION_MARK ? F$2 : Nn;
        })), 16);
        return { type: 30, start: In, end: Dn };
      }
      var Ln = parseInt(fromCodePoint$1.apply(void 0, nr), 16);
      if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
        this.consumeCodePoint(), Cn = this.consumeCodePoint();
        for (var $n = []; isHex(Cn) && $n.length < 6; )
          $n.push(Cn), Cn = this.consumeCodePoint();
        var Dn = parseInt(fromCodePoint$1.apply(void 0, $n), 16);
        return { type: 30, start: Ln, end: Dn };
      } else
        return { type: 30, start: Ln, end: Ln };
    }, _n.prototype.consumeIdentLikeToken = function() {
      var nr = this.consumeName();
      return nr.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS ? (this.consumeCodePoint(), this.consumeUrlToken()) : this.peekCodePoint(0) === LEFT_PARENTHESIS ? (this.consumeCodePoint(), { type: 19, value: nr }) : { type: 20, value: nr };
    }, _n.prototype.consumeUrlToken = function() {
      var nr = [];
      if (this.consumeWhiteSpace(), this.peekCodePoint(0) === EOF)
        return { type: 22, value: "" };
      var Cn = this.peekCodePoint(0);
      if (Cn === APOSTROPHE || Cn === QUOTATION_MARK) {
        var Bn = this.consumeStringToken(this.consumeCodePoint());
        return Bn.type === 0 && (this.consumeWhiteSpace(), this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) ? (this.consumeCodePoint(), { type: 22, value: Bn.value }) : (this.consumeBadUrlRemnants(), BAD_URL_TOKEN);
      }
      for (; ; ) {
        var In = this.consumeCodePoint();
        if (In === EOF || In === RIGHT_PARENTHESIS)
          return { type: 22, value: fromCodePoint$1.apply(void 0, nr) };
        if (isWhiteSpace(In))
          return this.consumeWhiteSpace(), this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS ? (this.consumeCodePoint(), { type: 22, value: fromCodePoint$1.apply(void 0, nr) }) : (this.consumeBadUrlRemnants(), BAD_URL_TOKEN);
        if (In === QUOTATION_MARK || In === APOSTROPHE || In === LEFT_PARENTHESIS || isNonPrintableCodePoint(In))
          return this.consumeBadUrlRemnants(), BAD_URL_TOKEN;
        if (In === REVERSE_SOLIDUS)
          if (isValidEscape(In, this.peekCodePoint(0)))
            nr.push(this.consumeEscapedCodePoint());
          else
            return this.consumeBadUrlRemnants(), BAD_URL_TOKEN;
        else
          nr.push(In);
      }
    }, _n.prototype.consumeWhiteSpace = function() {
      for (; isWhiteSpace(this.peekCodePoint(0)); )
        this.consumeCodePoint();
    }, _n.prototype.consumeBadUrlRemnants = function() {
      for (; ; ) {
        var nr = this.consumeCodePoint();
        if (nr === RIGHT_PARENTHESIS || nr === EOF)
          return;
        isValidEscape(nr, this.peekCodePoint(0)) && this.consumeEscapedCodePoint();
      }
    }, _n.prototype.consumeStringSlice = function(nr) {
      for (var Cn = 5e4, Bn = ""; nr > 0; ) {
        var In = Math.min(Cn, nr);
        Bn += fromCodePoint$1.apply(void 0, this._value.splice(0, In)), nr -= In;
      }
      return this._value.shift(), Bn;
    }, _n.prototype.consumeStringToken = function(nr) {
      var Cn = "", Bn = 0;
      do {
        var In = this._value[Bn];
        if (In === EOF || In === void 0 || In === nr)
          return Cn += this.consumeStringSlice(Bn), { type: 0, value: Cn };
        if (In === LINE_FEED)
          return this._value.splice(0, Bn), BAD_STRING_TOKEN;
        if (In === REVERSE_SOLIDUS) {
          var Dn = this._value[Bn + 1];
          Dn !== EOF && Dn !== void 0 && (Dn === LINE_FEED ? (Cn += this.consumeStringSlice(Bn), Bn = -1, this._value.shift()) : isValidEscape(In, Dn) && (Cn += this.consumeStringSlice(Bn), Cn += fromCodePoint$1(this.consumeEscapedCodePoint()), Bn = -1));
        }
        Bn++;
      } while (!0);
    }, _n.prototype.consumeNumber = function() {
      var nr = [], Cn = FLAG_INTEGER, Bn = this.peekCodePoint(0);
      for ((Bn === PLUS_SIGN || Bn === HYPHEN_MINUS) && nr.push(this.consumeCodePoint()); isDigit(this.peekCodePoint(0)); )
        nr.push(this.consumeCodePoint());
      Bn = this.peekCodePoint(0);
      var In = this.peekCodePoint(1);
      if (Bn === FULL_STOP && isDigit(In))
        for (nr.push(this.consumeCodePoint(), this.consumeCodePoint()), Cn = FLAG_NUMBER; isDigit(this.peekCodePoint(0)); )
          nr.push(this.consumeCodePoint());
      Bn = this.peekCodePoint(0), In = this.peekCodePoint(1);
      var Dn = this.peekCodePoint(2);
      if ((Bn === E$2 || Bn === e$1) && ((In === PLUS_SIGN || In === HYPHEN_MINUS) && isDigit(Dn) || isDigit(In)))
        for (nr.push(this.consumeCodePoint(), this.consumeCodePoint()), Cn = FLAG_NUMBER; isDigit(this.peekCodePoint(0)); )
          nr.push(this.consumeCodePoint());
      return [stringToNumber(nr), Cn];
    }, _n.prototype.consumeNumericToken = function() {
      var nr = this.consumeNumber(), Cn = nr[0], Bn = nr[1], In = this.peekCodePoint(0), Dn = this.peekCodePoint(1), Ln = this.peekCodePoint(2);
      if (isIdentifierStart(In, Dn, Ln)) {
        var $n = this.consumeName();
        return { type: 15, number: Cn, flags: Bn, unit: $n };
      }
      return In === PERCENTAGE_SIGN ? (this.consumeCodePoint(), { type: 16, number: Cn, flags: Bn }) : { type: 17, number: Cn, flags: Bn };
    }, _n.prototype.consumeEscapedCodePoint = function() {
      var nr = this.consumeCodePoint();
      if (isHex(nr)) {
        for (var Cn = fromCodePoint$1(nr); isHex(this.peekCodePoint(0)) && Cn.length < 6; )
          Cn += fromCodePoint$1(this.consumeCodePoint());
        isWhiteSpace(this.peekCodePoint(0)) && this.consumeCodePoint();
        var Bn = parseInt(Cn, 16);
        return Bn === 0 || isSurrogateCodePoint(Bn) || Bn > 1114111 ? REPLACEMENT_CHARACTER : Bn;
      }
      return nr === EOF ? REPLACEMENT_CHARACTER : nr;
    }, _n.prototype.consumeName = function() {
      for (var nr = ""; ; ) {
        var Cn = this.consumeCodePoint();
        if (isNameCodePoint(Cn))
          nr += fromCodePoint$1(Cn);
        else if (isValidEscape(Cn, this.peekCodePoint(0)))
          nr += fromCodePoint$1(this.consumeEscapedCodePoint());
        else
          return this.reconsumeCodePoint(Cn), nr;
      }
    }, _n;
  }()
), Parser = (
  /** @class */
  function() {
    function _n(nr) {
      this._tokens = nr;
    }
    return _n.create = function(nr) {
      var Cn = new Tokenizer();
      return Cn.write(nr), new _n(Cn.read());
    }, _n.parseValue = function(nr) {
      return _n.create(nr).parseComponentValue();
    }, _n.parseValues = function(nr) {
      return _n.create(nr).parseComponentValues();
    }, _n.prototype.parseComponentValue = function() {
      for (var nr = this.consumeToken(); nr.type === 31; )
        nr = this.consumeToken();
      if (nr.type === 32)
        throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      this.reconsumeToken(nr);
      var Cn = this.consumeComponentValue();
      do
        nr = this.consumeToken();
      while (nr.type === 31);
      if (nr.type === 32)
        return Cn;
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    }, _n.prototype.parseComponentValues = function() {
      for (var nr = []; ; ) {
        var Cn = this.consumeComponentValue();
        if (Cn.type === 32)
          return nr;
        nr.push(Cn), nr.push();
      }
    }, _n.prototype.consumeComponentValue = function() {
      var nr = this.consumeToken();
      switch (nr.type) {
        case 11:
        case 28:
        case 2:
          return this.consumeSimpleBlock(nr.type);
        case 19:
          return this.consumeFunction(nr);
      }
      return nr;
    }, _n.prototype.consumeSimpleBlock = function(nr) {
      for (var Cn = { type: nr, values: [] }, Bn = this.consumeToken(); ; ) {
        if (Bn.type === 32 || isEndingTokenFor(Bn, nr))
          return Cn;
        this.reconsumeToken(Bn), Cn.values.push(this.consumeComponentValue()), Bn = this.consumeToken();
      }
    }, _n.prototype.consumeFunction = function(nr) {
      for (var Cn = {
        name: nr.value,
        values: [],
        type: 18
        /* FUNCTION */
      }; ; ) {
        var Bn = this.consumeToken();
        if (Bn.type === 32 || Bn.type === 3)
          return Cn;
        this.reconsumeToken(Bn), Cn.values.push(this.consumeComponentValue());
      }
    }, _n.prototype.consumeToken = function() {
      var nr = this._tokens.shift();
      return typeof nr > "u" ? EOF_TOKEN : nr;
    }, _n.prototype.reconsumeToken = function(nr) {
      this._tokens.unshift(nr);
    }, _n;
  }()
), isDimensionToken = function(_n) {
  return _n.type === 15;
}, isNumberToken = function(_n) {
  return _n.type === 17;
}, isIdentToken = function(_n) {
  return _n.type === 20;
}, isStringToken = function(_n) {
  return _n.type === 0;
}, isIdentWithValue = function(_n, nr) {
  return isIdentToken(_n) && _n.value === nr;
}, nonWhiteSpace = function(_n) {
  return _n.type !== 31;
}, nonFunctionArgSeparator = function(_n) {
  return _n.type !== 31 && _n.type !== 4;
}, parseFunctionArgs = function(_n) {
  var nr = [], Cn = [];
  return _n.forEach(function(Bn) {
    if (Bn.type === 4) {
      if (Cn.length === 0)
        throw new Error("Error parsing function args, zero tokens for arg");
      nr.push(Cn), Cn = [];
      return;
    }
    Bn.type !== 31 && Cn.push(Bn);
  }), Cn.length && nr.push(Cn), nr;
}, isEndingTokenFor = function(_n, nr) {
  return nr === 11 && _n.type === 12 || nr === 28 && _n.type === 29 ? !0 : nr === 2 && _n.type === 3;
}, isLength$1 = function(_n) {
  return _n.type === 17 || _n.type === 15;
}, isLengthPercentage = function(_n) {
  return _n.type === 16 || isLength$1(_n);
}, parseLengthPercentageTuple = function(_n) {
  return _n.length > 1 ? [_n[0], _n[1]] : [_n[0]];
}, ZERO_LENGTH = {
  type: 17,
  number: 0,
  flags: FLAG_INTEGER
}, FIFTY_PERCENT = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
}, HUNDRED_PERCENT = {
  type: 16,
  number: 100,
  flags: FLAG_INTEGER
}, getAbsoluteValueForTuple = function(_n, nr, Cn) {
  var Bn = _n[0], In = _n[1];
  return [getAbsoluteValue(Bn, nr), getAbsoluteValue(typeof In < "u" ? In : Bn, Cn)];
}, getAbsoluteValue = function(_n, nr) {
  if (_n.type === 16)
    return _n.number / 100 * nr;
  if (isDimensionToken(_n))
    switch (_n.unit) {
      case "rem":
      case "em":
        return 16 * _n.number;
      case "px":
      default:
        return _n.number;
    }
  return _n.number;
}, DEG = "deg", GRAD = "grad", RAD = "rad", TURN = "turn", angle = {
  name: "angle",
  parse: function(_n, nr) {
    if (nr.type === 15)
      switch (nr.unit) {
        case DEG:
          return Math.PI * nr.number / 180;
        case GRAD:
          return Math.PI / 200 * nr.number;
        case RAD:
          return nr.number;
        case TURN:
          return Math.PI * 2 * nr.number;
      }
    throw new Error("Unsupported angle type");
  }
}, isAngle = function(_n) {
  return _n.type === 15 && (_n.unit === DEG || _n.unit === GRAD || _n.unit === RAD || _n.unit === TURN);
}, parseNamedSide = function(_n) {
  var nr = _n.filter(isIdentToken).map(function(Cn) {
    return Cn.value;
  }).join(" ");
  switch (nr) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [ZERO_LENGTH, ZERO_LENGTH];
    case "to top":
    case "bottom":
      return deg(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [ZERO_LENGTH, HUNDRED_PERCENT];
    case "to right":
    case "left":
      return deg(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [HUNDRED_PERCENT, HUNDRED_PERCENT];
    case "to bottom":
    case "top":
      return deg(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [HUNDRED_PERCENT, ZERO_LENGTH];
    case "to left":
    case "right":
      return deg(270);
  }
  return 0;
}, deg = function(_n) {
  return Math.PI * _n / 180;
}, color$1 = {
  name: "color",
  parse: function(_n, nr) {
    if (nr.type === 18) {
      var Cn = SUPPORTED_COLOR_FUNCTIONS[nr.name];
      if (typeof Cn > "u")
        throw new Error('Attempting to parse an unsupported color function "' + nr.name + '"');
      return Cn(_n, nr.values);
    }
    if (nr.type === 5) {
      if (nr.value.length === 3) {
        var Bn = nr.value.substring(0, 1), In = nr.value.substring(1, 2), Dn = nr.value.substring(2, 3);
        return pack(parseInt(Bn + Bn, 16), parseInt(In + In, 16), parseInt(Dn + Dn, 16), 1);
      }
      if (nr.value.length === 4) {
        var Bn = nr.value.substring(0, 1), In = nr.value.substring(1, 2), Dn = nr.value.substring(2, 3), Ln = nr.value.substring(3, 4);
        return pack(parseInt(Bn + Bn, 16), parseInt(In + In, 16), parseInt(Dn + Dn, 16), parseInt(Ln + Ln, 16) / 255);
      }
      if (nr.value.length === 6) {
        var Bn = nr.value.substring(0, 2), In = nr.value.substring(2, 4), Dn = nr.value.substring(4, 6);
        return pack(parseInt(Bn, 16), parseInt(In, 16), parseInt(Dn, 16), 1);
      }
      if (nr.value.length === 8) {
        var Bn = nr.value.substring(0, 2), In = nr.value.substring(2, 4), Dn = nr.value.substring(4, 6), Ln = nr.value.substring(6, 8);
        return pack(parseInt(Bn, 16), parseInt(In, 16), parseInt(Dn, 16), parseInt(Ln, 16) / 255);
      }
    }
    if (nr.type === 20) {
      var $n = COLORS[nr.value.toUpperCase()];
      if (typeof $n < "u")
        return $n;
    }
    return COLORS.TRANSPARENT;
  }
}, isTransparent = function(_n) {
  return (255 & _n) === 0;
}, asString = function(_n) {
  var nr = 255 & _n, Cn = 255 & _n >> 8, Bn = 255 & _n >> 16, In = 255 & _n >> 24;
  return nr < 255 ? "rgba(" + In + "," + Bn + "," + Cn + "," + nr / 255 + ")" : "rgb(" + In + "," + Bn + "," + Cn + ")";
}, pack = function(_n, nr, Cn, Bn) {
  return (_n << 24 | nr << 16 | Cn << 8 | Math.round(Bn * 255) << 0) >>> 0;
}, getTokenColorValue = function(_n, nr) {
  if (_n.type === 17)
    return _n.number;
  if (_n.type === 16) {
    var Cn = nr === 3 ? 1 : 255;
    return nr === 3 ? _n.number / 100 * Cn : Math.round(_n.number / 100 * Cn);
  }
  return 0;
}, rgb = function(_n, nr) {
  var Cn = nr.filter(nonFunctionArgSeparator);
  if (Cn.length === 3) {
    var Bn = Cn.map(getTokenColorValue), In = Bn[0], Dn = Bn[1], Ln = Bn[2];
    return pack(In, Dn, Ln, 1);
  }
  if (Cn.length === 4) {
    var $n = Cn.map(getTokenColorValue), In = $n[0], Dn = $n[1], Ln = $n[2], Nn = $n[3];
    return pack(In, Dn, Ln, Nn);
  }
  return 0;
};
function hue2rgb(_n, nr, Cn) {
  return Cn < 0 && (Cn += 1), Cn >= 1 && (Cn -= 1), Cn < 1 / 6 ? (nr - _n) * Cn * 6 + _n : Cn < 1 / 2 ? nr : Cn < 2 / 3 ? (nr - _n) * 6 * (2 / 3 - Cn) + _n : _n;
}
var hsl = function(_n, nr) {
  var Cn = nr.filter(nonFunctionArgSeparator), Bn = Cn[0], In = Cn[1], Dn = Cn[2], Ln = Cn[3], $n = (Bn.type === 17 ? deg(Bn.number) : angle.parse(_n, Bn)) / (Math.PI * 2), Nn = isLengthPercentage(In) ? In.number / 100 : 0, Rn = isLengthPercentage(Dn) ? Dn.number / 100 : 0, Fn = typeof Ln < "u" && isLengthPercentage(Ln) ? getAbsoluteValue(Ln, 1) : 1;
  if (Nn === 0)
    return pack(Rn * 255, Rn * 255, Rn * 255, 1);
  var Pn = Rn <= 0.5 ? Rn * (Nn + 1) : Rn + Nn - Rn * Nn, Un = Rn * 2 - Pn, Hn = hue2rgb(Un, Pn, $n + 1 / 3), zn = hue2rgb(Un, Pn, $n), Gn = hue2rgb(Un, Pn, $n - 1 / 3);
  return pack(Hn * 255, zn * 255, Gn * 255, Fn);
}, SUPPORTED_COLOR_FUNCTIONS = {
  hsl,
  hsla: hsl,
  rgb,
  rgba: rgb
}, parseColor = function(_n, nr) {
  return color$1.parse(_n, Parser.create(nr).parseComponentValue());
}, COLORS = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
}, backgroundClip = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    return nr.map(function(Cn) {
      if (isIdentToken(Cn))
        switch (Cn.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      return 0;
    });
  }
}, backgroundColor = {
  name: "background-color",
  initialValue: "transparent",
  prefix: !1,
  type: 3,
  format: "color"
}, parseColorStop = function(_n, nr) {
  var Cn = color$1.parse(_n, nr[0]), Bn = nr[1];
  return Bn && isLengthPercentage(Bn) ? { color: Cn, stop: Bn } : { color: Cn, stop: null };
}, processColorStops = function(_n, nr) {
  var Cn = _n[0], Bn = _n[_n.length - 1];
  Cn.stop === null && (Cn.stop = ZERO_LENGTH), Bn.stop === null && (Bn.stop = HUNDRED_PERCENT);
  for (var In = [], Dn = 0, Ln = 0; Ln < _n.length; Ln++) {
    var $n = _n[Ln].stop;
    if ($n !== null) {
      var Nn = getAbsoluteValue($n, nr);
      Nn > Dn ? In.push(Nn) : In.push(Dn), Dn = Nn;
    } else
      In.push(null);
  }
  for (var Rn = null, Ln = 0; Ln < In.length; Ln++) {
    var Fn = In[Ln];
    if (Fn === null)
      Rn === null && (Rn = Ln);
    else if (Rn !== null) {
      for (var Pn = Ln - Rn, Un = In[Rn - 1], Hn = (Fn - Un) / (Pn + 1), zn = 1; zn <= Pn; zn++)
        In[Rn + zn - 1] = Hn * zn;
      Rn = null;
    }
  }
  return _n.map(function(Gn, Yn) {
    var Wn = Gn.color;
    return { color: Wn, stop: Math.max(Math.min(1, In[Yn] / nr), 0) };
  });
}, getAngleFromCorner = function(_n, nr, Cn) {
  var Bn = nr / 2, In = Cn / 2, Dn = getAbsoluteValue(_n[0], nr) - Bn, Ln = In - getAbsoluteValue(_n[1], Cn);
  return (Math.atan2(Ln, Dn) + Math.PI * 2) % (Math.PI * 2);
}, calculateGradientDirection = function(_n, nr, Cn) {
  var Bn = typeof _n == "number" ? _n : getAngleFromCorner(_n, nr, Cn), In = Math.abs(nr * Math.sin(Bn)) + Math.abs(Cn * Math.cos(Bn)), Dn = nr / 2, Ln = Cn / 2, $n = In / 2, Nn = Math.sin(Bn - Math.PI / 2) * $n, Rn = Math.cos(Bn - Math.PI / 2) * $n;
  return [In, Dn - Rn, Dn + Rn, Ln - Nn, Ln + Nn];
}, distance = function(_n, nr) {
  return Math.sqrt(_n * _n + nr * nr);
}, findCorner = function(_n, nr, Cn, Bn, In) {
  var Dn = [
    [0, 0],
    [0, nr],
    [_n, 0],
    [_n, nr]
  ];
  return Dn.reduce(function(Ln, $n) {
    var Nn = $n[0], Rn = $n[1], Fn = distance(Cn - Nn, Bn - Rn);
    return (In ? Fn < Ln.optimumDistance : Fn > Ln.optimumDistance) ? {
      optimumCorner: $n,
      optimumDistance: Fn
    } : Ln;
  }, {
    optimumDistance: In ? 1 / 0 : -1 / 0,
    optimumCorner: null
  }).optimumCorner;
}, calculateRadius = function(_n, nr, Cn, Bn, In) {
  var Dn = 0, Ln = 0;
  switch (_n.size) {
    case 0:
      _n.shape === 0 ? Dn = Ln = Math.min(Math.abs(nr), Math.abs(nr - Bn), Math.abs(Cn), Math.abs(Cn - In)) : _n.shape === 1 && (Dn = Math.min(Math.abs(nr), Math.abs(nr - Bn)), Ln = Math.min(Math.abs(Cn), Math.abs(Cn - In)));
      break;
    case 2:
      if (_n.shape === 0)
        Dn = Ln = Math.min(distance(nr, Cn), distance(nr, Cn - In), distance(nr - Bn, Cn), distance(nr - Bn, Cn - In));
      else if (_n.shape === 1) {
        var $n = Math.min(Math.abs(Cn), Math.abs(Cn - In)) / Math.min(Math.abs(nr), Math.abs(nr - Bn)), Nn = findCorner(Bn, In, nr, Cn, !0), Rn = Nn[0], Fn = Nn[1];
        Dn = distance(Rn - nr, (Fn - Cn) / $n), Ln = $n * Dn;
      }
      break;
    case 1:
      _n.shape === 0 ? Dn = Ln = Math.max(Math.abs(nr), Math.abs(nr - Bn), Math.abs(Cn), Math.abs(Cn - In)) : _n.shape === 1 && (Dn = Math.max(Math.abs(nr), Math.abs(nr - Bn)), Ln = Math.max(Math.abs(Cn), Math.abs(Cn - In)));
      break;
    case 3:
      if (_n.shape === 0)
        Dn = Ln = Math.max(distance(nr, Cn), distance(nr, Cn - In), distance(nr - Bn, Cn), distance(nr - Bn, Cn - In));
      else if (_n.shape === 1) {
        var $n = Math.max(Math.abs(Cn), Math.abs(Cn - In)) / Math.max(Math.abs(nr), Math.abs(nr - Bn)), Pn = findCorner(Bn, In, nr, Cn, !1), Rn = Pn[0], Fn = Pn[1];
        Dn = distance(Rn - nr, (Fn - Cn) / $n), Ln = $n * Dn;
      }
      break;
  }
  return Array.isArray(_n.size) && (Dn = getAbsoluteValue(_n.size[0], Bn), Ln = _n.size.length === 2 ? getAbsoluteValue(_n.size[1], In) : Dn), [Dn, Ln];
}, linearGradient = function(_n, nr) {
  var Cn = deg(180), Bn = [];
  return parseFunctionArgs(nr).forEach(function(In, Dn) {
    if (Dn === 0) {
      var Ln = In[0];
      if (Ln.type === 20 && Ln.value === "to") {
        Cn = parseNamedSide(In);
        return;
      } else if (isAngle(Ln)) {
        Cn = angle.parse(_n, Ln);
        return;
      }
    }
    var $n = parseColorStop(_n, In);
    Bn.push($n);
  }), {
    angle: Cn,
    stops: Bn,
    type: 1
    /* LINEAR_GRADIENT */
  };
}, prefixLinearGradient = function(_n, nr) {
  var Cn = deg(180), Bn = [];
  return parseFunctionArgs(nr).forEach(function(In, Dn) {
    if (Dn === 0) {
      var Ln = In[0];
      if (Ln.type === 20 && ["top", "left", "right", "bottom"].indexOf(Ln.value) !== -1) {
        Cn = parseNamedSide(In);
        return;
      } else if (isAngle(Ln)) {
        Cn = (angle.parse(_n, Ln) + deg(270)) % deg(360);
        return;
      }
    }
    var $n = parseColorStop(_n, In);
    Bn.push($n);
  }), {
    angle: Cn,
    stops: Bn,
    type: 1
    /* LINEAR_GRADIENT */
  };
}, webkitGradient = function(_n, nr) {
  var Cn = deg(180), Bn = [], In = 1, Dn = 0, Ln = 3, $n = [];
  return parseFunctionArgs(nr).forEach(function(Nn, Rn) {
    var Fn = Nn[0];
    if (Rn === 0) {
      if (isIdentToken(Fn) && Fn.value === "linear") {
        In = 1;
        return;
      } else if (isIdentToken(Fn) && Fn.value === "radial") {
        In = 2;
        return;
      }
    }
    if (Fn.type === 18) {
      if (Fn.name === "from") {
        var Pn = color$1.parse(_n, Fn.values[0]);
        Bn.push({ stop: ZERO_LENGTH, color: Pn });
      } else if (Fn.name === "to") {
        var Pn = color$1.parse(_n, Fn.values[0]);
        Bn.push({ stop: HUNDRED_PERCENT, color: Pn });
      } else if (Fn.name === "color-stop") {
        var Un = Fn.values.filter(nonFunctionArgSeparator);
        if (Un.length === 2) {
          var Pn = color$1.parse(_n, Un[1]), Hn = Un[0];
          isNumberToken(Hn) && Bn.push({
            stop: { type: 16, number: Hn.number * 100, flags: Hn.flags },
            color: Pn
          });
        }
      }
    }
  }), In === 1 ? {
    angle: (Cn + deg(180)) % deg(360),
    stops: Bn,
    type: In
  } : { size: Ln, shape: Dn, stops: Bn, position: $n, type: In };
}, CLOSEST_SIDE = "closest-side", FARTHEST_SIDE = "farthest-side", CLOSEST_CORNER = "closest-corner", FARTHEST_CORNER = "farthest-corner", CIRCLE = "circle", ELLIPSE = "ellipse", COVER = "cover", CONTAIN = "contain", radialGradient = function(_n, nr) {
  var Cn = 0, Bn = 3, In = [], Dn = [];
  return parseFunctionArgs(nr).forEach(function(Ln, $n) {
    var Nn = !0;
    if ($n === 0) {
      var Rn = !1;
      Nn = Ln.reduce(function(Pn, Un) {
        if (Rn)
          if (isIdentToken(Un))
            switch (Un.value) {
              case "center":
                return Dn.push(FIFTY_PERCENT), Pn;
              case "top":
              case "left":
                return Dn.push(ZERO_LENGTH), Pn;
              case "right":
              case "bottom":
                return Dn.push(HUNDRED_PERCENT), Pn;
            }
          else
            (isLengthPercentage(Un) || isLength$1(Un)) && Dn.push(Un);
        else if (isIdentToken(Un))
          switch (Un.value) {
            case CIRCLE:
              return Cn = 0, !1;
            case ELLIPSE:
              return Cn = 1, !1;
            case "at":
              return Rn = !0, !1;
            case CLOSEST_SIDE:
              return Bn = 0, !1;
            case COVER:
            case FARTHEST_SIDE:
              return Bn = 1, !1;
            case CONTAIN:
            case CLOSEST_CORNER:
              return Bn = 2, !1;
            case FARTHEST_CORNER:
              return Bn = 3, !1;
          }
        else if (isLength$1(Un) || isLengthPercentage(Un))
          return Array.isArray(Bn) || (Bn = []), Bn.push(Un), !1;
        return Pn;
      }, Nn);
    }
    if (Nn) {
      var Fn = parseColorStop(_n, Ln);
      In.push(Fn);
    }
  }), {
    size: Bn,
    shape: Cn,
    stops: In,
    position: Dn,
    type: 2
    /* RADIAL_GRADIENT */
  };
}, prefixRadialGradient = function(_n, nr) {
  var Cn = 0, Bn = 3, In = [], Dn = [];
  return parseFunctionArgs(nr).forEach(function(Ln, $n) {
    var Nn = !0;
    if ($n === 0 ? Nn = Ln.reduce(function(Fn, Pn) {
      if (isIdentToken(Pn))
        switch (Pn.value) {
          case "center":
            return Dn.push(FIFTY_PERCENT), !1;
          case "top":
          case "left":
            return Dn.push(ZERO_LENGTH), !1;
          case "right":
          case "bottom":
            return Dn.push(HUNDRED_PERCENT), !1;
        }
      else if (isLengthPercentage(Pn) || isLength$1(Pn))
        return Dn.push(Pn), !1;
      return Fn;
    }, Nn) : $n === 1 && (Nn = Ln.reduce(function(Fn, Pn) {
      if (isIdentToken(Pn))
        switch (Pn.value) {
          case CIRCLE:
            return Cn = 0, !1;
          case ELLIPSE:
            return Cn = 1, !1;
          case CONTAIN:
          case CLOSEST_SIDE:
            return Bn = 0, !1;
          case FARTHEST_SIDE:
            return Bn = 1, !1;
          case CLOSEST_CORNER:
            return Bn = 2, !1;
          case COVER:
          case FARTHEST_CORNER:
            return Bn = 3, !1;
        }
      else if (isLength$1(Pn) || isLengthPercentage(Pn))
        return Array.isArray(Bn) || (Bn = []), Bn.push(Pn), !1;
      return Fn;
    }, Nn)), Nn) {
      var Rn = parseColorStop(_n, Ln);
      In.push(Rn);
    }
  }), {
    size: Bn,
    shape: Cn,
    stops: In,
    position: Dn,
    type: 2
    /* RADIAL_GRADIENT */
  };
}, isLinearGradient = function(_n) {
  return _n.type === 1;
}, isRadialGradient = function(_n) {
  return _n.type === 2;
}, image = {
  name: "image",
  parse: function(_n, nr) {
    if (nr.type === 22) {
      var Cn = {
        url: nr.value,
        type: 0
        /* URL */
      };
      return _n.cache.addImage(nr.value), Cn;
    }
    if (nr.type === 18) {
      var Bn = SUPPORTED_IMAGE_FUNCTIONS[nr.name];
      if (typeof Bn > "u")
        throw new Error('Attempting to parse an unsupported image function "' + nr.name + '"');
      return Bn(_n, nr.values);
    }
    throw new Error("Unsupported image type " + nr.type);
  }
};
function isSupportedImage(_n) {
  return !(_n.type === 20 && _n.value === "none") && (_n.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[_n.name]);
}
var SUPPORTED_IMAGE_FUNCTIONS = {
  "linear-gradient": linearGradient,
  "-moz-linear-gradient": prefixLinearGradient,
  "-ms-linear-gradient": prefixLinearGradient,
  "-o-linear-gradient": prefixLinearGradient,
  "-webkit-linear-gradient": prefixLinearGradient,
  "radial-gradient": radialGradient,
  "-moz-radial-gradient": prefixRadialGradient,
  "-ms-radial-gradient": prefixRadialGradient,
  "-o-radial-gradient": prefixRadialGradient,
  "-webkit-radial-gradient": prefixRadialGradient,
  "-webkit-gradient": webkitGradient
}, backgroundImage = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(_n, nr) {
    if (nr.length === 0)
      return [];
    var Cn = nr[0];
    return Cn.type === 20 && Cn.value === "none" ? [] : nr.filter(function(Bn) {
      return nonFunctionArgSeparator(Bn) && isSupportedImage(Bn);
    }).map(function(Bn) {
      return image.parse(_n, Bn);
    });
  }
}, backgroundOrigin = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    return nr.map(function(Cn) {
      if (isIdentToken(Cn))
        switch (Cn.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      return 0;
    });
  }
}, backgroundPosition = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: !1,
  parse: function(_n, nr) {
    return parseFunctionArgs(nr).map(function(Cn) {
      return Cn.filter(isLengthPercentage);
    }).map(parseLengthPercentageTuple);
  }
}, backgroundRepeat = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    return parseFunctionArgs(nr).map(function(Cn) {
      return Cn.filter(isIdentToken).map(function(Bn) {
        return Bn.value;
      }).join(" ");
    }).map(parseBackgroundRepeat);
  }
}, parseBackgroundRepeat = function(_n) {
  switch (_n) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
}, BACKGROUND_SIZE;
(function(_n) {
  _n.AUTO = "auto", _n.CONTAIN = "contain", _n.COVER = "cover";
})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
var backgroundSize = {
  name: "background-size",
  initialValue: "0",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    return parseFunctionArgs(nr).map(function(Cn) {
      return Cn.filter(isBackgroundSizeInfoToken);
    });
  }
}, isBackgroundSizeInfoToken = function(_n) {
  return isIdentToken(_n) || isLengthPercentage(_n);
}, borderColorForSide = function(_n) {
  return {
    name: "border-" + _n + "-color",
    initialValue: "transparent",
    prefix: !1,
    type: 3,
    format: "color"
  };
}, borderTopColor = borderColorForSide("top"), borderRightColor = borderColorForSide("right"), borderBottomColor = borderColorForSide("bottom"), borderLeftColor = borderColorForSide("left"), borderRadiusForSide = function(_n) {
  return {
    name: "border-radius-" + _n,
    initialValue: "0 0",
    prefix: !1,
    type: 1,
    parse: function(nr, Cn) {
      return parseLengthPercentageTuple(Cn.filter(isLengthPercentage));
    }
  };
}, borderTopLeftRadius = borderRadiusForSide("top-left"), borderTopRightRadius = borderRadiusForSide("top-right"), borderBottomRightRadius = borderRadiusForSide("bottom-right"), borderBottomLeftRadius = borderRadiusForSide("bottom-left"), borderStyleForSide = function(_n) {
  return {
    name: "border-" + _n + "-style",
    initialValue: "solid",
    prefix: !1,
    type: 2,
    parse: function(nr, Cn) {
      switch (Cn) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
}, borderTopStyle = borderStyleForSide("top"), borderRightStyle = borderStyleForSide("right"), borderBottomStyle = borderStyleForSide("bottom"), borderLeftStyle = borderStyleForSide("left"), borderWidthForSide = function(_n) {
  return {
    name: "border-" + _n + "-width",
    initialValue: "0",
    type: 0,
    prefix: !1,
    parse: function(nr, Cn) {
      return isDimensionToken(Cn) ? Cn.number : 0;
    }
  };
}, borderTopWidth = borderWidthForSide("top"), borderRightWidth = borderWidthForSide("right"), borderBottomWidth = borderWidthForSide("bottom"), borderLeftWidth = borderWidthForSide("left"), color = {
  name: "color",
  initialValue: "transparent",
  prefix: !1,
  type: 3,
  format: "color"
}, direction = {
  name: "direction",
  initialValue: "ltr",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
}, display = {
  name: "display",
  initialValue: "inline-block",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    return nr.filter(isIdentToken).reduce(
      function(Cn, Bn) {
        return Cn | parseDisplayValue(Bn.value);
      },
      0
      /* NONE */
    );
  }
}, parseDisplayValue = function(_n) {
  switch (_n) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
}, float = {
  name: "float",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
}, letterSpacing = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: !1,
  type: 0,
  parse: function(_n, nr) {
    return nr.type === 20 && nr.value === "normal" ? 0 : nr.type === 17 || nr.type === 15 ? nr.number : 0;
  }
}, LINE_BREAK;
(function(_n) {
  _n.NORMAL = "normal", _n.STRICT = "strict";
})(LINE_BREAK || (LINE_BREAK = {}));
var lineBreak = {
  name: "line-break",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "strict":
        return LINE_BREAK.STRICT;
      case "normal":
      default:
        return LINE_BREAK.NORMAL;
    }
  }
}, lineHeight = {
  name: "line-height",
  initialValue: "normal",
  prefix: !1,
  type: 4
  /* TOKEN_VALUE */
}, computeLineHeight = function(_n, nr) {
  return isIdentToken(_n) && _n.value === "normal" ? 1.2 * nr : _n.type === 17 ? nr * _n.number : isLengthPercentage(_n) ? getAbsoluteValue(_n, nr) : nr;
}, listStyleImage = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: !1,
  parse: function(_n, nr) {
    return nr.type === 20 && nr.value === "none" ? null : image.parse(_n, nr);
  }
}, listStylePosition = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
}, listStyleType = {
  name: "list-style-type",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
}, marginForSide = function(_n) {
  return {
    name: "margin-" + _n,
    initialValue: "0",
    prefix: !1,
    type: 4
    /* TOKEN_VALUE */
  };
}, marginTop = marginForSide("top"), marginRight = marginForSide("right"), marginBottom = marginForSide("bottom"), marginLeft = marginForSide("left"), overflow = {
  name: "overflow",
  initialValue: "visible",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    return nr.filter(isIdentToken).map(function(Cn) {
      switch (Cn.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
}, overflowWrap = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
}, paddingForSide = function(_n) {
  return {
    name: "padding-" + _n,
    initialValue: "0",
    prefix: !1,
    type: 3,
    format: "length-percentage"
  };
}, paddingTop = paddingForSide("top"), paddingRight = paddingForSide("right"), paddingBottom = paddingForSide("bottom"), paddingLeft = paddingForSide("left"), textAlign = {
  name: "text-align",
  initialValue: "left",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
}, position$1 = {
  name: "position",
  initialValue: "static",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
}, textShadow = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(_n, nr) {
    return nr.length === 1 && isIdentWithValue(nr[0], "none") ? [] : parseFunctionArgs(nr).map(function(Cn) {
      for (var Bn = {
        color: COLORS.TRANSPARENT,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH
      }, In = 0, Dn = 0; Dn < Cn.length; Dn++) {
        var Ln = Cn[Dn];
        isLength$1(Ln) ? (In === 0 ? Bn.offsetX = Ln : In === 1 ? Bn.offsetY = Ln : Bn.blur = Ln, In++) : Bn.color = color$1.parse(_n, Ln);
      }
      return Bn;
    });
  }
}, textTransform = {
  name: "text-transform",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
}, transform$1 = {
  name: "transform",
  initialValue: "none",
  prefix: !0,
  type: 0,
  parse: function(_n, nr) {
    if (nr.type === 20 && nr.value === "none")
      return null;
    if (nr.type === 18) {
      var Cn = SUPPORTED_TRANSFORM_FUNCTIONS[nr.name];
      if (typeof Cn > "u")
        throw new Error('Attempting to parse an unsupported transform function "' + nr.name + '"');
      return Cn(nr.values);
    }
    return null;
  }
}, matrix = function(_n) {
  var nr = _n.filter(function(Cn) {
    return Cn.type === 17;
  }).map(function(Cn) {
    return Cn.number;
  });
  return nr.length === 6 ? nr : null;
}, matrix3d = function(_n) {
  var nr = _n.filter(function(Nn) {
    return Nn.type === 17;
  }).map(function(Nn) {
    return Nn.number;
  }), Cn = nr[0], Bn = nr[1];
  nr[2], nr[3];
  var In = nr[4], Dn = nr[5];
  nr[6], nr[7], nr[8], nr[9], nr[10], nr[11];
  var Ln = nr[12], $n = nr[13];
  return nr[14], nr[15], nr.length === 16 ? [Cn, Bn, In, Dn, Ln, $n] : null;
}, SUPPORTED_TRANSFORM_FUNCTIONS = {
  matrix,
  matrix3d
}, DEFAULT_VALUE = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
}, DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE], transformOrigin = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: !0,
  type: 1,
  parse: function(_n, nr) {
    var Cn = nr.filter(isLengthPercentage);
    return Cn.length !== 2 ? DEFAULT : [Cn[0], Cn[1]];
  }
}, visibility = {
  name: "visible",
  initialValue: "none",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
}, WORD_BREAK;
(function(_n) {
  _n.NORMAL = "normal", _n.BREAK_ALL = "break-all", _n.KEEP_ALL = "keep-all";
})(WORD_BREAK || (WORD_BREAK = {}));
var wordBreak = {
  name: "word-break",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "break-all":
        return WORD_BREAK.BREAK_ALL;
      case "keep-all":
        return WORD_BREAK.KEEP_ALL;
      case "normal":
      default:
        return WORD_BREAK.NORMAL;
    }
  }
}, zIndex = {
  name: "z-index",
  initialValue: "auto",
  prefix: !1,
  type: 0,
  parse: function(_n, nr) {
    if (nr.type === 20)
      return { auto: !0, order: 0 };
    if (isNumberToken(nr))
      return { auto: !1, order: nr.number };
    throw new Error("Invalid z-index number parsed");
  }
}, time = {
  name: "time",
  parse: function(_n, nr) {
    if (nr.type === 15)
      switch (nr.unit.toLowerCase()) {
        case "s":
          return 1e3 * nr.number;
        case "ms":
          return nr.number;
      }
    throw new Error("Unsupported time type");
  }
}, opacity = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: !1,
  parse: function(_n, nr) {
    return isNumberToken(nr) ? nr.number : 1;
  }
}, textDecorationColor = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: !1,
  type: 3,
  format: "color"
}, textDecorationLine = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    return nr.filter(isIdentToken).map(function(Cn) {
      switch (Cn.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(Cn) {
      return Cn !== 0;
    });
  }
}, fontFamily = {
  name: "font-family",
  initialValue: "",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    var Cn = [], Bn = [];
    return nr.forEach(function(In) {
      switch (In.type) {
        case 20:
        case 0:
          Cn.push(In.value);
          break;
        case 17:
          Cn.push(In.number.toString());
          break;
        case 4:
          Bn.push(Cn.join(" ")), Cn.length = 0;
          break;
      }
    }), Cn.length && Bn.push(Cn.join(" ")), Bn.map(function(In) {
      return In.indexOf(" ") === -1 ? In : "'" + In + "'";
    });
  }
}, fontSize = {
  name: "font-size",
  initialValue: "0",
  prefix: !1,
  type: 3,
  format: "length"
}, fontWeight = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: !1,
  parse: function(_n, nr) {
    if (isNumberToken(nr))
      return nr.number;
    if (isIdentToken(nr))
      switch (nr.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    return 400;
  }
}, fontVariant = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(_n, nr) {
    return nr.filter(isIdentToken).map(function(Cn) {
      return Cn.value;
    });
  }
}, fontStyle = {
  name: "font-style",
  initialValue: "normal",
  prefix: !1,
  type: 2,
  parse: function(_n, nr) {
    switch (nr) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
}, contains$1 = function(_n, nr) {
  return (_n & nr) !== 0;
}, content = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(_n, nr) {
    if (nr.length === 0)
      return [];
    var Cn = nr[0];
    return Cn.type === 20 && Cn.value === "none" ? [] : nr;
  }
}, counterIncrement = {
  name: "counter-increment",
  initialValue: "none",
  prefix: !0,
  type: 1,
  parse: function(_n, nr) {
    if (nr.length === 0)
      return null;
    var Cn = nr[0];
    if (Cn.type === 20 && Cn.value === "none")
      return null;
    for (var Bn = [], In = nr.filter(nonWhiteSpace), Dn = 0; Dn < In.length; Dn++) {
      var Ln = In[Dn], $n = In[Dn + 1];
      if (Ln.type === 20) {
        var Nn = $n && isNumberToken($n) ? $n.number : 1;
        Bn.push({ counter: Ln.value, increment: Nn });
      }
    }
    return Bn;
  }
}, counterReset = {
  name: "counter-reset",
  initialValue: "none",
  prefix: !0,
  type: 1,
  parse: function(_n, nr) {
    if (nr.length === 0)
      return [];
    for (var Cn = [], Bn = nr.filter(nonWhiteSpace), In = 0; In < Bn.length; In++) {
      var Dn = Bn[In], Ln = Bn[In + 1];
      if (isIdentToken(Dn) && Dn.value !== "none") {
        var $n = Ln && isNumberToken(Ln) ? Ln.number : 0;
        Cn.push({ counter: Dn.value, reset: $n });
      }
    }
    return Cn;
  }
}, duration = {
  name: "duration",
  initialValue: "0s",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    return nr.filter(isDimensionToken).map(function(Cn) {
      return time.parse(_n, Cn);
    });
  }
}, quotes = {
  name: "quotes",
  initialValue: "none",
  prefix: !0,
  type: 1,
  parse: function(_n, nr) {
    if (nr.length === 0)
      return null;
    var Cn = nr[0];
    if (Cn.type === 20 && Cn.value === "none")
      return null;
    var Bn = [], In = nr.filter(isStringToken);
    if (In.length % 2 !== 0)
      return null;
    for (var Dn = 0; Dn < In.length; Dn += 2) {
      var Ln = In[Dn].value, $n = In[Dn + 1].value;
      Bn.push({ open: Ln, close: $n });
    }
    return Bn;
  }
}, getQuote = function(_n, nr, Cn) {
  if (!_n)
    return "";
  var Bn = _n[Math.min(nr, _n.length - 1)];
  return Bn ? Cn ? Bn.open : Bn.close : "";
}, boxShadow = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: !1,
  parse: function(_n, nr) {
    return nr.length === 1 && isIdentWithValue(nr[0], "none") ? [] : parseFunctionArgs(nr).map(function(Cn) {
      for (var Bn = {
        color: 255,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH,
        spread: ZERO_LENGTH,
        inset: !1
      }, In = 0, Dn = 0; Dn < Cn.length; Dn++) {
        var Ln = Cn[Dn];
        isIdentWithValue(Ln, "inset") ? Bn.inset = !0 : isLength$1(Ln) ? (In === 0 ? Bn.offsetX = Ln : In === 1 ? Bn.offsetY = Ln : In === 2 ? Bn.blur = Ln : Bn.spread = Ln, In++) : Bn.color = color$1.parse(_n, Ln);
      }
      return Bn;
    });
  }
}, paintOrder = {
  name: "paint-order",
  initialValue: "normal",
  prefix: !1,
  type: 1,
  parse: function(_n, nr) {
    var Cn = [
      0,
      1,
      2
      /* MARKERS */
    ], Bn = [];
    return nr.filter(isIdentToken).forEach(function(In) {
      switch (In.value) {
        case "stroke":
          Bn.push(
            1
            /* STROKE */
          );
          break;
        case "fill":
          Bn.push(
            0
            /* FILL */
          );
          break;
        case "markers":
          Bn.push(
            2
            /* MARKERS */
          );
          break;
      }
    }), Cn.forEach(function(In) {
      Bn.indexOf(In) === -1 && Bn.push(In);
    }), Bn;
  }
}, webkitTextStrokeColor = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: !1,
  type: 3,
  format: "color"
}, webkitTextStrokeWidth = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: !1,
  parse: function(_n, nr) {
    return isDimensionToken(nr) ? nr.number : 0;
  }
}, CSSParsedDeclaration = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      var Bn, In;
      this.animationDuration = parse$1(nr, duration, Cn.animationDuration), this.backgroundClip = parse$1(nr, backgroundClip, Cn.backgroundClip), this.backgroundColor = parse$1(nr, backgroundColor, Cn.backgroundColor), this.backgroundImage = parse$1(nr, backgroundImage, Cn.backgroundImage), this.backgroundOrigin = parse$1(nr, backgroundOrigin, Cn.backgroundOrigin), this.backgroundPosition = parse$1(nr, backgroundPosition, Cn.backgroundPosition), this.backgroundRepeat = parse$1(nr, backgroundRepeat, Cn.backgroundRepeat), this.backgroundSize = parse$1(nr, backgroundSize, Cn.backgroundSize), this.borderTopColor = parse$1(nr, borderTopColor, Cn.borderTopColor), this.borderRightColor = parse$1(nr, borderRightColor, Cn.borderRightColor), this.borderBottomColor = parse$1(nr, borderBottomColor, Cn.borderBottomColor), this.borderLeftColor = parse$1(nr, borderLeftColor, Cn.borderLeftColor), this.borderTopLeftRadius = parse$1(nr, borderTopLeftRadius, Cn.borderTopLeftRadius), this.borderTopRightRadius = parse$1(nr, borderTopRightRadius, Cn.borderTopRightRadius), this.borderBottomRightRadius = parse$1(nr, borderBottomRightRadius, Cn.borderBottomRightRadius), this.borderBottomLeftRadius = parse$1(nr, borderBottomLeftRadius, Cn.borderBottomLeftRadius), this.borderTopStyle = parse$1(nr, borderTopStyle, Cn.borderTopStyle), this.borderRightStyle = parse$1(nr, borderRightStyle, Cn.borderRightStyle), this.borderBottomStyle = parse$1(nr, borderBottomStyle, Cn.borderBottomStyle), this.borderLeftStyle = parse$1(nr, borderLeftStyle, Cn.borderLeftStyle), this.borderTopWidth = parse$1(nr, borderTopWidth, Cn.borderTopWidth), this.borderRightWidth = parse$1(nr, borderRightWidth, Cn.borderRightWidth), this.borderBottomWidth = parse$1(nr, borderBottomWidth, Cn.borderBottomWidth), this.borderLeftWidth = parse$1(nr, borderLeftWidth, Cn.borderLeftWidth), this.boxShadow = parse$1(nr, boxShadow, Cn.boxShadow), this.color = parse$1(nr, color, Cn.color), this.direction = parse$1(nr, direction, Cn.direction), this.display = parse$1(nr, display, Cn.display), this.float = parse$1(nr, float, Cn.cssFloat), this.fontFamily = parse$1(nr, fontFamily, Cn.fontFamily), this.fontSize = parse$1(nr, fontSize, Cn.fontSize), this.fontStyle = parse$1(nr, fontStyle, Cn.fontStyle), this.fontVariant = parse$1(nr, fontVariant, Cn.fontVariant), this.fontWeight = parse$1(nr, fontWeight, Cn.fontWeight), this.letterSpacing = parse$1(nr, letterSpacing, Cn.letterSpacing), this.lineBreak = parse$1(nr, lineBreak, Cn.lineBreak), this.lineHeight = parse$1(nr, lineHeight, Cn.lineHeight), this.listStyleImage = parse$1(nr, listStyleImage, Cn.listStyleImage), this.listStylePosition = parse$1(nr, listStylePosition, Cn.listStylePosition), this.listStyleType = parse$1(nr, listStyleType, Cn.listStyleType), this.marginTop = parse$1(nr, marginTop, Cn.marginTop), this.marginRight = parse$1(nr, marginRight, Cn.marginRight), this.marginBottom = parse$1(nr, marginBottom, Cn.marginBottom), this.marginLeft = parse$1(nr, marginLeft, Cn.marginLeft), this.opacity = parse$1(nr, opacity, Cn.opacity);
      var Dn = parse$1(nr, overflow, Cn.overflow);
      this.overflowX = Dn[0], this.overflowY = Dn[Dn.length > 1 ? 1 : 0], this.overflowWrap = parse$1(nr, overflowWrap, Cn.overflowWrap), this.paddingTop = parse$1(nr, paddingTop, Cn.paddingTop), this.paddingRight = parse$1(nr, paddingRight, Cn.paddingRight), this.paddingBottom = parse$1(nr, paddingBottom, Cn.paddingBottom), this.paddingLeft = parse$1(nr, paddingLeft, Cn.paddingLeft), this.paintOrder = parse$1(nr, paintOrder, Cn.paintOrder), this.position = parse$1(nr, position$1, Cn.position), this.textAlign = parse$1(nr, textAlign, Cn.textAlign), this.textDecorationColor = parse$1(nr, textDecorationColor, (Bn = Cn.textDecorationColor) !== null && Bn !== void 0 ? Bn : Cn.color), this.textDecorationLine = parse$1(nr, textDecorationLine, (In = Cn.textDecorationLine) !== null && In !== void 0 ? In : Cn.textDecoration), this.textShadow = parse$1(nr, textShadow, Cn.textShadow), this.textTransform = parse$1(nr, textTransform, Cn.textTransform), this.transform = parse$1(nr, transform$1, Cn.transform), this.transformOrigin = parse$1(nr, transformOrigin, Cn.transformOrigin), this.visibility = parse$1(nr, visibility, Cn.visibility), this.webkitTextStrokeColor = parse$1(nr, webkitTextStrokeColor, Cn.webkitTextStrokeColor), this.webkitTextStrokeWidth = parse$1(nr, webkitTextStrokeWidth, Cn.webkitTextStrokeWidth), this.wordBreak = parse$1(nr, wordBreak, Cn.wordBreak), this.zIndex = parse$1(nr, zIndex, Cn.zIndex);
    }
    return _n.prototype.isVisible = function() {
      return this.display > 0 && this.opacity > 0 && this.visibility === 0;
    }, _n.prototype.isTransparent = function() {
      return isTransparent(this.backgroundColor);
    }, _n.prototype.isTransformed = function() {
      return this.transform !== null;
    }, _n.prototype.isPositioned = function() {
      return this.position !== 0;
    }, _n.prototype.isPositionedWithZIndex = function() {
      return this.isPositioned() && !this.zIndex.auto;
    }, _n.prototype.isFloating = function() {
      return this.float !== 0;
    }, _n.prototype.isInlineLevel = function() {
      return contains$1(
        this.display,
        4
        /* INLINE */
      ) || contains$1(
        this.display,
        33554432
        /* INLINE_BLOCK */
      ) || contains$1(
        this.display,
        268435456
        /* INLINE_FLEX */
      ) || contains$1(
        this.display,
        536870912
        /* INLINE_GRID */
      ) || contains$1(
        this.display,
        67108864
        /* INLINE_LIST_ITEM */
      ) || contains$1(
        this.display,
        134217728
        /* INLINE_TABLE */
      );
    }, _n;
  }()
), CSSParsedPseudoDeclaration = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.content = parse$1(nr, content, Cn.content), this.quotes = parse$1(nr, quotes, Cn.quotes);
    }
    return _n;
  }()
), CSSParsedCounterDeclaration = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.counterIncrement = parse$1(nr, counterIncrement, Cn.counterIncrement), this.counterReset = parse$1(nr, counterReset, Cn.counterReset);
    }
    return _n;
  }()
), parse$1 = function(_n, nr, Cn) {
  var Bn = new Tokenizer(), In = Cn !== null && typeof Cn < "u" ? Cn.toString() : nr.initialValue;
  Bn.write(In);
  var Dn = new Parser(Bn.read());
  switch (nr.type) {
    case 2:
      var Ln = Dn.parseComponentValue();
      return nr.parse(_n, isIdentToken(Ln) ? Ln.value : nr.initialValue);
    case 0:
      return nr.parse(_n, Dn.parseComponentValue());
    case 1:
      return nr.parse(_n, Dn.parseComponentValues());
    case 4:
      return Dn.parseComponentValue();
    case 3:
      switch (nr.format) {
        case "angle":
          return angle.parse(_n, Dn.parseComponentValue());
        case "color":
          return color$1.parse(_n, Dn.parseComponentValue());
        case "image":
          return image.parse(_n, Dn.parseComponentValue());
        case "length":
          var $n = Dn.parseComponentValue();
          return isLength$1($n) ? $n : ZERO_LENGTH;
        case "length-percentage":
          var Nn = Dn.parseComponentValue();
          return isLengthPercentage(Nn) ? Nn : ZERO_LENGTH;
        case "time":
          return time.parse(_n, Dn.parseComponentValue());
      }
      break;
  }
}, elementDebuggerAttribute = "data-html2canvas-debug", getElementDebugType = function(_n) {
  var nr = _n.getAttribute(elementDebuggerAttribute);
  switch (nr) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
}, isDebugging = function(_n, nr) {
  var Cn = getElementDebugType(_n);
  return Cn === 1 || nr === Cn;
}, ElementContainer = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      if (this.context = nr, this.textNodes = [], this.elements = [], this.flags = 0, isDebugging(
        Cn,
        3
        /* PARSE */
      ))
        debugger;
      this.styles = new CSSParsedDeclaration(nr, window.getComputedStyle(Cn, null)), isHTMLElementNode(Cn) && (this.styles.animationDuration.some(function(Bn) {
        return Bn > 0;
      }) && (Cn.style.animationDuration = "0s"), this.styles.transform !== null && (Cn.style.transform = "none")), this.bounds = parseBounds(this.context, Cn), isDebugging(
        Cn,
        4
        /* RENDER */
      ) && (this.flags |= 16);
    }
    return _n;
  }()
), base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=", chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$1 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var i$1$2 = 0; i$1$2 < chars$1.length; i$1$2++)
  lookup$1[chars$1.charCodeAt(i$1$2)] = i$1$2;
var decode$2 = function(_n) {
  var nr = _n.length * 0.75, Cn = _n.length, Bn, In = 0, Dn, Ln, $n, Nn;
  _n[_n.length - 1] === "=" && (nr--, _n[_n.length - 2] === "=" && nr--);
  var Rn = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(nr) : new Array(nr), Fn = Array.isArray(Rn) ? Rn : new Uint8Array(Rn);
  for (Bn = 0; Bn < Cn; Bn += 4)
    Dn = lookup$1[_n.charCodeAt(Bn)], Ln = lookup$1[_n.charCodeAt(Bn + 1)], $n = lookup$1[_n.charCodeAt(Bn + 2)], Nn = lookup$1[_n.charCodeAt(Bn + 3)], Fn[In++] = Dn << 2 | Ln >> 4, Fn[In++] = (Ln & 15) << 4 | $n >> 2, Fn[In++] = ($n & 3) << 6 | Nn & 63;
  return Rn;
}, polyUint16Array = function(_n) {
  for (var nr = _n.length, Cn = [], Bn = 0; Bn < nr; Bn += 2)
    Cn.push(_n[Bn + 1] << 8 | _n[Bn]);
  return Cn;
}, polyUint32Array = function(_n) {
  for (var nr = _n.length, Cn = [], Bn = 0; Bn < nr; Bn += 4)
    Cn.push(_n[Bn + 3] << 24 | _n[Bn + 2] << 16 | _n[Bn + 1] << 8 | _n[Bn]);
  return Cn;
}, UTRIE2_SHIFT_2 = 5, UTRIE2_SHIFT_1 = 6 + 5, UTRIE2_INDEX_SHIFT = 2, UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2, UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2, UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2, UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1, UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2, UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH, UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH, UTRIE2_UTF8_2B_INDEX_2_LENGTH = 32, UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH, UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1, UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2, UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1, slice16 = function(_n, nr, Cn) {
  return _n.slice ? _n.slice(nr, Cn) : new Uint16Array(Array.prototype.slice.call(_n, nr, Cn));
}, slice32 = function(_n, nr, Cn) {
  return _n.slice ? _n.slice(nr, Cn) : new Uint32Array(Array.prototype.slice.call(_n, nr, Cn));
}, createTrieFromBase64 = function(_n, nr) {
  var Cn = decode$2(_n), Bn = Array.isArray(Cn) ? polyUint32Array(Cn) : new Uint32Array(Cn), In = Array.isArray(Cn) ? polyUint16Array(Cn) : new Uint16Array(Cn), Dn = 24, Ln = slice16(In, Dn / 2, Bn[4] / 2), $n = Bn[5] === 2 ? slice16(In, (Dn + Bn[4]) / 2) : slice32(Bn, Math.ceil((Dn + Bn[4]) / 4));
  return new Trie(Bn[0], Bn[1], Bn[2], Bn[3], Ln, $n);
}, Trie = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn, In, Dn, Ln) {
      this.initialValue = nr, this.errorValue = Cn, this.highStart = Bn, this.highValueIndex = In, this.index = Dn, this.data = Ln;
    }
    return _n.prototype.get = function(nr) {
      var Cn;
      if (nr >= 0) {
        if (nr < 55296 || nr > 56319 && nr <= 65535)
          return Cn = this.index[nr >> UTRIE2_SHIFT_2], Cn = (Cn << UTRIE2_INDEX_SHIFT) + (nr & UTRIE2_DATA_MASK), this.data[Cn];
        if (nr <= 65535)
          return Cn = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (nr - 55296 >> UTRIE2_SHIFT_2)], Cn = (Cn << UTRIE2_INDEX_SHIFT) + (nr & UTRIE2_DATA_MASK), this.data[Cn];
        if (nr < this.highStart)
          return Cn = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (nr >> UTRIE2_SHIFT_1), Cn = this.index[Cn], Cn += nr >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK, Cn = this.index[Cn], Cn = (Cn << UTRIE2_INDEX_SHIFT) + (nr & UTRIE2_DATA_MASK), this.data[Cn];
        if (nr <= 1114111)
          return this.data[this.highValueIndex];
      }
      return this.errorValue;
    }, _n;
  }()
), chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var i$4 = 0; i$4 < chars.length; i$4++)
  lookup[chars.charCodeAt(i$4)] = i$4;
var Prepend = 1, CR = 2, LF = 3, Control = 4, Extend = 5, SpacingMark = 7, L$2 = 8, V$2 = 9, T$2 = 10, LV = 11, LVT = 12, ZWJ = 13, Extended_Pictographic = 14, RI = 15, toCodePoints = function(_n) {
  for (var nr = [], Cn = 0, Bn = _n.length; Cn < Bn; ) {
    var In = _n.charCodeAt(Cn++);
    if (In >= 55296 && In <= 56319 && Cn < Bn) {
      var Dn = _n.charCodeAt(Cn++);
      (Dn & 64512) === 56320 ? nr.push(((In & 1023) << 10) + (Dn & 1023) + 65536) : (nr.push(In), Cn--);
    } else
      nr.push(In);
  }
  return nr;
}, fromCodePoint = function() {
  for (var _n = [], nr = 0; nr < arguments.length; nr++)
    _n[nr] = arguments[nr];
  if (String.fromCodePoint)
    return String.fromCodePoint.apply(String, _n);
  var Cn = _n.length;
  if (!Cn)
    return "";
  for (var Bn = [], In = -1, Dn = ""; ++In < Cn; ) {
    var Ln = _n[In];
    Ln <= 65535 ? Bn.push(Ln) : (Ln -= 65536, Bn.push((Ln >> 10) + 55296, Ln % 1024 + 56320)), (In + 1 === Cn || Bn.length > 16384) && (Dn += String.fromCharCode.apply(String, Bn), Bn.length = 0);
  }
  return Dn;
}, UnicodeTrie = createTrieFromBase64(base64), BREAK_NOT_ALLOWED = "×", BREAK_ALLOWED = "÷", codePointToClass = function(_n) {
  return UnicodeTrie.get(_n);
}, _graphemeBreakAtIndex = function(_n, nr, Cn) {
  var Bn = Cn - 2, In = nr[Bn], Dn = nr[Cn - 1], Ln = nr[Cn];
  if (Dn === CR && Ln === LF)
    return BREAK_NOT_ALLOWED;
  if (Dn === CR || Dn === LF || Dn === Control || Ln === CR || Ln === LF || Ln === Control)
    return BREAK_ALLOWED;
  if (Dn === L$2 && [L$2, V$2, LV, LVT].indexOf(Ln) !== -1 || (Dn === LV || Dn === V$2) && (Ln === V$2 || Ln === T$2) || (Dn === LVT || Dn === T$2) && Ln === T$2 || Ln === ZWJ || Ln === Extend || Ln === SpacingMark || Dn === Prepend)
    return BREAK_NOT_ALLOWED;
  if (Dn === ZWJ && Ln === Extended_Pictographic) {
    for (; In === Extend; )
      In = nr[--Bn];
    if (In === Extended_Pictographic)
      return BREAK_NOT_ALLOWED;
  }
  if (Dn === RI && Ln === RI) {
    for (var $n = 0; In === RI; )
      $n++, In = nr[--Bn];
    if ($n % 2 === 0)
      return BREAK_NOT_ALLOWED;
  }
  return BREAK_ALLOWED;
}, GraphemeBreaker = function(_n) {
  var nr = toCodePoints(_n), Cn = nr.length, Bn = 0, In = 0, Dn = nr.map(codePointToClass);
  return {
    next: function() {
      if (Bn >= Cn)
        return { done: !0, value: null };
      for (var Ln = BREAK_NOT_ALLOWED; Bn < Cn && (Ln = _graphemeBreakAtIndex(nr, Dn, ++Bn)) === BREAK_NOT_ALLOWED; )
        ;
      if (Ln !== BREAK_NOT_ALLOWED || Bn === Cn) {
        var $n = fromCodePoint.apply(null, nr.slice(In, Bn));
        return In = Bn, { value: $n, done: !1 };
      }
      return { done: !0, value: null };
    }
  };
}, splitGraphemes = function(_n) {
  for (var nr = GraphemeBreaker(_n), Cn = [], Bn; !(Bn = nr.next()).done; )
    Bn.value && Cn.push(Bn.value.slice());
  return Cn;
}, testRangeBounds = function(_n) {
  var nr = 123;
  if (_n.createRange) {
    var Cn = _n.createRange();
    if (Cn.getBoundingClientRect) {
      var Bn = _n.createElement("boundtest");
      Bn.style.height = nr + "px", Bn.style.display = "block", _n.body.appendChild(Bn), Cn.selectNode(Bn);
      var In = Cn.getBoundingClientRect(), Dn = Math.round(In.height);
      if (_n.body.removeChild(Bn), Dn === nr)
        return !0;
    }
  }
  return !1;
}, testIOSLineBreak = function(_n) {
  var nr = _n.createElement("boundtest");
  nr.style.width = "50px", nr.style.display = "block", nr.style.fontSize = "12px", nr.style.letterSpacing = "0px", nr.style.wordSpacing = "0px", _n.body.appendChild(nr);
  var Cn = _n.createRange();
  nr.innerHTML = typeof "".repeat == "function" ? "&#128104;".repeat(10) : "";
  var Bn = nr.firstChild, In = toCodePoints$1(Bn.data).map(function(Nn) {
    return fromCodePoint$1(Nn);
  }), Dn = 0, Ln = {}, $n = In.every(function(Nn, Rn) {
    Cn.setStart(Bn, Dn), Cn.setEnd(Bn, Dn + Nn.length);
    var Fn = Cn.getBoundingClientRect();
    Dn += Nn.length;
    var Pn = Fn.x > Ln.x || Fn.y > Ln.y;
    return Ln = Fn, Rn === 0 ? !0 : Pn;
  });
  return _n.body.removeChild(nr), $n;
}, testCORS = function() {
  return typeof new Image().crossOrigin < "u";
}, testResponseType = function() {
  return typeof new XMLHttpRequest().responseType == "string";
}, testSVG = function(_n) {
  var nr = new Image(), Cn = _n.createElement("canvas"), Bn = Cn.getContext("2d");
  if (!Bn)
    return !1;
  nr.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    Bn.drawImage(nr, 0, 0), Cn.toDataURL();
  } catch {
    return !1;
  }
  return !0;
}, isGreenPixel = function(_n) {
  return _n[0] === 0 && _n[1] === 255 && _n[2] === 0 && _n[3] === 255;
}, testForeignObject = function(_n) {
  var nr = _n.createElement("canvas"), Cn = 100;
  nr.width = Cn, nr.height = Cn;
  var Bn = nr.getContext("2d");
  if (!Bn)
    return Promise.reject(!1);
  Bn.fillStyle = "rgb(0, 255, 0)", Bn.fillRect(0, 0, Cn, Cn);
  var In = new Image(), Dn = nr.toDataURL();
  In.src = Dn;
  var Ln = createForeignObjectSVG(Cn, Cn, 0, 0, In);
  return Bn.fillStyle = "red", Bn.fillRect(0, 0, Cn, Cn), loadSerializedSVG$1(Ln).then(function($n) {
    Bn.drawImage($n, 0, 0);
    var Nn = Bn.getImageData(0, 0, Cn, Cn).data;
    Bn.fillStyle = "red", Bn.fillRect(0, 0, Cn, Cn);
    var Rn = _n.createElement("div");
    return Rn.style.backgroundImage = "url(" + Dn + ")", Rn.style.height = Cn + "px", isGreenPixel(Nn) ? loadSerializedSVG$1(createForeignObjectSVG(Cn, Cn, 0, 0, Rn)) : Promise.reject(!1);
  }).then(function($n) {
    return Bn.drawImage($n, 0, 0), isGreenPixel(Bn.getImageData(0, 0, Cn, Cn).data);
  }).catch(function() {
    return !1;
  });
}, createForeignObjectSVG = function(_n, nr, Cn, Bn, In) {
  var Dn = "http://www.w3.org/2000/svg", Ln = document.createElementNS(Dn, "svg"), $n = document.createElementNS(Dn, "foreignObject");
  return Ln.setAttributeNS(null, "width", _n.toString()), Ln.setAttributeNS(null, "height", nr.toString()), $n.setAttributeNS(null, "width", "100%"), $n.setAttributeNS(null, "height", "100%"), $n.setAttributeNS(null, "x", Cn.toString()), $n.setAttributeNS(null, "y", Bn.toString()), $n.setAttributeNS(null, "externalResourcesRequired", "true"), Ln.appendChild($n), $n.appendChild(In), Ln;
}, loadSerializedSVG$1 = function(_n) {
  return new Promise(function(nr, Cn) {
    var Bn = new Image();
    Bn.onload = function() {
      return nr(Bn);
    }, Bn.onerror = Cn, Bn.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(_n));
  });
}, FEATURES = {
  get SUPPORT_RANGE_BOUNDS() {
    var _n = testRangeBounds(document);
    return Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value: _n }), _n;
  },
  get SUPPORT_WORD_BREAKING() {
    var _n = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
    return Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value: _n }), _n;
  },
  get SUPPORT_SVG_DRAWING() {
    var _n = testSVG(document);
    return Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value: _n }), _n;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var _n = typeof Array.from == "function" && typeof window.fetch == "function" ? testForeignObject(document) : Promise.resolve(!1);
    return Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value: _n }), _n;
  },
  get SUPPORT_CORS_IMAGES() {
    var _n = testCORS();
    return Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value: _n }), _n;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var _n = testResponseType();
    return Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value: _n }), _n;
  },
  get SUPPORT_CORS_XHR() {
    var _n = "withCredentials" in new XMLHttpRequest();
    return Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value: _n }), _n;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var _n = !!(typeof Intl < "u" && Intl.Segmenter);
    return Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value: _n }), _n;
  }
}, TextBounds = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.text = nr, this.bounds = Cn;
    }
    return _n;
  }()
), parseTextBounds = function(_n, nr, Cn, Bn) {
  var In = breakText(nr, Cn), Dn = [], Ln = 0;
  return In.forEach(function($n) {
    if (Cn.textDecorationLine.length || $n.trim().length > 0)
      if (FEATURES.SUPPORT_RANGE_BOUNDS) {
        var Nn = createRange(Bn, Ln, $n.length).getClientRects();
        if (Nn.length > 1) {
          var Rn = segmentGraphemes($n), Fn = 0;
          Rn.forEach(function(Un) {
            Dn.push(new TextBounds(Un, Bounds.fromDOMRectList(_n, createRange(Bn, Fn + Ln, Un.length).getClientRects()))), Fn += Un.length;
          });
        } else
          Dn.push(new TextBounds($n, Bounds.fromDOMRectList(_n, Nn)));
      } else {
        var Pn = Bn.splitText($n.length);
        Dn.push(new TextBounds($n, getWrapperBounds(_n, Bn))), Bn = Pn;
      }
    else
      FEATURES.SUPPORT_RANGE_BOUNDS || (Bn = Bn.splitText($n.length));
    Ln += $n.length;
  }), Dn;
}, getWrapperBounds = function(_n, nr) {
  var Cn = nr.ownerDocument;
  if (Cn) {
    var Bn = Cn.createElement("html2canvaswrapper");
    Bn.appendChild(nr.cloneNode(!0));
    var In = nr.parentNode;
    if (In) {
      In.replaceChild(Bn, nr);
      var Dn = parseBounds(_n, Bn);
      return Bn.firstChild && In.replaceChild(Bn.firstChild, Bn), Dn;
    }
  }
  return Bounds.EMPTY;
}, createRange = function(_n, nr, Cn) {
  var Bn = _n.ownerDocument;
  if (!Bn)
    throw new Error("Node has no owner document");
  var In = Bn.createRange();
  return In.setStart(_n, nr), In.setEnd(_n, nr + Cn), In;
}, segmentGraphemes = function(_n) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var nr = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(nr.segment(_n)).map(function(Cn) {
      return Cn.segment;
    });
  }
  return splitGraphemes(_n);
}, segmentWords = function(_n, nr) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var Cn = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(Cn.segment(_n)).map(function(Bn) {
      return Bn.segment;
    });
  }
  return breakWords(_n, nr);
}, breakText = function(_n, nr) {
  return nr.letterSpacing !== 0 ? segmentGraphemes(_n) : segmentWords(_n, nr);
}, wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241], breakWords = function(_n, nr) {
  for (var Cn = LineBreaker(_n, {
    lineBreak: nr.lineBreak,
    wordBreak: nr.overflowWrap === "break-word" ? "break-word" : nr.wordBreak
  }), Bn = [], In, Dn = function() {
    if (In.value) {
      var Ln = In.value.slice(), $n = toCodePoints$1(Ln), Nn = "";
      $n.forEach(function(Rn) {
        wordSeparators.indexOf(Rn) === -1 ? Nn += fromCodePoint$1(Rn) : (Nn.length && Bn.push(Nn), Bn.push(fromCodePoint$1(Rn)), Nn = "");
      }), Nn.length && Bn.push(Nn);
    }
  }; !(In = Cn.next()).done; )
    Dn();
  return Bn;
}, TextContainer = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.text = transform(Cn.data, Bn.textTransform), this.textBounds = parseTextBounds(nr, this.text, Bn, Cn);
    }
    return _n;
  }()
), transform = function(_n, nr) {
  switch (nr) {
    case 1:
      return _n.toLowerCase();
    case 3:
      return _n.replace(CAPITALIZE, capitalize);
    case 2:
      return _n.toUpperCase();
    default:
      return _n;
  }
}, CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g, capitalize = function(_n, nr, Cn) {
  return _n.length > 0 ? nr + Cn.toUpperCase() : _n;
}, ImageElementContainer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this;
      return In.src = Bn.currentSrc || Bn.src, In.intrinsicWidth = Bn.naturalWidth, In.intrinsicHeight = Bn.naturalHeight, In.context.cache.addImage(In.src), In;
    }
    return nr;
  }(ElementContainer)
), CanvasElementContainer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this;
      return In.canvas = Bn, In.intrinsicWidth = Bn.width, In.intrinsicHeight = Bn.height, In;
    }
    return nr;
  }(ElementContainer)
), SVGElementContainer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this, Dn = new XMLSerializer(), Ln = parseBounds(Cn, Bn);
      return Bn.setAttribute("width", Ln.width + "px"), Bn.setAttribute("height", Ln.height + "px"), In.svg = "data:image/svg+xml," + encodeURIComponent(Dn.serializeToString(Bn)), In.intrinsicWidth = Bn.width.baseVal.value, In.intrinsicHeight = Bn.height.baseVal.value, In.context.cache.addImage(In.svg), In;
    }
    return nr;
  }(ElementContainer)
), LIElementContainer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this;
      return In.value = Bn.value, In;
    }
    return nr;
  }(ElementContainer)
), OLElementContainer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this;
      return In.start = Bn.start, In.reversed = typeof Bn.reversed == "boolean" && Bn.reversed === !0, In;
    }
    return nr;
  }(ElementContainer)
), CHECKBOX_BORDER_RADIUS = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
], RADIO_BORDER_RADIUS = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
], reformatInputBounds = function(_n) {
  return _n.width > _n.height ? new Bounds(_n.left + (_n.width - _n.height) / 2, _n.top, _n.height, _n.height) : _n.width < _n.height ? new Bounds(_n.left, _n.top + (_n.height - _n.width) / 2, _n.width, _n.width) : _n;
}, getInputValue = function(_n) {
  var nr = _n.type === PASSWORD ? new Array(_n.value.length + 1).join("•") : _n.value;
  return nr.length === 0 ? _n.placeholder || "" : nr;
}, CHECKBOX = "checkbox", RADIO = "radio", PASSWORD = "password", INPUT_COLOR = 707406591, InputElementContainer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this;
      switch (In.type = Bn.type.toLowerCase(), In.checked = Bn.checked, In.value = getInputValue(Bn), (In.type === CHECKBOX || In.type === RADIO) && (In.styles.backgroundColor = 3739148031, In.styles.borderTopColor = In.styles.borderRightColor = In.styles.borderBottomColor = In.styles.borderLeftColor = 2779096575, In.styles.borderTopWidth = In.styles.borderRightWidth = In.styles.borderBottomWidth = In.styles.borderLeftWidth = 1, In.styles.borderTopStyle = In.styles.borderRightStyle = In.styles.borderBottomStyle = In.styles.borderLeftStyle = 1, In.styles.backgroundClip = [
        0
        /* BORDER_BOX */
      ], In.styles.backgroundOrigin = [
        0
        /* BORDER_BOX */
      ], In.bounds = reformatInputBounds(In.bounds)), In.type) {
        case CHECKBOX:
          In.styles.borderTopRightRadius = In.styles.borderTopLeftRadius = In.styles.borderBottomRightRadius = In.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
          break;
        case RADIO:
          In.styles.borderTopRightRadius = In.styles.borderTopLeftRadius = In.styles.borderBottomRightRadius = In.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
          break;
      }
      return In;
    }
    return nr;
  }(ElementContainer)
), SelectElementContainer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this, Dn = Bn.options[Bn.selectedIndex || 0];
      return In.value = Dn && Dn.text || "", In;
    }
    return nr;
  }(ElementContainer)
), TextareaElementContainer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this;
      return In.value = Bn.value, In;
    }
    return nr;
  }(ElementContainer)
), IFrameElementContainer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this;
      In.src = Bn.src, In.width = parseInt(Bn.width, 10) || 0, In.height = parseInt(Bn.height, 10) || 0, In.backgroundColor = In.styles.backgroundColor;
      try {
        if (Bn.contentWindow && Bn.contentWindow.document && Bn.contentWindow.document.documentElement) {
          In.tree = parseTree(Cn, Bn.contentWindow.document.documentElement);
          var Dn = Bn.contentWindow.document.documentElement ? parseColor(Cn, getComputedStyle(Bn.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT, Ln = Bn.contentWindow.document.body ? parseColor(Cn, getComputedStyle(Bn.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
          In.backgroundColor = isTransparent(Dn) ? isTransparent(Ln) ? In.styles.backgroundColor : Ln : Dn;
        }
      } catch {
      }
      return In;
    }
    return nr;
  }(ElementContainer)
), LIST_OWNERS = ["OL", "UL", "MENU"], parseNodeTree = function(_n, nr, Cn, Bn) {
  for (var In = nr.firstChild, Dn = void 0; In; In = Dn)
    if (Dn = In.nextSibling, isTextNode(In) && In.data.trim().length > 0)
      Cn.textNodes.push(new TextContainer(_n, In, Cn.styles));
    else if (isElementNode(In))
      if (isSlotElement(In) && In.assignedNodes)
        In.assignedNodes().forEach(function($n) {
          return parseNodeTree(_n, $n, Cn, Bn);
        });
      else {
        var Ln = createContainer(_n, In);
        Ln.styles.isVisible() && (createsRealStackingContext(In, Ln, Bn) ? Ln.flags |= 4 : createsStackingContext(Ln.styles) && (Ln.flags |= 2), LIST_OWNERS.indexOf(In.tagName) !== -1 && (Ln.flags |= 8), Cn.elements.push(Ln), In.slot, In.shadowRoot ? parseNodeTree(_n, In.shadowRoot, Ln, Bn) : !isTextareaElement(In) && !isSVGElement(In) && !isSelectElement(In) && parseNodeTree(_n, In, Ln, Bn));
      }
}, createContainer = function(_n, nr) {
  return isImageElement(nr) ? new ImageElementContainer(_n, nr) : isCanvasElement(nr) ? new CanvasElementContainer(_n, nr) : isSVGElement(nr) ? new SVGElementContainer(_n, nr) : isLIElement(nr) ? new LIElementContainer(_n, nr) : isOLElement(nr) ? new OLElementContainer(_n, nr) : isInputElement(nr) ? new InputElementContainer(_n, nr) : isSelectElement(nr) ? new SelectElementContainer(_n, nr) : isTextareaElement(nr) ? new TextareaElementContainer(_n, nr) : isIFrameElement(nr) ? new IFrameElementContainer(_n, nr) : new ElementContainer(_n, nr);
}, parseTree = function(_n, nr) {
  var Cn = createContainer(_n, nr);
  return Cn.flags |= 4, parseNodeTree(_n, nr, Cn, Cn), Cn;
}, createsRealStackingContext = function(_n, nr, Cn) {
  return nr.styles.isPositionedWithZIndex() || nr.styles.opacity < 1 || nr.styles.isTransformed() || isBodyElement(_n) && Cn.styles.isTransparent();
}, createsStackingContext = function(_n) {
  return _n.isPositioned() || _n.isFloating();
}, isTextNode = function(_n) {
  return _n.nodeType === Node.TEXT_NODE;
}, isElementNode = function(_n) {
  return _n.nodeType === Node.ELEMENT_NODE;
}, isHTMLElementNode = function(_n) {
  return isElementNode(_n) && typeof _n.style < "u" && !isSVGElementNode(_n);
}, isSVGElementNode = function(_n) {
  return typeof _n.className == "object";
}, isLIElement = function(_n) {
  return _n.tagName === "LI";
}, isOLElement = function(_n) {
  return _n.tagName === "OL";
}, isInputElement = function(_n) {
  return _n.tagName === "INPUT";
}, isHTMLElement$1 = function(_n) {
  return _n.tagName === "HTML";
}, isSVGElement = function(_n) {
  return _n.tagName === "svg";
}, isBodyElement = function(_n) {
  return _n.tagName === "BODY";
}, isCanvasElement = function(_n) {
  return _n.tagName === "CANVAS";
}, isVideoElement = function(_n) {
  return _n.tagName === "VIDEO";
}, isImageElement = function(_n) {
  return _n.tagName === "IMG";
}, isIFrameElement = function(_n) {
  return _n.tagName === "IFRAME";
}, isStyleElement = function(_n) {
  return _n.tagName === "STYLE";
}, isScriptElement = function(_n) {
  return _n.tagName === "SCRIPT";
}, isTextareaElement = function(_n) {
  return _n.tagName === "TEXTAREA";
}, isSelectElement = function(_n) {
  return _n.tagName === "SELECT";
}, isSlotElement = function(_n) {
  return _n.tagName === "SLOT";
}, isCustomElement = function(_n) {
  return _n.tagName.indexOf("-") > 0;
}, CounterState = (
  /** @class */
  function() {
    function _n() {
      this.counters = {};
    }
    return _n.prototype.getCounterValue = function(nr) {
      var Cn = this.counters[nr];
      return Cn && Cn.length ? Cn[Cn.length - 1] : 1;
    }, _n.prototype.getCounterValues = function(nr) {
      var Cn = this.counters[nr];
      return Cn || [];
    }, _n.prototype.pop = function(nr) {
      var Cn = this;
      nr.forEach(function(Bn) {
        return Cn.counters[Bn].pop();
      });
    }, _n.prototype.parse = function(nr) {
      var Cn = this, Bn = nr.counterIncrement, In = nr.counterReset, Dn = !0;
      Bn !== null && Bn.forEach(function($n) {
        var Nn = Cn.counters[$n.counter];
        Nn && $n.increment !== 0 && (Dn = !1, Nn.length || Nn.push(1), Nn[Math.max(0, Nn.length - 1)] += $n.increment);
      });
      var Ln = [];
      return Dn && In.forEach(function($n) {
        var Nn = Cn.counters[$n.counter];
        Ln.push($n.counter), Nn || (Nn = Cn.counters[$n.counter] = []), Nn.push($n.reset);
      }), Ln;
    }, _n;
  }()
), ROMAN_UPPER = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
}, ARMENIAN = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "Ք",
    "Փ",
    "Ւ",
    "Ց",
    "Ր",
    "Տ",
    "Վ",
    "Ս",
    "Ռ",
    "Ջ",
    "Պ",
    "Չ",
    "Ո",
    "Շ",
    "Ն",
    "Յ",
    "Մ",
    "Ճ",
    "Ղ",
    "Ձ",
    "Հ",
    "Կ",
    "Ծ",
    "Խ",
    "Լ",
    "Ի",
    "Ժ",
    "Թ",
    "Ը",
    "Է",
    "Զ",
    "Ե",
    "Դ",
    "Գ",
    "Բ",
    "Ա"
  ]
}, HEBREW = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "י׳",
    "ט׳",
    "ח׳",
    "ז׳",
    "ו׳",
    "ה׳",
    "ד׳",
    "ג׳",
    "ב׳",
    "א׳",
    "ת",
    "ש",
    "ר",
    "ק",
    "צ",
    "פ",
    "ע",
    "ס",
    "נ",
    "מ",
    "ל",
    "כ",
    "יט",
    "יח",
    "יז",
    "טז",
    "טו",
    "י",
    "ט",
    "ח",
    "ז",
    "ו",
    "ה",
    "ד",
    "ג",
    "ב",
    "א"
  ]
}, GEORGIAN = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "ჵ",
    "ჰ",
    "ჯ",
    "ჴ",
    "ხ",
    "ჭ",
    "წ",
    "ძ",
    "ც",
    "ჩ",
    "შ",
    "ყ",
    "ღ",
    "ქ",
    "ფ",
    "ჳ",
    "ტ",
    "ს",
    "რ",
    "ჟ",
    "პ",
    "ო",
    "ჲ",
    "ნ",
    "მ",
    "ლ",
    "კ",
    "ი",
    "თ",
    "ჱ",
    "ზ",
    "ვ",
    "ე",
    "დ",
    "გ",
    "ბ",
    "ა"
  ]
}, createAdditiveCounter = function(_n, nr, Cn, Bn, In, Dn) {
  return _n < nr || _n > Cn ? createCounterText(_n, In, Dn.length > 0) : Bn.integers.reduce(function(Ln, $n, Nn) {
    for (; _n >= $n; )
      _n -= $n, Ln += Bn.values[Nn];
    return Ln;
  }, "") + Dn;
}, createCounterStyleWithSymbolResolver = function(_n, nr, Cn, Bn) {
  var In = "";
  do
    Cn || _n--, In = Bn(_n) + In, _n /= nr;
  while (_n * nr >= nr);
  return In;
}, createCounterStyleFromRange = function(_n, nr, Cn, Bn, In) {
  var Dn = Cn - nr + 1;
  return (_n < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(_n), Dn, Bn, function(Ln) {
    return fromCodePoint$1(Math.floor(Ln % Dn) + nr);
  }) + In);
}, createCounterStyleFromSymbols = function(_n, nr, Cn) {
  Cn === void 0 && (Cn = ". ");
  var Bn = nr.length;
  return createCounterStyleWithSymbolResolver(Math.abs(_n), Bn, !1, function(In) {
    return nr[Math.floor(In % Bn)];
  }) + Cn;
}, CJK_ZEROS = 1, CJK_TEN_COEFFICIENTS = 2, CJK_TEN_HIGH_COEFFICIENTS = 4, CJK_HUNDRED_COEFFICIENTS = 8, createCJKCounter = function(_n, nr, Cn, Bn, In, Dn) {
  if (_n < -9999 || _n > 9999)
    return createCounterText(_n, 4, In.length > 0);
  var Ln = Math.abs(_n), $n = In;
  if (Ln === 0)
    return nr[0] + $n;
  for (var Nn = 0; Ln > 0 && Nn <= 4; Nn++) {
    var Rn = Ln % 10;
    Rn === 0 && contains$1(Dn, CJK_ZEROS) && $n !== "" ? $n = nr[Rn] + $n : Rn > 1 || Rn === 1 && Nn === 0 || Rn === 1 && Nn === 1 && contains$1(Dn, CJK_TEN_COEFFICIENTS) || Rn === 1 && Nn === 1 && contains$1(Dn, CJK_TEN_HIGH_COEFFICIENTS) && _n > 100 || Rn === 1 && Nn > 1 && contains$1(Dn, CJK_HUNDRED_COEFFICIENTS) ? $n = nr[Rn] + (Nn > 0 ? Cn[Nn - 1] : "") + $n : Rn === 1 && Nn > 0 && ($n = Cn[Nn - 1] + $n), Ln = Math.floor(Ln / 10);
  }
  return (_n < 0 ? Bn : "") + $n;
}, CHINESE_INFORMAL_MULTIPLIERS = "十百千萬", CHINESE_FORMAL_MULTIPLIERS = "拾佰仟萬", JAPANESE_NEGATIVE = "マイナス", KOREAN_NEGATIVE = "마이너스", createCounterText = function(_n, nr, Cn) {
  var Bn = Cn ? ". " : "", In = Cn ? "、" : "", Dn = Cn ? ", " : "", Ln = Cn ? " " : "";
  switch (nr) {
    case 0:
      return "•" + Ln;
    case 1:
      return "◦" + Ln;
    case 2:
      return "◾" + Ln;
    case 5:
      var $n = createCounterStyleFromRange(_n, 48, 57, !0, Bn);
      return $n.length < 4 ? "0" + $n : $n;
    case 4:
      return createCounterStyleFromSymbols(_n, "〇一二三四五六七八九", In);
    case 6:
      return createAdditiveCounter(_n, 1, 3999, ROMAN_UPPER, 3, Bn).toLowerCase();
    case 7:
      return createAdditiveCounter(_n, 1, 3999, ROMAN_UPPER, 3, Bn);
    case 8:
      return createCounterStyleFromRange(_n, 945, 969, !1, Bn);
    case 9:
      return createCounterStyleFromRange(_n, 97, 122, !1, Bn);
    case 10:
      return createCounterStyleFromRange(_n, 65, 90, !1, Bn);
    case 11:
      return createCounterStyleFromRange(_n, 1632, 1641, !0, Bn);
    case 12:
    case 49:
      return createAdditiveCounter(_n, 1, 9999, ARMENIAN, 3, Bn);
    case 35:
      return createAdditiveCounter(_n, 1, 9999, ARMENIAN, 3, Bn).toLowerCase();
    case 13:
      return createCounterStyleFromRange(_n, 2534, 2543, !0, Bn);
    case 14:
    case 30:
      return createCounterStyleFromRange(_n, 6112, 6121, !0, Bn);
    case 15:
      return createCounterStyleFromSymbols(_n, "子丑寅卯辰巳午未申酉戌亥", In);
    case 16:
      return createCounterStyleFromSymbols(_n, "甲乙丙丁戊己庚辛壬癸", In);
    case 17:
    case 48:
      return createCJKCounter(_n, "零一二三四五六七八九", CHINESE_INFORMAL_MULTIPLIERS, "負", In, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 47:
      return createCJKCounter(_n, "零壹貳參肆伍陸柒捌玖", CHINESE_FORMAL_MULTIPLIERS, "負", In, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 42:
      return createCJKCounter(_n, "零一二三四五六七八九", CHINESE_INFORMAL_MULTIPLIERS, "负", In, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 41:
      return createCJKCounter(_n, "零壹贰叁肆伍陆柒捌玖", CHINESE_FORMAL_MULTIPLIERS, "负", In, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 26:
      return createCJKCounter(_n, "〇一二三四五六七八九", "十百千万", JAPANESE_NEGATIVE, In, 0);
    case 25:
      return createCJKCounter(_n, "零壱弐参四伍六七八九", "拾百千万", JAPANESE_NEGATIVE, In, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 31:
      return createCJKCounter(_n, "영일이삼사오육칠팔구", "십백천만", KOREAN_NEGATIVE, Dn, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 33:
      return createCJKCounter(_n, "零一二三四五六七八九", "十百千萬", KOREAN_NEGATIVE, Dn, 0);
    case 32:
      return createCJKCounter(_n, "零壹貳參四五六七八九", "拾百千", KOREAN_NEGATIVE, Dn, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 18:
      return createCounterStyleFromRange(_n, 2406, 2415, !0, Bn);
    case 20:
      return createAdditiveCounter(_n, 1, 19999, GEORGIAN, 3, Bn);
    case 21:
      return createCounterStyleFromRange(_n, 2790, 2799, !0, Bn);
    case 22:
      return createCounterStyleFromRange(_n, 2662, 2671, !0, Bn);
    case 22:
      return createAdditiveCounter(_n, 1, 10999, HEBREW, 3, Bn);
    case 23:
      return createCounterStyleFromSymbols(_n, "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん");
    case 24:
      return createCounterStyleFromSymbols(_n, "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす");
    case 27:
      return createCounterStyleFromRange(_n, 3302, 3311, !0, Bn);
    case 28:
      return createCounterStyleFromSymbols(_n, "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン", In);
    case 29:
      return createCounterStyleFromSymbols(_n, "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス", In);
    case 34:
      return createCounterStyleFromRange(_n, 3792, 3801, !0, Bn);
    case 37:
      return createCounterStyleFromRange(_n, 6160, 6169, !0, Bn);
    case 38:
      return createCounterStyleFromRange(_n, 4160, 4169, !0, Bn);
    case 39:
      return createCounterStyleFromRange(_n, 2918, 2927, !0, Bn);
    case 40:
      return createCounterStyleFromRange(_n, 1776, 1785, !0, Bn);
    case 43:
      return createCounterStyleFromRange(_n, 3046, 3055, !0, Bn);
    case 44:
      return createCounterStyleFromRange(_n, 3174, 3183, !0, Bn);
    case 45:
      return createCounterStyleFromRange(_n, 3664, 3673, !0, Bn);
    case 46:
      return createCounterStyleFromRange(_n, 3872, 3881, !0, Bn);
    case 3:
    default:
      return createCounterStyleFromRange(_n, 48, 57, !0, Bn);
  }
}, IGNORE_ATTRIBUTE = "data-html2canvas-ignore", DocumentCloner = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      if (this.context = nr, this.options = Bn, this.scrolledElements = [], this.referenceElement = Cn, this.counters = new CounterState(), this.quoteDepth = 0, !Cn.ownerDocument)
        throw new Error("Cloned element does not have an owner document");
      this.documentElement = this.cloneNode(Cn.ownerDocument.documentElement, !1);
    }
    return _n.prototype.toIFrame = function(nr, Cn) {
      var Bn = this, In = createIFrameContainer(nr, Cn);
      if (!In.contentWindow)
        return Promise.reject("Unable to find iframe window");
      var Dn = nr.defaultView.pageXOffset, Ln = nr.defaultView.pageYOffset, $n = In.contentWindow, Nn = $n.document, Rn = iframeLoader(In).then(function() {
        return __awaiter(Bn, void 0, void 0, function() {
          var Fn, Pn;
          return __generator(this, function(Un) {
            switch (Un.label) {
              case 0:
                return this.scrolledElements.forEach(restoreNodeScroll), $n && ($n.scrollTo(Cn.left, Cn.top), /(iPad|iPhone|iPod)/g.test(navigator.userAgent) && ($n.scrollY !== Cn.top || $n.scrollX !== Cn.left) && (this.context.logger.warn("Unable to restore scroll position for cloned document"), this.context.windowBounds = this.context.windowBounds.add($n.scrollX - Cn.left, $n.scrollY - Cn.top, 0, 0))), Fn = this.options.onclone, Pn = this.clonedReferenceElement, typeof Pn > "u" ? [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")] : Nn.fonts && Nn.fonts.ready ? [4, Nn.fonts.ready] : [3, 2];
              case 1:
                Un.sent(), Un.label = 2;
              case 2:
                return /(AppleWebKit)/g.test(navigator.userAgent) ? [4, imagesReady(Nn)] : [3, 4];
              case 3:
                Un.sent(), Un.label = 4;
              case 4:
                return typeof Fn == "function" ? [2, Promise.resolve().then(function() {
                  return Fn(Nn, Pn);
                }).then(function() {
                  return In;
                })] : [2, In];
            }
          });
        });
      });
      return Nn.open(), Nn.write(serializeDoctype(document.doctype) + "<html></html>"), restoreOwnerScroll(this.referenceElement.ownerDocument, Dn, Ln), Nn.replaceChild(Nn.adoptNode(this.documentElement), Nn.documentElement), Nn.close(), Rn;
    }, _n.prototype.createElementClone = function(nr) {
      if (isDebugging(
        nr,
        2
        /* CLONE */
      ))
        debugger;
      if (isCanvasElement(nr))
        return this.createCanvasClone(nr);
      if (isVideoElement(nr))
        return this.createVideoClone(nr);
      if (isStyleElement(nr))
        return this.createStyleClone(nr);
      var Cn = nr.cloneNode(!1);
      return isImageElement(Cn) && (isImageElement(nr) && nr.currentSrc && nr.currentSrc !== nr.src && (Cn.src = nr.currentSrc, Cn.srcset = ""), Cn.loading === "lazy" && (Cn.loading = "eager")), isCustomElement(Cn) ? this.createCustomElementClone(Cn) : Cn;
    }, _n.prototype.createCustomElementClone = function(nr) {
      var Cn = document.createElement("html2canvascustomelement");
      return copyCSSStyles(nr.style, Cn), Cn;
    }, _n.prototype.createStyleClone = function(nr) {
      try {
        var Cn = nr.sheet;
        if (Cn && Cn.cssRules) {
          var Bn = [].slice.call(Cn.cssRules, 0).reduce(function(Dn, Ln) {
            return Ln && typeof Ln.cssText == "string" ? Dn + Ln.cssText : Dn;
          }, ""), In = nr.cloneNode(!1);
          return In.textContent = Bn, In;
        }
      } catch (Dn) {
        if (this.context.logger.error("Unable to access cssRules property", Dn), Dn.name !== "SecurityError")
          throw Dn;
      }
      return nr.cloneNode(!1);
    }, _n.prototype.createCanvasClone = function(nr) {
      var Cn;
      if (this.options.inlineImages && nr.ownerDocument) {
        var Bn = nr.ownerDocument.createElement("img");
        try {
          return Bn.src = nr.toDataURL(), Bn;
        } catch {
          this.context.logger.info("Unable to inline canvas contents, canvas is tainted", nr);
        }
      }
      var In = nr.cloneNode(!1);
      try {
        In.width = nr.width, In.height = nr.height;
        var Dn = nr.getContext("2d"), Ln = In.getContext("2d");
        if (Ln)
          if (!this.options.allowTaint && Dn)
            Ln.putImageData(Dn.getImageData(0, 0, nr.width, nr.height), 0, 0);
          else {
            var $n = (Cn = nr.getContext("webgl2")) !== null && Cn !== void 0 ? Cn : nr.getContext("webgl");
            if ($n) {
              var Nn = $n.getContextAttributes();
              (Nn == null ? void 0 : Nn.preserveDrawingBuffer) === !1 && this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", nr);
            }
            Ln.drawImage(nr, 0, 0);
          }
        return In;
      } catch {
        this.context.logger.info("Unable to clone canvas as it is tainted", nr);
      }
      return In;
    }, _n.prototype.createVideoClone = function(nr) {
      var Cn = nr.ownerDocument.createElement("canvas");
      Cn.width = nr.offsetWidth, Cn.height = nr.offsetHeight;
      var Bn = Cn.getContext("2d");
      try {
        return Bn && (Bn.drawImage(nr, 0, 0, Cn.width, Cn.height), this.options.allowTaint || Bn.getImageData(0, 0, Cn.width, Cn.height)), Cn;
      } catch {
        this.context.logger.info("Unable to clone video as it is tainted", nr);
      }
      var In = nr.ownerDocument.createElement("canvas");
      return In.width = nr.offsetWidth, In.height = nr.offsetHeight, In;
    }, _n.prototype.appendChildNode = function(nr, Cn, Bn) {
      (!isElementNode(Cn) || !isScriptElement(Cn) && !Cn.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements != "function" || !this.options.ignoreElements(Cn))) && (!this.options.copyStyles || !isElementNode(Cn) || !isStyleElement(Cn)) && nr.appendChild(this.cloneNode(Cn, Bn));
    }, _n.prototype.cloneChildNodes = function(nr, Cn, Bn) {
      for (var In = this, Dn = nr.shadowRoot ? nr.shadowRoot.firstChild : nr.firstChild; Dn; Dn = Dn.nextSibling)
        if (isElementNode(Dn) && isSlotElement(Dn) && typeof Dn.assignedNodes == "function") {
          var Ln = Dn.assignedNodes();
          Ln.length && Ln.forEach(function($n) {
            return In.appendChildNode(Cn, $n, Bn);
          });
        } else
          this.appendChildNode(Cn, Dn, Bn);
    }, _n.prototype.cloneNode = function(nr, Cn) {
      if (isTextNode(nr))
        return document.createTextNode(nr.data);
      if (!nr.ownerDocument)
        return nr.cloneNode(!1);
      var Bn = nr.ownerDocument.defaultView;
      if (Bn && isElementNode(nr) && (isHTMLElementNode(nr) || isSVGElementNode(nr))) {
        var In = this.createElementClone(nr);
        In.style.transitionProperty = "none";
        var Dn = Bn.getComputedStyle(nr), Ln = Bn.getComputedStyle(nr, ":before"), $n = Bn.getComputedStyle(nr, ":after");
        this.referenceElement === nr && isHTMLElementNode(In) && (this.clonedReferenceElement = In), isBodyElement(In) && createPseudoHideStyles(In);
        var Nn = this.counters.parse(new CSSParsedCounterDeclaration(this.context, Dn)), Rn = this.resolvePseudoContent(nr, In, Ln, PseudoElementType.BEFORE);
        isCustomElement(nr) && (Cn = !0), isVideoElement(nr) || this.cloneChildNodes(nr, In, Cn), Rn && In.insertBefore(Rn, In.firstChild);
        var Fn = this.resolvePseudoContent(nr, In, $n, PseudoElementType.AFTER);
        return Fn && In.appendChild(Fn), this.counters.pop(Nn), (Dn && (this.options.copyStyles || isSVGElementNode(nr)) && !isIFrameElement(nr) || Cn) && copyCSSStyles(Dn, In), (nr.scrollTop !== 0 || nr.scrollLeft !== 0) && this.scrolledElements.push([In, nr.scrollLeft, nr.scrollTop]), (isTextareaElement(nr) || isSelectElement(nr)) && (isTextareaElement(In) || isSelectElement(In)) && (In.value = nr.value), In;
      }
      return nr.cloneNode(!1);
    }, _n.prototype.resolvePseudoContent = function(nr, Cn, Bn, In) {
      var Dn = this;
      if (Bn) {
        var Ln = Bn.content, $n = Cn.ownerDocument;
        if (!(!$n || !Ln || Ln === "none" || Ln === "-moz-alt-content" || Bn.display === "none")) {
          this.counters.parse(new CSSParsedCounterDeclaration(this.context, Bn));
          var Nn = new CSSParsedPseudoDeclaration(this.context, Bn), Rn = $n.createElement("html2canvaspseudoelement");
          copyCSSStyles(Bn, Rn), Nn.content.forEach(function(Pn) {
            if (Pn.type === 0)
              Rn.appendChild($n.createTextNode(Pn.value));
            else if (Pn.type === 22) {
              var Un = $n.createElement("img");
              Un.src = Pn.value, Un.style.opacity = "1", Rn.appendChild(Un);
            } else if (Pn.type === 18) {
              if (Pn.name === "attr") {
                var Hn = Pn.values.filter(isIdentToken);
                Hn.length && Rn.appendChild($n.createTextNode(nr.getAttribute(Hn[0].value) || ""));
              } else if (Pn.name === "counter") {
                var zn = Pn.values.filter(nonFunctionArgSeparator), Gn = zn[0], Yn = zn[1];
                if (Gn && isIdentToken(Gn)) {
                  var Wn = Dn.counters.getCounterValue(Gn.value), Xn = Yn && isIdentToken(Yn) ? listStyleType.parse(Dn.context, Yn.value) : 3;
                  Rn.appendChild($n.createTextNode(createCounterText(Wn, Xn, !1)));
                }
              } else if (Pn.name === "counters") {
                var ea = Pn.values.filter(nonFunctionArgSeparator), Gn = ea[0], ta = ea[1], Yn = ea[2];
                if (Gn && isIdentToken(Gn)) {
                  var na = Dn.counters.getCounterValues(Gn.value), ra = Yn && isIdentToken(Yn) ? listStyleType.parse(Dn.context, Yn.value) : 3, aa = ta && ta.type === 0 ? ta.value : "", ia = na.map(function(oa) {
                    return createCounterText(oa, ra, !1);
                  }).join(aa);
                  Rn.appendChild($n.createTextNode(ia));
                }
              }
            } else if (Pn.type === 20)
              switch (Pn.value) {
                case "open-quote":
                  Rn.appendChild($n.createTextNode(getQuote(Nn.quotes, Dn.quoteDepth++, !0)));
                  break;
                case "close-quote":
                  Rn.appendChild($n.createTextNode(getQuote(Nn.quotes, --Dn.quoteDepth, !1)));
                  break;
                default:
                  Rn.appendChild($n.createTextNode(Pn.value));
              }
          }), Rn.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          var Fn = In === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          return isSVGElementNode(Cn) ? Cn.className.baseValue += Fn : Cn.className += Fn, Rn;
        }
      }
    }, _n.destroy = function(nr) {
      return nr.parentNode ? (nr.parentNode.removeChild(nr), !0) : !1;
    }, _n;
  }()
), PseudoElementType;
(function(_n) {
  _n[_n.BEFORE = 0] = "BEFORE", _n[_n.AFTER = 1] = "AFTER";
})(PseudoElementType || (PseudoElementType = {}));
var createIFrameContainer = function(_n, nr) {
  var Cn = _n.createElement("iframe");
  return Cn.className = "html2canvas-container", Cn.style.visibility = "hidden", Cn.style.position = "fixed", Cn.style.left = "-10000px", Cn.style.top = "0px", Cn.style.border = "0", Cn.width = nr.width.toString(), Cn.height = nr.height.toString(), Cn.scrolling = "no", Cn.setAttribute(IGNORE_ATTRIBUTE, "true"), _n.body.appendChild(Cn), Cn;
}, imageReady = function(_n) {
  return new Promise(function(nr) {
    if (_n.complete) {
      nr();
      return;
    }
    if (!_n.src) {
      nr();
      return;
    }
    _n.onload = nr, _n.onerror = nr;
  });
}, imagesReady = function(_n) {
  return Promise.all([].slice.call(_n.images, 0).map(imageReady));
}, iframeLoader = function(_n) {
  return new Promise(function(nr, Cn) {
    var Bn = _n.contentWindow;
    if (!Bn)
      return Cn("No window assigned for iframe");
    var In = Bn.document;
    Bn.onload = _n.onload = function() {
      Bn.onload = _n.onload = null;
      var Dn = setInterval(function() {
        In.body.childNodes.length > 0 && In.readyState === "complete" && (clearInterval(Dn), nr(_n));
      }, 50);
    };
  });
}, ignoredStyleProperties = [
  "all",
  "d",
  "content"
  // Safari shows pseudoelements if content is set
], copyCSSStyles = function(_n, nr) {
  for (var Cn = _n.length - 1; Cn >= 0; Cn--) {
    var Bn = _n.item(Cn);
    ignoredStyleProperties.indexOf(Bn) === -1 && nr.style.setProperty(Bn, _n.getPropertyValue(Bn));
  }
  return nr;
}, serializeDoctype = function(_n) {
  var nr = "";
  return _n && (nr += "<!DOCTYPE ", _n.name && (nr += _n.name), _n.internalSubset && (nr += _n.internalSubset), _n.publicId && (nr += '"' + _n.publicId + '"'), _n.systemId && (nr += '"' + _n.systemId + '"'), nr += ">"), nr;
}, restoreOwnerScroll = function(_n, nr, Cn) {
  _n && _n.defaultView && (nr !== _n.defaultView.pageXOffset || Cn !== _n.defaultView.pageYOffset) && _n.defaultView.scrollTo(nr, Cn);
}, restoreNodeScroll = function(_n) {
  var nr = _n[0], Cn = _n[1], Bn = _n[2];
  nr.scrollLeft = Cn, nr.scrollTop = Bn;
}, PSEUDO_BEFORE = ":before", PSEUDO_AFTER = ":after", PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before", PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after", PSEUDO_HIDE_ELEMENT_STYLE = `{
    content: "" !important;
    display: none !important;
}`, createPseudoHideStyles = function(_n) {
  createStyles(_n, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + `
         .` + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
}, createStyles = function(_n, nr) {
  var Cn = _n.ownerDocument;
  if (Cn) {
    var Bn = Cn.createElement("style");
    Bn.textContent = nr, _n.appendChild(Bn);
  }
}, CacheStorage = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.getOrigin = function(nr) {
      var Cn = _n._link;
      return Cn ? (Cn.href = nr, Cn.href = Cn.href, Cn.protocol + Cn.hostname + Cn.port) : "about:blank";
    }, _n.isSameOrigin = function(nr) {
      return _n.getOrigin(nr) === _n._origin;
    }, _n.setContext = function(nr) {
      _n._link = nr.document.createElement("a"), _n._origin = _n.getOrigin(nr.location.href);
    }, _n._origin = "about:blank", _n;
  }()
), Cache = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.context = nr, this._options = Cn, this._cache = {};
    }
    return _n.prototype.addImage = function(nr) {
      var Cn = Promise.resolve();
      return this.has(nr) || (isBlobImage(nr) || isRenderable(nr)) && (this._cache[nr] = this.loadImage(nr)).catch(function() {
      }), Cn;
    }, _n.prototype.match = function(nr) {
      return this._cache[nr];
    }, _n.prototype.loadImage = function(nr) {
      return __awaiter(this, void 0, void 0, function() {
        var Cn, Bn, In, Dn, Ln = this;
        return __generator(this, function($n) {
          switch ($n.label) {
            case 0:
              return Cn = CacheStorage.isSameOrigin(nr), Bn = !isInlineImage(nr) && this._options.useCORS === !0 && FEATURES.SUPPORT_CORS_IMAGES && !Cn, In = !isInlineImage(nr) && !Cn && !isBlobImage(nr) && typeof this._options.proxy == "string" && FEATURES.SUPPORT_CORS_XHR && !Bn, !Cn && this._options.allowTaint === !1 && !isInlineImage(nr) && !isBlobImage(nr) && !In && !Bn ? [
                2
                /*return*/
              ] : (Dn = nr, In ? [4, this.proxy(Dn)] : [3, 2]);
            case 1:
              Dn = $n.sent(), $n.label = 2;
            case 2:
              return this.context.logger.debug("Added image " + nr.substring(0, 256)), [4, new Promise(function(Nn, Rn) {
                var Fn = new Image();
                Fn.onload = function() {
                  return Nn(Fn);
                }, Fn.onerror = Rn, (isInlineBase64Image(Dn) || Bn) && (Fn.crossOrigin = "anonymous"), Fn.src = Dn, Fn.complete === !0 && setTimeout(function() {
                  return Nn(Fn);
                }, 500), Ln._options.imageTimeout > 0 && setTimeout(function() {
                  return Rn("Timed out (" + Ln._options.imageTimeout + "ms) loading image");
                }, Ln._options.imageTimeout);
              })];
            case 3:
              return [2, $n.sent()];
          }
        });
      });
    }, _n.prototype.has = function(nr) {
      return typeof this._cache[nr] < "u";
    }, _n.prototype.keys = function() {
      return Promise.resolve(Object.keys(this._cache));
    }, _n.prototype.proxy = function(nr) {
      var Cn = this, Bn = this._options.proxy;
      if (!Bn)
        throw new Error("No proxy defined");
      var In = nr.substring(0, 256);
      return new Promise(function(Dn, Ln) {
        var $n = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text", Nn = new XMLHttpRequest();
        Nn.onload = function() {
          if (Nn.status === 200)
            if ($n === "text")
              Dn(Nn.response);
            else {
              var Pn = new FileReader();
              Pn.addEventListener("load", function() {
                return Dn(Pn.result);
              }, !1), Pn.addEventListener("error", function(Un) {
                return Ln(Un);
              }, !1), Pn.readAsDataURL(Nn.response);
            }
          else
            Ln("Failed to proxy resource " + In + " with status code " + Nn.status);
        }, Nn.onerror = Ln;
        var Rn = Bn.indexOf("?") > -1 ? "&" : "?";
        if (Nn.open("GET", "" + Bn + Rn + "url=" + encodeURIComponent(nr) + "&responseType=" + $n), $n !== "text" && Nn instanceof XMLHttpRequest && (Nn.responseType = $n), Cn._options.imageTimeout) {
          var Fn = Cn._options.imageTimeout;
          Nn.timeout = Fn, Nn.ontimeout = function() {
            return Ln("Timed out (" + Fn + "ms) proxying " + In);
          };
        }
        Nn.send();
      });
    }, _n;
  }()
), INLINE_SVG = /^data:image\/svg\+xml/i, INLINE_BASE64 = /^data:image\/.*;base64,/i, INLINE_IMG = /^data:image\/.*/i, isRenderable = function(_n) {
  return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(_n);
}, isInlineImage = function(_n) {
  return INLINE_IMG.test(_n);
}, isInlineBase64Image = function(_n) {
  return INLINE_BASE64.test(_n);
}, isBlobImage = function(_n) {
  return _n.substr(0, 4) === "blob";
}, isSVG = function(_n) {
  return _n.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(_n);
}, Vector = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.type = 0, this.x = nr, this.y = Cn;
    }
    return _n.prototype.add = function(nr, Cn) {
      return new _n(this.x + nr, this.y + Cn);
    }, _n;
  }()
), lerp = function(_n, nr, Cn) {
  return new Vector(_n.x + (nr.x - _n.x) * Cn, _n.y + (nr.y - _n.y) * Cn);
}, BezierCurve = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn, In) {
      this.type = 1, this.start = nr, this.startControl = Cn, this.endControl = Bn, this.end = In;
    }
    return _n.prototype.subdivide = function(nr, Cn) {
      var Bn = lerp(this.start, this.startControl, nr), In = lerp(this.startControl, this.endControl, nr), Dn = lerp(this.endControl, this.end, nr), Ln = lerp(Bn, In, nr), $n = lerp(In, Dn, nr), Nn = lerp(Ln, $n, nr);
      return Cn ? new _n(this.start, Bn, Ln, Nn) : new _n(Nn, $n, Dn, this.end);
    }, _n.prototype.add = function(nr, Cn) {
      return new _n(this.start.add(nr, Cn), this.startControl.add(nr, Cn), this.endControl.add(nr, Cn), this.end.add(nr, Cn));
    }, _n.prototype.reverse = function() {
      return new _n(this.end, this.endControl, this.startControl, this.start);
    }, _n;
  }()
), isBezierCurve = function(_n) {
  return _n.type === 1;
}, BoundCurves = (
  /** @class */
  function() {
    function _n(nr) {
      var Cn = nr.styles, Bn = nr.bounds, In = getAbsoluteValueForTuple(Cn.borderTopLeftRadius, Bn.width, Bn.height), Dn = In[0], Ln = In[1], $n = getAbsoluteValueForTuple(Cn.borderTopRightRadius, Bn.width, Bn.height), Nn = $n[0], Rn = $n[1], Fn = getAbsoluteValueForTuple(Cn.borderBottomRightRadius, Bn.width, Bn.height), Pn = Fn[0], Un = Fn[1], Hn = getAbsoluteValueForTuple(Cn.borderBottomLeftRadius, Bn.width, Bn.height), zn = Hn[0], Gn = Hn[1], Yn = [];
      Yn.push((Dn + Nn) / Bn.width), Yn.push((zn + Pn) / Bn.width), Yn.push((Ln + Gn) / Bn.height), Yn.push((Rn + Un) / Bn.height);
      var Wn = Math.max.apply(Math, Yn);
      Wn > 1 && (Dn /= Wn, Ln /= Wn, Nn /= Wn, Rn /= Wn, Pn /= Wn, Un /= Wn, zn /= Wn, Gn /= Wn);
      var Xn = Bn.width - Nn, ea = Bn.height - Un, ta = Bn.width - Pn, na = Bn.height - Gn, ra = Cn.borderTopWidth, aa = Cn.borderRightWidth, ia = Cn.borderBottomWidth, Aa = Cn.borderLeftWidth, sa = getAbsoluteValue(Cn.paddingTop, nr.bounds.width), oa = getAbsoluteValue(Cn.paddingRight, nr.bounds.width), la = getAbsoluteValue(Cn.paddingBottom, nr.bounds.width), ua = getAbsoluteValue(Cn.paddingLeft, nr.bounds.width);
      this.topLeftBorderDoubleOuterBox = Dn > 0 || Ln > 0 ? getCurvePoints(Bn.left + Aa / 3, Bn.top + ra / 3, Dn - Aa / 3, Ln - ra / 3, CORNER.TOP_LEFT) : new Vector(Bn.left + Aa / 3, Bn.top + ra / 3), this.topRightBorderDoubleOuterBox = Dn > 0 || Ln > 0 ? getCurvePoints(Bn.left + Xn, Bn.top + ra / 3, Nn - aa / 3, Rn - ra / 3, CORNER.TOP_RIGHT) : new Vector(Bn.left + Bn.width - aa / 3, Bn.top + ra / 3), this.bottomRightBorderDoubleOuterBox = Pn > 0 || Un > 0 ? getCurvePoints(Bn.left + ta, Bn.top + ea, Pn - aa / 3, Un - ia / 3, CORNER.BOTTOM_RIGHT) : new Vector(Bn.left + Bn.width - aa / 3, Bn.top + Bn.height - ia / 3), this.bottomLeftBorderDoubleOuterBox = zn > 0 || Gn > 0 ? getCurvePoints(Bn.left + Aa / 3, Bn.top + na, zn - Aa / 3, Gn - ia / 3, CORNER.BOTTOM_LEFT) : new Vector(Bn.left + Aa / 3, Bn.top + Bn.height - ia / 3), this.topLeftBorderDoubleInnerBox = Dn > 0 || Ln > 0 ? getCurvePoints(Bn.left + Aa * 2 / 3, Bn.top + ra * 2 / 3, Dn - Aa * 2 / 3, Ln - ra * 2 / 3, CORNER.TOP_LEFT) : new Vector(Bn.left + Aa * 2 / 3, Bn.top + ra * 2 / 3), this.topRightBorderDoubleInnerBox = Dn > 0 || Ln > 0 ? getCurvePoints(Bn.left + Xn, Bn.top + ra * 2 / 3, Nn - aa * 2 / 3, Rn - ra * 2 / 3, CORNER.TOP_RIGHT) : new Vector(Bn.left + Bn.width - aa * 2 / 3, Bn.top + ra * 2 / 3), this.bottomRightBorderDoubleInnerBox = Pn > 0 || Un > 0 ? getCurvePoints(Bn.left + ta, Bn.top + ea, Pn - aa * 2 / 3, Un - ia * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(Bn.left + Bn.width - aa * 2 / 3, Bn.top + Bn.height - ia * 2 / 3), this.bottomLeftBorderDoubleInnerBox = zn > 0 || Gn > 0 ? getCurvePoints(Bn.left + Aa * 2 / 3, Bn.top + na, zn - Aa * 2 / 3, Gn - ia * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(Bn.left + Aa * 2 / 3, Bn.top + Bn.height - ia * 2 / 3), this.topLeftBorderStroke = Dn > 0 || Ln > 0 ? getCurvePoints(Bn.left + Aa / 2, Bn.top + ra / 2, Dn - Aa / 2, Ln - ra / 2, CORNER.TOP_LEFT) : new Vector(Bn.left + Aa / 2, Bn.top + ra / 2), this.topRightBorderStroke = Dn > 0 || Ln > 0 ? getCurvePoints(Bn.left + Xn, Bn.top + ra / 2, Nn - aa / 2, Rn - ra / 2, CORNER.TOP_RIGHT) : new Vector(Bn.left + Bn.width - aa / 2, Bn.top + ra / 2), this.bottomRightBorderStroke = Pn > 0 || Un > 0 ? getCurvePoints(Bn.left + ta, Bn.top + ea, Pn - aa / 2, Un - ia / 2, CORNER.BOTTOM_RIGHT) : new Vector(Bn.left + Bn.width - aa / 2, Bn.top + Bn.height - ia / 2), this.bottomLeftBorderStroke = zn > 0 || Gn > 0 ? getCurvePoints(Bn.left + Aa / 2, Bn.top + na, zn - Aa / 2, Gn - ia / 2, CORNER.BOTTOM_LEFT) : new Vector(Bn.left + Aa / 2, Bn.top + Bn.height - ia / 2), this.topLeftBorderBox = Dn > 0 || Ln > 0 ? getCurvePoints(Bn.left, Bn.top, Dn, Ln, CORNER.TOP_LEFT) : new Vector(Bn.left, Bn.top), this.topRightBorderBox = Nn > 0 || Rn > 0 ? getCurvePoints(Bn.left + Xn, Bn.top, Nn, Rn, CORNER.TOP_RIGHT) : new Vector(Bn.left + Bn.width, Bn.top), this.bottomRightBorderBox = Pn > 0 || Un > 0 ? getCurvePoints(Bn.left + ta, Bn.top + ea, Pn, Un, CORNER.BOTTOM_RIGHT) : new Vector(Bn.left + Bn.width, Bn.top + Bn.height), this.bottomLeftBorderBox = zn > 0 || Gn > 0 ? getCurvePoints(Bn.left, Bn.top + na, zn, Gn, CORNER.BOTTOM_LEFT) : new Vector(Bn.left, Bn.top + Bn.height), this.topLeftPaddingBox = Dn > 0 || Ln > 0 ? getCurvePoints(Bn.left + Aa, Bn.top + ra, Math.max(0, Dn - Aa), Math.max(0, Ln - ra), CORNER.TOP_LEFT) : new Vector(Bn.left + Aa, Bn.top + ra), this.topRightPaddingBox = Nn > 0 || Rn > 0 ? getCurvePoints(Bn.left + Math.min(Xn, Bn.width - aa), Bn.top + ra, Xn > Bn.width + aa ? 0 : Math.max(0, Nn - aa), Math.max(0, Rn - ra), CORNER.TOP_RIGHT) : new Vector(Bn.left + Bn.width - aa, Bn.top + ra), this.bottomRightPaddingBox = Pn > 0 || Un > 0 ? getCurvePoints(Bn.left + Math.min(ta, Bn.width - Aa), Bn.top + Math.min(ea, Bn.height - ia), Math.max(0, Pn - aa), Math.max(0, Un - ia), CORNER.BOTTOM_RIGHT) : new Vector(Bn.left + Bn.width - aa, Bn.top + Bn.height - ia), this.bottomLeftPaddingBox = zn > 0 || Gn > 0 ? getCurvePoints(Bn.left + Aa, Bn.top + Math.min(na, Bn.height - ia), Math.max(0, zn - Aa), Math.max(0, Gn - ia), CORNER.BOTTOM_LEFT) : new Vector(Bn.left + Aa, Bn.top + Bn.height - ia), this.topLeftContentBox = Dn > 0 || Ln > 0 ? getCurvePoints(Bn.left + Aa + ua, Bn.top + ra + sa, Math.max(0, Dn - (Aa + ua)), Math.max(0, Ln - (ra + sa)), CORNER.TOP_LEFT) : new Vector(Bn.left + Aa + ua, Bn.top + ra + sa), this.topRightContentBox = Nn > 0 || Rn > 0 ? getCurvePoints(Bn.left + Math.min(Xn, Bn.width + Aa + ua), Bn.top + ra + sa, Xn > Bn.width + Aa + ua ? 0 : Nn - Aa + ua, Rn - (ra + sa), CORNER.TOP_RIGHT) : new Vector(Bn.left + Bn.width - (aa + oa), Bn.top + ra + sa), this.bottomRightContentBox = Pn > 0 || Un > 0 ? getCurvePoints(Bn.left + Math.min(ta, Bn.width - (Aa + ua)), Bn.top + Math.min(ea, Bn.height + ra + sa), Math.max(0, Pn - (aa + oa)), Un - (ia + la), CORNER.BOTTOM_RIGHT) : new Vector(Bn.left + Bn.width - (aa + oa), Bn.top + Bn.height - (ia + la)), this.bottomLeftContentBox = zn > 0 || Gn > 0 ? getCurvePoints(Bn.left + Aa + ua, Bn.top + na, Math.max(0, zn - (Aa + ua)), Gn - (ia + la), CORNER.BOTTOM_LEFT) : new Vector(Bn.left + Aa + ua, Bn.top + Bn.height - (ia + la));
    }
    return _n;
  }()
), CORNER;
(function(_n) {
  _n[_n.TOP_LEFT = 0] = "TOP_LEFT", _n[_n.TOP_RIGHT = 1] = "TOP_RIGHT", _n[_n.BOTTOM_RIGHT = 2] = "BOTTOM_RIGHT", _n[_n.BOTTOM_LEFT = 3] = "BOTTOM_LEFT";
})(CORNER || (CORNER = {}));
var getCurvePoints = function(_n, nr, Cn, Bn, In) {
  var Dn = 4 * ((Math.sqrt(2) - 1) / 3), Ln = Cn * Dn, $n = Bn * Dn, Nn = _n + Cn, Rn = nr + Bn;
  switch (In) {
    case CORNER.TOP_LEFT:
      return new BezierCurve(new Vector(_n, Rn), new Vector(_n, Rn - $n), new Vector(Nn - Ln, nr), new Vector(Nn, nr));
    case CORNER.TOP_RIGHT:
      return new BezierCurve(new Vector(_n, nr), new Vector(_n + Ln, nr), new Vector(Nn, Rn - $n), new Vector(Nn, Rn));
    case CORNER.BOTTOM_RIGHT:
      return new BezierCurve(new Vector(Nn, nr), new Vector(Nn, nr + $n), new Vector(_n + Ln, Rn), new Vector(_n, Rn));
    case CORNER.BOTTOM_LEFT:
    default:
      return new BezierCurve(new Vector(Nn, Rn), new Vector(Nn - Ln, Rn), new Vector(_n, nr + $n), new Vector(_n, nr));
  }
}, calculateBorderBoxPath = function(_n) {
  return [_n.topLeftBorderBox, _n.topRightBorderBox, _n.bottomRightBorderBox, _n.bottomLeftBorderBox];
}, calculateContentBoxPath = function(_n) {
  return [
    _n.topLeftContentBox,
    _n.topRightContentBox,
    _n.bottomRightContentBox,
    _n.bottomLeftContentBox
  ];
}, calculatePaddingBoxPath = function(_n) {
  return [
    _n.topLeftPaddingBox,
    _n.topRightPaddingBox,
    _n.bottomRightPaddingBox,
    _n.bottomLeftPaddingBox
  ];
}, TransformEffect = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.offsetX = nr, this.offsetY = Cn, this.matrix = Bn, this.type = 0, this.target = 6;
    }
    return _n;
  }()
), ClipEffect = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.path = nr, this.target = Cn, this.type = 1;
    }
    return _n;
  }()
), OpacityEffect = (
  /** @class */
  function() {
    function _n(nr) {
      this.opacity = nr, this.type = 2, this.target = 6;
    }
    return _n;
  }()
), isTransformEffect = function(_n) {
  return _n.type === 0;
}, isClipEffect = function(_n) {
  return _n.type === 1;
}, isOpacityEffect = function(_n) {
  return _n.type === 2;
}, equalPath = function(_n, nr) {
  return _n.length === nr.length ? _n.some(function(Cn, Bn) {
    return Cn === nr[Bn];
  }) : !1;
}, transformPath = function(_n, nr, Cn, Bn, In) {
  return _n.map(function(Dn, Ln) {
    switch (Ln) {
      case 0:
        return Dn.add(nr, Cn);
      case 1:
        return Dn.add(nr + Bn, Cn);
      case 2:
        return Dn.add(nr + Bn, Cn + In);
      case 3:
        return Dn.add(nr, Cn + In);
    }
    return Dn;
  });
}, StackingContext = (
  /** @class */
  function() {
    function _n(nr) {
      this.element = nr, this.inlineLevel = [], this.nonInlineLevel = [], this.negativeZIndex = [], this.zeroOrAutoZIndexOrTransformedOrOpacity = [], this.positiveZIndex = [], this.nonPositionedFloats = [], this.nonPositionedInlineLevel = [];
    }
    return _n;
  }()
), ElementPaint = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      if (this.container = nr, this.parent = Cn, this.effects = [], this.curves = new BoundCurves(this.container), this.container.styles.opacity < 1 && this.effects.push(new OpacityEffect(this.container.styles.opacity)), this.container.styles.transform !== null) {
        var Bn = this.container.bounds.left + this.container.styles.transformOrigin[0].number, In = this.container.bounds.top + this.container.styles.transformOrigin[1].number, Dn = this.container.styles.transform;
        this.effects.push(new TransformEffect(Bn, In, Dn));
      }
      if (this.container.styles.overflowX !== 0) {
        var Ln = calculateBorderBoxPath(this.curves), $n = calculatePaddingBoxPath(this.curves);
        equalPath(Ln, $n) ? this.effects.push(new ClipEffect(
          Ln,
          6
          /* CONTENT */
        )) : (this.effects.push(new ClipEffect(
          Ln,
          2
          /* BACKGROUND_BORDERS */
        )), this.effects.push(new ClipEffect(
          $n,
          4
          /* CONTENT */
        )));
      }
    }
    return _n.prototype.getEffects = function(nr) {
      for (var Cn = [
        2,
        3
        /* FIXED */
      ].indexOf(this.container.styles.position) === -1, Bn = this.parent, In = this.effects.slice(0); Bn; ) {
        var Dn = Bn.effects.filter(function(Nn) {
          return !isClipEffect(Nn);
        });
        if (Cn || Bn.container.styles.position !== 0 || !Bn.parent) {
          if (In.unshift.apply(In, Dn), Cn = [
            2,
            3
            /* FIXED */
          ].indexOf(Bn.container.styles.position) === -1, Bn.container.styles.overflowX !== 0) {
            var Ln = calculateBorderBoxPath(Bn.curves), $n = calculatePaddingBoxPath(Bn.curves);
            equalPath(Ln, $n) || In.unshift(new ClipEffect(
              $n,
              6
              /* CONTENT */
            ));
          }
        } else
          In.unshift.apply(In, Dn);
        Bn = Bn.parent;
      }
      return In.filter(function(Nn) {
        return contains$1(Nn.target, nr);
      });
    }, _n;
  }()
), parseStackTree = function(_n, nr, Cn, Bn) {
  _n.container.elements.forEach(function(In) {
    var Dn = contains$1(
      In.flags,
      4
      /* CREATES_REAL_STACKING_CONTEXT */
    ), Ln = contains$1(
      In.flags,
      2
      /* CREATES_STACKING_CONTEXT */
    ), $n = new ElementPaint(In, _n);
    contains$1(
      In.styles.display,
      2048
      /* LIST_ITEM */
    ) && Bn.push($n);
    var Nn = contains$1(
      In.flags,
      8
      /* IS_LIST_OWNER */
    ) ? [] : Bn;
    if (Dn || Ln) {
      var Rn = Dn || In.styles.isPositioned() ? Cn : nr, Fn = new StackingContext($n);
      if (In.styles.isPositioned() || In.styles.opacity < 1 || In.styles.isTransformed()) {
        var Pn = In.styles.zIndex.order;
        if (Pn < 0) {
          var Un = 0;
          Rn.negativeZIndex.some(function(zn, Gn) {
            return Pn > zn.element.container.styles.zIndex.order ? (Un = Gn, !1) : Un > 0;
          }), Rn.negativeZIndex.splice(Un, 0, Fn);
        } else if (Pn > 0) {
          var Hn = 0;
          Rn.positiveZIndex.some(function(zn, Gn) {
            return Pn >= zn.element.container.styles.zIndex.order ? (Hn = Gn + 1, !1) : Hn > 0;
          }), Rn.positiveZIndex.splice(Hn, 0, Fn);
        } else
          Rn.zeroOrAutoZIndexOrTransformedOrOpacity.push(Fn);
      } else
        In.styles.isFloating() ? Rn.nonPositionedFloats.push(Fn) : Rn.nonPositionedInlineLevel.push(Fn);
      parseStackTree($n, Fn, Dn ? Fn : Cn, Nn);
    } else
      In.styles.isInlineLevel() ? nr.inlineLevel.push($n) : nr.nonInlineLevel.push($n), parseStackTree($n, nr, Cn, Nn);
    contains$1(
      In.flags,
      8
      /* IS_LIST_OWNER */
    ) && processListItems(In, Nn);
  });
}, processListItems = function(_n, nr) {
  for (var Cn = _n instanceof OLElementContainer ? _n.start : 1, Bn = _n instanceof OLElementContainer ? _n.reversed : !1, In = 0; In < nr.length; In++) {
    var Dn = nr[In];
    Dn.container instanceof LIElementContainer && typeof Dn.container.value == "number" && Dn.container.value !== 0 && (Cn = Dn.container.value), Dn.listValue = createCounterText(Cn, Dn.container.styles.listStyleType, !0), Cn += Bn ? -1 : 1;
  }
}, parseStackingContexts = function(_n) {
  var nr = new ElementPaint(_n, null), Cn = new StackingContext(nr), Bn = [];
  return parseStackTree(nr, Cn, Cn, Bn), processListItems(nr.container, Bn), Cn;
}, parsePathForBorder = function(_n, nr) {
  switch (nr) {
    case 0:
      return createPathFromCurves(_n.topLeftBorderBox, _n.topLeftPaddingBox, _n.topRightBorderBox, _n.topRightPaddingBox);
    case 1:
      return createPathFromCurves(_n.topRightBorderBox, _n.topRightPaddingBox, _n.bottomRightBorderBox, _n.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(_n.bottomRightBorderBox, _n.bottomRightPaddingBox, _n.bottomLeftBorderBox, _n.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(_n.bottomLeftBorderBox, _n.bottomLeftPaddingBox, _n.topLeftBorderBox, _n.topLeftPaddingBox);
  }
}, parsePathForBorderDoubleOuter = function(_n, nr) {
  switch (nr) {
    case 0:
      return createPathFromCurves(_n.topLeftBorderBox, _n.topLeftBorderDoubleOuterBox, _n.topRightBorderBox, _n.topRightBorderDoubleOuterBox);
    case 1:
      return createPathFromCurves(_n.topRightBorderBox, _n.topRightBorderDoubleOuterBox, _n.bottomRightBorderBox, _n.bottomRightBorderDoubleOuterBox);
    case 2:
      return createPathFromCurves(_n.bottomRightBorderBox, _n.bottomRightBorderDoubleOuterBox, _n.bottomLeftBorderBox, _n.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return createPathFromCurves(_n.bottomLeftBorderBox, _n.bottomLeftBorderDoubleOuterBox, _n.topLeftBorderBox, _n.topLeftBorderDoubleOuterBox);
  }
}, parsePathForBorderDoubleInner = function(_n, nr) {
  switch (nr) {
    case 0:
      return createPathFromCurves(_n.topLeftBorderDoubleInnerBox, _n.topLeftPaddingBox, _n.topRightBorderDoubleInnerBox, _n.topRightPaddingBox);
    case 1:
      return createPathFromCurves(_n.topRightBorderDoubleInnerBox, _n.topRightPaddingBox, _n.bottomRightBorderDoubleInnerBox, _n.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(_n.bottomRightBorderDoubleInnerBox, _n.bottomRightPaddingBox, _n.bottomLeftBorderDoubleInnerBox, _n.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(_n.bottomLeftBorderDoubleInnerBox, _n.bottomLeftPaddingBox, _n.topLeftBorderDoubleInnerBox, _n.topLeftPaddingBox);
  }
}, parsePathForBorderStroke = function(_n, nr) {
  switch (nr) {
    case 0:
      return createStrokePathFromCurves(_n.topLeftBorderStroke, _n.topRightBorderStroke);
    case 1:
      return createStrokePathFromCurves(_n.topRightBorderStroke, _n.bottomRightBorderStroke);
    case 2:
      return createStrokePathFromCurves(_n.bottomRightBorderStroke, _n.bottomLeftBorderStroke);
    case 3:
    default:
      return createStrokePathFromCurves(_n.bottomLeftBorderStroke, _n.topLeftBorderStroke);
  }
}, createStrokePathFromCurves = function(_n, nr) {
  var Cn = [];
  return isBezierCurve(_n) ? Cn.push(_n.subdivide(0.5, !1)) : Cn.push(_n), isBezierCurve(nr) ? Cn.push(nr.subdivide(0.5, !0)) : Cn.push(nr), Cn;
}, createPathFromCurves = function(_n, nr, Cn, Bn) {
  var In = [];
  return isBezierCurve(_n) ? In.push(_n.subdivide(0.5, !1)) : In.push(_n), isBezierCurve(Cn) ? In.push(Cn.subdivide(0.5, !0)) : In.push(Cn), isBezierCurve(Bn) ? In.push(Bn.subdivide(0.5, !0).reverse()) : In.push(Bn), isBezierCurve(nr) ? In.push(nr.subdivide(0.5, !1).reverse()) : In.push(nr), In;
}, paddingBox = function(_n) {
  var nr = _n.bounds, Cn = _n.styles;
  return nr.add(Cn.borderLeftWidth, Cn.borderTopWidth, -(Cn.borderRightWidth + Cn.borderLeftWidth), -(Cn.borderTopWidth + Cn.borderBottomWidth));
}, contentBox = function(_n) {
  var nr = _n.styles, Cn = _n.bounds, Bn = getAbsoluteValue(nr.paddingLeft, Cn.width), In = getAbsoluteValue(nr.paddingRight, Cn.width), Dn = getAbsoluteValue(nr.paddingTop, Cn.width), Ln = getAbsoluteValue(nr.paddingBottom, Cn.width);
  return Cn.add(Bn + nr.borderLeftWidth, Dn + nr.borderTopWidth, -(nr.borderRightWidth + nr.borderLeftWidth + Bn + In), -(nr.borderTopWidth + nr.borderBottomWidth + Dn + Ln));
}, calculateBackgroundPositioningArea = function(_n, nr) {
  return _n === 0 ? nr.bounds : _n === 2 ? contentBox(nr) : paddingBox(nr);
}, calculateBackgroundPaintingArea = function(_n, nr) {
  return _n === 0 ? nr.bounds : _n === 2 ? contentBox(nr) : paddingBox(nr);
}, calculateBackgroundRendering = function(_n, nr, Cn) {
  var Bn = calculateBackgroundPositioningArea(getBackgroundValueForIndex(_n.styles.backgroundOrigin, nr), _n), In = calculateBackgroundPaintingArea(getBackgroundValueForIndex(_n.styles.backgroundClip, nr), _n), Dn = calculateBackgroundSize(getBackgroundValueForIndex(_n.styles.backgroundSize, nr), Cn, Bn), Ln = Dn[0], $n = Dn[1], Nn = getAbsoluteValueForTuple(getBackgroundValueForIndex(_n.styles.backgroundPosition, nr), Bn.width - Ln, Bn.height - $n), Rn = calculateBackgroundRepeatPath(getBackgroundValueForIndex(_n.styles.backgroundRepeat, nr), Nn, Dn, Bn, In), Fn = Math.round(Bn.left + Nn[0]), Pn = Math.round(Bn.top + Nn[1]);
  return [Rn, Fn, Pn, Ln, $n];
}, isAuto = function(_n) {
  return isIdentToken(_n) && _n.value === BACKGROUND_SIZE.AUTO;
}, hasIntrinsicValue = function(_n) {
  return typeof _n == "number";
}, calculateBackgroundSize = function(_n, nr, Cn) {
  var Bn = nr[0], In = nr[1], Dn = nr[2], Ln = _n[0], $n = _n[1];
  if (!Ln)
    return [0, 0];
  if (isLengthPercentage(Ln) && $n && isLengthPercentage($n))
    return [getAbsoluteValue(Ln, Cn.width), getAbsoluteValue($n, Cn.height)];
  var Nn = hasIntrinsicValue(Dn);
  if (isIdentToken(Ln) && (Ln.value === BACKGROUND_SIZE.CONTAIN || Ln.value === BACKGROUND_SIZE.COVER)) {
    if (hasIntrinsicValue(Dn)) {
      var Rn = Cn.width / Cn.height;
      return Rn < Dn != (Ln.value === BACKGROUND_SIZE.COVER) ? [Cn.width, Cn.width / Dn] : [Cn.height * Dn, Cn.height];
    }
    return [Cn.width, Cn.height];
  }
  var Fn = hasIntrinsicValue(Bn), Pn = hasIntrinsicValue(In), Un = Fn || Pn;
  if (isAuto(Ln) && (!$n || isAuto($n))) {
    if (Fn && Pn)
      return [Bn, In];
    if (!Nn && !Un)
      return [Cn.width, Cn.height];
    if (Un && Nn) {
      var Hn = Fn ? Bn : In * Dn, zn = Pn ? In : Bn / Dn;
      return [Hn, zn];
    }
    var Gn = Fn ? Bn : Cn.width, Yn = Pn ? In : Cn.height;
    return [Gn, Yn];
  }
  if (Nn) {
    var Wn = 0, Xn = 0;
    return isLengthPercentage(Ln) ? Wn = getAbsoluteValue(Ln, Cn.width) : isLengthPercentage($n) && (Xn = getAbsoluteValue($n, Cn.height)), isAuto(Ln) ? Wn = Xn * Dn : (!$n || isAuto($n)) && (Xn = Wn / Dn), [Wn, Xn];
  }
  var ea = null, ta = null;
  if (isLengthPercentage(Ln) ? ea = getAbsoluteValue(Ln, Cn.width) : $n && isLengthPercentage($n) && (ta = getAbsoluteValue($n, Cn.height)), ea !== null && (!$n || isAuto($n)) && (ta = Fn && Pn ? ea / Bn * In : Cn.height), ta !== null && isAuto(Ln) && (ea = Fn && Pn ? ta / In * Bn : Cn.width), ea !== null && ta !== null)
    return [ea, ta];
  throw new Error("Unable to calculate background-size for element");
}, getBackgroundValueForIndex = function(_n, nr) {
  var Cn = _n[nr];
  return typeof Cn > "u" ? _n[0] : Cn;
}, calculateBackgroundRepeatPath = function(_n, nr, Cn, Bn, In) {
  var Dn = nr[0], Ln = nr[1], $n = Cn[0], Nn = Cn[1];
  switch (_n) {
    case 2:
      return [
        new Vector(Math.round(Bn.left), Math.round(Bn.top + Ln)),
        new Vector(Math.round(Bn.left + Bn.width), Math.round(Bn.top + Ln)),
        new Vector(Math.round(Bn.left + Bn.width), Math.round(Nn + Bn.top + Ln)),
        new Vector(Math.round(Bn.left), Math.round(Nn + Bn.top + Ln))
      ];
    case 3:
      return [
        new Vector(Math.round(Bn.left + Dn), Math.round(Bn.top)),
        new Vector(Math.round(Bn.left + Dn + $n), Math.round(Bn.top)),
        new Vector(Math.round(Bn.left + Dn + $n), Math.round(Bn.height + Bn.top)),
        new Vector(Math.round(Bn.left + Dn), Math.round(Bn.height + Bn.top))
      ];
    case 1:
      return [
        new Vector(Math.round(Bn.left + Dn), Math.round(Bn.top + Ln)),
        new Vector(Math.round(Bn.left + Dn + $n), Math.round(Bn.top + Ln)),
        new Vector(Math.round(Bn.left + Dn + $n), Math.round(Bn.top + Ln + Nn)),
        new Vector(Math.round(Bn.left + Dn), Math.round(Bn.top + Ln + Nn))
      ];
    default:
      return [
        new Vector(Math.round(In.left), Math.round(In.top)),
        new Vector(Math.round(In.left + In.width), Math.round(In.top)),
        new Vector(Math.round(In.left + In.width), Math.round(In.height + In.top)),
        new Vector(Math.round(In.left), Math.round(In.height + In.top))
      ];
  }
}, SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", SAMPLE_TEXT = "Hidden Text", FontMetrics = (
  /** @class */
  function() {
    function _n(nr) {
      this._data = {}, this._document = nr;
    }
    return _n.prototype.parseMetrics = function(nr, Cn) {
      var Bn = this._document.createElement("div"), In = this._document.createElement("img"), Dn = this._document.createElement("span"), Ln = this._document.body;
      Bn.style.visibility = "hidden", Bn.style.fontFamily = nr, Bn.style.fontSize = Cn, Bn.style.margin = "0", Bn.style.padding = "0", Bn.style.whiteSpace = "nowrap", Ln.appendChild(Bn), In.src = SMALL_IMAGE, In.width = 1, In.height = 1, In.style.margin = "0", In.style.padding = "0", In.style.verticalAlign = "baseline", Dn.style.fontFamily = nr, Dn.style.fontSize = Cn, Dn.style.margin = "0", Dn.style.padding = "0", Dn.appendChild(this._document.createTextNode(SAMPLE_TEXT)), Bn.appendChild(Dn), Bn.appendChild(In);
      var $n = In.offsetTop - Dn.offsetTop + 2;
      Bn.removeChild(Dn), Bn.appendChild(this._document.createTextNode(SAMPLE_TEXT)), Bn.style.lineHeight = "normal", In.style.verticalAlign = "super";
      var Nn = In.offsetTop - Bn.offsetTop + 2;
      return Ln.removeChild(Bn), { baseline: $n, middle: Nn };
    }, _n.prototype.getMetrics = function(nr, Cn) {
      var Bn = nr + " " + Cn;
      return typeof this._data[Bn] > "u" && (this._data[Bn] = this.parseMetrics(nr, Cn)), this._data[Bn];
    }, _n;
  }()
), Renderer = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.context = nr, this.options = Cn;
    }
    return _n;
  }()
), MASK_OFFSET = 1e4, CanvasRenderer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this;
      return In._activeEffects = [], In.canvas = Bn.canvas ? Bn.canvas : document.createElement("canvas"), In.ctx = In.canvas.getContext("2d"), Bn.canvas || (In.canvas.width = Math.floor(Bn.width * Bn.scale), In.canvas.height = Math.floor(Bn.height * Bn.scale), In.canvas.style.width = Bn.width + "px", In.canvas.style.height = Bn.height + "px"), In.fontMetrics = new FontMetrics(document), In.ctx.scale(In.options.scale, In.options.scale), In.ctx.translate(-Bn.x, -Bn.y), In.ctx.textBaseline = "bottom", In._activeEffects = [], In.context.logger.debug("Canvas renderer initialized (" + Bn.width + "x" + Bn.height + ") with scale " + Bn.scale), In;
    }
    return nr.prototype.applyEffects = function(Cn) {
      for (var Bn = this; this._activeEffects.length; )
        this.popEffect();
      Cn.forEach(function(In) {
        return Bn.applyEffect(In);
      });
    }, nr.prototype.applyEffect = function(Cn) {
      this.ctx.save(), isOpacityEffect(Cn) && (this.ctx.globalAlpha = Cn.opacity), isTransformEffect(Cn) && (this.ctx.translate(Cn.offsetX, Cn.offsetY), this.ctx.transform(Cn.matrix[0], Cn.matrix[1], Cn.matrix[2], Cn.matrix[3], Cn.matrix[4], Cn.matrix[5]), this.ctx.translate(-Cn.offsetX, -Cn.offsetY)), isClipEffect(Cn) && (this.path(Cn.path), this.ctx.clip()), this._activeEffects.push(Cn);
    }, nr.prototype.popEffect = function() {
      this._activeEffects.pop(), this.ctx.restore();
    }, nr.prototype.renderStack = function(Cn) {
      return __awaiter(this, void 0, void 0, function() {
        var Bn;
        return __generator(this, function(In) {
          switch (In.label) {
            case 0:
              return Bn = Cn.element.container.styles, Bn.isVisible() ? [4, this.renderStackContent(Cn)] : [3, 2];
            case 1:
              In.sent(), In.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, nr.prototype.renderNode = function(Cn) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(Bn) {
          switch (Bn.label) {
            case 0:
              if (contains$1(
                Cn.container.flags,
                16
                /* DEBUG_RENDER */
              ))
                debugger;
              return Cn.container.styles.isVisible() ? [4, this.renderNodeBackgroundAndBorders(Cn)] : [3, 3];
            case 1:
              return Bn.sent(), [4, this.renderNodeContent(Cn)];
            case 2:
              Bn.sent(), Bn.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, nr.prototype.renderTextWithLetterSpacing = function(Cn, Bn, In) {
      var Dn = this;
      if (Bn === 0)
        this.ctx.fillText(Cn.text, Cn.bounds.left, Cn.bounds.top + In);
      else {
        var Ln = segmentGraphemes(Cn.text);
        Ln.reduce(function($n, Nn) {
          return Dn.ctx.fillText(Nn, $n, Cn.bounds.top + In), $n + Dn.ctx.measureText(Nn).width;
        }, Cn.bounds.left);
      }
    }, nr.prototype.createFontStyle = function(Cn) {
      var Bn = Cn.fontVariant.filter(function(Ln) {
        return Ln === "normal" || Ln === "small-caps";
      }).join(""), In = fixIOSSystemFonts(Cn.fontFamily).join(", "), Dn = isDimensionToken(Cn.fontSize) ? "" + Cn.fontSize.number + Cn.fontSize.unit : Cn.fontSize.number + "px";
      return [
        [Cn.fontStyle, Bn, Cn.fontWeight, Dn, In].join(" "),
        In,
        Dn
      ];
    }, nr.prototype.renderTextNode = function(Cn, Bn) {
      return __awaiter(this, void 0, void 0, function() {
        var In, Dn, Ln, $n, Nn, Rn, Fn, Pn, Un = this;
        return __generator(this, function(Hn) {
          return In = this.createFontStyle(Bn), Dn = In[0], Ln = In[1], $n = In[2], this.ctx.font = Dn, this.ctx.direction = Bn.direction === 1 ? "rtl" : "ltr", this.ctx.textAlign = "left", this.ctx.textBaseline = "alphabetic", Nn = this.fontMetrics.getMetrics(Ln, $n), Rn = Nn.baseline, Fn = Nn.middle, Pn = Bn.paintOrder, Cn.textBounds.forEach(function(zn) {
            Pn.forEach(function(Gn) {
              switch (Gn) {
                case 0:
                  Un.ctx.fillStyle = asString(Bn.color), Un.renderTextWithLetterSpacing(zn, Bn.letterSpacing, Rn);
                  var Yn = Bn.textShadow;
                  Yn.length && zn.text.trim().length && (Yn.slice(0).reverse().forEach(function(Wn) {
                    Un.ctx.shadowColor = asString(Wn.color), Un.ctx.shadowOffsetX = Wn.offsetX.number * Un.options.scale, Un.ctx.shadowOffsetY = Wn.offsetY.number * Un.options.scale, Un.ctx.shadowBlur = Wn.blur.number, Un.renderTextWithLetterSpacing(zn, Bn.letterSpacing, Rn);
                  }), Un.ctx.shadowColor = "", Un.ctx.shadowOffsetX = 0, Un.ctx.shadowOffsetY = 0, Un.ctx.shadowBlur = 0), Bn.textDecorationLine.length && (Un.ctx.fillStyle = asString(Bn.textDecorationColor || Bn.color), Bn.textDecorationLine.forEach(function(Wn) {
                    switch (Wn) {
                      case 1:
                        Un.ctx.fillRect(zn.bounds.left, Math.round(zn.bounds.top + Rn), zn.bounds.width, 1);
                        break;
                      case 2:
                        Un.ctx.fillRect(zn.bounds.left, Math.round(zn.bounds.top), zn.bounds.width, 1);
                        break;
                      case 3:
                        Un.ctx.fillRect(zn.bounds.left, Math.ceil(zn.bounds.top + Fn), zn.bounds.width, 1);
                        break;
                    }
                  }));
                  break;
                case 1:
                  Bn.webkitTextStrokeWidth && zn.text.trim().length && (Un.ctx.strokeStyle = asString(Bn.webkitTextStrokeColor), Un.ctx.lineWidth = Bn.webkitTextStrokeWidth, Un.ctx.lineJoin = window.chrome ? "miter" : "round", Un.ctx.strokeText(zn.text, zn.bounds.left, zn.bounds.top + Rn)), Un.ctx.strokeStyle = "", Un.ctx.lineWidth = 0, Un.ctx.lineJoin = "miter";
                  break;
              }
            });
          }), [
            2
            /*return*/
          ];
        });
      });
    }, nr.prototype.renderReplacedElement = function(Cn, Bn, In) {
      if (In && Cn.intrinsicWidth > 0 && Cn.intrinsicHeight > 0) {
        var Dn = contentBox(Cn), Ln = calculatePaddingBoxPath(Bn);
        this.path(Ln), this.ctx.save(), this.ctx.clip(), this.ctx.drawImage(In, 0, 0, Cn.intrinsicWidth, Cn.intrinsicHeight, Dn.left, Dn.top, Dn.width, Dn.height), this.ctx.restore();
      }
    }, nr.prototype.renderNodeContent = function(Cn) {
      return __awaiter(this, void 0, void 0, function() {
        var Bn, In, Dn, Ln, $n, Nn, Xn, Xn, Rn, Fn, Pn, Un, ta, Hn, zn, na, Gn, Yn, Wn, Xn, ea, ta, na;
        return __generator(this, function(ra) {
          switch (ra.label) {
            case 0:
              this.applyEffects(Cn.getEffects(
                4
                /* CONTENT */
              )), Bn = Cn.container, In = Cn.curves, Dn = Bn.styles, Ln = 0, $n = Bn.textNodes, ra.label = 1;
            case 1:
              return Ln < $n.length ? (Nn = $n[Ln], [4, this.renderTextNode(Nn, Dn)]) : [3, 4];
            case 2:
              ra.sent(), ra.label = 3;
            case 3:
              return Ln++, [3, 1];
            case 4:
              if (!(Bn instanceof ImageElementContainer))
                return [3, 8];
              ra.label = 5;
            case 5:
              return ra.trys.push([5, 7, , 8]), [4, this.context.cache.match(Bn.src)];
            case 6:
              return Xn = ra.sent(), this.renderReplacedElement(Bn, In, Xn), [3, 8];
            case 7:
              return ra.sent(), this.context.logger.error("Error loading image " + Bn.src), [3, 8];
            case 8:
              if (Bn instanceof CanvasElementContainer && this.renderReplacedElement(Bn, In, Bn.canvas), !(Bn instanceof SVGElementContainer))
                return [3, 12];
              ra.label = 9;
            case 9:
              return ra.trys.push([9, 11, , 12]), [4, this.context.cache.match(Bn.svg)];
            case 10:
              return Xn = ra.sent(), this.renderReplacedElement(Bn, In, Xn), [3, 12];
            case 11:
              return ra.sent(), this.context.logger.error("Error loading svg " + Bn.svg.substring(0, 255)), [3, 12];
            case 12:
              return Bn instanceof IFrameElementContainer && Bn.tree ? (Rn = new nr(this.context, {
                scale: this.options.scale,
                backgroundColor: Bn.backgroundColor,
                x: 0,
                y: 0,
                width: Bn.width,
                height: Bn.height
              }), [4, Rn.render(Bn.tree)]) : [3, 14];
            case 13:
              Fn = ra.sent(), Bn.width && Bn.height && this.ctx.drawImage(Fn, 0, 0, Bn.width, Bn.height, Bn.bounds.left, Bn.bounds.top, Bn.bounds.width, Bn.bounds.height), ra.label = 14;
            case 14:
              if (Bn instanceof InputElementContainer && (Pn = Math.min(Bn.bounds.width, Bn.bounds.height), Bn.type === CHECKBOX ? Bn.checked && (this.ctx.save(), this.path([
                new Vector(Bn.bounds.left + Pn * 0.39363, Bn.bounds.top + Pn * 0.79),
                new Vector(Bn.bounds.left + Pn * 0.16, Bn.bounds.top + Pn * 0.5549),
                new Vector(Bn.bounds.left + Pn * 0.27347, Bn.bounds.top + Pn * 0.44071),
                new Vector(Bn.bounds.left + Pn * 0.39694, Bn.bounds.top + Pn * 0.5649),
                new Vector(Bn.bounds.left + Pn * 0.72983, Bn.bounds.top + Pn * 0.23),
                new Vector(Bn.bounds.left + Pn * 0.84, Bn.bounds.top + Pn * 0.34085),
                new Vector(Bn.bounds.left + Pn * 0.39363, Bn.bounds.top + Pn * 0.79)
              ]), this.ctx.fillStyle = asString(INPUT_COLOR), this.ctx.fill(), this.ctx.restore()) : Bn.type === RADIO && Bn.checked && (this.ctx.save(), this.ctx.beginPath(), this.ctx.arc(Bn.bounds.left + Pn / 2, Bn.bounds.top + Pn / 2, Pn / 4, 0, Math.PI * 2, !0), this.ctx.fillStyle = asString(INPUT_COLOR), this.ctx.fill(), this.ctx.restore())), isTextInputElement(Bn) && Bn.value.length) {
                switch (Un = this.createFontStyle(Dn), ta = Un[0], Hn = Un[1], zn = this.fontMetrics.getMetrics(ta, Hn).baseline, this.ctx.font = ta, this.ctx.fillStyle = asString(Dn.color), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = canvasTextAlign(Bn.styles.textAlign), na = contentBox(Bn), Gn = 0, Bn.styles.textAlign) {
                  case 1:
                    Gn += na.width / 2;
                    break;
                  case 2:
                    Gn += na.width;
                    break;
                }
                Yn = na.add(Gn, 0, 0, -na.height / 2 + 1), this.ctx.save(), this.path([
                  new Vector(na.left, na.top),
                  new Vector(na.left + na.width, na.top),
                  new Vector(na.left + na.width, na.top + na.height),
                  new Vector(na.left, na.top + na.height)
                ]), this.ctx.clip(), this.renderTextWithLetterSpacing(new TextBounds(Bn.value, Yn), Dn.letterSpacing, zn), this.ctx.restore(), this.ctx.textBaseline = "alphabetic", this.ctx.textAlign = "left";
              }
              if (!contains$1(
                Bn.styles.display,
                2048
                /* LIST_ITEM */
              ))
                return [3, 20];
              if (Bn.styles.listStyleImage === null)
                return [3, 19];
              if (Wn = Bn.styles.listStyleImage, Wn.type !== 0)
                return [3, 18];
              Xn = void 0, ea = Wn.url, ra.label = 15;
            case 15:
              return ra.trys.push([15, 17, , 18]), [4, this.context.cache.match(ea)];
            case 16:
              return Xn = ra.sent(), this.ctx.drawImage(Xn, Bn.bounds.left - (Xn.width + 10), Bn.bounds.top), [3, 18];
            case 17:
              return ra.sent(), this.context.logger.error("Error loading list-style-image " + ea), [3, 18];
            case 18:
              return [3, 20];
            case 19:
              Cn.listValue && Bn.styles.listStyleType !== -1 && (ta = this.createFontStyle(Dn)[0], this.ctx.font = ta, this.ctx.fillStyle = asString(Dn.color), this.ctx.textBaseline = "middle", this.ctx.textAlign = "right", na = new Bounds(Bn.bounds.left, Bn.bounds.top + getAbsoluteValue(Bn.styles.paddingTop, Bn.bounds.width), Bn.bounds.width, computeLineHeight(Dn.lineHeight, Dn.fontSize.number) / 2 + 1), this.renderTextWithLetterSpacing(new TextBounds(Cn.listValue, na), Dn.letterSpacing, computeLineHeight(Dn.lineHeight, Dn.fontSize.number) / 2 + 2), this.ctx.textBaseline = "bottom", this.ctx.textAlign = "left"), ra.label = 20;
            case 20:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, nr.prototype.renderStackContent = function(Cn) {
      return __awaiter(this, void 0, void 0, function() {
        var Bn, In, Wn, Dn, Ln, Wn, $n, Nn, Wn, Rn, Fn, Wn, Pn, Un, Wn, Hn, zn, Wn, Gn, Yn, Wn;
        return __generator(this, function(Xn) {
          switch (Xn.label) {
            case 0:
              if (contains$1(
                Cn.element.container.flags,
                16
                /* DEBUG_RENDER */
              ))
                debugger;
              return [4, this.renderNodeBackgroundAndBorders(Cn.element)];
            case 1:
              Xn.sent(), Bn = 0, In = Cn.negativeZIndex, Xn.label = 2;
            case 2:
              return Bn < In.length ? (Wn = In[Bn], [4, this.renderStack(Wn)]) : [3, 5];
            case 3:
              Xn.sent(), Xn.label = 4;
            case 4:
              return Bn++, [3, 2];
            case 5:
              return [4, this.renderNodeContent(Cn.element)];
            case 6:
              Xn.sent(), Dn = 0, Ln = Cn.nonInlineLevel, Xn.label = 7;
            case 7:
              return Dn < Ln.length ? (Wn = Ln[Dn], [4, this.renderNode(Wn)]) : [3, 10];
            case 8:
              Xn.sent(), Xn.label = 9;
            case 9:
              return Dn++, [3, 7];
            case 10:
              $n = 0, Nn = Cn.nonPositionedFloats, Xn.label = 11;
            case 11:
              return $n < Nn.length ? (Wn = Nn[$n], [4, this.renderStack(Wn)]) : [3, 14];
            case 12:
              Xn.sent(), Xn.label = 13;
            case 13:
              return $n++, [3, 11];
            case 14:
              Rn = 0, Fn = Cn.nonPositionedInlineLevel, Xn.label = 15;
            case 15:
              return Rn < Fn.length ? (Wn = Fn[Rn], [4, this.renderStack(Wn)]) : [3, 18];
            case 16:
              Xn.sent(), Xn.label = 17;
            case 17:
              return Rn++, [3, 15];
            case 18:
              Pn = 0, Un = Cn.inlineLevel, Xn.label = 19;
            case 19:
              return Pn < Un.length ? (Wn = Un[Pn], [4, this.renderNode(Wn)]) : [3, 22];
            case 20:
              Xn.sent(), Xn.label = 21;
            case 21:
              return Pn++, [3, 19];
            case 22:
              Hn = 0, zn = Cn.zeroOrAutoZIndexOrTransformedOrOpacity, Xn.label = 23;
            case 23:
              return Hn < zn.length ? (Wn = zn[Hn], [4, this.renderStack(Wn)]) : [3, 26];
            case 24:
              Xn.sent(), Xn.label = 25;
            case 25:
              return Hn++, [3, 23];
            case 26:
              Gn = 0, Yn = Cn.positiveZIndex, Xn.label = 27;
            case 27:
              return Gn < Yn.length ? (Wn = Yn[Gn], [4, this.renderStack(Wn)]) : [3, 30];
            case 28:
              Xn.sent(), Xn.label = 29;
            case 29:
              return Gn++, [3, 27];
            case 30:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, nr.prototype.mask = function(Cn) {
      this.ctx.beginPath(), this.ctx.moveTo(0, 0), this.ctx.lineTo(this.canvas.width, 0), this.ctx.lineTo(this.canvas.width, this.canvas.height), this.ctx.lineTo(0, this.canvas.height), this.ctx.lineTo(0, 0), this.formatPath(Cn.slice(0).reverse()), this.ctx.closePath();
    }, nr.prototype.path = function(Cn) {
      this.ctx.beginPath(), this.formatPath(Cn), this.ctx.closePath();
    }, nr.prototype.formatPath = function(Cn) {
      var Bn = this;
      Cn.forEach(function(In, Dn) {
        var Ln = isBezierCurve(In) ? In.start : In;
        Dn === 0 ? Bn.ctx.moveTo(Ln.x, Ln.y) : Bn.ctx.lineTo(Ln.x, Ln.y), isBezierCurve(In) && Bn.ctx.bezierCurveTo(In.startControl.x, In.startControl.y, In.endControl.x, In.endControl.y, In.end.x, In.end.y);
      });
    }, nr.prototype.renderRepeat = function(Cn, Bn, In, Dn) {
      this.path(Cn), this.ctx.fillStyle = Bn, this.ctx.translate(In, Dn), this.ctx.fill(), this.ctx.translate(-In, -Dn);
    }, nr.prototype.resizeImage = function(Cn, Bn, In) {
      var Dn;
      if (Cn.width === Bn && Cn.height === In)
        return Cn;
      var Ln = (Dn = this.canvas.ownerDocument) !== null && Dn !== void 0 ? Dn : document, $n = Ln.createElement("canvas");
      $n.width = Math.max(1, Bn), $n.height = Math.max(1, In);
      var Nn = $n.getContext("2d");
      return Nn.drawImage(Cn, 0, 0, Cn.width, Cn.height, 0, 0, Bn, In), $n;
    }, nr.prototype.renderBackgroundImage = function(Cn) {
      return __awaiter(this, void 0, void 0, function() {
        var Bn, In, Dn, Ln, $n, Nn;
        return __generator(this, function(Rn) {
          switch (Rn.label) {
            case 0:
              Bn = Cn.styles.backgroundImage.length - 1, In = function(Fn) {
                var Pn, Un, Hn, sa, ha, pa, ua, ca, ia, zn, sa, ha, pa, ua, ca, Gn, Yn, Wn, Xn, ea, ta, na, ra, aa, ia, Aa, sa, oa, la, ua, ca, fa, ha, pa, ya, da, Ca, ma, va, ga, xa, wa;
                return __generator(this, function(ba) {
                  switch (ba.label) {
                    case 0:
                      if (Fn.type !== 0)
                        return [3, 5];
                      Pn = void 0, Un = Fn.url, ba.label = 1;
                    case 1:
                      return ba.trys.push([1, 3, , 4]), [4, Dn.context.cache.match(Un)];
                    case 2:
                      return Pn = ba.sent(), [3, 4];
                    case 3:
                      return ba.sent(), Dn.context.logger.error("Error loading background-image " + Un), [3, 4];
                    case 4:
                      return Pn && (Hn = calculateBackgroundRendering(Cn, Bn, [
                        Pn.width,
                        Pn.height,
                        Pn.width / Pn.height
                      ]), sa = Hn[0], ha = Hn[1], pa = Hn[2], ua = Hn[3], ca = Hn[4], ia = Dn.ctx.createPattern(Dn.resizeImage(Pn, ua, ca), "repeat"), Dn.renderRepeat(sa, ia, ha, pa)), [3, 6];
                    case 5:
                      isLinearGradient(Fn) ? (zn = calculateBackgroundRendering(Cn, Bn, [null, null, null]), sa = zn[0], ha = zn[1], pa = zn[2], ua = zn[3], ca = zn[4], Gn = calculateGradientDirection(Fn.angle, ua, ca), Yn = Gn[0], Wn = Gn[1], Xn = Gn[2], ea = Gn[3], ta = Gn[4], na = document.createElement("canvas"), na.width = ua, na.height = ca, ra = na.getContext("2d"), aa = ra.createLinearGradient(Wn, ea, Xn, ta), processColorStops(Fn.stops, Yn).forEach(function(Ta) {
                        return aa.addColorStop(Ta.stop, asString(Ta.color));
                      }), ra.fillStyle = aa, ra.fillRect(0, 0, ua, ca), ua > 0 && ca > 0 && (ia = Dn.ctx.createPattern(na, "repeat"), Dn.renderRepeat(sa, ia, ha, pa))) : isRadialGradient(Fn) && (Aa = calculateBackgroundRendering(Cn, Bn, [
                        null,
                        null,
                        null
                      ]), sa = Aa[0], oa = Aa[1], la = Aa[2], ua = Aa[3], ca = Aa[4], fa = Fn.position.length === 0 ? [FIFTY_PERCENT] : Fn.position, ha = getAbsoluteValue(fa[0], ua), pa = getAbsoluteValue(fa[fa.length - 1], ca), ya = calculateRadius(Fn, ha, pa, ua, ca), da = ya[0], Ca = ya[1], da > 0 && Ca > 0 && (ma = Dn.ctx.createRadialGradient(oa + ha, la + pa, 0, oa + ha, la + pa, da), processColorStops(Fn.stops, da * 2).forEach(function(Ta) {
                        return ma.addColorStop(Ta.stop, asString(Ta.color));
                      }), Dn.path(sa), Dn.ctx.fillStyle = ma, da !== Ca ? (va = Cn.bounds.left + 0.5 * Cn.bounds.width, ga = Cn.bounds.top + 0.5 * Cn.bounds.height, xa = Ca / da, wa = 1 / xa, Dn.ctx.save(), Dn.ctx.translate(va, ga), Dn.ctx.transform(1, 0, 0, xa, 0, 0), Dn.ctx.translate(-va, -ga), Dn.ctx.fillRect(oa, wa * (la - ga) + ga, ua, ca * wa), Dn.ctx.restore()) : Dn.ctx.fill())), ba.label = 6;
                    case 6:
                      return Bn--, [
                        2
                        /*return*/
                      ];
                  }
                });
              }, Dn = this, Ln = 0, $n = Cn.styles.backgroundImage.slice(0).reverse(), Rn.label = 1;
            case 1:
              return Ln < $n.length ? (Nn = $n[Ln], [5, In(Nn)]) : [3, 4];
            case 2:
              Rn.sent(), Rn.label = 3;
            case 3:
              return Ln++, [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, nr.prototype.renderSolidBorder = function(Cn, Bn, In) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(Dn) {
          return this.path(parsePathForBorder(In, Bn)), this.ctx.fillStyle = asString(Cn), this.ctx.fill(), [
            2
            /*return*/
          ];
        });
      });
    }, nr.prototype.renderDoubleBorder = function(Cn, Bn, In, Dn) {
      return __awaiter(this, void 0, void 0, function() {
        var Ln, $n;
        return __generator(this, function(Nn) {
          switch (Nn.label) {
            case 0:
              return Bn < 3 ? [4, this.renderSolidBorder(Cn, In, Dn)] : [3, 2];
            case 1:
              return Nn.sent(), [
                2
                /*return*/
              ];
            case 2:
              return Ln = parsePathForBorderDoubleOuter(Dn, In), this.path(Ln), this.ctx.fillStyle = asString(Cn), this.ctx.fill(), $n = parsePathForBorderDoubleInner(Dn, In), this.path($n), this.ctx.fill(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, nr.prototype.renderNodeBackgroundAndBorders = function(Cn) {
      return __awaiter(this, void 0, void 0, function() {
        var Bn, In, Dn, Ln, $n, Nn, Rn, Fn, Pn = this;
        return __generator(this, function(Un) {
          switch (Un.label) {
            case 0:
              return this.applyEffects(Cn.getEffects(
                2
                /* BACKGROUND_BORDERS */
              )), Bn = Cn.container.styles, In = !isTransparent(Bn.backgroundColor) || Bn.backgroundImage.length, Dn = [
                { style: Bn.borderTopStyle, color: Bn.borderTopColor, width: Bn.borderTopWidth },
                { style: Bn.borderRightStyle, color: Bn.borderRightColor, width: Bn.borderRightWidth },
                { style: Bn.borderBottomStyle, color: Bn.borderBottomColor, width: Bn.borderBottomWidth },
                { style: Bn.borderLeftStyle, color: Bn.borderLeftColor, width: Bn.borderLeftWidth }
              ], Ln = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(Bn.backgroundClip, 0), Cn.curves), In || Bn.boxShadow.length ? (this.ctx.save(), this.path(Ln), this.ctx.clip(), isTransparent(Bn.backgroundColor) || (this.ctx.fillStyle = asString(Bn.backgroundColor), this.ctx.fill()), [4, this.renderBackgroundImage(Cn.container)]) : [3, 2];
            case 1:
              Un.sent(), this.ctx.restore(), Bn.boxShadow.slice(0).reverse().forEach(function(Hn) {
                Pn.ctx.save();
                var zn = calculateBorderBoxPath(Cn.curves), Gn = Hn.inset ? 0 : MASK_OFFSET, Yn = transformPath(zn, -Gn + (Hn.inset ? 1 : -1) * Hn.spread.number, (Hn.inset ? 1 : -1) * Hn.spread.number, Hn.spread.number * (Hn.inset ? -2 : 2), Hn.spread.number * (Hn.inset ? -2 : 2));
                Hn.inset ? (Pn.path(zn), Pn.ctx.clip(), Pn.mask(Yn)) : (Pn.mask(zn), Pn.ctx.clip(), Pn.path(Yn)), Pn.ctx.shadowOffsetX = Hn.offsetX.number + Gn, Pn.ctx.shadowOffsetY = Hn.offsetY.number, Pn.ctx.shadowColor = asString(Hn.color), Pn.ctx.shadowBlur = Hn.blur.number, Pn.ctx.fillStyle = Hn.inset ? asString(Hn.color) : "rgba(0,0,0,1)", Pn.ctx.fill(), Pn.ctx.restore();
              }), Un.label = 2;
            case 2:
              $n = 0, Nn = 0, Rn = Dn, Un.label = 3;
            case 3:
              return Nn < Rn.length ? (Fn = Rn[Nn], Fn.style !== 0 && !isTransparent(Fn.color) && Fn.width > 0 ? Fn.style !== 2 ? [3, 5] : [4, this.renderDashedDottedBorder(
                Fn.color,
                Fn.width,
                $n,
                Cn.curves,
                2
                /* DASHED */
              )] : [3, 11]) : [3, 13];
            case 4:
              return Un.sent(), [3, 11];
            case 5:
              return Fn.style !== 3 ? [3, 7] : [4, this.renderDashedDottedBorder(
                Fn.color,
                Fn.width,
                $n,
                Cn.curves,
                3
                /* DOTTED */
              )];
            case 6:
              return Un.sent(), [3, 11];
            case 7:
              return Fn.style !== 4 ? [3, 9] : [4, this.renderDoubleBorder(Fn.color, Fn.width, $n, Cn.curves)];
            case 8:
              return Un.sent(), [3, 11];
            case 9:
              return [4, this.renderSolidBorder(Fn.color, $n, Cn.curves)];
            case 10:
              Un.sent(), Un.label = 11;
            case 11:
              $n++, Un.label = 12;
            case 12:
              return Nn++, [3, 3];
            case 13:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, nr.prototype.renderDashedDottedBorder = function(Cn, Bn, In, Dn, Ln) {
      return __awaiter(this, void 0, void 0, function() {
        var $n, Nn, Rn, Fn, Pn, Un, Hn, zn, Gn, Yn, Wn, Xn, ea, ta, na, ra, na, ra;
        return __generator(this, function(aa) {
          return this.ctx.save(), $n = parsePathForBorderStroke(Dn, In), Nn = parsePathForBorder(Dn, In), Ln === 2 && (this.path(Nn), this.ctx.clip()), isBezierCurve(Nn[0]) ? (Rn = Nn[0].start.x, Fn = Nn[0].start.y) : (Rn = Nn[0].x, Fn = Nn[0].y), isBezierCurve(Nn[1]) ? (Pn = Nn[1].end.x, Un = Nn[1].end.y) : (Pn = Nn[1].x, Un = Nn[1].y), In === 0 || In === 2 ? Hn = Math.abs(Rn - Pn) : Hn = Math.abs(Fn - Un), this.ctx.beginPath(), Ln === 3 ? this.formatPath($n) : this.formatPath(Nn.slice(0, 2)), zn = Bn < 3 ? Bn * 3 : Bn * 2, Gn = Bn < 3 ? Bn * 2 : Bn, Ln === 3 && (zn = Bn, Gn = Bn), Yn = !0, Hn <= zn * 2 ? Yn = !1 : Hn <= zn * 2 + Gn ? (Wn = Hn / (2 * zn + Gn), zn *= Wn, Gn *= Wn) : (Xn = Math.floor((Hn + Gn) / (zn + Gn)), ea = (Hn - Xn * zn) / (Xn - 1), ta = (Hn - (Xn + 1) * zn) / Xn, Gn = ta <= 0 || Math.abs(Gn - ea) < Math.abs(Gn - ta) ? ea : ta), Yn && (Ln === 3 ? this.ctx.setLineDash([0, zn + Gn]) : this.ctx.setLineDash([zn, Gn])), Ln === 3 ? (this.ctx.lineCap = "round", this.ctx.lineWidth = Bn) : this.ctx.lineWidth = Bn * 2 + 1.1, this.ctx.strokeStyle = asString(Cn), this.ctx.stroke(), this.ctx.setLineDash([]), Ln === 2 && (isBezierCurve(Nn[0]) && (na = Nn[3], ra = Nn[0], this.ctx.beginPath(), this.formatPath([new Vector(na.end.x, na.end.y), new Vector(ra.start.x, ra.start.y)]), this.ctx.stroke()), isBezierCurve(Nn[1]) && (na = Nn[1], ra = Nn[2], this.ctx.beginPath(), this.formatPath([new Vector(na.end.x, na.end.y), new Vector(ra.start.x, ra.start.y)]), this.ctx.stroke())), this.ctx.restore(), [
            2
            /*return*/
          ];
        });
      });
    }, nr.prototype.render = function(Cn) {
      return __awaiter(this, void 0, void 0, function() {
        var Bn;
        return __generator(this, function(In) {
          switch (In.label) {
            case 0:
              return this.options.backgroundColor && (this.ctx.fillStyle = asString(this.options.backgroundColor), this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height)), Bn = parseStackingContexts(Cn), [4, this.renderStack(Bn)];
            case 1:
              return In.sent(), this.applyEffects([]), [2, this.canvas];
          }
        });
      });
    }, nr;
  }(Renderer)
), isTextInputElement = function(_n) {
  return _n instanceof TextareaElementContainer || _n instanceof SelectElementContainer ? !0 : _n instanceof InputElementContainer && _n.type !== RADIO && _n.type !== CHECKBOX;
}, calculateBackgroundCurvedPaintingArea = function(_n, nr) {
  switch (_n) {
    case 0:
      return calculateBorderBoxPath(nr);
    case 2:
      return calculateContentBoxPath(nr);
    case 1:
    default:
      return calculatePaddingBoxPath(nr);
  }
}, canvasTextAlign = function(_n) {
  switch (_n) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
}, iOSBrokenFonts = ["-apple-system", "system-ui"], fixIOSSystemFonts = function(_n) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? _n.filter(function(nr) {
    return iOSBrokenFonts.indexOf(nr) === -1;
  }) : _n;
}, ForeignObjectRenderer = (
  /** @class */
  function(_n) {
    __extends$1(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this, Cn, Bn) || this;
      return In.canvas = Bn.canvas ? Bn.canvas : document.createElement("canvas"), In.ctx = In.canvas.getContext("2d"), In.options = Bn, In.canvas.width = Math.floor(Bn.width * Bn.scale), In.canvas.height = Math.floor(Bn.height * Bn.scale), In.canvas.style.width = Bn.width + "px", In.canvas.style.height = Bn.height + "px", In.ctx.scale(In.options.scale, In.options.scale), In.ctx.translate(-Bn.x, -Bn.y), In.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + Bn.width + "x" + Bn.height + " at " + Bn.x + "," + Bn.y + ") with scale " + Bn.scale), In;
    }
    return nr.prototype.render = function(Cn) {
      return __awaiter(this, void 0, void 0, function() {
        var Bn, In;
        return __generator(this, function(Dn) {
          switch (Dn.label) {
            case 0:
              return Bn = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, Cn), [4, loadSerializedSVG(Bn)];
            case 1:
              return In = Dn.sent(), this.options.backgroundColor && (this.ctx.fillStyle = asString(this.options.backgroundColor), this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale)), this.ctx.drawImage(In, -this.options.x * this.options.scale, -this.options.y * this.options.scale), [2, this.canvas];
          }
        });
      });
    }, nr;
  }(Renderer)
), loadSerializedSVG = function(_n) {
  return new Promise(function(nr, Cn) {
    var Bn = new Image();
    Bn.onload = function() {
      nr(Bn);
    }, Bn.onerror = Cn, Bn.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(_n));
  });
}, Logger = (
  /** @class */
  function() {
    function _n(nr) {
      var Cn = nr.id, Bn = nr.enabled;
      this.id = Cn, this.enabled = Bn, this.start = Date.now();
    }
    return _n.prototype.debug = function() {
      for (var nr = [], Cn = 0; Cn < arguments.length; Cn++)
        nr[Cn] = arguments[Cn];
      this.enabled && (typeof window < "u" && window.console && typeof console.debug == "function" ? console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], nr)) : this.info.apply(this, nr));
    }, _n.prototype.getTime = function() {
      return Date.now() - this.start;
    }, _n.prototype.info = function() {
      for (var nr = [], Cn = 0; Cn < arguments.length; Cn++)
        nr[Cn] = arguments[Cn];
      this.enabled && typeof window < "u" && window.console && typeof console.info == "function" && console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], nr));
    }, _n.prototype.warn = function() {
      for (var nr = [], Cn = 0; Cn < arguments.length; Cn++)
        nr[Cn] = arguments[Cn];
      this.enabled && (typeof window < "u" && window.console && typeof console.warn == "function" ? console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], nr)) : this.info.apply(this, nr));
    }, _n.prototype.error = function() {
      for (var nr = [], Cn = 0; Cn < arguments.length; Cn++)
        nr[Cn] = arguments[Cn];
      this.enabled && (typeof window < "u" && window.console && typeof console.error == "function" ? console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], nr)) : this.info.apply(this, nr));
    }, _n.instances = {}, _n;
  }()
), Context = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      var Bn;
      this.windowBounds = Cn, this.instanceName = "#" + _n.instanceCount++, this.logger = new Logger({ id: this.instanceName, enabled: nr.logging }), this.cache = (Bn = nr.cache) !== null && Bn !== void 0 ? Bn : new Cache(this, nr);
    }
    return _n.instanceCount = 1, _n;
  }()
), html2canvas = function(_n, nr) {
  return nr === void 0 && (nr = {}), renderElement(_n, nr);
};
typeof window < "u" && CacheStorage.setContext(window);
var renderElement = function(_n, nr) {
  return __awaiter(void 0, void 0, void 0, function() {
    var Cn, Bn, In, Dn, Ln, $n, Nn, Rn, Fn, Pn, Un, Hn, zn, Gn, Yn, Wn, Xn, ea, ta, na, aa, ra, aa, ia, Aa, sa, oa, la, ua, ca, fa, ha, pa, ya, da, Ca, ma, va, ga, xa;
    return __generator(this, function(wa) {
      switch (wa.label) {
        case 0:
          if (!_n || typeof _n != "object")
            return [2, Promise.reject("Invalid element provided as first argument")];
          if (Cn = _n.ownerDocument, !Cn)
            throw new Error("Element is not attached to a Document");
          if (Bn = Cn.defaultView, !Bn)
            throw new Error("Document is not attached to a Window");
          return In = {
            allowTaint: (ia = nr.allowTaint) !== null && ia !== void 0 ? ia : !1,
            imageTimeout: (Aa = nr.imageTimeout) !== null && Aa !== void 0 ? Aa : 15e3,
            proxy: nr.proxy,
            useCORS: (sa = nr.useCORS) !== null && sa !== void 0 ? sa : !1
          }, Dn = __assign({ logging: (oa = nr.logging) !== null && oa !== void 0 ? oa : !0, cache: nr.cache }, In), Ln = {
            windowWidth: (la = nr.windowWidth) !== null && la !== void 0 ? la : Bn.innerWidth,
            windowHeight: (ua = nr.windowHeight) !== null && ua !== void 0 ? ua : Bn.innerHeight,
            scrollX: (ca = nr.scrollX) !== null && ca !== void 0 ? ca : Bn.pageXOffset,
            scrollY: (fa = nr.scrollY) !== null && fa !== void 0 ? fa : Bn.pageYOffset
          }, $n = new Bounds(Ln.scrollX, Ln.scrollY, Ln.windowWidth, Ln.windowHeight), Nn = new Context(Dn, $n), Rn = (ha = nr.foreignObjectRendering) !== null && ha !== void 0 ? ha : !1, Fn = {
            allowTaint: (pa = nr.allowTaint) !== null && pa !== void 0 ? pa : !1,
            onclone: nr.onclone,
            ignoreElements: nr.ignoreElements,
            inlineImages: Rn,
            copyStyles: Rn
          }, Nn.logger.debug("Starting document clone with size " + $n.width + "x" + $n.height + " scrolled to " + -$n.left + "," + -$n.top), Pn = new DocumentCloner(Nn, _n, Fn), Un = Pn.clonedReferenceElement, Un ? [4, Pn.toIFrame(Cn, $n)] : [2, Promise.reject("Unable to find element in cloned iframe")];
        case 1:
          return Hn = wa.sent(), zn = isBodyElement(Un) || isHTMLElement$1(Un) ? parseDocumentSize(Un.ownerDocument) : parseBounds(Nn, Un), Gn = zn.width, Yn = zn.height, Wn = zn.left, Xn = zn.top, ea = parseBackgroundColor(Nn, Un, nr.backgroundColor), ta = {
            canvas: nr.canvas,
            backgroundColor: ea,
            scale: (da = (ya = nr.scale) !== null && ya !== void 0 ? ya : Bn.devicePixelRatio) !== null && da !== void 0 ? da : 1,
            x: ((Ca = nr.x) !== null && Ca !== void 0 ? Ca : 0) + Wn,
            y: ((ma = nr.y) !== null && ma !== void 0 ? ma : 0) + Xn,
            width: (va = nr.width) !== null && va !== void 0 ? va : Math.ceil(Gn),
            height: (ga = nr.height) !== null && ga !== void 0 ? ga : Math.ceil(Yn)
          }, Rn ? (Nn.logger.debug("Document cloned, using foreign object rendering"), aa = new ForeignObjectRenderer(Nn, ta), [4, aa.render(Un)]) : [3, 3];
        case 2:
          return na = wa.sent(), [3, 5];
        case 3:
          return Nn.logger.debug("Document cloned, element located at " + Wn + "," + Xn + " with size " + Gn + "x" + Yn + " using computed rendering"), Nn.logger.debug("Starting DOM parsing"), ra = parseTree(Nn, Un), ea === ra.styles.backgroundColor && (ra.styles.backgroundColor = COLORS.TRANSPARENT), Nn.logger.debug("Starting renderer for element at " + ta.x + "," + ta.y + " with size " + ta.width + "x" + ta.height), aa = new CanvasRenderer(Nn, ta), [4, aa.render(ra)];
        case 4:
          na = wa.sent(), wa.label = 5;
        case 5:
          return (!((xa = nr.removeContainer) !== null && xa !== void 0) || xa) && (DocumentCloner.destroy(Hn) || Nn.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore")), Nn.logger.debug("Finished rendering"), [2, na];
      }
    });
  });
}, parseBackgroundColor = function(_n, nr, Cn) {
  var Bn = nr.ownerDocument, In = Bn.documentElement ? parseColor(_n, getComputedStyle(Bn.documentElement).backgroundColor) : COLORS.TRANSPARENT, Dn = Bn.body ? parseColor(_n, getComputedStyle(Bn.body).backgroundColor) : COLORS.TRANSPARENT, Ln = typeof Cn == "string" ? parseColor(_n, Cn) : Cn === null ? COLORS.TRANSPARENT : 4294967295;
  return nr === Bn.documentElement ? isTransparent(In) ? isTransparent(Dn) ? Ln : Dn : In : Ln;
};
const canvasCut = (_n, nr, Cn) => {
  if (!_n) {
    window.$message.error("导出失败！"), Cn && Cn();
    return;
  }
  html2canvas(_n, {
    backgroundColor: null,
    allowTaint: !0,
    useCORS: !0
  }).then((Bn) => {
    window.$message.success("导出成功！");
    try {
      downloadByA(Bn.toDataURL(), nr, "png");
    } catch {
      console.log("图片导出失败");
    }
    Cn && Cn();
  });
};
function setScreenHome(_n) {
  return get$1("/dms/screen/home/" + _n);
}
function addGroup(_n) {
  return post("/dms/screen/group/add", _n);
}
function updateGroup(_n) {
  return post("/dms/screen/group/update", _n);
}
function deleteGroup(_n) {
  return get$1("/dms/screen/group/delete/" + _n);
}
function deleteScreen(_n) {
  return get$1("/dms/screen/delete/" + _n);
}
function addScreen(_n) {
  return post("/dms/screen/add", _n);
}
function getScreenUrlByGroupId(_n) {
  return get$1("/dms/v2/screen/related/customUrl/" + _n);
}
function getScreenInfo(_n) {
  return get$1(`/dms/screen/info/${_n}`);
}
function updateScreen(_n) {
  return post("/dms/screen/update", _n);
}
function publishScreen(_n, nr) {
  return post("/dms/screen/publish/" + _n, nr);
}
function getHistoryInfo(_n) {
  return get$1(`/dms/screen/history/info/${_n}`);
}
function getHistoryLists(_n) {
  return get$1(`/dms/screen/history/list/id/${_n}`);
}
const _hoisted_1$h = { class: "layout-header" }, _hoisted_2$8 = { class: "page-name" }, _hoisted_3$6 = { class: "app-icon" }, _hoisted_4$4 = ["title"], _hoisted_5$2 = { class: "header-left" }, _hoisted_6$2 = { class: "pop-list" }, _hoisted_7$1 = { class: "header-center" }, _hoisted_8$1 = { class: "header-right" }, _hoisted_9$1 = { class: "btn-item" }, _hoisted_10$1 = { class: "btn-item" }, _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "Header",
  props: {
    data: {
      type: Object,
      default: {}
    }
  },
  setup(_n) {
    const nr = defineAsyncComponent(() => import("./EditDrawer-db544d5c.js")), Cn = useHistoryStore(), Bn = useLayoutStore(), In = useChartEditStore(), { importJsonFileList: Dn, importJsonRequest: Ln, importJsonBeforeUpload: $n } = useImportJson(), { getSidebar: Nn, getConfig: Rn, getResource: Fn, getAppPage: Pn, getFilterConfig: Un } = toRefs(Bn), Hn = computed(() => Cn.getBackStack.length > 1), zn = computed(() => Cn.getForwardStack.length > 0), Gn = inject("pageData", { groupId: 0, appId: 0, screenId: 0, name: "", list: [] }), Yn = reactive({
      sidePopVisible: !1,
      recordPopVisible: !1,
      importUploadFileList: [],
      loadDrawer: !1,
      editDrawerVisible: !1
    }), Wn = ref(!1), { importDesignFileList: Xn, importDesignRequest: ea, importDesignBeforeUpload: ta } = useImportDesign(Gn, In), na = computed(() => In.getEditCanvasConfig.publishStatus), ra = () => {
      Bn.setAppPage(!Pn.value);
    }, aa = () => {
      Bn.setFilterConfig(!Un.value);
    }, ia = () => {
      Bn.setResource(!Fn.value);
    }, Aa = inject("getPageList", () => {
    }), sa = () => {
      In.setTargetSelectChart(void 0), downloadTextFile(
        JSONStringify(In.getStorageInfo || []),
        In.getStorageInfo.editCanvasConfig.projectName,
        "json"
      );
      const Ta = document.querySelector(".dms-edit-range"), Sa = document.getElementById("dms-edit-watermark");
      if (!Ta) {
        window.$message.error("导出失败！");
        return;
      }
      const Ea = In.getEditCanvas.scale;
      In.setScale(1, !0), Sa && (Sa.style.display = "block"), setTimeout(() => {
        canvasCut(Ta, In.getStorageInfo.editCanvasConfig.projectName, () => {
          Sa && (Sa.style.display = "none"), In.setScale(Ea, !0);
        });
      }, 600);
    }, oa = (Ta) => {
      getHistoryInfo(Ta.flag).then((Sa) => {
        if (Sa) {
          const { code: Ea, data: Ia, msg: Ba } = Sa;
          if (Ea === 200) {
            const Ma = Ta.name + "_" + Ta.version;
            downloadTextFile(Ia.content, Ma, "json");
          } else
            window.$message.error(Ba);
        }
      });
    }, la = (Ta) => {
      const Sa = In.getStorageInfo, Ea = getSessionStorage(StorageEnum.DMS_CHART_STORAGE_LIST) || [];
      if (Ea != null && Ea.length) {
        const Ia = Ea.findIndex((Ba) => Ba.id === Ta);
        Ia !== -1 ? (Ea.splice(Ia, 1, { ...Sa, id: Ta }), setSessionStorage(StorageEnum.DMS_CHART_STORAGE_LIST, Ea)) : (Ea.push({ ...Sa, id: Ta }), setSessionStorage(StorageEnum.DMS_CHART_STORAGE_LIST, Ea));
      } else
        setSessionStorage(StorageEnum.DMS_CHART_STORAGE_LIST, [{ ...Sa, id: Ta }]);
    }, ua = (Ta) => {
      const Sa = fetchPathByName("PublishPreview", "href");
      Sa && routerTurnByPath(Sa, [Ta], void 0, !0);
    }, ca = () => {
      const Ta = fetchPathByName("LocalPreview", "href");
      Ta && (la(Gn.screenId + ""), routerTurnByPath(Ta, [Gn.screenId], void 0, !0));
    }, fa = () => {
      const Ta = fetchPathByName("Preview", "href");
      Ta && routerTurnByPath(Ta, [Gn.screenId], void 0, !0);
    }, ha = () => {
      Yn.loadDrawer = !0, Yn.editDrawerVisible = !0;
    }, pa = () => {
      In.setBack();
    }, ya = () => {
      In.setForward();
    }, da = () => {
      Bn.setSidebar(!Nn.value);
    }, Ca = () => {
      Bn.setConfig(!Rn.value);
    }, ma = ref([]), va = () => {
      Yn.recordPopVisible = !0, getHistoryLists(Gn.screenId).then((Ta) => {
        ma.value = Ta.data;
      });
    }, ga = () => {
      const Ta = cloneDeep(In.getStorageInfo);
      if (!Ta.editCanvasConfig.projectName)
        return ElMessage.warning("请输入大屏名称"), !1;
      const Sa = {
        id: Gn.screenId,
        name: Ta.editCanvasConfig.projectName,
        content: "",
        startPerm: Ta.editCanvasConfig.setAuth ? 1 : 0,
        customUrl: Ta.editCanvasConfig.customUrl,
        photo: Ta.editCanvasConfig.photo,
        remark: Ta.editCanvasConfig.projectSummary,
        needLogin: Ta.editCanvasConfig.needLogin,
        width: Ta.editCanvasConfig.width,
        height: Ta.editCanvasConfig.height
      };
      return Ta.componentList.map((Ea) => {
        Ea.key === "Page" && (Ea.componentList = []);
      }), Sa.content = JSONStringify(Ta), Sa;
    }, xa = () => {
      const Ta = ga();
      if (In.editCanvasConfig.publishStatus === 0)
        return ElMessage.warning("该页面还未发布！无需撤稿"), !1;
      publishScreen(0, Ta).then((Sa) => {
        if (Sa) {
          const { code: Ea, data: Ia, msg: Ba } = Sa;
          Ea === 200 ? (In.editCanvasConfig.publishStatus = 0, ElMessage.success("撤稿成功")) : ElMessage.error(Ba);
        }
      });
    }, wa = () => {
      const Ta = ga();
      if (!Wn.value) {
        const Sa = cloneDeep(In.getStorageInfo);
        return setLocalStorage("localData", Sa), ElMessage.success("保存成功"), !1;
      }
      Ta && (Ta.id ? updateScreen(Ta).then((Sa) => {
        if (Sa) {
          const { code: Ea, data: Ia, msg: Ba } = Sa;
          Ea === 200 ? ElMessage.success("保存成功") : ElMessage.error(Ba);
        }
      }) : (delete Ta.id, Gn.appId && (Ta.appId = Gn.appId), addScreen(Ta).then((Sa) => {
        if (Sa) {
          const { code: Ea, data: Ia, msg: Ba } = Sa;
          Ea === 200 ? (Gn.screenId = Ia, Aa(), ElMessage.success("保存成功")) : ElMessage.error(Ba);
        }
      })));
    }, ba = () => {
      const Ta = ga();
      Ta && publishScreen(1, Ta).then((Sa) => {
        if (Sa) {
          const { code: Ea, data: Ia, msg: Ba } = Sa;
          Ea === 200 ? (In.editCanvasConfig.publishStatus = 1, ElMessage.success("发布成功")) : ElMessage.error(Ba);
        }
      });
    };
    return (Ta, Sa) => {
      const Ea = __unplugin_components_0, Ia = resolveComponent("el-popover"), Ba = resolveComponent("el-table-column"), Ma = resolveComponent("el-button"), La = resolveComponent("el-tooltip"), Da = resolveComponent("el-table"), Na = resolveComponent("el-upload");
      return openBlock(), createElementBlock(Fragment, null, [
        createElementVNode("div", _hoisted_1$h, [
          createElementVNode("div", _hoisted_2$8, [
            createElementVNode("div", _hoisted_3$6, [
              createVNode$1(Ea, { "icon-class": "app" })
            ]),
            createElementVNode("span", {
              class: "name",
              title: unref(Gn).name
            }, toDisplayString(unref(Gn).name), 9, _hoisted_4$4)
          ]),
          createElementVNode("div", _hoisted_5$2, [
            createVNode$1(Ia, {
              width: "90px",
              "popper-style": { padding: "0px" },
              onShow: Sa[0] || (Sa[0] = ($a) => Yn.sidePopVisible = !0),
              onHide: Sa[1] || (Sa[1] = ($a) => Yn.sidePopVisible = !1)
            }, {
              reference: withCtx(() => [
                createElementVNode("div", {
                  class: normalizeClass(["btn-item", { "active-bg": Yn.sidePopVisible }])
                }, [
                  createVNode$1(Ea, { "icon-class": "hideSide" }),
                  Sa[8] || (Sa[8] = createElementVNode("div", { class: "btn-name" }, "隐藏边栏", -1))
                ], 2)
              ]),
              default: withCtx(() => [
                createElementVNode("div", _hoisted_6$2, [
                  createElementVNode("div", {
                    class: "pop-item",
                    onClick: da
                  }, [
                    Sa[9] || (Sa[9] = createTextVNode("左边栏 ")),
                    unref(Nn) ? (openBlock(), createBlock(Ea, {
                      key: 0,
                      "icon-class": "check"
                    })) : createCommentVNode("", !0)
                  ]),
                  createElementVNode("div", {
                    class: "pop-item",
                    onClick: Ca
                  }, [
                    Sa[10] || (Sa[10] = createTextVNode("右边栏 ")),
                    unref(Rn) ? (openBlock(), createBlock(Ea, {
                      key: 0,
                      "icon-class": "check"
                    })) : createCommentVNode("", !0)
                  ])
                ])
              ]),
              _: 1
            }),
            createElementVNode("div", {
              class: normalizeClass(["btn-item", { "active-bg": unref(Un) }]),
              onClick: aa
            }, [
              createVNode$1(Ea, { "icon-class": "page_filter" }),
              Sa[11] || (Sa[11] = createElementVNode("div", { class: "btn-name" }, "滤镜", -1))
            ], 2),
            Wn.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["btn-item", { "active-bg": unref(Pn) }]),
              onClick: ra
            }, [
              createVNode$1(Ea, { "icon-class": "page_switch" }),
              Sa[12] || (Sa[12] = createElementVNode("div", { class: "btn-name" }, "应用页面", -1))
            ], 2)) : createCommentVNode("", !0),
            Wn.value ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "btn-item",
              onClick: ia
            }, [
              createVNode$1(Ea, { "icon-class": "zyk" }),
              Sa[13] || (Sa[13] = createElementVNode("div", { class: "btn-name" }, "资源库", -1))
            ])) : createCommentVNode("", !0)
          ]),
          createElementVNode("div", _hoisted_7$1, [
            createElementVNode("div", {
              class: normalizeClass(["btn-item", { disabled: !Hn.value }]),
              onClick: Sa[2] || (Sa[2] = ($a) => Hn.value ? pa() : void 0)
            }, [
              createVNode$1(Ea, { "icon-class": "undo" }),
              Sa[14] || (Sa[14] = createElementVNode("div", { class: "btn-name" }, "撤销", -1))
            ], 2),
            createElementVNode("div", {
              class: normalizeClass(["btn-item", { disabled: !zn.value }]),
              onClick: Sa[3] || (Sa[3] = ($a) => zn.value ? ya() : void 0)
            }, [
              createVNode$1(Ea, { "icon-class": "redo" }),
              Sa[15] || (Sa[15] = createElementVNode("div", { class: "btn-name" }, "恢复", -1))
            ], 2)
          ]),
          createElementVNode("div", _hoisted_8$1, [
            Wn.value ? (openBlock(), createBlock(Ia, {
              key: 0,
              placement: "bottom",
              trigger: "click",
              width: 650,
              "popper-style": { padding: "0px" },
              onShow: va,
              onHide: Sa[4] || (Sa[4] = ($a) => Yn.recordPopVisible = !1)
            }, {
              reference: withCtx(() => [
                createElementVNode("div", {
                  class: normalizeClass(["btn-item", { "active-bg": Yn.recordPopVisible }])
                }, [
                  createVNode$1(Ea, { "icon-class": "page_record" }),
                  Sa[16] || (Sa[16] = createElementVNode("div", { class: "btn-name" }, "版本记录", -1))
                ], 2)
              ]),
              default: withCtx(() => [
                createVNode$1(Da, {
                  data: ma.value,
                  style: { height: "500px" }
                }, {
                  default: withCtx(() => [
                    createVNode$1(Ba, {
                      property: "name",
                      label: "名称",
                      width: "200"
                    }),
                    createVNode$1(Ba, {
                      property: "version",
                      label: "版本",
                      width: "80"
                    }),
                    createVNode$1(Ba, {
                      label: "类型",
                      width: "100"
                    }, {
                      default: withCtx(($a) => [
                        createElementVNode("div", null, toDisplayString($a.row.type == 1 ? "发布触发" : "保存触发"), 1)
                      ]),
                      _: 1
                    }),
                    createVNode$1(Ba, {
                      label: "保存时间",
                      prop: "createDate",
                      width: "180"
                    }),
                    createVNode$1(Ba, {
                      label: "操作",
                      width: "150"
                    }, {
                      default: withCtx(($a) => [
                        createVNode$1(La, { content: "查看" }, {
                          default: withCtx(() => [
                            createVNode$1(Ma, {
                              circle: "",
                              size: "small",
                              onClick: (Oa) => ua($a.row.flag)
                            }, {
                              icon: withCtx(() => [
                                createVNode$1(Ea, { "icon-class": "page_preview" })
                              ]),
                              _: 2
                            }, 1032, ["onClick"])
                          ]),
                          _: 2
                        }, 1024),
                        createVNode$1(La, { content: "导出" }, {
                          default: withCtx(() => [
                            createVNode$1(Ma, {
                              circle: "",
                              size: "small",
                              onClick: (Oa) => oa($a.row)
                            }, {
                              icon: withCtx(() => [
                                createVNode$1(Ea, { "icon-class": "page_export" })
                              ]),
                              _: 2
                            }, 1032, ["onClick"])
                          ]),
                          _: 2
                        }, 1024)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["data"])
              ]),
              _: 1
            })) : createCommentVNode("", !0),
            createElementVNode("div", {
              class: "btn-item",
              onClick: ca
            }, [
              createVNode$1(Ea, { "icon-class": "page_preview" }),
              Sa[17] || (Sa[17] = createElementVNode("div", { class: "btn-name" }, "本地预览", -1))
            ]),
            Wn.value ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "btn-item",
              onClick: fa
            }, [
              createVNode$1(Ea, { "icon-class": "page_publish_preview" }),
              Sa[18] || (Sa[18] = createElementVNode("div", { class: "btn-name" }, "预览", -1))
            ])) : createCommentVNode("", !0),
            Sa[26] || (Sa[26] = createElementVNode("div", { class: "split-line" }, null, -1)),
            Wn.value ? (openBlock(), createBlock(Na, {
              key: 2,
              "file-list": unref(Xn),
              "onUpdate:fileList": Sa[5] || (Sa[5] = ($a) => isRef(Xn) ? Xn.value = $a : null),
              class: "upload-btn-item",
              "show-file-list": !1,
              accept: ".sketch",
              "http-request": unref(ea),
              "before-upload": unref(ta)
            }, {
              default: withCtx(() => [
                createElementVNode("div", _hoisted_9$1, [
                  createVNode$1(Ea, { "icon-class": "import" }),
                  Sa[19] || (Sa[19] = createElementVNode("div", { class: "btn-name" }, "导入设计图", -1))
                ])
              ]),
              _: 1
            }, 8, ["file-list", "http-request", "before-upload"])) : createCommentVNode("", !0),
            createVNode$1(Na, {
              class: "upload-btn-item",
              "file-list": unref(Dn),
              "onUpdate:fileList": Sa[6] || (Sa[6] = ($a) => isRef(Dn) ? Dn.value = $a : null),
              "show-file-list": !1,
              accept: ".json",
              "http-request": unref(Ln),
              "before-upload": unref($n)
            }, {
              default: withCtx(() => [
                createElementVNode("div", _hoisted_10$1, [
                  createVNode$1(Ea, { "icon-class": "import" }),
                  Sa[20] || (Sa[20] = createElementVNode("div", { class: "btn-name" }, "导入", -1))
                ])
              ]),
              _: 1
            }, 8, ["file-list", "http-request", "before-upload"]),
            createElementVNode("div", {
              class: "btn-item",
              onClick: sa
            }, [
              createVNode$1(Ea, { "icon-class": "page_export" }),
              Sa[21] || (Sa[21] = createElementVNode("div", { class: "btn-name" }, "导出", -1))
            ]),
            Wn.value ? (openBlock(), createElementBlock("div", {
              key: 3,
              class: normalizeClass(["btn-item", { disabled: !na.value }]),
              onClick: xa
            }, [
              createVNode$1(Ea, { "icon-class": "withdraw" }),
              Sa[22] || (Sa[22] = createElementVNode("div", { class: "btn-name" }, "撤稿", -1))
            ], 2)) : createCommentVNode("", !0),
            createElementVNode("div", {
              class: "btn-item",
              onClick: ha
            }, [
              createVNode$1(Ea, { "icon-class": "page_edit" }),
              Sa[23] || (Sa[23] = createElementVNode("div", { class: "btn-name" }, "编辑", -1))
            ]),
            createElementVNode("div", {
              class: "btn-item",
              onClick: wa
            }, [
              createVNode$1(Ea, { "icon-class": "page_save" }),
              Sa[24] || (Sa[24] = createElementVNode("div", { class: "btn-name" }, "保存", -1))
            ]),
            Wn.value ? (openBlock(), createElementBlock("div", {
              key: 4,
              class: "btn-item",
              onClick: ba
            }, [
              createVNode$1(Ea, { "icon-class": "page_publish" }),
              Sa[25] || (Sa[25] = createElementVNode("div", { class: "btn-name" }, "发布", -1))
            ])) : createCommentVNode("", !0)
          ])
        ]),
        Yn.loadDrawer ? (openBlock(), createBlock(unref(nr), {
          key: 0,
          modelValue: Yn.editDrawerVisible,
          "onUpdate:modelValue": Sa[7] || (Sa[7] = ($a) => Yn.editDrawerVisible = $a)
        }, null, 8, ["modelValue"])) : createCommentVNode("", !0)
      ], 64);
    };
  }
}), Header_vue_vue_type_style_index_0_scoped_67986ab2_lang = "", Header = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-67986ab2"]]), _imports_0 = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzYwIiBoZWlnaHQ9IjI3MC43NzUzOTA2MjUiIHZpZXdCb3g9IjAgMCAzNjAgMjcwLjc3NTM5MDYyNSIgZmlsbD0ibm9uZSI+DQo8ZyAgb3BhY2l0eT0iMC4zMDAwMDAwMTE5MjA5Mjg5NiI+DQo8cGF0aCBkPSJNNTMuNzU2NyA2Ni42OTMyQzI0LjcwMzEgNzUuOTUyOCAxMS43ODM0IDExNS45OSAyNC44ODU4IDE1Ni4xMDdDMzcuOTkyOCAxOTYuMjM2IDcyLjE1OTIgMjIxLjI1MSAxMDEuMjEzIDIxMS45OTJDMTMwLjI2NiAyMDIuNzMyIDE0My4xOSAxNjIuNzA4IDEzMC4wODMgMTIyLjU3OUMxMTYuOTgxIDgyLjQ2MjMgODIuODEwMSA1Ny40MzM1IDUzLjc1NjcgNjYuNjkzMloiIGZpbGwtcnVsZT0iZXZlbm9kZCIgIGZpbGw9InVybCgjbGluZWFyXzApIiA+DQo8L3BhdGg+DQo8L2c+DQo8ZyBvcGFjaXR5PSIwLjMwMDAwMDAxMTkyMDkyODk2Ij4NCjxwYXRoIGQ9Ik0yNDIuNDAxIDkyLjIxMzRDMjQyLjQwMSA5My40NzI0IDI0Mi4zNzYgOTQuNzMwNiAyNDIuMzI1IDk1Ljk4ODJDMjQyLjI3NCA5Ny4yNDU2IDI0Mi4xOTkgOTguNTAwOCAyNDIuMDk4IDk5Ljc1MzhDMjQxLjk5NyAxMDEuMDA3IDI0MS44NzEgMTAyLjI1NiAyNDEuNzIgMTAzLjUwMUMyNDEuNTY5IDEwNC43NDYgMjQxLjM5MiAxMDUuOTg3IDI0MS4xOTEgMTA3LjIyMUMyNDAuOTkxIDEwOC40NTYgMjQwLjc2NiAxMDkuNjg0IDI0MC41MTUgMTEwLjkwNkMyNDAuMjY1IDExMi4xMjcgMjM5Ljk5MSAxMTMuMzQgMjM5LjY5MSAxMTQuNTQ1QzIzOS4zOTMgMTE1Ljc0OSAyMzkuMDcgMTE2Ljk0NCAyMzguNzIyIDExOC4xM0MyMzguMzc1IDExOS4zMTUgMjM4LjAwNSAxMjAuNDkgMjM3LjYxMiAxMjEuNjUzQzIzNy4yMTcgMTIyLjgxNiAyMzYuOCAxMjMuOTY2IDIzNi4zNiAxMjUuMTA1QzIzNS45MTkgMTI2LjI0MyAyMzUuNDU3IDEyNy4zNjcgMjM0Ljk3MiAxMjguNDc3QzIzNC40ODYgMTI5LjU4NyAyMzMuOTc4IDEzMC42ODIgMjMzLjQ0OSAxMzEuNzYyQzIzMi45MTkgMTMyLjg0MiAyMzIuMzY4IDEzMy45MDYgMjMxLjc5NiAxMzQuOTUyQzIzMS4yMjUgMTM1Ljk5OSAyMzAuNjMyIDEzNy4wMjggMjMwLjAxOCAxMzguMDRDMjI5LjQwNSAxMzkuMDUxIDIyOC43NzIgMTQwLjA0MyAyMjguMTE5IDE0MS4wMTZDMjI3LjQ2NSAxNDEuOTg5IDIyNi43OTMgMTQyLjk0MyAyMjYuMTAyIDE0My44NzVDMjI1LjQxIDE0NC44MDggMjI0LjcgMTQ1LjcxOSAyMjMuOTcyIDE0Ni42MUMyMjMuMjQ0IDE0Ny41IDIyMi40OTggMTQ4LjM2OCAyMjEuNzM1IDE0OS4yMTNDMjIwLjk3MiAxNTAuMDU4IDIyMC4xOTMgMTUwLjg4MSAyMTkuMzk3IDE1MS42OEMyMTguNjAyIDE1Mi40NzkgMjE3Ljc5IDE1My4yNTMgMjE2Ljk2MiAxNTQuMDAzQzIxNi4xMzUgMTU0Ljc1MyAyMTUuMjkzIDE1NS40NzggMjE0LjQzNyAxNTYuMTc4QzIxMy41ODEgMTU2Ljg3NyAyMTIuNzEyIDE1Ny41NSAyMTEuODI5IDE1OC4xOThDMjEwLjk0NSAxNTguODQ1IDIxMC4wNDkgMTU5LjQ2NSAyMDkuMTQxIDE2MC4wNThDMjA4LjIzMiAxNjAuNjUxIDIwNy4zMTMgMTYxLjIxNyAyMDYuMzgzIDE2MS43NTZDMjA1LjQ1MiAxNjIuMjk0IDIwNC41MSAxNjIuODA0IDIwMy41NTkgMTYzLjI4NkMyMDIuNjA3IDE2My43NjcgMjAxLjY0OCAxNjQuMjIxIDIwMC42NzkgMTY0LjY0NUMxOTkuNzA5IDE2NS4wNjggMTk4LjczMiAxNjUuNDY0IDE5Ny43NDYgMTY1LjgyOUMxOTYuNzYgMTY2LjE5NSAxOTUuNzY3IDE2Ni41MzEgMTk0Ljc2OSAxNjYuODM2QzE5My43NyAxNjcuMTQyIDE5Mi43NjYgMTY3LjQxOCAxOTEuNzU2IDE2Ny42NjNDMTkwLjc0NiAxNjcuOTA5IDE4OS43MzIgMTY4LjEyNCAxODguNzEzIDE2OC4zMDlDMTg3LjY5NCAxNjguNDkzIDE4Ni42NzMgMTY4LjY0OCAxODUuNjQ4IDE2OC43NzFDMTg0LjYyMyAxNjguODk1IDE4My41OTcgMTY4Ljk4NyAxODIuNTY4IDE2OS4wNDlDMTgxLjU0IDE2OS4xMTEgMTgwLjUxMSAxNjkuMTQyIDE3OS40ODEgMTY5LjE0MkMxNzguNDUxIDE2OS4xNDIgMTc3LjQyMiAxNjkuMTExIDE3Ni4zOTQgMTY5LjA0OUMxNzUuMzY1IDE2OC45ODcgMTc0LjMzOCAxNjguODk1IDE3My4zMTMgMTY4Ljc3MUMxNzIuMjg5IDE2OC42NDggMTcxLjI2OCAxNjguNDkzIDE3MC4yNDkgMTY4LjMwOUMxNjkuMjMgMTY4LjEyNCAxNjguMjE2IDE2Ny45MDkgMTY3LjIwNiAxNjcuNjYzQzE2Ni4xOTYgMTY3LjQxOCAxNjUuMTkyIDE2Ny4xNDIgMTY0LjE5MyAxNjYuODM2QzE2My4xOTUgMTY2LjUzMSAxNjIuMjAyIDE2Ni4xOTUgMTYxLjIxNiAxNjUuODI5QzE2MC4yMyAxNjUuNDY0IDE1OS4yNTMgMTY1LjA2OCAxNTguMjgzIDE2NC42NDVDMTU3LjMxNCAxNjQuMjIxIDE1Ni4zNTQgMTYzLjc2NyAxNTUuNDAyIDE2My4yODZDMTU0LjQ1MSAxNjIuODA0IDE1My41MSAxNjIuMjk0IDE1Mi41NzkgMTYxLjc1NkMxNTEuNjQ4IDE2MS4yMTcgMTUwLjcyOSAxNjAuNjUxIDE0OS44MjEgMTYwLjA1OEMxNDguOTEzIDE1OS40NjUgMTQ4LjAxNyAxNTguODQ1IDE0Ny4xMzMgMTU4LjE5OEMxNDYuMjUgMTU3LjU1IDE0NS4zODEgMTU2Ljg3NyAxNDQuNTI1IDE1Ni4xNzhDMTQzLjY2OCAxNTUuNDc4IDE0Mi44MjcgMTU0Ljc1MyAxNDIgMTU0LjAwM0MxNDEuMTczIDE1My4yNTMgMTQwLjM2MSAxNTIuNDc5IDEzOS41NjUgMTUxLjY4QzEzOC43NjkgMTUwLjg4MSAxMzcuOTg5IDE1MC4wNTggMTM3LjIyNiAxNDkuMjEzQzEzNi40NjQgMTQ4LjM2OCAxMzUuNzE4IDE0Ny41IDEzNC45OSAxNDYuNjFDMTM0LjI2MiAxNDUuNzE5IDEzMy41NTIgMTQ0LjgwOCAxMzIuODYgMTQzLjg3NUMxMzIuMTY5IDE0Mi45NDMgMTMxLjQ5NyAxNDEuOTg5IDEzMC44NDMgMTQxLjAxNkMxMzAuMTkgMTQwLjA0MyAxMjkuNTU3IDEzOS4wNTEgMTI4Ljk0MyAxMzguMDRDMTI4LjMzIDEzNy4wMjggMTI3LjczNyAxMzUuOTk5IDEyNy4xNjUgMTM0Ljk1MkMxMjYuNTkzIDEzMy45MDYgMTI2LjA0MiAxMzIuODQyIDEyNS41MTMgMTMxLjc2MkMxMjQuOTgzIDEzMC42ODIgMTI0LjQ3NiAxMjkuNTg3IDEyMy45OTEgMTI4LjQ3N0MxMjMuNTA1IDEyNy4zNjcgMTIzLjA0MiAxMjYuMjQzIDEyMi42MDIgMTI1LjEwNUMxMjIuMTYyIDEyMy45NjYgMTIxLjc0NSAxMjIuODE2IDEyMS4zNSAxMjEuNjUzQzEyMC45NTYgMTIwLjQ5IDEyMC41ODYgMTE5LjMxNSAxMjAuMjM5IDExOC4xM0MxMTkuODkyIDExNi45NDQgMTE5LjU2OSAxMTUuNzQ5IDExOS4yNyAxMTQuNTQ1QzExOC45NzEgMTEzLjM0IDExOC42OTcgMTEyLjEyNyAxMTguNDQ3IDExMC45MDZDMTE4LjE5NiAxMDkuNjg0IDExNy45NzEgMTA4LjQ1NiAxMTcuNzcgMTA3LjIyMUMxMTcuNTY5IDEwNS45ODcgMTE3LjM5MyAxMDQuNzQ2IDExNy4yNDIgMTAzLjUwMUMxMTcuMDkxIDEwMi4yNTYgMTE2Ljk2NSAxMDEuMDA3IDExNi44NjQgOTkuNzUzOEMxMTYuNzYzIDk4LjUwMDggMTE2LjY4NyA5Ny4yNDU2IDExNi42MzcgOTUuOTg4MkMxMTYuNTg2IDk0LjczMDYgMTE2LjU2MSA5My40NzI0IDExNi41NjEgOTIuMjEzNEMxMTYuNTYxIDkwLjk1NDQgMTE2LjU4NiA4OS42OTYzIDExNi42MzcgODguNDM4N0MxMTYuNjg3IDg3LjE4MTMgMTE2Ljc2MyA4NS45MjYgMTE2Ljg2NCA4NC42NzMxQzExNi45NjUgODMuNDIwMSAxMTcuMDkxIDgyLjE3MTEgMTE3LjI0MiA4MC45MjU3QzExNy4zOTMgNzkuNjgwNCAxMTcuNTY5IDc4LjQ0MDMgMTE3Ljc3IDc3LjIwNTVDMTE3Ljk3MSA3NS45NzA4IDExOC4xOTYgNzQuNzQyNyAxMTguNDQ3IDczLjUyMTNDMTE4LjY5NyA3Mi4zMDAyIDExOC45NzEgNzEuMDg3MSAxMTkuMjcgNjkuODgyNEMxMTkuNTY5IDY4LjY3NzYgMTE5Ljg5MiA2Ny40ODI1IDEyMC4yMzkgNjYuMjk3MUMxMjAuNTg2IDY1LjExMTcgMTIwLjk1NiA2My45MzczIDEyMS4zNSA2Mi43NzQyQzEyMS43NDUgNjEuNjExMSAxMjIuMTYyIDYwLjQ2MDUgMTIyLjYwMiA1OS4zMjI0QzEyMy4wNDIgNTguMTg0MiAxMjMuNTA1IDU3LjA1OTkgMTIzLjk5MSA1NS45NDk2QzEyNC40NzYgNTQuODM5NCAxMjQuOTgzIDUzLjc0NDIgMTI1LjUxMyA1Mi42NjQ0QzEyNi4wNDIgNTEuNTg0NSAxMjYuNTkzIDUwLjUyMTEgMTI3LjE2NSA0OS40NzQ0QzEyNy43MzcgNDguNDI3NiAxMjguMzMgNDcuMzk4NSAxMjguOTQzIDQ2LjM4NzNDMTI5LjU1NyA0NS4zNzYxIDEzMC4xOSA0NC4zODM5IDEzMC44NDMgNDMuNDEwN0MxMzEuNDk3IDQyLjQzNzQgMTMyLjE2OSA0MS40ODQ0IDEzMi44NiA0MC41NTE2QzEzMy41NTIgMzkuNjE4OCAxMzQuMjYyIDM4LjcwNzIgMTM0Ljk5IDM3LjgxNjlDMTM1LjcxOCAzNi45MjY3IDEzNi40NjQgMzYuMDU4OCAxMzcuMjI2IDM1LjIxMzNDMTM3Ljk4OSAzNC4zNjc4IDEzOC43NjkgMzMuNTQ1OCAxMzkuNTY1IDMyLjc0NzFDMTQwLjM2MSAzMS45NDg1IDE0MS4xNzMgMzEuMTc0IDE0MiAzMC40MjRDMTQyLjgyNyAyOS42NzQxIDE0My42NjggMjguOTQ5NCAxNDQuNTI1IDI4LjI1QzE0NS4zODEgMjcuNTUwNSAxNDYuMjUgMjYuODc3MSAxNDcuMTMzIDI2LjIyOThDMTQ4LjAxNyAyNS41ODI1IDE0OC45MTMgMjQuOTYyMiAxNDkuODIxIDI0LjM2ODdDMTUwLjcyOSAyMy43NzUyIDE1MS42NDggMjMuMjA5NCAxNTIuNTc5IDIyLjY3MTFDMTUzLjUxIDIyLjEzMjggMTU0LjQ1MSAyMS42MjI4IDE1NS40MDIgMjEuMTQwOUMxNTYuMzU0IDIwLjY1OTEgMTU3LjMxNCAyMC4yMDYyIDE1OC4yODMgMTkuNzgyQzE1OS4yNTMgMTkuMzU3OSAxNjAuMjMgMTguOTYzMSAxNjEuMjE2IDE4LjU5NzdDMTYyLjIwMiAxOC4yMzIyIDE2My4xOTUgMTcuODk2NiAxNjQuMTkzIDE3LjU5MDZDMTY1LjE5MiAxNy4yODQ3IDE2Ni4xOTYgMTcuMDA4OSAxNjcuMjA2IDE2Ljc2MzRDMTY4LjIxNiAxNi41MTc3IDE2OS4yMyAxNi4zMDI1IDE3MC4yNDkgMTYuMTE3OEMxNzEuMjY4IDE1LjkzMyAxNzIuMjg5IDE1Ljc3OSAxNzMuMzEzIDE1LjY1NTVDMTc0LjMzOCAxNS41MzIxIDE3NS4zNjUgMTUuNDM5NiAxNzYuMzk0IDE1LjM3NzlDMTc3LjQyMiAxNS4zMTYxIDE3OC40NTEgMTUuMjg1MiAxNzkuNDgxIDE1LjI4NTJDMTgwLjUxMSAxNS4yODUyIDE4MS41NCAxNS4zMTYxIDE4Mi41NjggMTUuMzc3OUMxODMuNTk3IDE1LjQzOTYgMTg0LjYyMyAxNS41MzIxIDE4NS42NDggMTUuNjU1NUMxODYuNjczIDE1Ljc3OSAxODcuNjk0IDE1LjkzMyAxODguNzEzIDE2LjExNzhDMTg5LjczMiAxNi4zMDI1IDE5MC43NDYgMTYuNTE3NyAxOTEuNzU2IDE2Ljc2MzRDMTkyLjc2NiAxNy4wMDg5IDE5My43NyAxNy4yODQ3IDE5NC43NjkgMTcuNTkwNkMxOTUuNzY3IDE3Ljg5NjYgMTk2Ljc2IDE4LjIzMjIgMTk3Ljc0NiAxOC41OTc3QzE5OC43MzIgMTguOTYzMSAxOTkuNzA5IDE5LjM1NzkgMjAwLjY3OSAxOS43ODJDMjAxLjY0OCAyMC4yMDYyIDIwMi42MDcgMjAuNjU5MSAyMDMuNTU5IDIxLjE0MDlDMjA0LjUxIDIxLjYyMjggMjA1LjQ1MiAyMi4xMzI4IDIwNi4zODMgMjIuNjcxMUMyMDcuMzEzIDIzLjIwOTQgMjA4LjIzMiAyMy43NzUyIDIwOS4xNDEgMjQuMzY4N0MyMTAuMDQ5IDI0Ljk2MjIgMjEwLjk0NSAyNS41ODI1IDIxMS44MjkgMjYuMjI5OEMyMTIuNzEyIDI2Ljg3NzEgMjEzLjU4MSAyNy41NTA1IDIxNC40MzcgMjguMjVDMjE1LjI5MyAyOC45NDk0IDIxNi4xMzUgMjkuNjc0MSAyMTYuOTYyIDMwLjQyNEMyMTcuNzkgMzEuMTc0IDIxOC42MDIgMzEuOTQ4NSAyMTkuMzk3IDMyLjc0NzFDMjIwLjE5MyAzMy41NDU4IDIyMC45NzIgMzQuMzY3OCAyMjEuNzM1IDM1LjIxMzNDMjIyLjQ5OCAzNi4wNTg4IDIyMy4yNDQgMzYuOTI2NyAyMjMuOTcyIDM3LjgxNjlDMjI0LjcgMzguNzA3MiAyMjUuNDEgMzkuNjE4OCAyMjYuMTAyIDQwLjU1MTZDMjI2Ljc5MyA0MS40ODQ0IDIyNy40NjUgNDIuNDM3NCAyMjguMTE5IDQzLjQxMDdDMjI4Ljc3MiA0NC4zODM5IDIyOS40MDUgNDUuMzc2MSAyMzAuMDE4IDQ2LjM4NzNDMjMwLjYzMiA0Ny4zOTg1IDIzMS4yMjUgNDguNDI3NiAyMzEuNzk2IDQ5LjQ3NDRDMjMyLjM2OCA1MC41MjExIDIzMi45MTkgNTEuNTg0NSAyMzMuNDQ5IDUyLjY2NDRDMjMzLjk3OCA1My43NDQyIDIzNC40ODYgNTQuODM5NCAyMzQuOTcyIDU1Ljk0OTZDMjM1LjQ1NyA1Ny4wNTk5IDIzNS45MTkgNTguMTg0MiAyMzYuMzYgNTkuMzIyNEMyMzYuOCA2MC40NjA1IDIzNy4yMTcgNjEuNjExMSAyMzcuNjEyIDYyLjc3NDJDMjM4LjAwNSA2My45MzczIDIzOC4zNzUgNjUuMTExNyAyMzguNzIyIDY2LjI5NzFDMjM5LjA3IDY3LjQ4MjUgMjM5LjM5MyA2OC42Nzc2IDIzOS42OTEgNjkuODgyNEMyMzkuOTkxIDcxLjA4NzEgMjQwLjI2NSA3Mi4zMDAyIDI0MC41MTUgNzMuNTIxM0MyNDAuNzY2IDc0Ljc0MjcgMjQwLjk5MSA3NS45NzA4IDI0MS4xOTEgNzcuMjA1NUMyNDEuMzkyIDc4LjQ0MDMgMjQxLjU2OSA3OS42ODA0IDI0MS43MiA4MC45MjU3QzI0MS44NzEgODIuMTcxMSAyNDEuOTk3IDgzLjQyMDEgMjQyLjA5OCA4NC42NzMxQzI0Mi4xOTkgODUuOTI2IDI0Mi4yNzQgODcuMTgxMyAyNDIuMzI1IDg4LjQzODdDMjQyLjM3NiA4OS42OTYzIDI0Mi40MDEgOTAuOTU0NCAyNDIuNDAxIDkyLjIxMzRaIiAgIGZpbGw9InVybCgjbGluZWFyXzEpIiA+DQo8L3BhdGg+DQo8L2c+DQo8ZyAgb3BhY2l0eT0iMC40MDAwMDAwMDU5NjA0NjQ1Ij4NCjxwYXRoIGQ9Ik0zMDEuMjA5IDIwMi43NzRDMzAxLjIwOSAyMDMuMjc1IDMwMS4xNiAyMDMuNzc1IDMwMS4wNjIgMjA0LjI3NUMzMDAuOTY0IDIwNC43NzQgMzAwLjgxOSAyMDUuMjczIDMwMC42MjMgMjA1Ljc3MUMzMDAuNDI4IDIwNi4yNjggMzAwLjE4NSAyMDYuNzY0IDI5OS44OTIgMjA3LjI1OUMyOTkuNTk5IDIwNy43NTQgMjk5LjI1OSAyMDguMjQ3IDI5OC44NyAyMDguNzM4QzI5OC40ODEgMjA5LjIyOSAyOTguMDQ1IDIwOS43MTcgMjk3LjU2MSAyMTAuMjAyQzI5Ny4wNzcgMjEwLjY4NyAyOTYuNTQ3IDIxMS4xNjkgMjk1Ljk2OCAyMTEuNjQ4QzI5NS4zODkgMjEyLjEyNyAyOTQuNzY2IDIxMi42MDIgMjk0LjA5NCAyMTMuMDczQzI5My40MjIgMjEzLjU0MyAyOTIuNzA2IDIxNC4wMSAyOTEuOTQ0IDIxNC40NzJDMjkxLjE4MiAyMTQuOTM0IDI5MC4zNzQgMjE1LjM5MSAyODkuNTIzIDIxNS44NDRDMjg4LjY3IDIxNi4yOTYgMjg3Ljc3NiAyMTYuNzQzIDI4Ni44MzcgMjE3LjE4NUMyODUuODk3IDIxNy42MjYgMjg0LjkxNiAyMTguMDYxIDI4My44OTEgMjE4LjQ5MUMyODIuODY3IDIxOC45MTkgMjgxLjgwMSAyMTkuMzQxIDI4MC42OTUgMjE5Ljc1N0MyNzkuNTg5IDIyMC4xNzMgMjc4LjQ0MiAyMjAuNTgyIDI3Ny4yNTUgMjIwLjk4NEMyNzYuMDY4IDIyMS4zODYgMjc0Ljg0MyAyMjEuNzggMjczLjU4IDIyMi4xNjdDMjcyLjMxNiAyMjIuNTU0IDI3MS4wMTQgMjIyLjkzMyAyNjkuNjc2IDIyMy4zMDNDMjY4LjM0IDIyMy42NzQgMjY2Ljk2NyAyMjQuMDM2IDI2NS41NTggMjI0LjM4OUMyNjQuMTQ4IDIyNC43NDMgMjYyLjcwNyAyMjUuMDg5IDI2MS4yMyAyMjUuNDI1QzI1OS43NTQgMjI1Ljc2MSAyNTguMjQ3IDIyNi4wODcgMjU2LjcwNiAyMjYuNDA1QzI1NS4xNjYgMjI2LjcyMiAyNTMuNTk2IDIyNy4wMjkgMjUxLjk5NyAyMjcuMzI4QzI1MC4zOTcgMjI3LjYyNiAyNDguNzY5IDIyNy45MTQgMjQ3LjExMiAyMjguMTkxQzI0NS40NTYgMjI4LjQ3IDI0My43NzQgMjI4LjczNyAyNDIuMDY0IDIyOC45OTRDMjQwLjM1NiAyMjkuMjUxIDIzOC42MjMgMjI5LjQ5OCAyMzYuODY3IDIyOS43MzNDMjM1LjEwOSAyMjkuOTY5IDIzMy4zMyAyMzAuMTk0IDIzMS41MyAyMzAuNDA4QzIyOS43MyAyMzAuNjIyIDIyNy45MDkgMjMwLjgyNiAyMjYuMDY4IDIzMS4wMTdDMjI0LjIyOCAyMzEuMjA4IDIyMi4zNjkgMjMxLjM4NyAyMjAuNDk0IDIzMS41NTZDMjE4LjYxOCAyMzEuNzI1IDIxNi43MjcgMjMxLjg4MiAyMTQuODIxIDIzMi4wMjZDMjEyLjkxNSAyMzIuMTcyIDIxMC45OTUgMjMyLjMwNiAyMDkuMDYyIDIzMi40MjhDMjA3LjEzMSAyMzIuNTQ5IDIwNS4xODggMjMyLjY1OSAyMDMuMjM0IDIzMi43NTZDMjAxLjI4IDIzMi44NTQgMTk5LjMxOCAyMzIuOTQgMTk3LjM0NyAyMzMuMDEzQzE5NS4zNzYgMjMzLjA4NiAxOTMuNCAyMzMuMTQ3IDE5MS40MTggMjMzLjE5NkMxODkuNDM2IDIzMy4yNDUgMTg3LjQ1IDIzMy4yODIgMTg1LjQ2IDIzMy4zMDdDMTgzLjQ3IDIzMy4zMzEgMTgxLjQ3OSAyMzMuMzQzIDE3OS40ODcgMjMzLjM0M0MxNzcuNDk1IDIzMy4zNDMgMTc1LjUwNCAyMzMuMzMxIDE3My41MTQgMjMzLjMwN0MxNzEuNTI0IDIzMy4yODIgMTY5LjUzOCAyMzMuMjQ1IDE2Ny41NTYgMjMzLjE5NkMxNjUuNTc0IDIzMy4xNDcgMTYzLjU5NyAyMzMuMDg2IDE2MS42MjcgMjMzLjAxM0MxNTkuNjU2IDIzMi45NCAxNTcuNjk0IDIzMi44NTQgMTU1Ljc0IDIzMi43NTZDMTUzLjc4NiAyMzIuNjU5IDE1MS44NDMgMjMyLjU0OSAxNDkuOTEyIDIzMi40MjhDMTQ3Ljk3OSAyMzIuMzA2IDE0Ni4wNTkgMjMyLjE3MiAxNDQuMTUzIDIzMi4wMjZDMTQyLjI0NyAyMzEuODgyIDE0MC4zNTYgMjMxLjcyNSAxMzguNDggMjMxLjU1NkMxMzYuNjA0IDIzMS4zODcgMTM0Ljc0NiAyMzEuMjA4IDEzMi45MDYgMjMxLjAxN0MxMzEuMDY1IDIzMC44MjYgMTI5LjI0NSAyMzAuNjIyIDEyNy40NDQgMjMwLjQwOEMxMjUuNjQzIDIzMC4xOTQgMTIzLjg2NCAyMjkuOTY5IDEyMi4xMDggMjI5LjczM0MxMjAuMzUxIDIyOS40OTggMTE4LjYxOCAyMjkuMjUxIDExNi45MDkgMjI4Ljk5NEMxMTUuMjAxIDIyOC43MzcgMTEzLjUxOCAyMjguNDcgMTExLjg2MiAyMjguMTkxQzExMC4yMDUgMjI3LjkxNCAxMDguNTc3IDIyNy42MjYgMTA2Ljk3NyAyMjcuMzI4QzEwNS4zNzcgMjI3LjAyOSAxMDMuODA3IDIyNi43MjIgMTAyLjI2NyAyMjYuNDA1QzEwMC43MjcgMjI2LjA4NyA5OS4yMTk0IDIyNS43NjEgOTcuNzQzNCAyMjUuNDI1Qzk2LjI2NzQgMjI1LjA4OSA5NC44MjUyIDIyNC43NDMgOTMuNDE2NSAyMjQuMzg5QzkyLjAwNzkgMjI0LjAzNiA5MC42MzQ4IDIyMy42NzQgODkuMjk2OSAyMjMuMzAzQzg3Ljk1OTEgMjIyLjkzMyA4Ni42NTgzIDIyMi41NTQgODUuMzk0NSAyMjIuMTY3Qzg0LjEzMDcgMjIxLjc4IDgyLjkwNTYgMjIxLjM4NiA4MS43MTg5IDIyMC45ODRDODAuNTMyMiAyMjAuNTgyIDc5LjM4NTQgMjIwLjE3MyA3OC4yNzg4IDIxOS43NTdDNzcuMTcyMSAyMTkuMzQxIDc2LjEwNjcgMjE4LjkxOSA3NS4wODI1IDIxOC40OTFDNzQuMDU4MyAyMTguMDYxIDczLjA3NjcgMjE3LjYyNiA3Mi4xMzc2IDIxNy4xODVDNzEuMTk4NiAyMTYuNzQzIDcwLjMwMzIgMjE2LjI5NiA2OS40NTE1IDIxNS44NDRDNjguNTk5OCAyMTUuMzkxIDY3Ljc5MjggMjE0LjkzNCA2Ny4wMzA0IDIxNC40NzJDNjYuMjY4MSAyMTQuMDEgNjUuNTUxMyAyMTMuNTQzIDY0Ljg4MDIgMjEzLjA3M0M2NC4yMDkyIDIxMi42MDIgNjMuNTg0NSAyMTIuMTI3IDYzLjAwNjIgMjExLjY0OEM2Mi40Mjc5IDIxMS4xNjkgNjEuODk2OCAyMTAuNjg3IDYxLjQxMjcgMjEwLjIwMkM2MC45Mjg3IDIwOS43MTcgNjAuNDkyNCAyMDkuMjI5IDYwLjEwMzcgMjA4LjczOEM1OS43MTUxIDIwOC4yNDcgNTkuMzc0NiAyMDcuNzU0IDU5LjA4MjMgMjA3LjI1OUM1OC43OSAyMDYuNzY0IDU4LjU0NjMgMjA2LjI2OCA1OC4zNTA5IDIwNS43NzFDNTguMTU1NyAyMDUuMjczIDU4LjAwOTMgMjA0Ljc3NCA1Ny45MTE1IDIwNC4yNzVDNTcuODEzOCAyMDMuNzc1IDU3Ljc2NDkgMjAzLjI3NSA1Ny43NjQ5IDIwMi43NzRDNTcuNzY0OSAyMDIuMjc0IDU3LjgxMzggMjAxLjc3NCA1Ny45MTE1IDIwMS4yNzRDNTguMDA5MyAyMDAuNzc0IDU4LjE1NTcgMjAwLjI3NiA1OC4zNTA5IDE5OS43NzhDNTguNTQ2MyAxOTkuMjggNTguNzkgMTk4Ljc4NCA1OS4wODIzIDE5OC4yODlDNTkuMzc0NiAxOTcuNzk0IDU5LjcxNTEgMTk3LjMwMiA2MC4xMDM3IDE5Ni44MTFDNjAuNDkyNCAxOTYuMzIgNjAuOTI4NyAxOTUuODMyIDYxLjQxMjcgMTk1LjM0NkM2MS44OTY4IDE5NC44NjEgNjIuNDI3OSAxOTQuMzc5IDYzLjAwNjIgMTkzLjkwMUM2My41ODQ1IDE5My40MjIgNjQuMjA5MiAxOTIuOTQ2IDY0Ljg4MDIgMTkyLjQ3NkM2NS41NTEzIDE5Mi4wMDUgNjYuMjY4MSAxOTEuNTM5IDY3LjAzMDQgMTkxLjA3N0M2Ny43OTI4IDE5MC42MTQgNjguNTk5OCAxOTAuMTU3IDY5LjQ1MTUgMTg5LjcwNUM3MC4zMDMyIDE4OS4yNTIgNzEuMTk4NiAxODguODA2IDcyLjEzNzYgMTg4LjM2NUM3My4wNzY3IDE4Ny45MjMgNzQuMDU4MyAxODcuNDg3IDc1LjA4MjUgMTg3LjA1OEM3Ni4xMDY3IDE4Ni42MyA3Ny4xNzIxIDE4Ni4yMDcgNzguMjc4OCAxODUuNzkyQzc5LjM4NTQgMTg1LjM3NSA4MC41MzIyIDE4NC45NjYgODEuNzE4OSAxODQuNTY0QzgyLjkwNTYgMTg0LjE2MyA4NC4xMzA3IDE4My43NjkgODUuMzk0NSAxODMuMzgyQzg2LjY1ODMgMTgyLjk5NSA4Ny45NTkxIDE4Mi42MTYgODkuMjk2OSAxODIuMjQ1QzkwLjYzNDggMTgxLjg3NCA5Mi4wMDc5IDE4MS41MTMgOTMuNDE2NSAxODEuMTU5Qzk0LjgyNTIgMTgwLjgwNSA5Ni4yNjc0IDE4MC40NiA5Ny43NDM0IDE4MC4xMjRDOTkuMjE5NCAxNzkuNzg4IDEwMC43MjcgMTc5LjQ2MSAxMDIuMjY3IDE3OS4xNDNDMTAzLjgwNyAxNzguODI3IDEwNS4zNzcgMTc4LjUxOSAxMDYuOTc3IDE3OC4yMjFDMTA4LjU3NyAxNzcuOTIzIDExMC4yMDUgMTc3LjYzNSAxMTEuODYyIDE3Ny4zNTdDMTEzLjUxOCAxNzcuMDc5IDExNS4yMDEgMTc2LjgxMSAxMTYuOTA5IDE3Ni41NTRDMTE4LjYxOCAxNzYuMjk3IDEyMC4zNTEgMTc2LjA1MSAxMjIuMTA4IDE3NS44MTVDMTIzLjg2NCAxNzUuNTc5IDEyNS42NDMgMTc1LjM1NCAxMjcuNDQ0IDE3NS4xNDFDMTI5LjI0NSAxNzQuOTI2IDEzMS4wNjUgMTc0LjcyMyAxMzIuOTA2IDE3NC41MzFDMTM0Ljc0NiAxNzQuMzQxIDEzNi42MDQgMTc0LjE2MSAxMzguNDggMTczLjk5M0MxNDAuMzU2IDE3My44MjMgMTQyLjI0NyAxNzMuNjY2IDE0NC4xNTMgMTczLjUyMkMxNDYuMDU5IDE3My4zNzcgMTQ3Ljk3OSAxNzMuMjQzIDE0OS45MTIgMTczLjEyMUMxNTEuODQzIDE3Mi45OTkgMTUzLjc4NiAxNzIuODkgMTU1Ljc0IDE3Mi43OTNDMTU3LjY5NCAxNzIuNjk1IDE1OS42NTYgMTcyLjYwOSAxNjEuNjI3IDE3Mi41MzZDMTYzLjU5NyAxNzIuNDYzIDE2NS41NzQgMTcyLjQwMSAxNjcuNTU2IDE3Mi4zNTJDMTY5LjUzOCAxNzIuMzAzIDE3MS41MjQgMTcyLjI2NyAxNzMuNTE0IDE3Mi4yNDNDMTc1LjUwNCAxNzIuMjE4IDE3Ny40OTUgMTcyLjIwNSAxNzkuNDg3IDE3Mi4yMDVDMTgxLjQ3OSAxNzIuMjA1IDE4My40NyAxNzIuMjE4IDE4NS40NiAxNzIuMjQzQzE4Ny40NSAxNzIuMjY3IDE4OS40MzYgMTcyLjMwMyAxOTEuNDE4IDE3Mi4zNTJDMTkzLjQgMTcyLjQwMSAxOTUuMzc2IDE3Mi40NjMgMTk3LjM0NyAxNzIuNTM2QzE5OS4zMTggMTcyLjYwOSAyMDEuMjggMTcyLjY5NSAyMDMuMjM0IDE3Mi43OTNDMjA1LjE4OCAxNzIuODkgMjA3LjEzMSAxNzIuOTk5IDIwOS4wNjIgMTczLjEyMUMyMTAuOTk1IDE3My4yNDMgMjEyLjkxNSAxNzMuMzc3IDIxNC44MjEgMTczLjUyMkMyMTYuNzI3IDE3My42NjYgMjE4LjYxOCAxNzMuODIzIDIyMC40OTQgMTczLjk5M0MyMjIuMzY5IDE3NC4xNjEgMjI0LjIyOCAxNzQuMzQxIDIyNi4wNjggMTc0LjUzMUMyMjcuOTA5IDE3NC43MjMgMjI5LjczIDE3NC45MjYgMjMxLjUzIDE3NS4xNDFDMjMzLjMzIDE3NS4zNTQgMjM1LjEwOSAxNzUuNTc5IDIzNi44NjcgMTc1LjgxNUMyMzguNjIzIDE3Ni4wNTEgMjQwLjM1NiAxNzYuMjk3IDI0Mi4wNjQgMTc2LjU1NEMyNDMuNzc0IDE3Ni44MTEgMjQ1LjQ1NiAxNzcuMDc5IDI0Ny4xMTIgMTc3LjM1N0MyNDguNzY5IDE3Ny42MzUgMjUwLjM5NyAxNzcuOTIzIDI1MS45OTcgMTc4LjIyMUMyNTMuNTk2IDE3OC41MTkgMjU1LjE2NiAxNzguODI3IDI1Ni43MDYgMTc5LjE0M0MyNTguMjQ3IDE3OS40NjEgMjU5Ljc1NCAxNzkuNzg4IDI2MS4yMyAxODAuMTI0QzI2Mi43MDcgMTgwLjQ2IDI2NC4xNDggMTgwLjgwNSAyNjUuNTU4IDE4MS4xNTlDMjY2Ljk2NyAxODEuNTEzIDI2OC4zNCAxODEuODc0IDI2OS42NzYgMTgyLjI0NUMyNzEuMDE0IDE4Mi42MTYgMjcyLjMxNiAxODIuOTk1IDI3My41OCAxODMuMzgyQzI3NC44NDMgMTgzLjc2OSAyNzYuMDY4IDE4NC4xNjMgMjc3LjI1NSAxODQuNTY0QzI3OC40NDIgMTg0Ljk2NiAyNzkuNTg5IDE4NS4zNzUgMjgwLjY5NSAxODUuNzkyQzI4MS44MDEgMTg2LjIwNyAyODIuODY3IDE4Ni42MyAyODMuODkxIDE4Ny4wNThDMjg0LjkxNiAxODcuNDg3IDI4NS44OTcgMTg3LjkyMyAyODYuODM3IDE4OC4zNjVDMjg3Ljc3NiAxODguODA2IDI4OC42NyAxODkuMjUyIDI4OS41MjMgMTg5LjcwNUMyOTAuMzc0IDE5MC4xNTcgMjkxLjE4MiAxOTAuNjE0IDI5MS45NDQgMTkxLjA3N0MyOTIuNzA2IDE5MS41MzkgMjkzLjQyMiAxOTIuMDA1IDI5NC4wOTQgMTkyLjQ3NkMyOTQuNzY2IDE5Mi45NDYgMjk1LjM4OSAxOTMuNDIyIDI5NS45NjggMTkzLjkwMUMyOTYuNTQ3IDE5NC4zNzkgMjk3LjA3NyAxOTQuODYxIDI5Ny41NjEgMTk1LjM0NkMyOTguMDQ1IDE5NS44MzIgMjk4LjQ4MSAxOTYuMzIgMjk4Ljg3IDE5Ni44MTFDMjk5LjI1OSAxOTcuMzAyIDI5OS41OTkgMTk3Ljc5NCAyOTkuODkyIDE5OC4yODlDMzAwLjE4NSAxOTguNzg0IDMwMC40MjggMTk5LjI4IDMwMC42MjMgMTk5Ljc3OEMzMDAuODE5IDIwMC4yNzYgMzAwLjk2NCAyMDAuNzc0IDMwMS4wNjIgMjAxLjI3NEMzMDEuMTYgMjAxLjc3NCAzMDEuMjA5IDIwMi4yNzQgMzAxLjIwOSAyMDIuNzc0WiIgIGZpbGw9InVybCgjbGluZWFyXzIpIiA+DQo8L3BhdGg+DQo8L2c+DQo8ZyBmaWx0ZXI9InVybCgjZmlsdGVyXzYpIj4NCjxnICBvcGFjaXR5PSIwLjIzOTk5OTk5NDYzNTU4MTk3Ij4NCjxwYXRoIGQ9Ik0xNzguOTc0IDE4Mi4zOTVDMTYzLjAxNCAxODIuMzk1IDE1MC4wODYgMTg0LjIxNCAxNTAuMDg2IDE4Ni40NjdDMTUwLjA4NiAxODguNzE5IDE2My4wMTQgMTkwLjU1MyAxNzguOTc0IDE5MC41NTNDMTk0LjkxOSAxOTAuNTUzIDIwNy44NDcgMTg4LjcxOSAyMDcuODQ3IDE4Ni40NjdDMjA3Ljg0NyAxODQuMjE0IDE5NC45MTkgMTgyLjM5NSAxNzguOTc0IDE4Mi4zOTVaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSIjNTQ4M0U4IiA+DQo8L3BhdGg+DQo8L2c+DQo8L2c+DQo8cGF0aCBkPSJNMTQ2LjExNiAxNTEuODI3TDIxMS44MiAxNTEuODI3QzIxNS4wNDEgMTUxLjgyNyAyMTcuNjUgMTQ5LjI0MiAyMTcuNjUgMTQ2LjA1MUwyMTcuNjUgNjcuOTMyMkMyMTcuNjUgNjQuNzQxIDIxNS4wNDEgNjIuMTU2MiAyMTEuODIgNjIuMTU2MkwxNDYuMTE2IDYyLjE1NjJDMTQyLjg5NiA2Mi4xNTYyIDE0MC4yODcgNjQuNzQxIDE0MC4yODcgNjcuOTMyMkwxNDAuMjg3IDE0Ni4wNTFDMTQwLjI4NyAxNDkuMjQyIDE0Mi44OTYgMTUxLjgyNyAxNDYuMTE2IDE1MS44MjdaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSJ1cmwoI2xpbmVhcl8zKSIgPg0KPC9wYXRoPg0KPGcgIG9wYWNpdHk9IjAuNDAwMDAwMDA1OTYwNDY0NSI+DQo8cGF0aCBkPSJNMTU4Ljg2MiA3OC40NjcxTDE5OS4wODkgNzguNDY3MUMyMDAuMzcxIDc4LjQ2NzEgMjAxLjUwOCA3Ny42Mjk2IDIwMS44NzMgNzYuNDAyMkwyMDIuNjAxIDc0LjAzNDFDMjAzLjE3IDcyLjE3MTMgMjAxLjc1NiA3MC4zMDg2IDE5OS44MDMgNzAuMzA4NkwxNTguMTMzIDcwLjMwODZDMTU2LjE4IDcwLjMwODYgMTU0Ljc4MSA3Mi4xODU4IDE1NS4zNDkgNzQuMDM0MUwxNTYuMDY0IDc2LjQwMjJDMTU2LjQyOCA3Ny42Mjk2IDE1Ny41NjUgNzguNDY3MSAxNTguODYyIDc4LjQ2NzFaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSIjNTQ4M0U4IiA+DQo8L3BhdGg+DQo8L2c+DQo8cGF0aCBkPSJNMTU1Ljc1MiA5OC44MzU5TDIwMi4xODcgOTguODM1OUMyMDMuMzI0IDk4LjgzNTkgMjA0LjI0MyA5Ny45MjYxIDIwNC4yNDMgOTYuNzk5N0MyMDQuMjQzIDk1LjY3MzQgMjAzLjMyNCA5NC43NjM3IDIwMi4xODcgOTQuNzYzN0wxNTUuNzUyIDk0Ljc2MzdDMTU0LjYxNSA5NC43NjM3IDE1My42OTcgOTUuNjczNCAxNTMuNjk3IDk2Ljc5OTdDMTUzLjY5NyA5Ny45MjYxIDE1NC42MTUgOTguODM1OSAxNTUuNzUyIDk4LjgzNTlaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSIjRkZGRkZGIiA+DQo8L3BhdGg+DQo8cGF0aCBkPSJNMTU1Ljc1MiAxMTMuMTAxTDIwMi4xODcgMTEzLjEwMUMyMDMuMzI0IDExMy4xMDEgMjA0LjI0MyAxMTIuMTkyIDIwNC4yNDMgMTExLjA2NUMyMDQuMjQzIDEwOS45MzkgMjAzLjMyNCAxMDkuMDI5IDIwMi4xODcgMTA5LjAyOUwxNTUuNzUyIDEwOS4wMjlDMTU0LjYxNSAxMDkuMDI5IDE1My42OTcgMTA5LjkzOSAxNTMuNjk3IDExMS4wNjVDMTUzLjY5NyAxMTIuMTkyIDE1NC42MTUgMTEzLjEwMSAxNTUuNzUyIDExMy4xMDFaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSIjRkZGRkZGIiA+DQo8L3BhdGg+DQo8cGF0aCBkPSJNMTg4Ljc2IDEyNy4zNjdMMjAyLjE4MyAxMjcuMzY3QzIwMy4zMiAxMjcuMzY3IDIwNC4yMzggMTI2LjQ1NyAyMDQuMjM4IDEyNS4zMzFDMjA0LjIzOCAxMjQuMjA1IDIwMy4zMiAxMjMuMjk1IDIwMi4xODMgMTIzLjI5NUwxODguNzYgMTIzLjI5NUMxODcuNjIzIDEyMy4yOTUgMTg2LjcwNSAxMjQuMjA1IDE4Ni43MDUgMTI1LjMzMUMxODYuNzA1IDEyNi40NTcgMTg3LjYyMyAxMjcuMzY3IDE4OC43NiAxMjcuMzY3WiIgZmlsbC1ydWxlPSJldmVub2RkIiAgZmlsbD0iI0ZGRkZGRiIgPg0KPC9wYXRoPg0KPHBhdGggZD0iTTEwNi4yNDcgMjAyLjc2OEwxMTQuNDk2IDIwMi43NjhMMTE0LjQ5NiAxODAuMzU3TDEwNi4yNDcgMTgwLjM1N0wxMDYuMjQ3IDIwMi43NjhaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSJ1cmwoI2xpbmVhcl80KSIgPg0KPC9wYXRoPg0KPHBhdGggZD0iTTI0NC40NzEgMTkwLjU0NEwyNTAuNjY1IDE5MC41NDRMMjUwLjY2NSAxNzcuNjA1TDI0NC40NzEgMTc3LjYwNUwyNDQuNDcxIDE5MC41NDRaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSJ1cmwoI2xpbmVhcl81KSIgPg0KPC9wYXRoPg0KPHBhdGggZD0iTTE2MC45MTcgMTc1LjI2MUwxNjIuOTg3IDE3NS4yNjFMMTYyLjk4NyAxNjYuMDkyTDE2MC45MTcgMTY2LjA5MkwxNjAuOTE3IDE3NS4yNjFaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSJ1cmwoI2xpbmVhcl82KSIgPg0KPC9wYXRoPg0KPHBhdGggZD0iTTE2MC45MTcgMTc1LjI2MUwxNjIuOTg3IDE3NS4yNjFMMTYyLjk4NyAxNjYuMDkyTDE2MC45MTcgMTY2LjA5MkwxNjAuOTE3IDE3NS4yNjFaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSIjRThFRkZDIiA+DQo8L3BhdGg+DQo8cGF0aCBkPSJNMjA2LjMwMyAxNzYuMjhMMjA3LjMzNSAxNzYuMjhMMjA3LjMzNSAxNjcuMTA5TDIwNi4zMDMgMTY3LjEwOUwyMDYuMzAzIDE3Ni4yOFoiIGZpbGwtcnVsZT0iZXZlbm9kZCIgIGZpbGw9IiNFOEVGRkMiID4NCjwvcGF0aD4NCjxwYXRoIGQ9Ik0xMDQuOTYyIDEzNi41NDFDOTcuODM0NSAxMzYuNTQxIDkyLjA2MjkgMTQyLjIwMSA5Mi4wNjI5IDE0OS4xOUM5Mi4wNjI5IDE1MC44NjkgOTIuMzk1OCAxNTIuNDcgOTMuMDAwNSAxNTMuOTM2Qzg4LjUzOSAxNTYuOTUgODUuNjE2IDE2MS45OTggODUuNjE2IDE2Ny43MkM4NS42MTYgMTc2Ljk0NyA5My4yMzg2IDE4NC40MjcgMTAyLjY1NCAxODQuNDI3QzEwNS4yMjcgMTg0LjQyNyAxMDcuNjY1IDE4My44NjggMTA5Ljg1MiAxODIuODY5QzExMi4yMjcgMTgzLjg4IDExNC44NDYgMTg0LjQ0IDExNy41OTcgMTg0LjQ0QzEyOC40MTIgMTg0LjQ0IDEzNy4xODYgMTc1Ljc2MiAxMzcuMTg2IDE2NS4wNzZDMTM3LjE4NiAxNTQuMzc2IDEyOC40MTIgMTQ1LjcxMiAxMTcuNTk3IDE0NS43MTJDMTE3LjUxNiAxNDUuNzEyIDExNy40MzQgMTQ1LjcxMiAxMTcuMzUzIDE0NS43MTRDMTE1LjgxNCAxNDAuNDE3IDExMC44NDcgMTM2LjU0MSAxMDQuOTYyIDEzNi41NDFaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSJ1cmwoI2xpbmVhcl83KSIgPg0KPC9wYXRoPg0KPHBhdGggZD0iTTI0Mi40MTEgMTQyLjY1NEMyMzYuNzEyIDE0Mi42NTQgMjMyLjA5MiAxNDcuMTg4IDIzMi4wOTIgMTUyLjc3NkMyMzIuMDkyIDE1NC4xMTkgMjMyLjM1OSAxNTUuNDAxIDIzMi44NDMgMTU2LjU3NEMyMjkuMjc1IDE1OC45ODcgMjI2LjkzNCAxNjMuMDI0IDIyNi45MzQgMTY3LjU5MUMyMjYuOTM0IDE3NC45ODUgMjMzLjA0MSAxODAuOTYzIDI0MC41NjIgMTgwLjk2M0MyNDIuNTgyIDE4MC45NjMgMjQ0LjQ5NyAxODAuNTM0IDI0Ni4yMiAxNzkuNzYzQzI0OC4xMDcgMTgwLjU0MiAyNTAuMTggMTgwLjk3MyAyNTIuMzU2IDE4MC45NzNDMjYxLjEwMSAxODAuOTczIDI2OC4xOTkgMTc0LjAxMyAyNjguMTk5IDE2NS40MjFDMjY4LjE5OSAxNTYuODQ0IDI2MS4xMDEgMTQ5Ljg4NCAyNTIuMzU2IDE0OS44ODRDMjUyLjMzMiAxNDkuODg0IDI1Mi4zMSAxNDkuODg0IDI1Mi4yODkgMTQ5Ljg4NEMyNTEuMDIzIDE0NS43MDMgMjQ3LjA4NCAxNDIuNjU0IDI0Mi40MTEgMTQyLjY1NFoiIGZpbGwtcnVsZT0iZXZlbm9kZCIgIGZpbGw9IiNDOUQ4RkEiID4NCjwvcGF0aD4NCjxwYXRoIGQ9Ik0xNjAuMjc2IDE1Mi44NDRDMTU3Ljg1NiAxNTIuODQ0IDE1NS44ODkgMTU0Ljc2NCAxNTUuODg5IDE1Ny4xNDdDMTU1Ljg4OSAxNTcuNzE2IDE1Ni4wMDMgMTU4LjI2IDE1Ni4yMDggMTU4Ljc1N0MxNTQuNjkyIDE1OS43ODIgMTUzLjY5NyAxNjEuNDk5IDE1My42OTcgMTYzLjQ0OEMxNTMuNjk3IDE2Ni41ODIgMTU2LjI5MSAxNjkuMTIzIDE1OS40ODMgMTY5LjEyM0MxNjAuMzQzIDE2OS4xMjMgMTYxLjE1OCAxNjguOTQxIDE2MS44OTIgMTY4LjYxNEMxNjIuNjk0IDE2OC45NDYgMTYzLjU3NiAxNjkuMTI5IDE2NC41MDEgMTY5LjEyOUMxNjguMjE4IDE2OS4xMjkgMTcxLjIzNSAxNjYuMTY5IDE3MS4yMzUgMTYyLjUxNkMxNzEuMjM1IDE1OC44NzcgMTY4LjIxOCAxNTUuOTE3IDE2NC41MDEgMTU1LjkxN0wxNjQuNDgxIDE1NS45MTdDMTYzLjk0MSAxNTQuMTM2IDE2Mi4yNjEgMTUyLjg0NCAxNjAuMjc2IDE1Mi44NDRaIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiICBmaWxsPSIjQzlEOEZBIiA+DQo8L3BhdGg+DQo8cGF0aCBkPSJNMjA1LjI3OSAxNjIuMDE2QzIwNC4xMjcgMTYyLjAxNiAyMDMuMjA5IDE2Mi45ODMgMjAzLjIwOSAxNjQuMTY3QzIwMy4yMDkgMTY0LjQ1MyAyMDMuMjYzIDE2NC43MjYgMjAzLjM2MSAxNjQuOTc2QzIwMi42NDcgMTY1LjQ4OCAyMDIuMTc3IDE2Ni4zNDYgMjAyLjE3NyAxNjcuMzIxQzIwMi4xNzcgMTY4Ljg5NSAyMDMuNDAyIDE3MC4xNjUgMjA0LjkwMyAxNzAuMTY1QzIwNS4zMDYgMTcwLjE2NSAyMDUuNjg4IDE3MC4wNzUgMjA2LjAzNCAxNjkuOTFDMjA2LjQxIDE3MC4wNzYgMjA2LjgyMiAxNzAuMTY3IDIwNy4yNTcgMTcwLjE2N0MyMDkuMDA2IDE3MC4xNjcgMjEwLjQzNCAxNjguNjggMjEwLjQzNCAxNjYuODZDMjEwLjQzNCAxNjUuMDQxIDIwOS4wMDYgMTYzLjU1MyAyMDcuMjU3IDE2My41NTNMMjA3LjI0OSAxNjMuNTUzQzIwNi45OTcgMTYyLjY2NyAyMDYuMjEyIDE2Mi4wMTYgMjA1LjI3OSAxNjIuMDE2WiIgZmlsbC1ydWxlPSJldmVub2RkIiAgZmlsbD0iI0M5RDhGQSIgPg0KPC9wYXRoPg0KPGcgIG9wYWNpdHk9IjAuMzAwMDAwMDExOTIwOTI4OTYiPg0KPHBhdGggZD0iTTI3OC45MjggOTYuNzkzMUMyNjIuNTcxIDk0LjU0OCAyNDYuNjA2IDExMS45MDUgMjQzLjI3NyAxMzUuNTc1QzIzOS45NDggMTU5LjI0NCAyNTAuNTE2IDE4MC4yNTggMjY2Ljg3NCAxODIuNTAzQzI4My4yNDQgMTg0Ljc1IDI5OS4yMTIgMTY3LjM3OCAzMDIuNTQxIDE0My43MDlDMzA1Ljg3IDEyMC4wNCAyOTUuMyA5OS4wNDAyIDI3OC45MjggOTYuNzkzMVoiIGZpbGwtcnVsZT0iZXZlbm9kZCIgIGZpbGw9InVybCgjbGluZWFyXzgpIiA+DQo8L3BhdGg+DQo8L2c+DQo8ZGVmcz4NCjxtYXNrIGlkPSJtYXNrLXVuZGVmaW5lZCIgc3R5bGU9Im1hc2stdHlwZTphbHBoYSIgbWFza1VuaXRzPSJ1c2VyU3BhY2VPblVzZSI+DQo8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMzU5Ljk5OTkzODk5MjY5OTUiIGhlaWdodD0iMjcwLjAyNTMyOTU4OTg0Mzc1IiAgIGZpbGw9IiMwMDAwMDAiID4NCjwvcmVjdD4NCjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIzNTkuOTk5OTM4OTkyNjk5NSIgaGVpZ2h0PSIyNzAuMDI1MzI5NTg5ODQzNzUiICAgZmlsbD0iIzAwMDAwMCIgPg0KPC9yZWN0Pg0KPC9tYXNrPg0KPGxpbmVhckdyYWRpZW50IGlkPSJsaW5lYXJfMCIgeDE9IjM4LjgxMzA0ODU1NzQ3OTc1JSIgeTE9Ii0wLjM1MDkxMjU4NzE2NDc1ODQlIiB4Mj0iMTkuMDI2NzU1MTg4NzE2NjI4JSIgeTI9IjU4LjMwOTUyODk2NzgzMjUxJSIgZ3JhZGllbnRVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giPg0KPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjNTQ4M0U4IiBzdG9wLW9wYWNpdHk9IjAuNCIgLz4NCjxzdG9wIG9mZnNldD0iMC45OTk3MDAwMDk4MjI4NDU1IiBzdG9wLWNvbG9yPSIjNTg4QkY5IiBzdG9wLW9wYWNpdHk9IjAiIC8+DQo8L2xpbmVhckdyYWRpZW50Pg0KPGxpbmVhckdyYWRpZW50IGlkPSJsaW5lYXJfMSIgeDE9IjQ5Ljk5OTkxOTcyODg3NTA4JSIgeTE9IjAlIiB4Mj0iNTAuOTk5OTE3MTY5Nzc5OCUiIHkyPSI2OC41NDA4MTE2NzMyODM1NyUiIGdyYWRpZW50VW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij4NCjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzU0ODNFOCIgc3RvcC1vcGFjaXR5PSIwLjQiIC8+DQo8c3RvcCBvZmZzZXQ9IjAuOTk5MzAwMDAzMDUxNzU3OCIgc3RvcC1jb2xvcj0iIzU4OEJGOSIgc3RvcC1vcGFjaXR5PSIwIiAvPg0KPC9saW5lYXJHcmFkaWVudD4NCjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyXzIiIHgxPSI1MC4wMDAwNDA3OTEzOTMxOCUiIHkxPSItMjUuNjgyMDA4MTE0Njg5MTM2JSIgeDI9IjUxLjAwMDA0MDY1MzU0NTk1JSIgeTI9Ijg5LjMxMjAyOTY0NzA2NzQyJSIgZ3JhZGllbnRVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giPg0KPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjNTQ4M0U4IiBzdG9wLW9wYWNpdHk9IjAuNCIgLz4NCjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGRkZGRiIgc3RvcC1vcGFjaXR5PSIwLjAxIiAvPg0KPC9saW5lYXJHcmFkaWVudD4NCjxmaWx0ZXIgaWQ9ImZpbHRlcl82IiB4PSIxNDYuMDg3NDAyMzQzNzUiIHk9IjE3OS4xNDQ1MzEyNSIgd2lkdGg9IjY1Ljc2MDc0MjE4NzUiIGhlaWdodD0iMTYuMTU4MjAzMTI1IiBmaWx0ZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+DQo8ZmVGbG9vZCBmbG9vZC1vcGFjaXR5PSIwIiByZXN1bHQ9ImZlRmxvb2RJZF82Ii8+DQo8ZmVDb2xvck1hdHJpeCBpbj0iU291cmNlQWxwaGEiIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxMjcgMCIgcmVzdWx0PSJoYXJkQWxwaGFfNiIvPg0KPGZlT2Zmc2V0IGR4PSJ1bmRlZmluZWQiIGR5PSJ1bmRlZmluZWQiLz4NCjxmZUNvbXBvc2l0ZSBpbjI9ImhhcmRBbHBoYV82IiBvcGVyYXRvcj0ib3V0Ii8+DQo8ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIi8+DQo8ZmVCbGVuZCBtb2RlPSIiIGluMj0iZmVGbG9vZElkXzYiIHJlc3VsdD0iZHJvcFNoYWRvd18xXzYiLz4NCjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iZHJvcFNoYWRvd18xXzYiIHJlc3VsdD0ic2hhcGVfNiIvPg0KPGZlR2F1c3NpYW5CbHVyIHJlc3VsdD0iZ2F1c3NpYW5fYmx1cl82IiBzdGREZXZpYXRpb249IjIiLz4NCjwvZmlsdGVyPg0KPGxpbmVhckdyYWRpZW50IGlkPSJsaW5lYXJfMyIgeDE9IjQ5Ljk5OTk3ODAyMDA3NjAyJSIgeTE9IjEwMC4wMDAwNTUzODUyMTEyNSUiIHgyPSI1MC45OTk5NzY2MjY4MDM2NDQlIiB5Mj0iMCUiIGdyYWRpZW50VW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij4NCjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzU0ODNFOCIgc3RvcC1vcGFjaXR5PSIwLjQiIC8+DQo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM1ODhCRjkiIHN0b3Atb3BhY2l0eT0iMC4yIiAvPg0KPC9saW5lYXJHcmFkaWVudD4NCjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyXzQiIHgxPSI0OS45OTk5OTc4NjkxNjA2MyUiIHkxPSIwJSIgeDI9IjUwLjk5OTk5Njg3Mjg2OTU2NiUiIHkyPSIxMDAuMDAwMTk4NzA2MTkyNiUiIGdyYWRpZW50VW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij4NCjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI0M4RDdGOSIgIC8+DQo8c3RvcCBvZmZzZXQ9IjAuNzk4OTAwMDA4MjAxNTk5MSIgc3RvcC1jb2xvcj0iI0M4RDdGOSIgc3RvcC1vcGFjaXR5PSIwIiAvPg0KPC9saW5lYXJHcmFkaWVudD4NCjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyXzUiIHgxPSI0OS45OTk5NjcyMDc5NjcyNyUiIHkxPSIwJSIgeDI9IjUwLjk5OTk2NTU5ODQ1MjkyNCUiIHkyPSIxMDAuMDAwMDgwMDA4MzY2NzUlIiBncmFkaWVudFVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCI+DQo8c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNDN0Q3RjkiICAvPg0KPHN0b3Agb2Zmc2V0PSIwLjc5ODYwMDAxODAyNDQ0NDYiIHN0b3AtY29sb3I9IiNFRUYzRkQiICAvPg0KPC9saW5lYXJHcmFkaWVudD4NCjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyXzYiIHgxPSI0OS45OTk1NDM3MjQxMjAxNSUiIHkxPSIwJSIgeDI9IjUwLjk5OTUzMzY0NDkzNjkzJSIgeTI9IjEwMC4wMDAwMTY2MTQ1MjcxNSUiIGdyYWRpZW50VW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij4NCjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI0NDQ0NDQyIgIC8+DQo8c3RvcCBvZmZzZXQ9IjAuNzk4OTAwMDA4MjAxNTk5MSIgc3RvcC1jb2xvcj0iI0NDQ0NDQyIgc3RvcC1vcGFjaXR5PSIwLjAxIiAvPg0KPC9saW5lYXJHcmFkaWVudD4NCjxsaW5lYXJHcmFkaWVudCBpZD0ibGluZWFyXzciIHgxPSI1MC4wMDAwMDA0OTcwODc3NSUiIHkxPSI5OS45OTk5MDUzNDkzMjkzJSIgeDI9IjUwLjk5OTk5OTU1MzM1NTE4JSIgeTI9IjAlIiBncmFkaWVudFVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCI+DQo8c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNDNkQ2RjkiICAvPg0KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRENFNkZFIiAgLz4NCjwvbGluZWFyR3JhZGllbnQ+DQo8bGluZWFyR3JhZGllbnQgaWQ9ImxpbmVhcl84IiB4MT0iNTkuMzU3MjkxODA1NjQ5MTklIiB5MT0iMC40NzUzODIxNTIwNjE5NjcxJSIgeDI9IjQ1Ljc3NjQxMjgxNjkwNDM3JSIgeTI9IjY4LjcwNzczNTk2MTY3MDM4JSIgZ3JhZGllbnRVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giPg0KPHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjNTQ4M0U4IiBzdG9wLW9wYWNpdHk9IjAuNCIgLz4NCjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzU4OEJGOSIgc3RvcC1vcGFjaXR5PSIwIiAvPg0KPC9saW5lYXJHcmFkaWVudD4NCjwvZGVmcz4NCjwvc3ZnPg0K", index_vue_vue_type_style_index_0_scoped_12dab498_lang = "", _sfc_main$l = {}, _hoisted_1$g = {
  class: "dms-loading-svg",
  "element-loading-text": "加载中...",
  "element-loading-background": "rgba(255, 255, 255, 0.8)"
};
function _sfc_render$3(_n, nr) {
  const Cn = resolveDirective("loading");
  return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$g, null, 512)), [
    [Cn, !0]
  ]);
}
const AsyncLoading = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$3], ["__scopeId", "data-v-12dab498"]]), _sfc_main$k = {};
function _sfc_render$2(_n, nr) {
  const Cn = resolveComponent("dms-skeleton");
  return openBlock(), createElementBlock("div", null, [
    createVNode$1(Cn, {
      repeat: 3,
      show: !0
    })
  ]);
}
const AsyncSkeletonLoading = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$2]]);
AsyncLoading.install = (_n) => {
  _n.component("AsyncLoading", AsyncLoading);
};
AsyncSkeletonLoading.install = (_n) => {
  _n.component("AsyncSkeletonLoading", AsyncSkeletonLoading);
};
const componentInstall = (_n, nr) => {
  !window.$vue.component(_n) && nr && window.$vue.component(_n, nr);
}, loadAsyncComponent = (_n) => defineAsyncComponent({
  loader: _n,
  loadingComponent: AsyncLoading,
  delay: 20
}), createComponent = async (_n) => {
  const { widgetPackage: nr, category: Cn, widgetKey: Bn, key: In, type: Dn } = _n;
  _n.key = Bn || In, _n.package = nr || _n.package;
  try {
    if (Dn === 2)
      return window[_n.key] ? new window[_n.key].Config(_n) : (await loadScript(`${_n.path}/index.js`), new window[_n.key].Config(_n));
    {
      const $n = await import(`${import.meta.resolve("/src/packages/components")}/${_n.package}/${Cn}/${_n.key}/config.ts`);
      return new $n.default(_n);
    }
  } catch {
    console.log(`${_n.package}/${Cn}/${_n.key}'无该组件'`);
    return;
  }
}, fetchComponent = async (_n, nr) => {
  const { widgetPackage: Cn, category: Bn, widgetKey: In, key: Dn, type: Ln } = _n;
  _n.key = In || Dn, _n.package = Cn || _n.package;
  const $n = import.meta.resolve("/src/packages/components");
  return nr === FetchComFlagType.VIEW ? await import(`${$n}/${_n.package}/${_n.category}/${_n.key}/index.vue`) : await import(`${$n}/${_n.package}/${_n.category}/${_n.key}/config.vue`);
};
function loadScript(_n) {
  return new Promise((nr, Cn) => {
    var Bn = document.createElement("script");
    Bn.type = "text/javascript", Bn.src = _n, Bn.onload = nr, Bn.onerror = Cn, document.head.appendChild(Bn);
  });
}
const fetchRemoteComponent = async (_n, nr) => (window[_n.key] || await loadScript(`${_n.path}/index.js`), nr === FetchComFlagType.VIEW ? window[_n.key].IndexComponent : window[_n.key].ConfigComponent), fetchChartComponent = async (_n) => {
  const { widgetKey: nr, key: Cn, type: Bn } = _n;
  return Bn === 2 ? await fetchRemoteComponent(_n, FetchComFlagType.VIEW) : (await fetchComponent(_n, FetchComFlagType.VIEW)).default;
}, fetchConfigComponent = async (_n) => {
  const { widgetKey: nr, key: Cn, type: Bn } = _n;
  return Bn === 2 ? await fetchRemoteComponent(_n, FetchComFlagType.CONFIG) : (await fetchComponent(_n, FetchComFlagType.CONFIG)).default;
}, _hoisted_1$f = {
  class: "sidebar",
  "element-loading-text": "组件库加载中...",
  "element-loading-background": "rgba(255, 255, 255, 1)"
}, _hoisted_2$7 = { class: "sidebar-left" }, _hoisted_3$5 = { class: "classify" }, _hoisted_4$3 = ["onClick"], _hoisted_5$1 = { class: "item-wrap font-14" }, _hoisted_6$1 = { class: "name" }, _hoisted_7 = { class: "sidebar-middle" }, _hoisted_8 = { class: "tab-label" }, _hoisted_9 = { class: "category" }, _hoisted_10 = { class: "content-wrap" }, _hoisted_11 = { class: "category-list" }, _hoisted_12 = { class: "category-item" }, _hoisted_13 = { class: "category-item" }, _hoisted_14 = { class: "category-item" }, _hoisted_15 = { class: "category-item" }, _hoisted_16 = { class: "category-item" }, _hoisted_17 = { class: "category-list" }, _hoisted_18 = ["onClick"], _hoisted_19 = { class: "components" }, _hoisted_20 = { class: "content-wrap" }, _hoisted_21 = { class: "component-list" }, _hoisted_22 = ["onDragstart", "onDblclick"], _hoisted_23 = { class: "component-title" }, _hoisted_24 = { key: 0 }, _hoisted_25 = { class: "tab-label" }, _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "Sidebar",
  setup(_n) {
    const nr = ref(!1), Cn = useChartEditStore(), Bn = defineAsyncComponent({
      loader: () => import("./ContentLayers-a056b28a.js"),
      loadingComponent: AsyncLoading,
      delay: 20
    }), In = reactive({
      loadedWeight: !1,
      menuOptions: [],
      loadLayer: !1,
      selectValue: "Charts",
      tabValue: "components",
      selectPackage: null,
      selectCateIndex: -1
    }), Dn = computed(() => {
      const zn = [];
      if (In.selectCateIndex === -1) {
        if (In.selectPackage && In.selectPackage.childList)
          for (let Gn = 0; Gn < In.selectPackage.childList.length; Gn++)
            In.selectPackage.childList[Gn].widgets && zn.push(...In.selectPackage.childList[Gn].widgets);
      } else
        In.selectPackage && In.selectPackage.childList && In.selectPackage.childList[In.selectCateIndex] && In.selectPackage.childList[In.selectCateIndex].widgets && zn.push(...In.selectPackage.childList[In.selectCateIndex].widgets);
      return zn;
    }), Ln = (zn) => {
      In.selectPackage = zn, In.selectCateIndex = -1, In.tabValue = "components";
    };
    inject("pageData");
    const $n = inject("widgets", []);
    ref(!1);
    const Nn = async (zn, Gn) => {
      const Yn = JSONStringify(omit(Gn, ["createDate", "modifyDate", "userGroup", "userId"]));
      zn.dataTransfer.setData(DragKeyEnum.DRAG_KEY, Yn), componentInstall(Gn.chartKey, await fetchChartComponent(Gn)), componentInstall(Gn.conKey, await fetchConfigComponent(Gn)), Cn.setEditCanvas(EditCanvasTypeEnum.IS_CREATE, !0);
    }, Rn = () => {
      Cn.setEditCanvas(EditCanvasTypeEnum.IS_CREATE, !1);
    }, Fn = async (zn) => {
      try {
        componentInstall(zn.chartKey, await fetchChartComponent(zn)), componentInstall(zn.conKey, await fetchConfigComponent(zn));
        const Gn = await createComponent(zn);
        Cn.addComponentList(Gn, !1, !0), Cn.setTargetSelectChart(Gn.id);
      } catch {
        window.$message.warning("图表正在研发中, 敬请期待...");
      }
    }, Pn = (zn) => {
      In.selectCateIndex = zn;
    }, Un = { 图表: { icon: "chart", key: "Charts" }, 信息: { icon: "text", key: "Informations" }, 地图: { icon: "map", key: "Maps" }, 表单: { icon: "form", key: "Forms" }, 表格: { icon: "table", key: "Tables" }, 控件: { icon: "control", key: "Controls" }, 媒体: { icon: "media", key: "Medias" }, 装饰: { icon: "decoration", key: "Decorates" }, 模型: { icon: "model", key: "Models" }, 三维: { icon: "3d", key: "Threes" }, 定制: { icon: "other", key: "Customs" }, 模板: { icon: "template", key: "Templates" } };
    $n && $n.length > 0 ? (In.loadedWeight = !0, In.menuOptions = $n, In.selectPackage = In.menuOptions[0]) : nr.value && getWidgetAll().then((zn) => {
      const { code: Gn, data: Yn } = zn;
      if (In.loadedWeight = !0, Gn === 200) {
        const Wn = [];
        Yn.forEach((Xn) => {
          Xn.key = Un[Xn.name], Wn.push({
            key: Un[Xn.name].key,
            icon: Un[Xn.name].icon,
            name: Xn.name,
            childList: Xn.childList
          });
        }), In.menuOptions = Wn, In.selectPackage = In.menuOptions[0];
      }
    });
    const Hn = (zn) => {
      zn === "layers" && (In.loadLayer = !0);
    };
    return (zn, Gn) => {
      const Yn = __unplugin_components_0, Wn = resolveComponent("el-scrollbar"), Xn = resolveComponent("el-skeleton-item"), ea = resolveComponent("el-skeleton"), ta = resolveComponent("el-image"), na = resolveComponent("el-tab-pane"), ra = resolveComponent("el-tabs"), aa = resolveDirective("loading");
      return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$f, [
        createElementVNode("div", _hoisted_2$7, [
          createVNode$1(Wn, { class: "classify-scroll" }, {
            default: withCtx(() => [
              createElementVNode("div", _hoisted_3$5, [
                (openBlock(!0), createElementBlock(Fragment, null, renderList(In.menuOptions, (ia) => (openBlock(), createElementBlock("div", {
                  key: ia.key,
                  class: normalizeClass(["classify-item", { active: In.selectPackage && In.selectPackage.key === ia.key }]),
                  onClick: (Aa) => Ln(ia)
                }, [
                  createElementVNode("div", _hoisted_5$1, [
                    createVNode$1(Yn, {
                      class: "icon",
                      "icon-class": ia.icon || "other"
                    }, null, 8, ["icon-class"]),
                    createElementVNode("div", _hoisted_6$1, toDisplayString(ia.name), 1)
                  ])
                ], 10, _hoisted_4$3))), 128))
              ])
            ]),
            _: 1
          })
        ]),
        createElementVNode("div", _hoisted_7, [
          createVNode$1(ra, {
            animated: "",
            modelValue: In.tabValue,
            "onUpdate:modelValue": Gn[1] || (Gn[1] = (ia) => In.tabValue = ia),
            type: "card",
            class: "sidebar-tabs",
            onTabChange: Hn
          }, {
            default: withCtx(() => [
              createVNode$1(na, {
                name: "components",
                "display-directive": "show",
                label: "组件"
              }, {
                label: withCtx(() => [
                  createElementVNode("span", _hoisted_8, [
                    createVNode$1(Yn, {
                      class: "label-icon",
                      "icon-class": "component"
                    }),
                    Gn[2] || (Gn[2] = createElementVNode("span", null, "组件", -1))
                  ])
                ]),
                default: withCtx(() => [
                  createElementVNode("div", _hoisted_9, [
                    createVNode$1(Wn, null, {
                      default: withCtx(() => [
                        createElementVNode("div", _hoisted_10, [
                          createVNode$1(ea, {
                            loading: !In.selectPackage,
                            animated: !0
                          }, {
                            template: withCtx(() => [
                              createElementVNode("div", _hoisted_11, [
                                createElementVNode("div", _hoisted_12, [
                                  createVNode$1(Xn, { variant: "p" })
                                ]),
                                createElementVNode("div", _hoisted_13, [
                                  createVNode$1(Xn, { variant: "p" })
                                ]),
                                createElementVNode("div", _hoisted_14, [
                                  createVNode$1(Xn, { variant: "p" })
                                ]),
                                createElementVNode("div", _hoisted_15, [
                                  createVNode$1(Xn, { variant: "p" })
                                ]),
                                createElementVNode("div", _hoisted_16, [
                                  createVNode$1(Xn, { variant: "p" })
                                ])
                              ])
                            ]),
                            default: withCtx(() => [
                              createElementVNode("div", _hoisted_17, [
                                createElementVNode("div", {
                                  class: normalizeClass(["category-item", { active: In.selectCateIndex === -1 }]),
                                  onClick: Gn[0] || (Gn[0] = (ia) => Pn(-1))
                                }, "全部", 2),
                                (openBlock(!0), createElementBlock(Fragment, null, renderList(In.selectPackage.childList, (ia, Aa) => (openBlock(), createElementBlock("div", {
                                  key: ia.id,
                                  class: normalizeClass(["category-item", { active: In.selectCateIndex === Aa }]),
                                  onClick: (sa) => Pn(Aa)
                                }, toDisplayString(ia.name), 11, _hoisted_18))), 128))
                              ])
                            ]),
                            _: 1
                          }, 8, ["loading"])
                        ])
                      ]),
                      _: 1
                    })
                  ]),
                  createElementVNode("div", _hoisted_19, [
                    createVNode$1(Wn, null, {
                      default: withCtx(() => [
                        createElementVNode("div", _hoisted_20, [
                          createElementVNode("div", _hoisted_21, [
                            (openBlock(!0), createElementBlock(Fragment, null, renderList(Dn.value, (ia, Aa) => (openBlock(), createElementBlock("div", {
                              class: "component-item",
                              key: Aa,
                              draggable: "",
                              onDragstart: (sa) => Nn(sa, ia),
                              onDragend: Rn,
                              onDblclick: (sa) => Fn(ia)
                            }, [
                              createElementVNode("div", _hoisted_23, toDisplayString(ia.title), 1),
                              ia.type === 2 ? (openBlock(), createBlock(ta, {
                                key: 0,
                                class: "component-img",
                                src: ia.path + "/" + ia.image
                              }, {
                                error: withCtx(() => Gn[3] || (Gn[3] = [
                                  createElementVNode("img", {
                                    src: "./static/images/widget/default.png",
                                    alt: ""
                                  }, null, -1)
                                ])),
                                _: 2
                              }, 1032, ["src"])) : (openBlock(), createBlock(ta, {
                                key: 1,
                                class: "component-img",
                                src: "./static/images/widget/" + ia.image
                              }, {
                                error: withCtx(() => Gn[4] || (Gn[4] = [
                                  createElementVNode("img", {
                                    src: "./static/images/widget/default.png",
                                    alt: "",
                                    srcset: ""
                                  }, null, -1)
                                ])),
                                _: 2
                              }, 1032, ["src"]))
                            ], 40, _hoisted_22))), 128))
                          ]),
                          Dn.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_24, Gn[5] || (Gn[5] = [
                            createElementVNode("div", { class: "empty-tips" }, [
                              createElementVNode("img", {
                                src: _imports_0,
                                alt: "",
                                srcset: ""
                              }),
                              createTextVNode(" 该模块组件正在开发中，"),
                              createElementVNode("br"),
                              createTextVNode("敬请期待 ")
                            ], -1)
                          ]))) : createCommentVNode("", !0)
                        ])
                      ]),
                      _: 1
                    })
                  ])
                ]),
                _: 1
              }),
              createVNode$1(na, {
                name: "layers",
                "display-directive": "show",
                label: "图层"
              }, {
                label: withCtx(() => [
                  createElementVNode("span", _hoisted_25, [
                    createVNode$1(Yn, {
                      class: "label-icon",
                      "icon-class": "layer"
                    }),
                    Gn[6] || (Gn[6] = createElementVNode("span", null, "图层", -1))
                  ])
                ]),
                default: withCtx(() => [
                  In.loadLayer ? (openBlock(), createBlock(unref(Bn), { key: 0 })) : createCommentVNode("", !0)
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["modelValue"])
        ])
      ])), [
        [aa, !In.loadedWeight]
      ]);
    };
  }
}), Sidebar_vue_vue_type_style_index_0_scoped_2140b918_lang = "", Sidebar = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-2140b918"]]), index_vue_vue_type_style_index_0_lang = "", PageListPanel_vue_vue_type_style_index_0_scoped_7250db83_lang = "";
/*!vue3-sketch-ruler v2.2.72025年2月Tue Feb 25 2025 20:18:12 GMT+0800 (中国标准时间)制作*/
const Ke$2 = (_n) => _n <= 0.25 ? 40 : _n <= 0.5 ? 20 : _n <= 1 ? 10 : _n <= 2 ? 5 : _n <= 4 ? 2 : 1;
function $e$1(_n, nr, Cn, Bn, In, Dn) {
  Dn ? In.moveTo(_n, 0) : In.moveTo(0, _n), In.save(), Dn ? In.translate(_n + 5, Bn * 0.2) : In.translate(Cn * 0.1, _n + 32), Dn || In.rotate(-Math.PI / 2), In.fillText(Math.round(nr).toString(), 4, 7), In.restore(), Dn ? In.lineTo(_n, Bn) : In.lineTo(Cn, _n), In.stroke(), In.closePath(), In.setTransform(1, 0, 0, 1, 0, 0);
}
function se$1(_n, nr, Cn, Bn, In, Dn) {
  Bn.fillStyle = In.fontShadowColor, Bn.strokeStyle = In.longfgColor, Bn.save(), Bn.translate(_n, nr), Dn || Bn.rotate(-Math.PI / 2), Bn.font = "bold 12px  Aria", Bn.fillText(String(Cn), 0, 0), Bn.restore();
}
const Qe$1 = (_n, nr, Cn, Bn, In, Dn) => {
  const { scale: Ln, width: $n, height: Nn, ratio: Rn, palette: Fn, gridRatio: Pn, showShadowText: Un } = In, { bgColor: Hn, fontColor: zn, shadowColor: Gn, longfgColor: Yn } = Fn, Wn = Dn ? In.canvasWidth : In.canvasHeight;
  _n.setTransform(1, 0, 0, 1, 0, 0), _n.scale(Rn, Rn), _n.clearRect(0, 0, $n, Nn), _n.fillStyle = Hn, _n.fillRect(0, 0, $n, Nn);
  const Xn = Ke$2(Ln) * Pn * 10, ea = Xn * Ln, ta = Math.floor(nr / Xn) * Xn, na = (ta - nr) / Xn * ea, ra = nr + Math.ceil((Dn ? $n : Nn) / Ln);
  if (Bn) {
    const aa = (Cn - nr) * Ln, ia = Bn * Ln;
    if (_n.fillStyle = Gn, Dn ? _n.fillRect(aa, 0, ia, Nn) : _n.fillRect(0, aa, $n, ia), Un)
      if (Dn) {
        se$1(aa, Nn * 0.4, Math.round(Cn), _n, Fn, Dn);
        const Aa = (Cn + Bn - nr) * Ln;
        se$1(
          Aa,
          Nn * 0.4,
          Math.round(Cn + Bn),
          _n,
          Fn,
          Dn
        );
      } else {
        se$1($n * 0.4, aa, Math.round(Cn), _n, Fn, Dn);
        const Aa = (Cn + Bn - nr) * Ln;
        se$1(
          $n * 0.4,
          Aa,
          Math.round(Cn + Bn),
          _n,
          Fn,
          Dn
        );
      }
  }
  _n.beginPath(), _n.fillStyle = zn, _n.strokeStyle = Yn;
  for (let aa = ta, ia = 0; aa < ra; aa += Xn, ia++) {
    const Aa = na + ia * ea + 0.5;
    if (aa - Xn < Wn && aa > Wn || aa == Wn) {
      const sa = na + ia * ea + 0.5 + (Wn - aa) * Ln;
      $e$1(sa, Wn, $n, Nn, _n, Dn);
      return;
    }
    aa >= 0 && aa <= Wn && (aa == 0 ? Dn ? (_n.moveTo(Aa, 0), _n.lineTo(Aa, Nn)) : (_n.moveTo(0, Aa), _n.lineTo($n, Aa)) : Dn ? (_n.moveTo(Aa, 20), _n.lineTo(Aa, Nn / 1.3)) : (_n.moveTo(20, Aa), _n.lineTo($n / 1.3, Aa)), _n.save(), aa == 0 ? Dn ? _n.translate(Aa - 15, Nn * 0.01) : _n.translate($n * 0.3, Aa - 5) : Dn ? _n.translate(Aa - 12, Nn * 0.05) : _n.translate($n * 0.05, Aa + 12), Dn || _n.rotate(-Math.PI / 2), Wn - aa > Xn / 2 && (!Un || Bn == 0 || Math.abs(aa - Cn) > Xn / 2 && Math.abs(aa - (Cn + Bn)) > Xn / 2) && _n.fillText(aa.toString(), 4, 9), _n.restore());
  }
  _n.stroke(), _n.closePath();
};
function Ce$2(_n, nr = 100) {
  let Cn = null;
  const Bn = function(...In) {
    Cn !== null && clearTimeout(Cn), Cn = setTimeout(() => {
      _n(...In);
    }, nr);
  };
  return Bn.cancel = function() {
    Cn !== null && (clearTimeout(Cn), Cn = null);
  }, Bn;
}
function Ne$2(_n, nr) {
  const Cn = ref(0), Bn = ref(0), In = ref(!1), Dn = computed(() => ({
    backgroundColor: _n.palette.hoverBg,
    color: _n.palette.hoverColor,
    [nr ? "top" : "left"]: "-8px",
    [nr ? "left" : "top"]: `${Cn.value + 10}px`
  })), Ln = ({ offsetX: Hn, offsetY: zn }) => {
    Cn.value = nr ? Hn : zn;
  }, $n = (Hn, zn) => new Promise((Gn) => {
    if (_n.lockLine)
      return;
    const Yn = nr ? Hn.clientY : Hn.clientX;
    Ln(Hn);
    const Wn = zn || Bn.value;
    let Xn = Wn;
    const ea = (na) => {
      let ra = ((nr ? na.clientY : na.clientX) - Yn) / _n.scale + Wn, aa = ra;
      const ia = (nr ? _n.snapsObj.h : _n.snapsObj.v).slice().sort((Aa, sa) => Math.abs(aa - Aa) - Math.abs(aa - sa));
      ia.length && Math.abs(ia[0] - ra) < _n.snapThreshold / _n.scale && (aa = ia[0], ra = aa), Xn = Math.round(ra), Bn.value = Xn;
    }, ta = () => {
      document.removeEventListener("mousemove", ea), Nn(Xn, _n.index), Gn();
    };
    document.addEventListener("mousemove", ea), document.addEventListener("mouseup", ta, { once: !0 });
  }), Nn = (Hn, zn) => {
    var Gn, Yn;
    const Wn = nr ? (Gn = _n.lines) == null ? void 0 : Gn.h : (Yn = _n.lines) == null ? void 0 : Yn.v, Xn = Rn(Hn);
    if (Wn)
      if (Xn)
        if (typeof zn == "number")
          Wn.splice(zn, 1);
        else
          return;
      else
        typeof zn != "number" ? Wn.push(Hn) : Wn[zn] = Hn;
  }, Rn = (Hn) => {
    const zn = nr ? _n.canvasHeight : _n.canvasWidth;
    return Hn < 0 || Hn > zn;
  }, Fn = computed(() => Rn(Bn.value) ? "放开删除" : `${nr ? "Y" : "X"}：${Bn.value * _n.rate}`), Pn = Ce$2(() => {
    In.value = !1;
  }, 200), Un = Ce$2(() => {
    In.value = !0;
  }, 200);
  return {
    showLabel: In,
    startValue: Bn,
    actionStyle: Dn,
    labelContent: Fn,
    handleMouseDown: $n,
    handleMouseenter: (Hn) => {
      _n.lockLine || (Ln(Hn), Un(), Pn.cancel());
    },
    handleMouseLeave: () => {
      Pn();
    }
  };
}
const Ge$1 = {
  key: 0,
  class: "value"
}, Fe$1 = /* @__PURE__ */ defineComponent({
  __name: "ruler-line",
  props: {
    scale: {},
    palette: {},
    index: {},
    start: {},
    vertical: { type: Boolean },
    value: {},
    canvasWidth: {},
    canvasHeight: {},
    lines: {},
    isShowReferLine: { type: Boolean },
    rate: {},
    snapThreshold: {},
    snapsObj: {},
    lockLine: { type: Boolean }
  },
  setup(_n) {
    const nr = _n, Cn = ref(!1), {
      actionStyle: Bn,
      handleMouseDown: In,
      labelContent: Dn,
      startValue: Ln,
      showLabel: $n,
      handleMouseenter: Nn,
      handleMouseLeave: Rn
    } = Ne$2(nr, nr.vertical), Fn = computed(() => Ln.value >= nr.start), Pn = computed(() => {
      const { lineType: Hn, lockLineColor: zn, lineColor: Gn } = nr.palette, Yn = nr.lockLine ? zn : Gn ?? "black", Wn = nr.lockLine || Cn.value ? "none" : "auto", Xn = nr.isShowReferLine && !nr.lockLine ? nr.vertical ? "ns-resize" : "ew-resize" : "default", ea = nr.vertical ? "borderTop" : "borderLeft", ta = (Ln.value - nr.start) * nr.scale;
      return {
        [ea]: `1px ${Hn} ${Yn}`,
        pointerEvents: Wn,
        cursor: Xn,
        [nr.vertical ? "top" : "left"]: `${ta}px`
      };
    });
    onMounted(() => {
      Ln.value = nr.value ?? 0;
    });
    const Un = Ce$2(() => {
      Cn.value = !1;
    }, 1e3);
    return watch([() => nr.scale], () => {
      Cn.value = !0, Un();
    }), (Hn, zn) => withDirectives((openBlock(), createElementBlock("div", {
      class: "line",
      style: normalizeStyle$1(Pn.value),
      onMouseenter: zn[0] || (zn[0] = withModifiers(
        //@ts-ignore
        (...Gn) => unref(Nn) && unref(Nn)(...Gn),
        ["stop"]
      )),
      onMouseleave: zn[1] || (zn[1] = withModifiers(
        //@ts-ignore
        (...Gn) => unref(Rn) && unref(Rn)(...Gn),
        ["stop"]
      )),
      onMousedown: zn[2] || (zn[2] = withModifiers(
        //@ts-ignore
        (...Gn) => unref(In) && unref(In)(...Gn),
        ["stop"]
      ))
    }, [
      createElementVNode("div", {
        class: "action",
        style: normalizeStyle$1(unref(Bn))
      }, [
        unref($n) ? (openBlock(), createElementBlock("span", Ge$1, toDisplayString(unref(Dn)), 1)) : createCommentVNode("", !0)
      ], 4)
    ], 36)), [
      [vShow, Fn.value]
    ]);
  }
}), qe$2 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    scale: {},
    palette: {},
    vertical: { type: Boolean },
    showShadowText: { type: Boolean },
    start: {},
    width: {},
    height: {},
    selectStart: {},
    selectLength: {},
    canvasWidth: {},
    canvasHeight: {},
    rate: {},
    gridRatio: {}
  },
  emits: ["handleDragStart"],
  setup(_n, { emit: nr }) {
    const Cn = _n, Bn = nr, In = reactive({
      isDragging: !1,
      canvasContext: null
    });
    let Dn = window.devicePixelRatio;
    const Ln = ref(null);
    onMounted(() => {
      window.addEventListener("resize", $n), Nn(), Fn(Dn), Pn(Dn);
    });
    const $n = () => {
      Dn = window.devicePixelRatio, Fn(Dn), Pn(Dn);
    }, Nn = () => {
      var Hn;
      In.canvasContext = ((Hn = Ln.value) == null ? void 0 : Hn.getContext("2d")) || null;
    }, Rn = computed(() => ({
      width: Cn.width + "px",
      height: Cn.height + "px",
      cursor: Cn.vertical ? "ew-resize" : "ns-resize",
      [Cn.vertical ? "borderRight" : "borderBottom"]: `1px solid ${Cn.palette.borderColor || "#eeeeef"} `
    }));
    onUnmounted(() => {
      window.removeEventListener("resize", $n);
    });
    const Fn = (Hn) => {
      if (Ln.value) {
        Ln.value.width = Math.round(Cn.width * Hn), Ln.value.height = Math.round(Cn.height * Hn);
        const zn = In.canvasContext;
        zn && (zn.font = `11px -apple-system,
                "Helvetica Neue", ".SFNSText-Regular",
                "SF UI Text", Arial, "PingFang SC", "Hiragino Sans GB",
                "Microsoft YaHei", "WenQuanYi Zen Hei", sans-serif`, zn.lineWidth = 1, zn.textBaseline = "middle");
      }
    }, Pn = (Hn) => {
      const zn = {
        scale: Cn.scale,
        width: Cn.width,
        height: Cn.height,
        palette: Cn.palette,
        canvasWidth: Cn.canvasWidth,
        canvasHeight: Cn.canvasHeight,
        ratio: Hn,
        rate: Cn.rate,
        gridRatio: Cn.gridRatio,
        showShadowText: Cn.showShadowText
      };
      zn.scale = Cn.scale / Cn.rate, zn.canvasWidth = Cn.canvasWidth * Cn.rate, zn.canvasHeight = Cn.canvasHeight * Cn.rate, In.canvasContext && Qe$1(
        In.canvasContext,
        Cn.start * Cn.rate,
        Cn.selectStart,
        Cn.selectLength,
        zn,
        !Cn.vertical
      );
    };
    watch(
      [
        () => Cn.width,
        () => Cn.height,
        () => Cn.start,
        () => Cn.palette,
        () => Cn.selectStart,
        () => Cn.selectLength
      ],
      () => {
        Pn(Dn);
      }
    ), watch([() => Cn.width, () => Cn.height], () => {
      Fn(Dn);
    });
    const Un = (Hn) => {
      Bn("handleDragStart", Hn);
    };
    return (Hn, zn) => (openBlock(), createElementBlock("canvas", {
      ref_key: "canvas",
      ref: Ln,
      class: "ruler",
      style: normalizeStyle$1(Rn.value),
      onMousedown: withModifiers(Un, ["stop"])
    }, null, 36));
  }
}), Ze$1 = { class: "lines" }, je$1 = {
  key: 0,
  class: "value"
}, Re$1 = /* @__PURE__ */ defineComponent({
  __name: "ruler-wrapper",
  props: {
    scale: {},
    thick: {},
    canvasWidth: {},
    canvasHeight: {},
    palette: {},
    vertical: { type: Boolean },
    width: {},
    height: {},
    start: {},
    startOther: {},
    lines: {},
    selectStart: {},
    selectLength: {},
    isShowReferLine: { type: Boolean },
    rate: {},
    snapThreshold: {},
    snapsObj: {},
    gridRatio: {},
    lockLine: { type: Boolean },
    showShadowText: { type: Boolean }
  },
  emits: ["changeLineState"],
  setup(_n, { emit: nr }) {
    const Cn = _n, {
      showLabel: Bn,
      actionStyle: In,
      handleMouseenter: Dn,
      handleMouseLeave: Ln,
      handleMouseDown: $n,
      labelContent: Nn,
      startValue: Rn
    } = Ne$2(Cn, !Cn.vertical), Fn = ref(!1), Pn = ref(!1), Un = computed(() => Cn.vertical ? "v-container" : "h-container"), Hn = nr, zn = computed(() => {
      var Wn, Xn;
      return Cn.vertical ? (Wn = Cn.lines) == null ? void 0 : Wn.h : (Xn = Cn.lines) == null ? void 0 : Xn.v;
    }), Gn = computed(() => {
      const Wn = Cn.palette.lineType;
      let Xn = Cn.vertical ? "left" : "top", ea = Cn.vertical ? "top" : "left", ta = Cn.vertical ? "borderLeft" : "borderBottom";
      const na = (Rn.value - Cn.startOther) * Cn.scale + Cn.thick;
      return {
        [Xn]: na + "px",
        [ea]: -Cn.thick + "px",
        cursor: Cn.vertical ? "ew-resize" : "ns-resize",
        [ta]: `1px ${Wn} ${Cn.palette.lineColor}`
      };
    }), Yn = async (Wn) => {
      const { offsetX: Xn, offsetY: ea } = Wn, { scale: ta, vertical: na, thick: ra, startOther: aa } = Cn;
      Pn.value = !0, Fn.value = !1, Hn("changeLineState", !1);
      let ia = Math.round(
        aa - ra / ta + (na ? Xn : ea) / ta
      );
      Rn.value = ia, await $n(Wn, ia), Pn.value = !1;
    };
    return watch([() => Cn.lockLine], () => {
      Fn.value = Cn.lockLine;
    }), (Wn, Xn) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(Un.value)
    }, [
      createVNode$1(qe$2, mergeProps(Wn.$props, { onHandleDragStart: Yn }), null, 16),
      withDirectives(createElementVNode("div", Ze$1, [
        (openBlock(!0), createElementBlock(Fragment, null, renderList(zn.value, (ea, ta) => (openBlock(), createBlock(Fe$1, mergeProps({
          key: ea + ta,
          index: ta,
          value: ea >> 0,
          ref_for: !0
        }, Wn.$props), null, 16, ["index", "value"]))), 128))
      ], 512), [
        [vShow, Wn.isShowReferLine]
      ]),
      Wn.isShowReferLine ? withDirectives((openBlock(), createElementBlock("div", {
        key: 0,
        class: "indicator",
        style: normalizeStyle$1(Gn.value),
        onMouseenter: Xn[0] || (Xn[0] = //@ts-ignore
        (...ea) => unref(Dn) && unref(Dn)(...ea)),
        onMouseleave: Xn[1] || (Xn[1] = //@ts-ignore
        (...ea) => unref(Ln) && unref(Ln)(...ea))
      }, [
        createElementVNode("div", {
          class: "action",
          style: normalizeStyle$1(unref(In))
        }, [
          unref(Bn) ? (openBlock(), createElementBlock("span", je$1, toDisplayString(unref(Nn)), 1)) : createCommentVNode("", !0)
        ], 4)
      ], 36)), [
        [vShow, Pn.value]
      ]) : createCommentVNode("", !0)
    ], 2));
  }
}), Je$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAAAXNSR0IArs4c6QAAAopJREFUOE/FlE9IVEEcx7+/N9ouds1Mu0QUSFZYdIgoUqQoKPBQHsKozpXE7jbTO/U8xLJvn6usBHWQ6hBFXupSkQeVbh0KJEPp0sH+eLGTsKs77xcj78m0ax0E8cHjzZv5zef3/c33xxA24KENYGJzoEEQbNNaN4Zh2OQ4znwYhr9c1/39vwrXVDo0NNS0tLR0GYB5D64BmAMwzMyvlFKz1es10Hw+f4mZ7wHYBeA9gNdENFepVOaEEM3M3OI4Thczn41gt6WUgQ3+C+r7/h0AWQD3mXnYqPA8L9nQ0HCemduIaFpKOWoAhUJhT6VSuQXgOjP3K6W8GLwKzeVyp4jonR0QBEErM48w8zFLyayUsjX+z+VyHhHdZebTSqkxM78CHRgYOKS1/ghgVErZY214RkQ7ADyRUj72ff8qgCtmXUrZGcf5vv8CwEUhxOF0Ov1pBRpla5dSdseBhUJhpznH6tIsZb1KqacW+BGArUaUXX63UuplHJTNZjuEEONSyhozfd/n6mQ1RkXZL2itz7mu+80EDA4ONi8vL/8AcM2UbikyR2BU9cSmmTU70YqKIAj2hWFo2uenlHK/BRg3Y2aeNO5GyU8S0ZbFxcUuz/NKEXAGQKPjOCcymcyX1dIi8DSAiWQyeaavr68cbSgCuBknYubnQoj+TCYzUywWE6VS6S2ADsdx2gxw1X3L7SNENMbMnwE8qK+vf5NKpRaMaeVyeW8ikfiaSqW+R7BuZr5BRMe11p2u607U9Gk8kc/ntzPzQwCmExYATDLzVBiGE0KIowAOADDf3QA+aK2VDaxRajto3K+rq+tl5nYAzQBamHmeiOYBTGmtR6ph/1Rqg9c73pz7dD1qN0TpHyNQRCUDJXrAAAAAAElFTkSuQmCC", _e$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAAAXNSR0IArs4c6QAAAjtJREFUOE/NlD9oFEEUxn9v9ghC0hpRUogIAUmniGAT/5Q2FrETPSNRJILg7RwimI0ox85eQFCEBGIUO1PYpFM0jSConQoBEZGgGPsgl+w+2eM2bC57SopAFqYZ3v7m+977ZoQt+GQLmGxPaBiGgYiMWWvXBHZUGoZhH3BERPYC+4F+4Keq/urt7b1RLpf/ZEBVHa9Wq0HWyg3QKIoGVPU8cA7wgK/pUtXPQJ8xZk+pVBpuNBqXUoUiEvi+P56fzTpo6+SbwHNg1lo7WzTITGEKXFlZeeB53tVCpa3CK8AFa+1cBgvD8LKIXAQOJkkyICJDeYVBEJS6u7s/qeoLa+1o+l9TqXNuBLhmjDlbqVQ+5ICjInIfOBPH8W9jzGCR5YmJiRNxHM+papgqzqDvgSlr7VTernPuO3An3c9bBt74vv+yrdaKyLDv+/1Sq9UGPc97nY9EVuycU2AQOA7cAm4Dr4D5TvVxHB9rKo2iaEFVp621Ln96FEUngaOqGmSxabVqsh3a2h+x1h5qQjNrae/yE4+iaCwDJkky73neTuBZe129Xk+H+BS4l7ZqLVIZ2BhzuFKpvMsDVXXWGPMxFdAedOfcKeCRqj7MYrUhpz09PfXl5eXrectFWXXODQHpOq2qd/95o/JXr6ura3J1dXU6SZIfwKKIHAD2tVYMPBGRx77vN10UXtO85fTkmZmZHUtLSzUR2QXsBhaAL6r6DXhbrVYXi1yss59GqOgub/bN3Z7v6X/tb9Zmp/q/kN8s+lJb8oEAAAAASUVORK5CYII=";
/*!simple-panzoom v1.0.72024年8月Sat Aug 10 2024 16:04:04 GMT+0800 (中国标准时间)制作*/
typeof window < "u" && (window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = Array.prototype.forEach), typeof window.CustomEvent != "function" && (window.CustomEvent = function(_n, nr) {
  nr = nr || { bubbles: !1, cancelable: !1, detail: null };
  var Cn = document.createEvent("CustomEvent");
  return Cn.initCustomEvent(_n, nr.bubbles, nr.cancelable, nr.detail), Cn;
}));
function ze$1(_n, nr) {
  let Cn = _n.length;
  for (; Cn--; )
    if (_n[Cn].pointerId === nr.pointerId)
      return Cn;
  return -1;
}
function Me$2(_n, nr) {
  let Cn;
  if (nr.touches) {
    Cn = 0;
    for (const Bn of nr.touches)
      Bn.pointerId = Cn++, Me$2(_n, Bn);
    return;
  }
  Cn = ze$1(_n, nr), Cn > -1 && _n.splice(Cn, 1), _n.push(nr);
}
function et$1(_n, nr) {
  if (nr.touches) {
    for (; _n.length; )
      _n.pop();
    return;
  }
  const Cn = ze$1(_n, nr);
  Cn > -1 && _n.splice(Cn, 1);
}
function Be$1(_n) {
  _n = _n.slice(0);
  let nr = _n.pop(), Cn;
  for (; Cn = _n.pop(); )
    nr = {
      clientX: (Cn.clientX - nr.clientX) / 2 + nr.clientX,
      clientY: (Cn.clientY - nr.clientY) / 2 + nr.clientY
    };
  return nr;
}
function ge$1(_n) {
  if (_n.length < 2)
    return 0;
  const nr = _n[0], Cn = _n[1];
  return Math.sqrt(
    Math.pow(Math.abs(Cn.clientX - nr.clientX), 2) + Math.pow(Math.abs(Cn.clientY - nr.clientY), 2)
  );
}
let re$2 = {
  down: "mousedown",
  move: "mousemove",
  up: "mouseup mouseleave"
};
typeof window < "u" && (typeof window.PointerEvent == "function" ? re$2 = {
  down: "pointerdown",
  move: "pointermove",
  up: "pointerup pointerleave pointercancel"
} : typeof window.TouchEvent == "function" && (re$2 = {
  down: "touchstart",
  move: "touchmove",
  up: "touchend touchcancel"
}));
function we$1(_n, nr, Cn, Bn) {
  re$2[_n].split(" ").forEach((In) => {
    nr.addEventListener(
      In,
      Cn,
      Bn
    );
  });
}
function ye$2(_n, nr, Cn) {
  re$2[_n].split(" ").forEach((Bn) => {
    nr.removeEventListener(Bn, Cn);
  });
}
const tt$1 = typeof document < "u" && !!document.documentMode;
let Oe$1;
function nt$1() {
  return Oe$1 || (Oe$1 = document.createElement("div").style);
}
const Pe$2 = ["webkit", "moz", "ms"], le$1 = {};
function Ee$1(_n) {
  if (le$1[_n])
    return le$1[_n];
  const nr = nt$1();
  if (_n in nr)
    return le$1[_n] = _n;
  const Cn = _n[0].toUpperCase() + _n.slice(1);
  let Bn = Pe$2.length;
  for (; Bn--; ) {
    const In = `${Pe$2[Bn]}${Cn}`;
    if (In in nr)
      return le$1[_n] = In;
  }
}
function ie$2(_n, nr) {
  return parseFloat(nr[Ee$1(_n)]) || 0;
}
function ce$1(_n, nr, Cn = window.getComputedStyle(_n)) {
  const Bn = nr === "border" ? "Width" : "";
  return {
    left: ie$2(`${nr}Left${Bn}`, Cn),
    right: ie$2(`${nr}Right${Bn}`, Cn),
    top: ie$2(`${nr}Top${Bn}`, Cn),
    bottom: ie$2(`${nr}Bottom${Bn}`, Cn)
  };
}
function J$2(_n, nr, Cn) {
  _n.style[Ee$1(nr)] = Cn;
}
function ot$1(_n, nr) {
  const Cn = Ee$1("transform");
  J$2(_n, "transition", `${Cn} ${nr.duration}ms ${nr.easing}`);
}
function at$1(_n, { x: nr, y: Cn, scale: Bn, isSVG: In }, Dn) {
  if (J$2(_n, "transform", `scale(${Bn}) translate(${nr}px, ${Cn}px)`), In && tt$1) {
    const Ln = window.getComputedStyle(_n).getPropertyValue("transform");
    _n.setAttribute("transform", Ln);
  }
}
function ue$2(_n) {
  const nr = _n.parentNode, Cn = window.getComputedStyle(_n), Bn = window.getComputedStyle(nr), In = _n.getBoundingClientRect(), Dn = nr.getBoundingClientRect();
  return {
    elem: {
      style: Cn,
      width: In.width,
      height: In.height,
      top: In.top,
      bottom: In.bottom,
      left: In.left,
      right: In.right,
      margin: ce$1(_n, "margin", Cn),
      border: ce$1(_n, "border", Cn)
    },
    parent: {
      style: Bn,
      width: Dn.width,
      height: Dn.height,
      top: Dn.top,
      bottom: Dn.bottom,
      left: Dn.left,
      right: Dn.right,
      padding: ce$1(nr, "padding", Bn),
      border: ce$1(nr, "border", Bn)
    }
  };
}
function rt$1(_n) {
  let nr = _n;
  for (; nr && nr.parentNode; ) {
    if (nr.parentNode === document)
      return !0;
    nr = nr.parentNode instanceof ShadowRoot ? nr.parentNode.host : nr.parentNode;
  }
  return !1;
}
function st$2(_n) {
  return (_n.getAttribute("class") || "").trim();
}
function lt$2(_n, nr) {
  return _n.nodeType === 1 && ` ${st$2(_n)} `.indexOf(` ${nr} `) > -1;
}
function it$2(_n, nr) {
  for (let Cn = _n; Cn != null; Cn = Cn.parentNode)
    if (lt$2(Cn, nr.excludeClass) || nr.exclude.indexOf(Cn) > -1)
      return !0;
  return !1;
}
const ct$2 = /^http:[\w\.\/]+svg$/;
function ut$2(_n) {
  return ct$2.test(_n.namespaceURI) && _n.nodeName.toLowerCase() !== "svg";
}
function dt$2(_n) {
  const nr = {};
  for (const Cn in _n)
    _n.hasOwnProperty(Cn) && (nr[Cn] = _n[Cn]);
  return nr;
}
const Ue$1 = {
  animate: !1,
  canvas: !1,
  cursor: "move",
  disablePan: !1,
  disableZoom: !1,
  disableXAxis: !1,
  disableYAxis: !1,
  duration: 200,
  easing: "ease-in-out",
  exclude: [],
  excludeClass: "panzoom-exclude",
  handleStartEvent: (_n) => {
    _n.preventDefault(), _n.stopPropagation();
  },
  maxScale: 4,
  minScale: 0.125,
  overflow: "hidden",
  panOnlyWhenZoomed: !1,
  pinchAndPan: !1,
  relative: !1,
  setTransform: at$1,
  startX: 0,
  startY: 0,
  startScale: 1,
  step: 0.3,
  touchAction: "none"
};
function Ye$2(_n, nr) {
  if (!_n)
    throw new Error("Panzoom requires an element as an argument");
  if (_n.nodeType !== 1)
    throw new Error("Panzoom requires an element with a nodeType of 1");
  if (!rt$1(_n))
    throw new Error(
      "Panzoom should be called on elements that have been attached to the DOM"
    );
  nr = {
    ...Ue$1,
    ...nr
  };
  const Cn = ut$2(_n), Bn = _n.parentNode;
  Bn.style.overflow = nr.overflow, Bn.style.userSelect = "none", Bn.style.touchAction = nr.touchAction, (nr.canvas ? Bn : _n).style.cursor = nr.cursor, _n.style.userSelect = "none", _n.style.touchAction = nr.touchAction, J$2(
    _n,
    "transformOrigin",
    typeof nr.origin == "string" ? nr.origin : Cn ? "0 0" : "50% 50%"
  );
  function In() {
    Bn.style.overflow = "", Bn.style.userSelect = "", Bn.style.touchAction = "", Bn.style.cursor = "", _n.style.cursor = "", _n.style.userSelect = "", _n.style.touchAction = "", J$2(_n, "transformOrigin", "");
  }
  function Dn(da = {}) {
    for (const Ca in da)
      da.hasOwnProperty(Ca) && (nr[Ca] = da[Ca]);
    (da.hasOwnProperty("cursor") || da.hasOwnProperty("canvas")) && (Bn.style.cursor = _n.style.cursor = "", (nr.canvas ? Bn : _n).style.cursor = nr.cursor), da.hasOwnProperty("overflow") && (Bn.style.overflow = da.overflow), da.hasOwnProperty("touchAction") && (Bn.style.touchAction = da.touchAction, _n.style.touchAction = da.touchAction);
  }
  let Ln = 0, $n = 0, Nn = 1, Rn = !1;
  Gn(nr.startScale, { animate: !1, force: !0 }), setTimeout(() => {
    zn(nr.startX, nr.startY, { animate: !1, force: !0 });
  });
  function Fn(da, Ca, ma) {
    if (ma.silent)
      return;
    const va = new CustomEvent(da, { detail: Ca });
    _n.dispatchEvent(va);
  }
  function Pn(da, Ca, ma) {
    const va = { x: Ln, y: $n, scale: Nn, isSVG: Cn, originalEvent: ma, dimsOut: {} };
    typeof Ca.animate == "boolean" && (Ca.animate ? ot$1(_n, Ca) : J$2(_n, "transition", "none")), Ca.setTransform(_n, va, Ca);
    function ga() {
      const xa = ue$2(_n);
      va.dimsOut = xa, Fn(da, va, Ca), Fn("panzoomchange", va, Ca);
    }
    return Ca.animate ? setTimeout(() => {
      ga();
    }, Ca.duration + 50) : requestAnimationFrame(() => {
      ga();
    }), va;
  }
  function Un(da, Ca, ma, va) {
    const ga = { ...nr, ...va }, xa = { x: Ln, y: $n, opts: ga };
    if (!ga.force && (ga.disablePan || ga.panOnlyWhenZoomed && Nn === ga.startScale))
      return xa;
    if (da = parseFloat(da), Ca = parseFloat(Ca), ga.disableXAxis || (xa.x = (ga.relative ? Ln : 0) + da), ga.disableYAxis || (xa.y = (ga.relative ? $n : 0) + Ca), ga.contain) {
      const wa = ue$2(_n), ba = wa.elem.width / Nn, Ta = wa.elem.height / Nn, Sa = ba * ma, Ea = Ta * ma, Ia = (Sa - ba) / 2, Ba = (Ea - Ta) / 2;
      if (ga.contain === "inside") {
        const Ma = (-wa.elem.margin.left - wa.parent.padding.left + Ia) / ma, La = (wa.parent.width - Sa - wa.parent.padding.left - wa.elem.margin.left - wa.parent.border.left - wa.parent.border.right + Ia) / ma;
        xa.x = Math.max(Math.min(xa.x, La), Ma);
        const Da = (-wa.elem.margin.top - wa.parent.padding.top + Ba) / ma, Na = (wa.parent.height - Ea - wa.parent.padding.top - wa.elem.margin.top - wa.parent.border.top - wa.parent.border.bottom + Ba) / ma;
        xa.y = Math.max(Math.min(xa.y, Na), Da);
      } else if (ga.contain === "outside") {
        const Ma = (-(Sa - wa.parent.width) - wa.parent.padding.left - wa.parent.border.left - wa.parent.border.right + Ia) / ma, La = (Ia - wa.parent.padding.left) / ma;
        xa.x = Math.max(Math.min(xa.x, La), Ma);
        const Da = (-(Ea - wa.parent.height) - wa.parent.padding.top - wa.parent.border.top - wa.parent.border.bottom + Ba) / ma, Na = (Ba - wa.parent.padding.top) / ma;
        xa.y = Math.max(Math.min(xa.y, Na), Da);
      }
    }
    return ga.roundPixels && (xa.x = Math.round(xa.x), xa.y = Math.round(xa.y)), xa;
  }
  function Hn(da, Ca) {
    const ma = { ...nr, ...Ca }, va = { scale: Nn, opts: ma };
    if (!ma.force && ma.disableZoom)
      return va;
    let ga = nr.minScale, xa = nr.maxScale;
    if (ma.contain) {
      const wa = ue$2(_n), ba = wa.elem.width / Nn, Ta = wa.elem.height / Nn;
      if (ba > 1 && Ta > 1) {
        const Sa = wa.parent.width - wa.parent.border.left - wa.parent.border.right, Ea = wa.parent.height - wa.parent.border.top - wa.parent.border.bottom, Ia = Sa / ba, Ba = Ea / Ta;
        nr.contain === "inside" ? xa = Math.min(xa, Ia, Ba) : nr.contain === "outside" && (ga = Math.max(ga, Ia, Ba));
      }
    }
    return va.scale = Math.min(Math.max(da, ga), xa), va;
  }
  function zn(da, Ca, ma, va) {
    const ga = Un(da, Ca, Nn, ma);
    return Ln !== ga.x || $n !== ga.y ? (Ln = ga.x, $n = ga.y, Pn("panzoompan", ga.opts, va)) : { x: Ln, y: $n, scale: Nn, isSVG: Cn, originalEvent: va };
  }
  function Gn(da, Ca, ma) {
    const va = Hn(da, Ca), ga = va.opts;
    if (!ga.force && ga.disableZoom)
      return;
    da = va.scale;
    let xa = Ln, wa = $n;
    if (ga.focal) {
      const Ta = ga.focal;
      xa = (Ta.x / da - Ta.x / Nn + Ln * da) / da, wa = (Ta.y / da - Ta.y / Nn + $n * da) / da;
    }
    const ba = Un(xa, wa, da, {
      relative: !1,
      force: !0
    });
    return Ln = ba.x, $n = ba.y, Nn = da, Pn("panzoomzoom", ga, ma);
  }
  function Yn(da, Ca) {
    const ma = { ...nr, animate: !0, ...Ca };
    return Gn(Nn * Math.exp((da ? 1 : -1) * ma.step), ma);
  }
  function Wn(da) {
    return Yn(!0, da);
  }
  function Xn(da) {
    return Yn(!1, da);
  }
  function ea(da, Ca, ma, va) {
    const ga = ue$2(_n), xa = {
      width: ga.parent.width - ga.parent.padding.left - ga.parent.padding.right - ga.parent.border.left - ga.parent.border.right,
      height: ga.parent.height - ga.parent.padding.top - ga.parent.padding.bottom - ga.parent.border.top - ga.parent.border.bottom
    };
    let wa = Ca.clientX - ga.parent.left - ga.parent.padding.left - ga.parent.border.left - ga.elem.margin.left, ba = Ca.clientY - ga.parent.top - ga.parent.padding.top - ga.parent.border.top - ga.elem.margin.top;
    Cn || (wa -= ga.elem.width / Nn / 2, ba -= ga.elem.height / Nn / 2);
    const Ta = {
      x: wa / xa.width * (xa.width * da),
      y: ba / xa.height * (xa.height * da)
    };
    return Gn(
      da,
      { ...ma, animate: !1, focal: Ta },
      va
    );
  }
  function ta(da, Ca) {
    da.preventDefault();
    const ma = { ...nr, ...Ca, animate: !1 }, va = (da.deltaY === 0 && da.deltaX ? da.deltaX : da.deltaY) < 0 ? 1 : -1, ga = Hn(
      Nn * Math.exp(va * ma.step / 3),
      ma
    ).scale;
    return ea(ga, da, ma, da);
  }
  function na(da) {
    const Ca = { ...nr, animate: !0, force: !0, ...da };
    Nn = Hn(Ca.startScale, Ca).scale;
    const ma = Un(Ca.startX, Ca.startY, Nn, Ca);
    return Ln = ma.x, $n = ma.y, Pn("panzoomreset", Ca);
  }
  let ra, aa, ia, Aa, sa, oa;
  const la = [];
  function ua(da) {
    if (it$2(da.target, nr))
      return;
    Me$2(la, da), Rn = !0, nr.handleStartEvent(da), ra = Ln, aa = $n, Fn(
      "panzoomstart",
      { x: Ln, y: $n, scale: Nn, isSVG: Cn, originalEvent: da },
      nr
    );
    const Ca = Be$1(la);
    ia = Ca.clientX, Aa = Ca.clientY, sa = Nn, oa = ge$1(la);
  }
  function ca(da) {
    if (!Rn || ra === void 0 || aa === void 0 || ia === void 0 || Aa === void 0)
      return;
    Me$2(la, da);
    const Ca = Be$1(la), ma = la.length > 1;
    let va = Nn;
    if (ma) {
      oa === 0 && (oa = ge$1(la));
      const ga = ge$1(la) - oa;
      va = Hn(ga * nr.step / 80 + sa).scale, ea(va, Ca, { animate: !1 }, da);
    }
    (!ma || nr.pinchAndPan) && zn(
      ra + (Ca.clientX - ia) / va,
      aa + (Ca.clientY - Aa) / va,
      {
        animate: !1
      },
      da
    );
  }
  function fa(da) {
    la.length === 1 && Fn(
      "panzoomend",
      { x: Ln, y: $n, scale: Nn, isSVG: Cn, originalEvent: da },
      nr
    ), et$1(la, da), Rn && (Rn = !1, ra = aa = ia = Aa = void 0);
  }
  let ha = !1;
  function pa() {
    ha || (ha = !0, we$1("down", nr.canvas ? Bn : _n, ua), we$1("move", document, ca, { passive: !0 }), we$1("up", document, fa, { passive: !0 }));
  }
  function ya() {
    ha = !1, ye$2("down", nr.canvas ? Bn : _n, ua), ye$2("move", document, ca), ye$2("up", document, fa);
  }
  return nr.noBind || pa(), {
    bind: pa,
    destroy: ya,
    eventNames: re$2,
    getPan: () => ({ x: Ln, y: $n }),
    getScale: () => Nn,
    getOptions: () => dt$2(nr),
    handleDown: ua,
    handleMove: ca,
    handleUp: fa,
    pan: zn,
    reset: na,
    resetStyle: In,
    setOptions: Dn,
    setStyle: (da, Ca) => J$2(_n, da, Ca),
    zoom: Gn,
    zoomIn: Wn,
    zoomOut: Xn,
    zoomToPoint: ea,
    zoomWithWheel: ta
  };
}
Ye$2.defaultOptions = Ue$1;
const ht$2 = { class: "sketch-ruler" }, pt$2 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    showRuler: { type: Boolean, default: !0 },
    eyeIcon: {},
    closeEyeIcon: {},
    scale: { default: 1 },
    rate: { default: 1 },
    thick: { default: 16 },
    palette: {},
    width: { default: 1400 },
    height: { default: 800 },
    paddingRatio: { default: 0.2 },
    autoCenter: { type: Boolean, default: !0 },
    shadow: { default: () => ({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }) },
    lines: { default: () => ({
      h: [],
      v: []
    }) },
    isShowReferLine: { type: Boolean, default: !0 },
    canvasWidth: { default: 700 },
    canvasHeight: { default: 700 },
    snapsObj: { default: () => ({
      h: [],
      v: []
    }) },
    snapThreshold: { default: 5 },
    gridRatio: { default: 1 },
    lockLine: { type: Boolean, default: !1 },
    selfHandle: { type: Boolean, default: !1 },
    showShadowText: { type: Boolean, default: !0 },
    panzoomOption: {}
  },
  emits: ["onCornerClick", "update:scale", "zoomchange", "update:lockLine"],
  setup(_n, { expose: nr, emit: Cn }) {
    useCssVars((pa) => ({
      "218edfd4": ha.value
    }));
    const Bn = _n, In = Cn, Dn = ref(null), Ln = ref(0), $n = ref(0);
    let Nn = 0, Rn = 0;
    const Fn = ref(1), Pn = ref(Bn.isShowReferLine), Un = ref(null), Hn = ref("defaultCursor"), zn = computed(() => ({
      bgColor: "#f6f7f9",
      // ruler bg color
      longfgColor: "#BABBBC",
      // ruler longer mark color
      fontColor: "#7D8694",
      // ruler font color
      fontShadowColor: "#106ebe",
      shadowColor: "#e9f7fe",
      // ruler shadow color
      lineColor: "#51d6a9",
      lineType: "solid",
      lockLineColor: "#d4d7dc",
      hoverBg: "#000",
      hoverColor: "#fff",
      borderColor: "#eeeeef",
      ...Bn.palette
    })), Gn = computed(() => ({
      backgroundImage: Pn.value ? `url(${Bn.eyeIcon ?? Je$1})` : `url(${Bn.closeEyeIcon ?? _e$2})`,
      width: Bn.thick + "px",
      height: Bn.thick + "px",
      borderRight: `1px solid ${zn.value.borderColor}`,
      borderBottom: `1px solid ${zn.value.borderColor}`
    })), Yn = computed(() => ({
      background: zn.value.bgColor,
      width: Wn.value + "px",
      height: Xn.value + "px"
    })), Wn = computed(() => Bn.width - Bn.thick), Xn = computed(() => Bn.height - Bn.thick), ea = (pa) => {
      var ya;
      (pa.ctrlKey || pa.metaKey) && ((ya = Un.value) == null || ya.zoomWithWheel(pa));
    }, ta = (pa) => {
      var ya;
      const da = document.activeElement;
      da != null && da.closest(".monaco-editor") || (da == null ? void 0 : da.tagName) === "INPUT" || (da == null ? void 0 : da.tagName) === "TEXTAREA" || (da == null ? void 0 : da.getAttribute("contenteditable")) === "true" || pa.key === " " && (Hn.value = "grabCursor", (ya = Un.value) == null || ya.bind(), pa.preventDefault());
    }, na = (pa) => {
      var ya;
      const da = document.activeElement;
      da != null && da.closest(".monaco-editor") || (da == null ? void 0 : da.tagName) === "INPUT" || (da == null ? void 0 : da.tagName) === "TEXTAREA" || (da == null ? void 0 : da.getAttribute("contenteditable")) === "true" || pa.key === " " && ((ya = Un.value) == null || ya.destroy(), Hn.value = "defaultCursor");
    };
    onMounted(() => {
      if (ia(), !Bn.selfHandle && Dn.value) {
        const pa = Dn.value.parentElement;
        if (!pa)
          return;
        pa.addEventListener("wheel", ea), document.addEventListener("keydown", ta), document.addEventListener("keyup", na);
      }
    });
    const ra = (pa) => ({
      noBind: !0,
      startScale: pa,
      // cursor: 'default',
      startX: Nn,
      startY: Rn,
      smoothScroll: !0,
      canvas: !0,
      ...Bn.panzoomOption
    }), aa = (pa) => {
      const { scale: ya, dimsOut: da } = pa.detail;
      if (da) {
        In("update:scale", ya), Fn.value = ya;
        const Ca = (da.parent.left - da.elem.left) / ya, ma = (da.parent.top - da.elem.top) / ya;
        Ln.value = Ca, In("zoomchange", pa.detail), $n.value = ma;
      }
    }, ia = () => {
      if (Dn.value = document.querySelector(".canvasedit"), Dn.value) {
        let pa = Bn.scale;
        Bn.autoCenter && (pa = Aa()), Un.value = Ye$2(Dn.value, ra(pa)), Dn.value && Dn.value.addEventListener("panzoomchange", aa);
      }
    }, Aa = () => {
      const pa = Wn.value * (1 - Bn.paddingRatio) / Bn.canvasWidth, ya = Xn.value * (1 - Bn.paddingRatio) / Bn.canvasHeight, da = Math.min(pa, ya);
      return Nn = Wn.value / 2 - Bn.canvasWidth / 2, da < 1 ? Rn = (Bn.canvasHeight * da / 2 - Bn.canvasHeight / 2) / da - (Bn.canvasHeight * da - Xn.value) / da / 2 : da > 1 ? Rn = (Bn.canvasHeight * da - Bn.canvasHeight) / 2 / da + (Xn.value - Bn.canvasHeight * da) / da / 2 : Rn = 0, da;
    }, sa = () => {
      var pa;
      return (pa = Un.value) == null ? void 0 : pa.reset();
    }, oa = () => {
      var pa;
      return (pa = Un.value) == null ? void 0 : pa.zoomIn();
    }, la = () => {
      var pa;
      return (pa = Un.value) == null ? void 0 : pa.zoomOut();
    }, ua = () => {
      var pa;
      (pa = Un.value) == null || pa.setOptions(ra(Bn.scale));
    }, ca = () => {
      Pn.value = !Pn.value, In("onCornerClick", Pn.value);
    }, fa = (pa) => {
      In("update:lockLine", pa);
    }, ha = computed(() => Bn.thick + "px");
    return watch([() => Bn.isShowReferLine], () => {
      Pn.value = Bn.isShowReferLine;
    }), watch(
      [() => Bn.canvasWidth, () => Bn.canvasHeight, () => Bn.width, () => Bn.height],
      () => {
        ia();
      }
    ), watch(
      () => Bn.panzoomOption,
      () => {
        ua();
      },
      { deep: !0 }
    ), nr({
      initPanzoom: ia,
      panzoomInstance: Un,
      reset: sa,
      zoomIn: oa,
      zoomOut: la,
      cursorClass: Hn
    }), (pa, ya) => (openBlock(), createElementBlock("div", ht$2, [
      renderSlot(pa.$slots, "btn", {
        reset: sa,
        zoomIn: oa,
        zoomOut: la
      }),
      createElementVNode("div", {
        class: normalizeClass(["canvasedit-parent", Hn.value]),
        style: normalizeStyle$1(Yn.value)
      }, [
        createElementVNode("div", {
          class: normalizeClass(["canvasedit", Hn.value])
        }, [
          renderSlot(pa.$slots, "default")
        ], 2)
      ], 6),
      withDirectives(createVNode$1(Re$1, {
        style: normalizeStyle$1({ marginLeft: pa.thick + "px", width: Wn.value + "px" }),
        vertical: !1,
        width: pa.width,
        height: pa.thick,
        "is-show-refer-line": Pn.value,
        thick: pa.thick,
        start: Ln.value,
        "start-other": $n.value,
        lines: pa.lines,
        "select-start": pa.shadow.x,
        "snap-threshold": pa.snapThreshold,
        "snaps-obj": pa.snapsObj,
        "select-length": pa.shadow.width,
        scale: Fn.value,
        palette: zn.value,
        "canvas-width": pa.canvasWidth,
        "show-shadow-text": pa.showShadowText,
        "canvas-height": pa.canvasHeight,
        rate: pa.rate,
        "grid-ratio": pa.gridRatio,
        "lock-line": pa.lockLine,
        onChangeLineState: fa
      }, null, 8, ["style", "width", "height", "is-show-refer-line", "thick", "start", "start-other", "lines", "select-start", "snap-threshold", "snaps-obj", "select-length", "scale", "palette", "canvas-width", "show-shadow-text", "canvas-height", "rate", "grid-ratio", "lock-line"]), [
        [vShow, pa.showRuler]
      ]),
      withDirectives(createVNode$1(Re$1, {
        style: normalizeStyle$1({ marginTop: pa.thick + "px", top: 0, height: Xn.value + "px" }),
        vertical: !0,
        width: pa.thick,
        height: pa.height,
        "is-show-refer-line": Pn.value,
        thick: pa.thick,
        start: $n.value,
        "start-other": Ln.value,
        lines: pa.lines,
        "select-start": pa.shadow.y,
        "select-length": pa.shadow.height,
        "snap-threshold": pa.snapThreshold,
        "snaps-obj": pa.snapsObj,
        scale: Fn.value,
        palette: zn.value,
        "canvas-width": pa.canvasWidth,
        "canvas-height": pa.canvasHeight,
        "show-shadow-text": pa.showShadowText,
        rate: pa.rate,
        "grid-ratio": pa.gridRatio,
        "lock-line": pa.lockLine,
        onChangeLineState: fa
      }, null, 8, ["style", "width", "height", "is-show-refer-line", "thick", "start", "start-other", "lines", "select-start", "select-length", "snap-threshold", "snaps-obj", "scale", "palette", "canvas-width", "canvas-height", "show-shadow-text", "rate", "grid-ratio", "lock-line"]), [
        [vShow, pa.showRuler]
      ]),
      withDirectives(createElementVNode("a", {
        class: "corner",
        style: normalizeStyle$1(Gn.value),
        onClick: ca
      }, null, 4), [
        [vShow, pa.showRuler]
      ])
    ]));
  }
}), style$1 = "", _hoisted_1$e = { class: "dms-sketch-rule" }, _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "EditRule",
  setup(_n) {
    const nr = useChartEditStore(), Cn = useLayoutStore(), Bn = reactive({
      scale: 2,
      startX: 0,
      startY: 0,
      gridRatio: 1,
      palette: {
        bgColor: "#f0f3f8",
        lineColor: "#0C63EE",
        borderColor: "#F0F3F8",
        fontColor: "#8a91a1"
      },
      thick: 20,
      lines: { h: [], v: [] },
      selfHandle: !1,
      panzoomOption: {
        minScale: 0.1,
        maxScale: 2,
        disableZoom: !1,
        roundPixels: !0,
        animate: !0
        // overflow: 'auto'
      }
    }), In = ref(), Dn = ref(!1);
    ref("auto");
    const { width: Ln, height: $n } = toRefs(nr.getEditCanvasConfig);
    ref(0), ref(0);
    const Nn = computed(() => nr.getEditCanvas.scale);
    provide(SCALE_KEY, { width: nr.getEditCanvas.scale, height: nr.getEditCanvas.scale });
    const Rn = reactive({ width: 0, height: 0 }), Fn = () => {
      const Yn = document.getElementById("edit_layout");
      Yn ? (Rn.width = Yn.clientWidth, Rn.height = Yn.clientHeight) : (Rn.width = Ln.value, Rn.height = $n.value);
    };
    watch(
      () => Cn.getSidebar,
      (Yn, Wn) => {
        Fn(), throttle$2(zn, 20);
      }
    ), watch(
      () => Cn.getConfig,
      (Yn, Wn) => {
        Fn(), throttle$2(zn, 20);
      }
    ), watch(
      () => Nn.value,
      (Yn, Wn) => {
        if (Hn.value)
          return !1;
        In.value && Yn !== Bn.scale && In.value.panzoomInstance.zoom(Yn, { animate: !0, force: !1 });
      }
    ), watch(
      () => nr.getEditCanvas.lockScale,
      (Yn, Wn) => {
        In.value && In.value.panzoomInstance.setOptions({ disableZoom: Yn });
      }
    );
    let Pn = null, Un = null;
    const Hn = ref(!1);
    watch(() => Bn.scale, (Yn, Wn) => {
      Yn !== Nn.value && (clearTimeout(Pn), Pn = setTimeout(() => {
        nr.setScale(Bn.scale);
      }, 300));
    });
    const zn = () => {
      Dn.value = !1, setTimeout(() => {
        Dn.value = !0;
      }, 10);
    }, Gn = () => {
      Hn.value = !0, clearTimeout(Un), Un = setTimeout(() => {
        Hn.value = !1, Fn(), In.value.panzoomInstance.reset({ animate: !1 });
      }, 300);
    };
    return onMounted(() => {
      Fn(), Dn.value = !0, window.addEventListener("resize", Gn);
    }), onUnmounted(() => {
      window.removeEventListener("resize", Gn);
    }), (Yn, Wn) => (openBlock(), createElementBlock("div", _hoisted_1$e, [
      Dn.value ? (openBlock(), createBlock(unref(pt$2), {
        key: 0,
        ref_key: "$sketchRule",
        ref: In,
        scale: Bn.scale,
        "onUpdate:scale": Wn[0] || (Wn[0] = (Xn) => Bn.scale = Xn),
        startX: Bn.startX,
        startY: Bn.startY,
        thick: Bn.thick,
        width: Rn.width,
        height: Rn.height,
        showRuler: !0,
        canvasWidth: unref(Ln),
        canvasHeight: unref($n),
        paddingRatio: 0.05,
        autoCenter: !0,
        animate: !0,
        lines: Bn.lines,
        palette: Bn.palette,
        panzoomOption: Bn.panzoomOption,
        selfHandle: Bn.selfHandle
      }, {
        default: withCtx(() => [
          createElementVNode("div", {
            class: "edit-screens",
            style: normalizeStyle$1({ width: unref(Ln) + "px", height: unref($n) + "px" })
          }, [
            renderSlot(Yn.$slots, "default", {}, void 0, !0)
          ], 4)
        ]),
        _: 3
      }, 8, ["scale", "startX", "startY", "thick", "width", "height", "canvasWidth", "canvasHeight", "lines", "palette", "panzoomOption", "selfHandle"])) : createCommentVNode("", !0)
    ]));
  }
}), EditRule_vue_vue_type_style_index_0_scoped_659aab64_lang = "", EditRule = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-659aab64"]]), _hoisted_1$d = { class: "dms-content-configurations" }, _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "Configuration",
  setup(_n) {
    const nr = defineAsyncComponent(() => import("./CanvasPage-dde81642.js")), Cn = loadAsyncComponent(() => import("./PageEvent-c6b600c1.js")), Bn = loadAsyncComponent(() => import("./ChartSetting-8ed027de.js")), In = loadAsyncComponent(() => import("./GroupSetting-5950239c.js")), Dn = loadAsyncComponent(() => import("./LoginEvent-4ea654ae.js")), Ln = loadAsyncComponent(() => import("./ChartAnimation-5661c559.js")), $n = loadAsyncComponent(() => import("./index-d1442ae1.js")), Nn = loadAsyncComponent(() => import("./index-77d4d92d.js")), Rn = reactive({
      globalTabSelect: "pageSetting",
      componentTabSelect: "chartSetting",
      oldTagetId: ""
    }), Fn = [
      {
        key: "pageSetting",
        title: "页面配置",
        render: nr
      },
      {
        key: "pageEvent",
        title: "页面事件",
        render: Cn
      }
    ], Pn = shallowRef([]), Un = useChartEditStore();
    ref("");
    const Hn = (Gn) => {
      Pn.value = [], Gn && (Rn.oldTagetId !== Gn.id && (Rn.componentTabSelect = "chartSetting"), Gn.isGroup ? (Pn.value.push({
        key: "chartSetting",
        title: "分组配置",
        render: In
      }), Pn.value.push({
        key: "chartAnimation",
        title: "动画",
        render: Ln
      })) : Gn.isTemplate || (Pn.value.push({
        key: "chartSetting",
        title: "配置",
        render: Bn
      }), Gn.chartConfig.category === "Logins" ? Pn.value.push({
        key: "loginEvent",
        title: "交互",
        render: Dn
      }) : (Pn.value.push({
        key: "chartData",
        title: "数据",
        render: $n
      }), Pn.value.push({
        key: "chartEvent",
        title: "事件",
        render: Nn
      })), Pn.value.push({
        key: "chartAnimation",
        title: "动画",
        render: Ln
      })), Rn.oldTagetId = Gn.id);
    }, zn = computed(() => {
      const Gn = Un.getTargetChart.selectId;
      if (Gn.length !== 1)
        return;
      const Yn = Un.getComponentById(Gn[0]);
      return Hn(Yn), Yn;
    });
    return (Gn, Yn) => {
      const Wn = resolveComponent("el-scrollbar"), Xn = resolveComponent("el-tab-pane"), ea = resolveComponent("el-tabs");
      return openBlock(), createElementBlock("div", _hoisted_1$d, [
        zn.value ? (openBlock(), createBlock(ea, {
          key: 1,
          modelValue: Rn.componentTabSelect,
          "onUpdate:modelValue": Yn[1] || (Yn[1] = (ta) => Rn.componentTabSelect = ta),
          class: "tabs-box"
        }, {
          default: withCtx(() => [
            (openBlock(!0), createElementBlock(Fragment, null, renderList(Pn.value, (ta) => (openBlock(), createBlock(Xn, {
              key: ta.key,
              label: ta.title,
              name: ta.key
            }, {
              default: withCtx(() => [
                createVNode$1(Wn, null, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(ta.render), {
                      "target-data": zn.value,
                      "canvas-config": unref(Un).getEditCanvasConfig
                    }, null, 8, ["target-data", "canvas-config"]))
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1032, ["label", "name"]))), 128))
          ]),
          _: 1
        }, 8, ["modelValue"])) : (openBlock(), createBlock(ea, {
          key: 0,
          modelValue: Rn.globalTabSelect,
          "onUpdate:modelValue": Yn[0] || (Yn[0] = (ta) => Rn.globalTabSelect = ta),
          class: "tabs-box"
        }, {
          default: withCtx(() => [
            (openBlock(), createElementBlock(Fragment, null, renderList(Fn, (ta) => createVNode$1(Xn, {
              key: ta.key,
              label: ta.title,
              name: ta.key
            }, {
              default: withCtx(() => [
                createVNode$1(Wn, null, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(ta.render)))
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1032, ["label", "name"])), 64))
          ]),
          _: 1
        }, 8, ["modelValue"]))
      ]);
    };
  }
}), Configuration_vue_vue_type_style_index_0_scoped_797ffb7c_lang = "", Configuration = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-797ffb7c"]]), chartEditStore$4 = useChartEditStore(), divider = (_n = 3) => ({
  type: "divider",
  key: `d${_n}`
}), defaultOptions = [
  {
    label: "移出分组",
    key: MenuEnum.REMOVEGROUP,
    icon: "remove_group",
    fnHandle: chartEditStore$4.setRemoveGroup
  },
  {
    label: "设置为模板",
    key: MenuEnum.TEMPLATE,
    icon: "set_template",
    fnHandle: chartEditStore$4.setTemplate
  },
  {
    type: "divider",
    key: "dt"
  },
  {
    label: "锁定",
    key: MenuEnum.LOCK,
    icon: "lock",
    fnHandle: chartEditStore$4.setLock
  },
  {
    label: "解锁",
    key: MenuEnum.UNLOCK,
    icon: "unlock",
    fnHandle: chartEditStore$4.setUnLock
  },
  {
    label: "隐藏",
    key: MenuEnum.HIDE,
    icon: "hide",
    fnHandle: chartEditStore$4.setHide
  },
  {
    label: "显示",
    key: MenuEnum.SHOW,
    icon: "show",
    fnHandle: chartEditStore$4.setShow
  },
  {
    type: "divider",
    key: "d0"
  },
  {
    label: "复制",
    key: MenuEnum.COPY,
    icon: "copy",
    fnHandle: chartEditStore$4.setCopy
  },
  {
    label: "剪切",
    key: MenuEnum.CUT,
    icon: "cut",
    fnHandle: chartEditStore$4.setCut
  },
  {
    label: "粘贴",
    key: MenuEnum.PARSE,
    icon: "parse",
    fnHandle: chartEditStore$4.setParse
  },
  {
    type: "divider",
    key: "d1"
  },
  {
    label: "置顶",
    key: MenuEnum.TOP,
    icon: "top",
    fnHandle: chartEditStore$4.setTop
  },
  {
    label: "置底",
    key: MenuEnum.BOTTOM,
    icon: "bottom",
    fnHandle: chartEditStore$4.setBottom
  },
  {
    label: "上移",
    key: MenuEnum.UP,
    icon: "up",
    fnHandle: chartEditStore$4.setUp
  },
  {
    label: "下移",
    key: MenuEnum.DOWN,
    icon: "down",
    fnHandle: chartEditStore$4.setDown
  },
  {
    type: "divider",
    key: "d2"
  },
  {
    label: "清空剪贴板",
    key: MenuEnum.CLEAR,
    icon: "clear",
    fnHandle: chartEditStore$4.setRecordChart
  },
  {
    label: "删除",
    key: MenuEnum.DELETE,
    icon: "delete",
    fnHandle: chartEditStore$4.removeComponentList
  }
], defaultMultiSelectOptions = [
  {
    label: "创建分组",
    key: MenuEnum.GROUP,
    icon: "merge_group",
    fnHandle: chartEditStore$4.setGroup
  },
  {
    label: "解除分组",
    key: MenuEnum.UN_GROUP,
    icon: "cancel_group",
    fnHandle: chartEditStore$4.setUnGroup
  }
], defaultNoItemKeys = [MenuEnum.PARSE, MenuEnum.CLEAR], pickOption = (_n, nr) => {
  if (!nr)
    return _n;
  const Cn = [];
  return nr.forEach((Bn) => {
    Cn.push(..._n.filter((In) => In.key === Bn));
  }), Cn;
}, hideOption = (_n, nr) => nr ? _n.filter((Cn) => nr.findIndex((Bn) => Bn !== Cn.key) !== -1) : _n, menuOptions = ref([]), handleContextMenu = (_n, nr, Cn, Bn, In, Dn) => {
  if (Dn)
    return !1;
  _n.stopPropagation(), _n.preventDefault();
  let Ln = _n.target;
  for (; Ln instanceof SVGElement; )
    Ln = Ln.parentNode;
  chartEditStore$4.setTargetSelectChart(nr && nr.id), chartEditStore$4.setRightMenuShow(!1), chartEditStore$4.getTargetChart.selectId.length > 1 ? menuOptions.value = defaultMultiSelectOptions : menuOptions.value = defaultOptions, nr || (menuOptions.value = pickOption(toRaw(menuOptions.value), defaultNoItemKeys)), Bn && (menuOptions.value = hideOption([...defaultMultiSelectOptions, divider(), ...defaultOptions], Bn)), In && (menuOptions.value = pickOption([...defaultMultiSelectOptions, divider(), ...defaultOptions], In)), Cn && (menuOptions.value = Cn(
    cloneDeep(toRaw(menuOptions.value)),
    [...defaultMultiSelectOptions, ...defaultOptions],
    nr
  )), nextTick().then(() => {
    chartEditStore$4.setMousePosition(_n.clientX, _n.clientY), chartEditStore$4.setRightMenuShow(!0);
  });
}, useContextMenu = () => (menuOptions.value = defaultOptions, {
  menuOptions,
  defaultOptions,
  defaultMultiSelectOptions,
  handleContextMenu,
  onClickOutSide: () => {
    chartEditStore$4.setRightMenuShow(!1);
  },
  handleMenuSelect: (Cn) => {
    chartEditStore$4.setRightMenuShow(!1);
    const Bn = menuOptions.value.filter((In) => In.key === Cn);
    menuOptions.value.forEach((In) => {
      if (In.key === Cn) {
        if (In.fnHandle) {
          In.fnHandle();
          return;
        }
        Bn || ElMessage.error("未选择组件");
      }
    });
  },
  mousePosition: chartEditStore$4.getMousePosition
}), { onClickOutSide } = useContextMenu(), chartEditStore$3 = useChartEditStore(), dragHandle = async (_n) => {
  if (_n.preventDefault(), _n.target.className.indexOf("canvasedit-parent") > -1)
    return ElMessage.warning("请拖拽到画布区域内"), !1;
  try {
    const nr = _n.dataTransfer.getData(DragKeyEnum.DRAG_KEY);
    if (!nr)
      return;
    chartEditStore$3.setEditCanvas(EditCanvasTypeEnum.IS_CREATE, !1);
    const Cn = JSONParse(nr), Bn = await createComponent(Cn);
    let In = _n.offsetX - Bn.attr.w / 2, Dn = _n.offsetY - Bn.attr.h / 2;
    In = In < 0 ? 0 : In, Dn = Dn < 0 ? 0 : Dn, setComponentPosition(Bn, In, Dn), chartEditStore$3.addComponentList(Bn, !1, !0), chartEditStore$3.setTargetSelectChart(Bn.id);
  } catch (nr) {
    console.log(nr), ElMessage.warning("图表正在研发中, 敬请期待...");
  }
}, dragoverHandle = (_n) => {
  _n.preventDefault(), _n.stopPropagation(), _n.dataTransfer && (_n.dataTransfer.dropEffect = "copy");
}, mousedownHandleUnStop = (_n, nr) => {
  if (nr) {
    chartEditStore$3.setTargetSelectChart(nr.id);
    return;
  }
  chartEditStore$3.setTargetSelectChart(void 0);
}, mousedownBoxSelect = (_n, nr) => {
  var Rn;
  if (_n.which == 2 || (Rn = window.$KeyboardActive) != null && Rn.space)
    return;
  mousedownHandleUnStop();
  const Cn = _n.offsetX, Bn = _n.offsetY, In = _n.screenX, Dn = _n.screenY, Ln = chartEditStore$3.getEditCanvas.scale;
  chartEditStore$3.setMousePosition(void 0, void 0, Cn, Bn);
  const $n = throttle$2((Fn) => {
    chartEditStore$3.setTargetSelectChart(), chartEditStore$3.setEditCanvas(EditCanvasTypeEnum.IS_SELECT, !0);
    const Pn = Cn + Fn.screenX - In, Un = Bn + Fn.screenY - Dn;
    chartEditStore$3.setMousePosition(Pn, Un);
    const Hn = {
      // 左上角
      x1: 0,
      y1: 0,
      // 右下角
      x2: 0,
      y2: 0
    };
    Pn > Cn && Un > Bn ? (Hn.x1 = Cn, Hn.y1 = Bn, Hn.x2 = Math.round(Cn + (Fn.screenX - In) / Ln), Hn.y2 = Math.round(Bn + (Fn.screenY - Dn) / Ln)) : Pn > Cn && Un < Bn ? (Hn.x1 = Cn, Hn.y1 = Math.round(Bn - (Dn - Fn.screenY) / Ln), Hn.x2 = Math.round(Cn + (Fn.screenX - In) / Ln), Hn.y2 = Bn) : Pn < Cn && Un > Bn ? (Hn.x1 = Math.round(Cn - (In - Fn.screenX) / Ln), Hn.y1 = Bn, Hn.x2 = Cn, Hn.y2 = Math.round(Bn + (Fn.screenY - Dn) / Ln)) : (Hn.x1 = Math.round(Cn - (In - Fn.screenX) / Ln), Hn.y1 = Math.round(Bn - (Dn - Fn.screenY) / Ln), Hn.x2 = Cn, Hn.y2 = Bn), chartEditStore$3.getComponentList.forEach((zn) => {
      if (!chartEditStore$3.getTargetChart.selectId.includes(zn.id)) {
        const { x: Gn, y: Yn, w: Wn, h: Xn } = zn.attr, ea = {
          // 左上角
          x1: Gn,
          y1: Yn,
          // 右下角
          x2: Gn + Wn,
          y2: Yn + Xn
        };
        ea.x1 - Hn.x1 >= 0 && ea.y1 - Hn.y1 >= 0 && ea.x2 - Hn.x2 <= 0 && ea.y2 - Hn.y2 <= 0 && !zn.status.lock && !zn.status.hide && chartEditStore$3.setTargetSelectChart(zn.id, !0);
      }
    });
  }, 30), Nn = () => {
    $n.cancel(), chartEditStore$3.setEditCanvas(EditCanvasTypeEnum.IS_SELECT, !1), chartEditStore$3.setMousePosition(0, 0, 0, 0), document.removeEventListener("mousemove", $n), document.removeEventListener("mouseup", Nn);
  };
  document.addEventListener("mousemove", $n), document.addEventListener("mouseup", Nn);
}, useMouseHandle = () => ({ mouseClickHandle: (In, Dn) => {
  var Ln;
  if (In.preventDefault(), In.stopPropagation(), !Dn.status.lock && (Ln = window.$KeyboardActive) != null && Ln.ctrl)
    if (chartEditStore$3.targetChart.selectId.includes(Dn.id)) {
      const $n = chartEditStore$3.targetChart.selectId.filter((Nn) => Nn !== Dn.id);
      chartEditStore$3.setTargetSelectChart($n);
    } else
      chartEditStore$3.setTargetSelectChart(Dn.id, !0);
}, mousedownHandle: (In, Dn) => {
  var zn;
  if (In.preventDefault(), In.stopPropagation(), Dn.status.lock || (onClickOutSide(), In.buttons === MouseEventButton.LEFT && ((zn = window.$KeyboardActive) != null && zn.ctrl)))
    return;
  const Ln = chartEditStore$3.getTargetChart.selectId;
  if (In.buttons === MouseEventButton.RIGHT && Ln.length > 1 && Ln.includes(Dn.id) || (chartEditStore$3.setTargetSelectChart(Dn.id), In.buttons === MouseEventButton.RIGHT))
    return;
  const $n = chartEditStore$3.getEditCanvas.scale;
  chartEditStore$3.getEditCanvasConfig.width, chartEditStore$3.getEditCanvasConfig.height;
  const Nn = /* @__PURE__ */ new Map();
  chartEditStore$3.getTargetChart.selectId.forEach((Gn) => {
    const Yn = chartEditStore$3.fetchTargetIndex(Gn);
    if (Yn !== -1) {
      const { x: Wn, y: Xn, w: ea, h: ta } = toRaw(chartEditStore$3.getComponentList[Yn]).attr;
      Nn.set(Gn, { x: Wn, y: Xn, w: ea, h: ta });
    }
  });
  const Rn = In.screenX, Fn = In.screenY;
  let Pn = [];
  chartEditStore$3.getTargetChart.selectId.forEach((Gn) => {
    if (!Nn.has(Gn))
      return;
    const Yn = chartEditStore$3.fetchTargetIndex(Gn);
    Pn.push(cloneDeep(chartEditStore$3.getComponentList[Yn]));
  }), chartEditStore$3.setMousePosition(void 0, void 0, Rn, Fn);
  const Un = throttle$2((Gn) => {
    chartEditStore$3.setEditCanvas(EditCanvasTypeEnum.IS_DRAG, !0), chartEditStore$3.setMousePosition(Gn.screenX, Gn.screenY);
    let Yn = (Gn.screenX - Rn) / $n, Wn = (Gn.screenY - Fn) / $n;
    chartEditStore$3.getTargetChart.selectId.forEach((Xn) => {
      if (!Nn.has(Xn))
        return;
      const ea = chartEditStore$3.fetchTargetIndex(Xn), { x: ta, y: na, w: ra, h: aa } = Nn.get(Xn), ia = chartEditStore$3.getComponentList[ea];
      let Aa = Math.round(ta + Yn), sa = Math.round(na + Wn);
      ia && (ia.attr = Object.assign(ia.attr, {
        x: Aa,
        y: sa
      }));
    });
  }, 20), Hn = () => {
    try {
      chartEditStore$3.setMousePosition(0, 0, 0, 0), chartEditStore$3.setEditCanvas(EditCanvasTypeEnum.IS_DRAG, !1), Pn.length && (chartEditStore$3.getTargetChart.selectId.forEach((Gn) => {
        if (!Nn.has(Gn))
          return;
        const Yn = chartEditStore$3.fetchTargetIndex(Gn), Wn = chartEditStore$3.getComponentList[Yn];
        Pn.forEach((Xn) => {
          Xn.id === Gn && (Xn.attr = Object.assign(Xn.attr, {
            offsetX: Wn.attr.x - Xn.attr.x,
            offsetY: Wn.attr.y - Xn.attr.y
          }));
        });
      }), chartEditStore$3.moveComponentList(Pn)), document.removeEventListener("mousemove", Un), document.removeEventListener("mouseup", Hn);
    } catch (Gn) {
      console.log(Gn);
    }
  };
  document.addEventListener("mousemove", Un), document.addEventListener("mouseup", Hn);
}, mouseenterHandle: (In, Dn) => {
  In.preventDefault(), In.stopPropagation(), chartEditStore$3.getEditCanvas.isSelect || chartEditStore$3.setTargetHoverChart(Dn.id);
}, mouseleaveHandle: (In) => {
  In.preventDefault(), In.stopPropagation(), chartEditStore$3.setEditCanvas(EditCanvasTypeEnum.IS_DRAG, !1), chartEditStore$3.setTargetHoverChart(void 0);
} }), useMousePointHandle = (_n, nr, Cn) => {
  _n.stopPropagation(), _n.preventDefault(), chartEditStore$3.setEditCanvas(EditCanvasTypeEnum.IS_DRAG, !0);
  const Bn = chartEditStore$3.getEditCanvas.scale, In = Cn.x, Dn = Cn.y, Ln = Cn.w, $n = Cn.h, Nn = _n.screenX, Rn = _n.screenY;
  chartEditStore$3.setMousePosition(Nn, Rn);
  const Fn = throttle$2((Un) => {
    chartEditStore$3.setMousePosition(Un.screenX, Un.screenY);
    let Hn = Math.round((Un.screenX - Nn) / Bn), zn = Math.round((Un.screenY - Rn) / Bn);
    const Gn = /t/.test(nr), Yn = /b/.test(nr), Wn = /l/.test(nr), Xn = /r/.test(nr), ea = $n + (Gn ? -zn : Yn ? zn : 0), ta = Ln + (Wn ? -Hn : Xn ? Hn : 0);
    Cn.h = ea > 0 ? ea : 0, Cn.w = ta > 0 ? ta : 0, Cn.x = In + (Wn ? Hn : 0), Cn.y = Dn + (Gn ? zn : 0);
  }, 50), Pn = () => {
    chartEditStore$3.setEditCanvas(EditCanvasTypeEnum.IS_DRAG, !1), chartEditStore$3.setMousePosition(0, 0, 0, 0), document.removeEventListener("mousemove", Fn), document.removeEventListener("mouseup", Pn);
  };
  document.addEventListener("mousemove", Fn), document.addEventListener("mouseup", Pn);
}, useComponentStyle = (_n, nr) => {
  if (!_n)
    return {};
  const Cn = {
    zIndex: nr + 1,
    left: `${_n.x}px`,
    top: `${_n.y}px`
  };
  return _n.style && (_n.style.borderWidth && (Cn.borderWidth = _n.style.borderWidth[0] + "px " + _n.style.borderWidth[1] + "px " + _n.style.borderWidth[2] + "px " + _n.style.borderWidth[3] + "px"), _n.style.borderStyle && (Cn.borderStyle = _n.style.borderStyle), _n.style.borderColor && (Cn.borderColor = _n.style.borderColor), _n.style.borderRadius && (Cn.borderRadius = _n.style.borderRadius[0] + "px " + _n.style.borderRadius[1] + "px " + _n.style.borderRadius[2] + "px " + _n.style.borderRadius[3] + "px"), _n.style.backgroundColor && (Cn.backgroundColor = _n.style.backgroundColor), _n.style.backgroundImage && (Cn.backgroundImage = "url(" + _n.style.backgroundImage + ")"), _n.style.fit && (Cn.backgroundSize = _n.style.fit), _n.style.boxShadow && (Cn.boxShadow = _n.style.boxShadow ? (_n.style.boxShadow[0] || 0) + "px " + (_n.style.boxShadow[1] || 0) + "px " + (_n.style.boxShadow[2] || 0) + "px " + (_n.style.boxShadow[3] || 0) + "px " + _n.style.boxShadow[4] + (_n.style.boxShadow[5] === "inset" ? _n.style.boxShadow[5] : "") : "")), Cn;
}, useSizeStyle = (_n, nr) => _n ? {
  width: `${nr ? nr * _n.w : _n.w}px`,
  height: `${nr ? nr * _n.h : _n.h}px`
} : {}, usePointStyle = (_n, nr, Cn, Bn) => {
  const { w: In, h: Dn } = Cn, Ln = /t/.test(_n), $n = /b/.test(_n), Nn = /l/.test(_n), Rn = /r/.test(_n);
  let Fn = 0, Pn = 0;
  return _n.length === 2 ? (Fn = Nn ? 0 : In, Pn = Ln ? 0 : Dn) : ((Ln || $n) && (Fn = In / 2, Pn = Ln ? 0 : Dn), (Nn || Rn) && (Fn = Nn ? 0 : In, Pn = Math.floor(Dn / 2))), {
    left: `${Fn}px`,
    top: `${Pn}px`,
    cursor: Bn[nr] + "-resize"
  };
}, _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "EditRange",
  setup(_n) {
    const nr = useChartEditStore(), { getEditCanvasConfig: Cn, getEditCanvas: Bn } = toRefs(nr), In = computed(() => ({
      w: Cn.value.width,
      h: Cn.value.height
    })), Dn = computed(() => ({ ...useSizeStyle(In.value) })), Ln = computed(() => {
      const $n = Bn.value.isCreate && { "z-index": 99999 };
      return { ...useSizeStyle(In.value), ...$n };
    });
    return ($n, Nn) => (openBlock(), createElementBlock("div", {
      class: "dms-edit-range dms-transition",
      style: normalizeStyle$1(Dn.value),
      onMousedown: Nn[0] || (Nn[0] = (Rn) => unref(mousedownBoxSelect)(Rn, void 0))
    }, [
      renderSlot($n.$slots, "default", {}, void 0, !0),
      createVNode$1(unref(EditWatermark)),
      createVNode$1(unref(EditAlignLine)),
      createVNode$1(unref(EditSelect)),
      createElementVNode("div", {
        class: "dms-edit-range-model",
        style: normalizeStyle$1(Ln.value)
      }, null, 4)
    ], 36));
  }
}), EditRange_vue_vue_type_style_index_0_scoped_f7355cec_lang = "", EditRange = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-f7355cec"]]), _hoisted_1$c = ["onMousedown"], _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "EditShapeBox",
  props: {
    item: {
      type: Object,
      required: !0
    },
    hiddenPoint: {
      type: Boolean,
      required: !1
    }
  },
  setup(_n) {
    const nr = _n, Cn = useChartEditStore(), Bn = ["t", "r", "b", "l", "lt", "rt", "lb", "rb"], In = ["n", "e", "s", "w", "nw", "ne", "sw", "se"], Dn = computed(() => nr.item.status.lock ? !1 : nr.item.id === Cn.getTargetChart.hoverId), Ln = computed(() => {
      const Rn = nr.item.id;
      return nr.item.status.lock ? !1 : Cn.getTargetChart.selectId.find((Fn) => Fn === Rn);
    }), $n = computed(() => nr.item.status.lock), Nn = computed(() => nr.item.status.hide);
    return (Rn, Fn) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["dms-shape-box", { lock: $n.value, hide: Nn.value }])
    }, [
      renderSlot(Rn.$slots, "default", {}, void 0, !0),
      _n.hiddenPoint ? createCommentVNode("", !0) : (openBlock(!0), createElementBlock(Fragment, { key: 0 }, renderList(Ln.value ? Bn : [], (Pn, Un) => (openBlock(), createElementBlock("div", {
        class: normalizeClass(`shape-point ${Pn} ${_n.item.attr.w < 60 ? "hide-x-point" : ""} ${_n.item.attr.h < 60 ? "hide-y-point" : ""}`),
        key: Un,
        style: normalizeStyle$1(unref(usePointStyle)(Pn, Un, _n.item.attr, In)),
        onMousedown: (Hn) => unref(useMousePointHandle)(Hn, Pn, _n.item.attr)
      }, null, 46, _hoisted_1$c))), 128)),
      createElementVNode("div", {
        class: "shape-modal",
        style: normalizeStyle$1(unref(useSizeStyle)(_n.item.attr))
      }, [
        createElementVNode("div", {
          class: normalizeClass(["shape-modal-select", { active: Ln.value }])
        }, null, 2),
        createElementVNode("div", {
          class: normalizeClass(["shape-modal-change", { selectActive: Ln.value, hoverActive: Dn.value }])
        }, null, 2)
      ], 4)
    ], 2));
  }
}), EditShapeBox_vue_vue_type_style_index_0_scoped_43a4428f_lang = "", EditShapeBox = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-43a4428f"]]), animationsClass = (_n) => _n.length ? `animate__animated  animate__${_n[0]}` : "", getFilterStyle = (_n) => {
  if (!_n || !_n.filterShow)
    return {};
  const { opacity: nr, saturate: Cn, contrast: Bn, hueRotate: In, brightness: Dn } = _n;
  return {
    opacity: nr,
    filter: `saturate(${Cn}) contrast(${Bn}) hue-rotate(${In}deg) brightness(${Dn})`
  };
}, getTransformStyle = (_n) => {
  const { rotateZ: nr, rotateX: Cn, rotateY: Bn, skewX: In, skewY: Dn } = _n;
  return {
    transform: `rotateZ(${nr || 0}deg) rotateX(${Cn || 0}deg) rotateY(${Bn || 0}deg) skewX(${In || 0}deg) skewY(${Dn || 0}deg)`
  };
}, getBlendModeStyle = (_n) => {
  if (!_n || !_n.filterShow)
    return {};
  const { blendMode: nr } = _n;
  return {
    "mix-blend-mode": nr
  };
}, colorCustomMerge = (_n) => {
  const nr = {};
  return _n == null || _n.forEach((Cn) => {
    nr[Cn.id] = {
      color: Cn.color,
      name: Cn.name
    };
  }), { ...nr, ...chartColors };
};
window.$components = {};
const useLifeHandler$2 = (_n) => ({
  [EventLife.VNODE_BEFORE_MOUNT](nr) {
    window.$components[_n.id] = nr.component;
  }
}), _hoisted_1$b = { class: "dms-edit-group-box" }, _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "EditGroup",
  props: {
    groupData: {
      type: Object,
      required: !0
    },
    groupIndex: {
      type: Number,
      required: !0
    }
  },
  setup(_n) {
    const nr = useChartEditStore(), { handleContextMenu: Cn } = useContextMenu(), { mouseenterHandle: Bn, mouseleaveHandle: In, mousedownHandle: Dn, mouseClickHandle: Ln } = useMouseHandle(), $n = (Fn, Pn, Un) => {
      const Hn = (zn) => Pn.filter((Gn) => zn.includes(Gn.key));
      if (nr.getTargetChart.selectId.length > 1)
        return Hn([MenuEnum.GROUP, MenuEnum.DELETE]);
      {
        const zn = [];
        Un.status.lock ? zn.push(MenuEnum.LOCK) : zn.push(MenuEnum.UNLOCK), Un.status.hide ? zn.push(MenuEnum.HIDE) : zn.push(MenuEnum.SHOW), zn.push(MenuEnum.REMOVEGROUP);
        const Gn = [MenuEnum.UN_GROUP];
        return ["Page"].includes(Un.chartConfig.key) && (zn.push(MenuEnum.TEMPLATE), zn.push("dt")), [
          ...Hn(Gn),
          divider(),
          ...Fn.filter((Yn) => !zn.includes(Yn.key))
        ];
      }
    }, Nn = computed(() => colorCustomMerge(nr.getEditCanvasConfig.chartCustomThemeColorInfo)[nr.getEditCanvasConfig.chartThemeColor]), Rn = computed(() => nr.getEditCanvasConfig.chartThemeSetting);
    return (Fn, Pn) => (openBlock(), createElementBlock("div", _hoisted_1$b, [
      (openBlock(), createBlock(EditShapeBox, {
        key: _n.groupData.id,
        "data-id": _n.groupData.id,
        index: _n.groupIndex,
        item: _n.groupData,
        hiddenPoint: !0,
        class: normalizeClass(unref(animationsClass)(_n.groupData.styles.animations)),
        style: normalizeStyle$1({
          ...unref(useComponentStyle)(_n.groupData.attr, _n.groupIndex),
          ...unref(useSizeStyle)(_n.groupData.attr),
          ...unref(getFilterStyle)(_n.groupData.styles),
          ...unref(getTransformStyle)(_n.groupData.styles),
          ...unref(getBlendModeStyle)(_n.groupData.styles)
        }),
        onClick: Pn[0] || (Pn[0] = (Un) => unref(Ln)(Un, _n.groupData)),
        onMousedown: Pn[1] || (Pn[1] = (Un) => unref(Dn)(Un, _n.groupData)),
        onMouseenter: Pn[2] || (Pn[2] = (Un) => unref(Bn)(Un, _n.groupData)),
        onMouseleave: Pn[3] || (Pn[3] = (Un) => unref(In)(Un)),
        onContextmenu: Pn[4] || (Pn[4] = (Un) => unref(Cn)(Un, _n.groupData, $n))
      }, {
        default: withCtx(() => [
          (openBlock(!0), createElementBlock(Fragment, null, renderList(_n.groupData.groupList, (Un) => (openBlock(), createBlock(EditShapeBox, {
            key: Un.id,
            "data-id": Un.id,
            index: _n.groupIndex,
            item: Un,
            hiddenPoint: !0,
            style: normalizeStyle$1({
              ...unref(useComponentStyle)(Un.attr, _n.groupIndex)
            })
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(Un.chartConfig.chartKey), mergeProps({
                class: ["edit-content-chart", unref(animationsClass)(Un.styles.animations)],
                chartConfig: Un,
                themeSetting: Rn.value,
                themeColor: Nn.value,
                style: {
                  ...unref(useSizeStyle)(Un.attr),
                  ...unref(getFilterStyle)(Un.styles),
                  ...unref(getTransformStyle)(Un.styles)
                }
              }, toHandlers(unref(useLifeHandler$2)(Un, unref(nr).editCanvasConfig))), null, 16, ["class", "chartConfig", "themeSetting", "themeColor", "style"]))
            ]),
            _: 2
          }, 1032, ["data-id", "index", "item", "style"]))), 128))
        ]),
        _: 1
      }, 8, ["data-id", "index", "item", "class", "style"]))
    ]));
  }
}), _sfc_main$d = {}, _hoisted_1$a = { class: "history-box" };
function _sfc_render$1(_n, nr) {
  return openBlock(), createElementBlock("div", _hoisted_1$a);
}
const EditHistory = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$1]]), _sfc_main$c = {}, _hoisted_1$9 = { class: "edit-shortcut-key" };
function _sfc_render(_n, nr) {
  return openBlock(), createElementBlock("div", _hoisted_1$9);
}
const EditShortcutKey = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render]]), _hoisted_1$8 = { class: "dms-edit-bottom" }, _hoisted_2$6 = { class: "bottom-left" }, _hoisted_3$4 = { class: "bottom-ri" }, _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "EditBottom",
  setup(_n) {
    const nr = useLayoutStore();
    toRefs(nr);
    const Cn = useChartEditStore(), { lockScale: Bn, scale: In } = toRefs(Cn.getEditCanvas), Dn = ref();
    let Ln = [
      {
        label: "200%",
        value: 200
      },
      {
        label: "150%",
        value: 150
      },
      {
        label: "100%",
        value: 100
      },
      {
        label: "50%",
        value: 50
      },
      {
        label: "自适应",
        value: 0
      }
    ];
    const $n = ref(""), Nn = (zn) => {
      var Gn;
      if ((Gn = Dn.value) == null || Gn.blur(), zn === 0) {
        Cn.computedScale();
        return;
      }
      Cn.setScale(zn / 100);
    }, Rn = () => {
      Cn.setEditCanvas(EditCanvasTypeEnum.LOCK_SCALE, !Bn.value);
    }, Fn = ref(100), Pn = (zn) => `${zn}%`, Un = (zn) => {
      Cn.setScale(zn / 100);
    }, Hn = reactive({
      100: ""
    });
    return watchEffect(() => {
      const zn = (In.value * 100).toFixed(0);
      $n.value = `${zn}%`, Fn.value = parseInt(zn);
    }), (zn, Gn) => {
      const Yn = resolveComponent("el-option"), Wn = resolveComponent("el-select"), Xn = __unplugin_components_0, ea = resolveComponent("el-tooltip"), ta = resolveComponent("el-slider");
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        createElementVNode("div", _hoisted_2$6, [
          createVNode$1(EditHistory),
          Gn[2] || (Gn[2] = createElementVNode("div", { id: "keyboard-dress-show" }, null, -1))
        ]),
        createElementVNode("div", _hoisted_3$4, [
          createVNode$1(EditShortcutKey),
          createVNode$1(Wn, {
            ref_key: "selectInstRef",
            ref: Dn,
            class: "scale-select",
            modelValue: $n.value,
            "onUpdate:modelValue": Gn[0] || (Gn[0] = (na) => $n.value = na),
            disabled: unref(Bn),
            size: "small",
            "popper-class": "scale-select-popper",
            onChange: Nn
          }, {
            default: withCtx(() => [
              (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(Ln), (na) => (openBlock(), createBlock(Yn, {
                class: normalizeClass(na.label === $n.value ? "active" : ""),
                key: na.value,
                label: na.label,
                value: na.value
              }, null, 8, ["class", "label", "value"]))), 128))
            ]),
            _: 1
          }, 8, ["modelValue", "disabled"]),
          createVNode$1(ea, {
            trigger: "hover",
            content: unref(Bn) ? "解锁" : "锁定当前比例"
          }, {
            default: withCtx(() => [
              createElementVNode("div", {
                class: "lock-btn",
                onClick: Rn
              }, [
                createVNode$1(Xn, {
                  "icon-class": unref(Bn) ? "lock_close" : "lock_open"
                }, null, 8, ["icon-class"])
              ])
            ]),
            _: 1
          }, 8, ["content"]),
          createVNode$1(ta, {
            class: "scale-slider",
            modelValue: Fn.value,
            "onUpdate:modelValue": Gn[1] || (Gn[1] = (na) => Fn.value = na),
            size: "small",
            min: 10,
            max: 200,
            step: 5,
            "format-tooltip": Pn,
            disabled: unref(Bn),
            marks: Hn,
            onChange: Un
          }, null, 8, ["modelValue", "disabled", "marks"])
        ])
      ]);
    };
  }
}), EditBottom_vue_vue_type_style_index_0_scoped_b2edcdfe_lang = "", EditBottom = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-b2edcdfe"]]), chartEditStore$2 = useChartEditStore(), useLayout = () => {
  onMounted(() => {
    chartEditStore$2.setEditCanvas(
      EditCanvasTypeEnum.EDIT_LAYOUT_DOM,
      document.getElementById("edit_layout")
    ), chartEditStore$2.setEditCanvas(
      EditCanvasTypeEnum.EDIT_CONTENT_DOM,
      document.getElementById("dms-chart-edit-content")
    );
    const _n = chartEditStore$2.listenerScale();
    onUnmounted(() => {
      chartEditStore$2.setEditCanvas(EditCanvasTypeEnum.EDIT_LAYOUT_DOM, null), chartEditStore$2.setEditCanvas(EditCanvasTypeEnum.EDIT_CONTENT_DOM, null), _n();
    });
  });
};
var keymaster$1 = { exports: {} };
(function(_n) {
  (function(nr) {
    var Cn, Bn = {}, In = { 16: !1, 18: !1, 17: !1, 91: !1 }, Dn = "all", Ln = {
      "⇧": 16,
      shift: 16,
      "⌥": 18,
      alt: 18,
      option: 18,
      "⌃": 17,
      ctrl: 17,
      control: 17,
      "⌘": 91,
      command: 91
    }, $n = {
      backspace: 8,
      tab: 9,
      clear: 12,
      enter: 13,
      return: 13,
      esc: 27,
      escape: 27,
      space: 32,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      del: 46,
      delete: 46,
      home: 36,
      end: 35,
      pageup: 33,
      pagedown: 34,
      ",": 188,
      ".": 190,
      "/": 191,
      "`": 192,
      "-": 189,
      "=": 187,
      ";": 186,
      "'": 222,
      "[": 219,
      "]": 221,
      "\\": 220
    }, Nn = function(ca) {
      return $n[ca] || ca.toUpperCase().charCodeAt(0);
    }, Rn = [];
    for (Cn = 1; Cn < 20; Cn++)
      $n["f" + Cn] = 111 + Cn;
    function Fn(ca, fa) {
      for (var ha = ca.length; ha--; )
        if (ca[ha] === fa)
          return ha;
      return -1;
    }
    function Pn(ca, fa) {
      if (ca.length != fa.length)
        return !1;
      for (var ha = 0; ha < ca.length; ha++)
        if (ca[ha] !== fa[ha])
          return !1;
      return !0;
    }
    var Un = {
      16: "shiftKey",
      18: "altKey",
      17: "ctrlKey",
      91: "metaKey"
    };
    function Hn(ca) {
      for (Cn in In)
        In[Cn] = ca[Un[Cn]];
    }
    function zn(ca) {
      var fa, ha, pa, ya, da, Ca;
      if (fa = ca.keyCode, Fn(Rn, fa) == -1 && Rn.push(fa), (fa == 93 || fa == 224) && (fa = 91), fa in In) {
        In[fa] = !0;
        for (pa in Ln)
          Ln[pa] == fa && (Wn[pa] = !0);
        return;
      }
      if (Hn(ca), !!Wn.filter.call(this, ca) && fa in Bn) {
        for (Ca = aa(), ya = 0; ya < Bn[fa].length; ya++)
          if (ha = Bn[fa][ya], ha.scope == Ca || ha.scope == "all") {
            da = ha.mods.length > 0;
            for (pa in In)
              (!In[pa] && Fn(ha.mods, +pa) > -1 || In[pa] && Fn(ha.mods, +pa) == -1) && (da = !1);
            (ha.mods.length == 0 && !In[16] && !In[18] && !In[17] && !In[91] || da) && ha.method(ca, ha) === !1 && (ca.preventDefault ? ca.preventDefault() : ca.returnValue = !1, ca.stopPropagation && ca.stopPropagation(), ca.cancelBubble && (ca.cancelBubble = !0));
          }
      }
    }
    function Gn(ca) {
      var fa = ca.keyCode, ha, pa = Fn(Rn, fa);
      if (pa >= 0 && Rn.splice(pa, 1), (fa == 93 || fa == 224) && (fa = 91), fa in In) {
        In[fa] = !1;
        for (ha in Ln)
          Ln[ha] == fa && (Wn[ha] = !1);
      }
    }
    function Yn() {
      for (Cn in In)
        In[Cn] = !1;
      for (Cn in Ln)
        Wn[Cn] = !1;
    }
    function Wn(ca, fa, ha) {
      var pa, ya;
      pa = Aa(ca), ha === void 0 && (ha = fa, fa = "all");
      for (var da = 0; da < pa.length; da++)
        ya = [], ca = pa[da].split("+"), ca.length > 1 && (ya = sa(ca), ca = [ca[ca.length - 1]]), ca = ca[0], ca = Nn(ca), ca in Bn || (Bn[ca] = []), Bn[ca].push({ shortcut: pa[da], scope: fa, method: ha, key: pa[da], mods: ya });
    }
    function Xn(ca, fa) {
      var ha, pa, ya = [], da, Ca, ma;
      for (ha = Aa(ca), Ca = 0; Ca < ha.length; Ca++) {
        if (pa = ha[Ca].split("+"), pa.length > 1 && (ya = sa(pa), ca = pa[pa.length - 1]), ca = Nn(ca), fa === void 0 && (fa = aa()), !Bn[ca])
          return;
        for (da = 0; da < Bn[ca].length; da++)
          ma = Bn[ca][da], ma.scope === fa && Pn(ma.mods, ya) && (Bn[ca][da] = {});
      }
    }
    function ea(ca) {
      return typeof ca == "string" && (ca = Nn(ca)), Fn(Rn, ca) != -1;
    }
    function ta() {
      return Rn.slice(0);
    }
    function na(ca) {
      var fa = (ca.target || ca.srcElement).tagName;
      return !(fa == "INPUT" || fa == "SELECT" || fa == "TEXTAREA");
    }
    for (Cn in Ln)
      Wn[Cn] = !1;
    function ra(ca) {
      Dn = ca || "all";
    }
    function aa() {
      return Dn || "all";
    }
    function ia(ca) {
      var fa, ha, pa;
      for (fa in Bn)
        for (ha = Bn[fa], pa = 0; pa < ha.length; )
          ha[pa].scope === ca ? ha.splice(pa, 1) : pa++;
    }
    function Aa(ca) {
      var fa;
      return ca = ca.replace(/\s/g, ""), fa = ca.split(","), fa[fa.length - 1] == "" && (fa[fa.length - 2] += ","), fa;
    }
    function sa(ca) {
      for (var fa = ca.slice(0, ca.length - 1), ha = 0; ha < fa.length; ha++)
        fa[ha] = Ln[fa[ha]];
      return fa;
    }
    function oa(ca, fa, ha) {
      ca.addEventListener ? ca.addEventListener(fa, ha, !1) : ca.attachEvent && ca.attachEvent("on" + fa, function() {
        ha(window.event);
      });
    }
    oa(document, "keydown", function(ca) {
      zn(ca);
    }), oa(document, "keyup", Gn), oa(window, "focus", Yn);
    var la = nr.key;
    function ua() {
      var ca = nr.key;
      return nr.key = la, ca;
    }
    nr.key = Wn, nr.key.setScope = ra, nr.key.getScope = aa, nr.key.deleteScope = ia, nr.key.filter = na, nr.key.isPressed = ea, nr.key.getPressedKeyCodes = ta, nr.key.noConflict = ua, nr.key.unbind = Xn, _n.exports = Wn;
  })(commonjsGlobal);
})(keymaster$1);
var keymasterExports = keymaster$1.exports;
const keymaster = /* @__PURE__ */ getDefaultExportFromCjs(keymasterExports), setKeyboardDressShow = (_n) => {
  var Bn, In;
  const nr = /* @__PURE__ */ new Map([
    [17, WinKeyboard.CTRL],
    [32, WinKeyboard.SPACE]
  ]), Cn = document.getElementById("keyboard-dress-show");
  if (Cn) {
    if (!_n) {
      (Bn = window.onKeySpacePressHold) == null || Bn.call(window, !1), Cn.innerText = "";
      return;
    }
    _n && nr.has(_n) && (_n == 32 && ((In = window.onKeySpacePressHold) == null || In.call(window, !0)), Cn.innerText = `按下了「${nr.get(_n)}」键`);
  }
}, chartEditStore$1 = useChartEditStore(), winCtrlMerge = (_n) => `${WinKeyboard.CTRL}+${_n}`, winShiftMerge = (_n) => `${WinKeyboard.SHIFT}+${_n}`, winKeyboardValue = {
  [MenuEnum.ALL]: winCtrlMerge("a"),
  [MenuEnum.ARROW_UP]: winCtrlMerge("up"),
  [MenuEnum.ARROW_RIGHT]: winCtrlMerge("right"),
  [MenuEnum.ARROW_DOWN]: winCtrlMerge("down"),
  [MenuEnum.ARROW_LEFT]: winCtrlMerge("left"),
  [MenuEnum.COPY]: winCtrlMerge("c"),
  [MenuEnum.CUT]: winCtrlMerge("x"),
  [MenuEnum.PARSE]: winCtrlMerge("v"),
  [MenuEnum.DELETE]: "delete",
  [MenuEnum.BACK]: winCtrlMerge("z"),
  [MenuEnum.FORWORD]: winCtrlMerge(winShiftMerge("z")),
  [MenuEnum.GROUP]: winCtrlMerge("g"),
  [MenuEnum.UN_GROUP]: winCtrlMerge(winShiftMerge("g")),
  [MenuEnum.LOCK]: winCtrlMerge("l"),
  [MenuEnum.UNLOCK]: winCtrlMerge(winShiftMerge("l")),
  [MenuEnum.HIDE]: winCtrlMerge("h"),
  [MenuEnum.SHOW]: winCtrlMerge(winShiftMerge("h"))
}, macCtrlMerge = (_n) => `${MacKeyboard.CTRL}+${_n}`, macShiftMerge = (_n) => `${MacKeyboard.SHIFT}+${_n}`, macKeyboardValue = {
  [MenuEnum.ALL]: macCtrlMerge("a"),
  [MenuEnum.ARROW_UP]: macCtrlMerge("arrowup"),
  [MenuEnum.ARROW_RIGHT]: macCtrlMerge("arrowright"),
  [MenuEnum.ARROW_DOWN]: macCtrlMerge("arrowdown"),
  [MenuEnum.ARROW_LEFT]: macCtrlMerge("arrowleft"),
  [MenuEnum.COPY]: macCtrlMerge("c"),
  [MenuEnum.CUT]: macCtrlMerge("x"),
  [MenuEnum.PARSE]: macCtrlMerge("v"),
  [MenuEnum.DELETE]: macCtrlMerge("backspace"),
  [MenuEnum.BACK]: macCtrlMerge("z"),
  [MenuEnum.FORWORD]: macCtrlMerge(macShiftMerge("z")),
  [MenuEnum.GROUP]: macCtrlMerge("g"),
  [MenuEnum.UN_GROUP]: macCtrlMerge(macShiftMerge("g")),
  [MenuEnum.LOCK]: macCtrlMerge("l"),
  [MenuEnum.UNLOCK]: macCtrlMerge(macShiftMerge("l")),
  [MenuEnum.HIDE]: macCtrlMerge("h"),
  [MenuEnum.SHOW]: macCtrlMerge(macShiftMerge("h"))
}, winKeyList = [
  winKeyboardValue.up,
  winKeyboardValue.right,
  winKeyboardValue.down,
  winKeyboardValue.left,
  winKeyboardValue.all,
  winKeyboardValue.delete,
  winKeyboardValue.copy,
  winKeyboardValue.cut,
  winKeyboardValue.parse,
  winKeyboardValue.back,
  winKeyboardValue.forward,
  winKeyboardValue.group,
  winKeyboardValue.unGroup,
  winKeyboardValue.lock,
  winKeyboardValue.unLock,
  winKeyboardValue.hide,
  winKeyboardValue.show
], macKeyList = [
  macKeyboardValue.up,
  macKeyboardValue.right,
  macKeyboardValue.down,
  macKeyboardValue.left,
  winKeyboardValue.all,
  macKeyboardValue.delete,
  macKeyboardValue.copy,
  macKeyboardValue.cut,
  macKeyboardValue.parse,
  macKeyboardValue.back,
  macKeyboardValue.forward,
  macKeyboardValue.group,
  macKeyboardValue.unGroup,
  macKeyboardValue.lock,
  macKeyboardValue.unLock,
  macKeyboardValue.hide,
  macKeyboardValue.show
], keyRecordHandle = () => {
  window.$KeyboardActive = {
    ctrl: !1,
    space: !1
  }, document.onkeydown = (_n) => {
    const { keyCode: nr } = _n;
    if (nr == 32 && _n.target == document.body && _n.preventDefault(), [17, 32].includes(nr) && window.$KeyboardActive)
      switch (setKeyboardDressShow(_n.keyCode), nr) {
        case 17:
          window.$KeyboardActive.ctrl = !0;
          break;
        case 32:
          window.$KeyboardActive.space = !0;
          break;
      }
  }, document.onkeyup = (_n) => {
    const { keyCode: nr } = _n;
    if (nr == 32 && _n.target == document.body && _n.preventDefault(), [17, 32].includes(nr) && window.$KeyboardActive)
      switch (setKeyboardDressShow(), nr) {
        case 17:
          window.$KeyboardActive.ctrl = !1;
          break;
        case 32:
          window.$KeyboardActive.space = !1;
          break;
      }
  };
}, useAddKeyboard = () => {
  const nr = (Cn, Bn) => {
    switch (Bn) {
      case Cn.up:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setMove(MenuEnum.ARROW_UP), !1), 50));
        break;
      case Cn.right:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setMove(MenuEnum.ARROW_RIGHT), !1), 50));
        break;
      case Cn.down:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setMove(MenuEnum.ARROW_DOWN), !1), 50));
        break;
      case Cn.left:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setMove(MenuEnum.ARROW_LEFT), !1), 50));
        break;
      case Cn.delete:
        keymaster(Bn, debounce$1(() => (chartEditStore$1.removeComponentList(), !1), 50));
        break;
      case Cn.copy:
        keymaster(Bn, debounce$1(() => (chartEditStore$1.setCopy(), !1), 50));
        break;
      case Cn.cut:
        keymaster(Bn, debounce$1(() => (chartEditStore$1.setCut(), !1), 50));
        break;
      case Cn.parse:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setParse(), !1), 50));
        break;
      case Cn.back:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setBack(), !1), 50));
        break;
      case Cn.forward:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setForward(), !1), 50));
        break;
      case Cn.group:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setGroup(), !1), 50));
        break;
      case Cn.unGroup:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setUnGroup(), !1), 50));
        break;
      case Cn.lock:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setLock(), !1), 50));
        break;
      case Cn.unLock:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setUnLock(), !1), 50));
        break;
      case Cn.hide:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setHide(), !1), 50));
        break;
      case Cn.show:
        keymaster(Bn, throttle$2(() => (chartEditStore$1.setShow(), !1), 50));
        break;
      case Cn.all:
        keymaster(Bn, throttle$2(() => (console.log("全选"), !1), 50));
        break;
    }
  };
  winKeyList.forEach((Cn) => {
    nr(winKeyboardValue, Cn);
  }), macKeyList.forEach((Cn) => {
    nr(macKeyboardValue, Cn);
  }), keyRecordHandle();
}, _hoisted_1$7 = { class: "layout-main" }, _hoisted_2$5 = { class: "bottom-bar" }, _hoisted_3$3 = { class: "right-menu-wrap" }, _hoisted_4$2 = ["onClick"], _hoisted_5 = { class: "right-menu-item-icon" }, _hoisted_6 = { class: "right-menu-item-text" }, _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "CanvasEdit",
  setup(_n) {
    const nr = (Yn, Wn, Xn, ea) => {
      if (Pn.getTargetChart.selectId.length > 1)
        return Wn.filter((na) => [MenuEnum.GROUP, MenuEnum.DELETE].includes(na.key));
      const ta = [];
      return ea || ta.push(MenuEnum.REMOVEGROUP), Xn.status.lock ? ta.push(MenuEnum.LOCK) : ta.push(MenuEnum.UNLOCK), Xn.status.hide ? ta.push(MenuEnum.HIDE) : ta.push(MenuEnum.SHOW), (Xn.isTemplate || ["Page"].includes(Xn.chartConfig.key)) && (ta.push(MenuEnum.TEMPLATE), ta.push("dt")), Yn.filter((na) => !ta.includes(na.key));
    }, { mouseenterHandle: Cn, mouseleaveHandle: Bn, mousedownHandle: In, mouseClickHandle: Dn } = useMouseHandle(), { menuOptions: Ln, mousePosition: $n, onClickOutSide: Nn, handleContextMenu: Rn, handleMenuSelect: Fn } = useContextMenu(), Pn = useChartEditStore();
    useHistoryStore().canvasInit(Pn.getEditCanvas), inject("pageData");
    const Hn = computed(() => Pn.getEditCanvasConfig.chartThemeSetting), zn = computed(() => colorCustomMerge(Pn.getEditCanvasConfig.chartCustomThemeColorInfo)[Pn.getEditCanvasConfig.chartThemeColor]), Gn = computed(() => {
      const Yn = Pn.getEditCanvasConfig.background, Wn = Pn.getEditCanvasConfig.backgroundImage, Xn = Pn.getEditCanvasConfig.backgroundFit;
      return {
        ...Pn.getEditCanvasConfig.selectColor ? { background: Yn || void 0 } : { background: `url(${Wn}) no-repeat center center / ${Xn}` },
        width: "inherit",
        height: "inherit"
      };
    });
    return useLayout(), onMounted(() => {
      useAddKeyboard();
    }), (Yn, Wn) => {
      const Xn = __unplugin_components_0;
      return openBlock(), createElementBlock(Fragment, null, [
        createElementVNode("div", _hoisted_1$7, [
          createElementVNode("div", {
            id: "edit_layout",
            class: "edit-layout",
            onMousedown: Wn[2] || (Wn[2] = //@ts-ignore
            (...ea) => unref(mousedownHandleUnStop) && unref(mousedownHandleUnStop)(...ea)),
            onDrop: Wn[3] || (Wn[3] = //@ts-ignore
            (...ea) => unref(dragHandle) && unref(dragHandle)(...ea)),
            onDragover: Wn[4] || (Wn[4] = //@ts-ignore
            (...ea) => unref(dragoverHandle) && unref(dragoverHandle)(...ea)),
            onDragenter: Wn[5] || (Wn[5] = //@ts-ignore
            (...ea) => unref(dragoverHandle) && unref(dragoverHandle)(...ea))
          }, [
            createVNode$1(unref(EditRule), null, {
              default: withCtx(() => [
                createElementVNode("div", {
                  id: "dms-chart-edit-content",
                  onContextmenu: Wn[1] || (Wn[1] = //@ts-ignore
                  (...ea) => unref(Rn) && unref(Rn)(...ea))
                }, [
                  createVNode$1(EditRange, null, {
                    default: withCtx(() => [
                      createElementVNode("div", {
                        style: normalizeStyle$1({ ...unref(getFilterStyle)(unref(Pn).getEditCanvasConfig), ...Gn.value, ...unref(getBlendModeStyle)(unref(Pn).getEditCanvasConfig) })
                      }, [
                        (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(Pn).getComponentList, (ea, ta) => (openBlock(), createElementBlock("div", {
                          key: ea.id
                        }, [
                          ea.isGroup ? (openBlock(), createBlock(_sfc_main$e, {
                            key: 0,
                            groupData: ea,
                            groupIndex: ta
                          }, null, 8, ["groupData", "groupIndex"])) : (openBlock(), createBlock(EditShapeBox, {
                            key: 1,
                            "data-id": ea.id,
                            index: ta,
                            style: normalizeStyle$1({
                              ...unref(useComponentStyle)(ea.attr, ta),
                              ...unref(getBlendModeStyle)(ea.styles)
                            }),
                            item: ea,
                            onClick: (na) => unref(Dn)(na, ea),
                            onMousedown: (na) => unref(In)(na, ea),
                            onMouseenter: (na) => unref(Cn)(na, ea),
                            onMouseleave: Wn[0] || (Wn[0] = (na) => unref(Bn)(na)),
                            onContextmenu: (na) => unref(Rn)(na, ea, nr)
                          }, {
                            default: withCtx(() => [
                              (openBlock(), createBlock(resolveDynamicComponent(ea.chartConfig.chartKey), {
                                class: normalizeClass(["edit-content-chart", unref(animationsClass)(ea.styles.animations) + (ea.isTemplate ? " is-template" : " ")]),
                                style: normalizeStyle$1({
                                  ...unref(useSizeStyle)(ea.attr),
                                  ...unref(getFilterStyle)(ea.styles),
                                  ...unref(getTransformStyle)(ea.styles)
                                }),
                                chartConfig: ea,
                                themeSetting: Hn.value,
                                themeColor: zn.value
                              }, null, 8, ["class", "style", "chartConfig", "themeSetting", "themeColor"]))
                            ]),
                            _: 2
                          }, 1032, ["data-id", "index", "style", "item", "onClick", "onMousedown", "onMouseenter", "onContextmenu"]))
                        ]))), 128))
                      ], 4)
                    ]),
                    _: 1
                  })
                ], 32)
              ]),
              _: 1
            })
          ], 32),
          createElementVNode("div", _hoisted_2$5, [
            createVNode$1(EditBottom)
          ])
        ]),
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          unref(Pn).getRightMenuShow ? withDirectives((openBlock(), createElementBlock("div", {
            key: 0,
            class: "right-menu",
            style: normalizeStyle$1({ left: unref($n).x + "px", top: unref($n).y + "px" })
          }, [
            createElementVNode("div", _hoisted_3$3, [
              (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(Ln), (ea) => (openBlock(), createElementBlock("div", {
                key: ea.key,
                class: normalizeClass(ea.type === "divider" ? "divider" : "right-menu-item")
              }, [
                ea.type !== "divider" ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "right-menu-item-wrap",
                  onClick: (ta) => unref(Fn)(ea.key)
                }, [
                  createElementVNode("div", _hoisted_5, [
                    createVNode$1(Xn, {
                      "icon-class": ea.icon
                    }, null, 8, ["icon-class"])
                  ]),
                  createElementVNode("div", _hoisted_6, toDisplayString(ea.label), 1)
                ], 8, _hoisted_4$2)) : createCommentVNode("", !0)
              ], 2))), 128))
            ])
          ], 4)), [
            [unref(ClickOutside), unref(Nn)]
          ]) : createCommentVNode("", !0)
        ]))
      ], 64);
    };
  }
}), CanvasEdit_vue_vue_type_style_index_0_scoped_76283237_lang = "", CanvasEdit = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-76283237"]]), SettingItem_vue_vue_type_style_index_0_scoped_d772b3a5_lang = "";
function tryOnScopeDispose(_n) {
  return getCurrentScope() ? (onScopeDispose(_n), !0) : !1;
}
function toValue(_n) {
  return typeof _n == "function" ? _n() : unref(_n);
}
const isClient = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const toString$1 = Object.prototype.toString, isObject$3 = (_n) => toString$1.call(_n) === "[object Object]", noop = () => {
}, isIOS = /* @__PURE__ */ getIsIOS();
function getIsIOS() {
  var _n, nr;
  return isClient && ((_n = window == null ? void 0 : window.navigator) == null ? void 0 : _n.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((nr = window == null ? void 0 : window.navigator) == null ? void 0 : nr.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(_n, nr) {
  function Cn(...Bn) {
    return new Promise((In, Dn) => {
      Promise.resolve(_n(() => nr.apply(this, Bn), { fn: nr, thisArg: this, args: Bn })).then(In).catch(Dn);
    });
  }
  return Cn;
}
const bypassFilter = (_n) => _n();
function debounceFilter(_n, nr = {}) {
  let Cn, Bn, In = noop;
  const Dn = ($n) => {
    clearTimeout($n), In(), In = noop;
  };
  return ($n) => {
    const Nn = toValue(_n), Rn = toValue(nr.maxWait);
    return Cn && Dn(Cn), Nn <= 0 || Rn !== void 0 && Rn <= 0 ? (Bn && (Dn(Bn), Bn = null), Promise.resolve($n())) : new Promise((Fn, Pn) => {
      In = nr.rejectOnCancel ? Pn : Fn, Rn && !Bn && (Bn = setTimeout(() => {
        Cn && Dn(Cn), Bn = null, Fn($n());
      }, Rn)), Cn = setTimeout(() => {
        Bn && Dn(Bn), Bn = null, Fn($n());
      }, Nn);
    });
  };
}
function pausableFilter(_n = bypassFilter) {
  const nr = ref(!0);
  function Cn() {
    nr.value = !1;
  }
  function Bn() {
    nr.value = !0;
  }
  const In = (...Dn) => {
    nr.value && _n(...Dn);
  };
  return { isActive: readonly(nr), pause: Cn, resume: Bn, eventFilter: In };
}
function createSingletonPromise(_n) {
  let nr;
  function Cn() {
    return nr || (nr = _n()), nr;
  }
  return Cn.reset = async () => {
    const Bn = nr;
    nr = void 0, Bn && await Bn;
  }, Cn;
}
function getLifeCycleTarget(_n) {
  return _n || getCurrentInstance();
}
function useDebounceFn(_n, nr = 200, Cn = {}) {
  return createFilterWrapper(
    debounceFilter(nr, Cn),
    _n
  );
}
function watchWithFilter(_n, nr, Cn = {}) {
  const {
    eventFilter: Bn = bypassFilter,
    ...In
  } = Cn;
  return watch(
    _n,
    createFilterWrapper(
      Bn,
      nr
    ),
    In
  );
}
function watchPausable(_n, nr, Cn = {}) {
  const {
    eventFilter: Bn,
    ...In
  } = Cn, { eventFilter: Dn, pause: Ln, resume: $n, isActive: Nn } = pausableFilter(Bn);
  return { stop: watchWithFilter(
    _n,
    nr,
    {
      ...In,
      eventFilter: Dn
    }
  ), pause: Ln, resume: $n, isActive: Nn };
}
function tryOnMounted(_n, nr = !0, Cn) {
  getLifeCycleTarget() ? onMounted(_n, Cn) : nr ? _n() : nextTick(_n);
}
function useTimeoutFn(_n, nr, Cn = {}) {
  const {
    immediate: Bn = !0
  } = Cn, In = ref(!1);
  let Dn = null;
  function Ln() {
    Dn && (clearTimeout(Dn), Dn = null);
  }
  function $n() {
    In.value = !1, Ln();
  }
  function Nn(...Rn) {
    Ln(), In.value = !0, Dn = setTimeout(() => {
      In.value = !1, Dn = null, _n(...Rn);
    }, toValue(nr));
  }
  return Bn && (In.value = !0, isClient && Nn()), tryOnScopeDispose($n), {
    isPending: readonly(In),
    start: Nn,
    stop: $n
  };
}
function whenever(_n, nr, Cn) {
  const Bn = watch(
    _n,
    (In, Dn, Ln) => {
      In && (Cn != null && Cn.once && nextTick(() => Bn()), nr(In, Dn, Ln));
    },
    {
      ...Cn,
      once: !1
    }
  );
  return Bn;
}
function unrefElement(_n) {
  var nr;
  const Cn = toValue(_n);
  return (nr = Cn == null ? void 0 : Cn.$el) != null ? nr : Cn;
}
const defaultWindow = isClient ? window : void 0, defaultNavigator = isClient ? window.navigator : void 0;
function useEventListener(..._n) {
  let nr, Cn, Bn, In;
  if (typeof _n[0] == "string" || Array.isArray(_n[0]) ? ([Cn, Bn, In] = _n, nr = defaultWindow) : [nr, Cn, Bn, In] = _n, !nr)
    return noop;
  Array.isArray(Cn) || (Cn = [Cn]), Array.isArray(Bn) || (Bn = [Bn]);
  const Dn = [], Ln = () => {
    Dn.forEach((Fn) => Fn()), Dn.length = 0;
  }, $n = (Fn, Pn, Un, Hn) => (Fn.addEventListener(Pn, Un, Hn), () => Fn.removeEventListener(Pn, Un, Hn)), Nn = watch(
    () => [unrefElement(nr), toValue(In)],
    ([Fn, Pn]) => {
      if (Ln(), !Fn)
        return;
      const Un = isObject$3(Pn) ? { ...Pn } : Pn;
      Dn.push(
        ...Cn.flatMap((Hn) => Bn.map((zn) => $n(Fn, Hn, zn, Un)))
      );
    },
    { immediate: !0, flush: "post" }
  ), Rn = () => {
    Nn(), Ln();
  };
  return tryOnScopeDispose(Rn), Rn;
}
let _iOSWorkaround = !1;
function onClickOutside(_n, nr, Cn = {}) {
  const { window: Bn = defaultWindow, ignore: In = [], capture: Dn = !0, detectIframe: Ln = !1 } = Cn;
  if (!Bn)
    return noop;
  isIOS && !_iOSWorkaround && (_iOSWorkaround = !0, Array.from(Bn.document.body.children).forEach((Un) => Un.addEventListener("click", noop)), Bn.document.documentElement.addEventListener("click", noop));
  let $n = !0;
  const Nn = (Un) => In.some((Hn) => {
    if (typeof Hn == "string")
      return Array.from(Bn.document.querySelectorAll(Hn)).some((zn) => zn === Un.target || Un.composedPath().includes(zn));
    {
      const zn = unrefElement(Hn);
      return zn && (Un.target === zn || Un.composedPath().includes(zn));
    }
  }), Fn = [
    useEventListener(Bn, "click", (Un) => {
      const Hn = unrefElement(_n);
      if (!(!Hn || Hn === Un.target || Un.composedPath().includes(Hn))) {
        if (Un.detail === 0 && ($n = !Nn(Un)), !$n) {
          $n = !0;
          return;
        }
        nr(Un);
      }
    }, { passive: !0, capture: Dn }),
    useEventListener(Bn, "pointerdown", (Un) => {
      const Hn = unrefElement(_n);
      $n = !Nn(Un) && !!(Hn && !Un.composedPath().includes(Hn));
    }, { passive: !0 }),
    Ln && useEventListener(Bn, "blur", (Un) => {
      setTimeout(() => {
        var Hn;
        const zn = unrefElement(_n);
        ((Hn = Bn.document.activeElement) == null ? void 0 : Hn.tagName) === "IFRAME" && !(zn != null && zn.contains(Bn.document.activeElement)) && nr(Un);
      }, 0);
    })
  ].filter(Boolean);
  return () => Fn.forEach((Un) => Un());
}
function useMounted() {
  const _n = ref(!1), nr = getCurrentInstance();
  return nr && onMounted(() => {
    _n.value = !0;
  }, nr), _n;
}
function useSupported(_n) {
  const nr = useMounted();
  return computed(() => (nr.value, !!_n()));
}
function usePermission(_n, nr = {}) {
  const {
    controls: Cn = !1,
    navigator: Bn = defaultNavigator
  } = nr, In = useSupported(() => Bn && "permissions" in Bn);
  let Dn;
  const Ln = typeof _n == "string" ? { name: _n } : _n, $n = ref(), Nn = () => {
    Dn && ($n.value = Dn.state);
  }, Rn = createSingletonPromise(async () => {
    if (In.value) {
      if (!Dn)
        try {
          Dn = await Bn.permissions.query(Ln), useEventListener(Dn, "change", Nn), Nn();
        } catch {
          $n.value = "prompt";
        }
      return Dn;
    }
  });
  return Rn(), Cn ? {
    state: $n,
    isSupported: In,
    query: Rn
  } : $n;
}
function useClipboard(_n = {}) {
  const {
    navigator: nr = defaultNavigator,
    read: Cn = !1,
    source: Bn,
    copiedDuring: In = 1500,
    legacy: Dn = !1
  } = _n, Ln = useSupported(() => nr && "clipboard" in nr), $n = usePermission("clipboard-read"), Nn = usePermission("clipboard-write"), Rn = computed(() => Ln.value || Dn), Fn = ref(""), Pn = ref(!1), Un = useTimeoutFn(() => Pn.value = !1, In);
  function Hn() {
    Ln.value && Wn($n.value) ? nr.clipboard.readText().then((Xn) => {
      Fn.value = Xn;
    }) : Fn.value = Yn();
  }
  Rn.value && Cn && useEventListener(["copy", "cut"], Hn);
  async function zn(Xn = toValue(Bn)) {
    Rn.value && Xn != null && (Ln.value && Wn(Nn.value) ? await nr.clipboard.writeText(Xn) : Gn(Xn), Fn.value = Xn, Pn.value = !0, Un.start());
  }
  function Gn(Xn) {
    const ea = document.createElement("textarea");
    ea.value = Xn ?? "", ea.style.position = "absolute", ea.style.opacity = "0", document.body.appendChild(ea), ea.select(), document.execCommand("copy"), ea.remove();
  }
  function Yn() {
    var Xn, ea, ta;
    return (ta = (ea = (Xn = document == null ? void 0 : document.getSelection) == null ? void 0 : Xn.call(document)) == null ? void 0 : ea.toString()) != null ? ta : "";
  }
  function Wn(Xn) {
    return Xn === "granted" || Xn === "prompt";
  }
  return {
    isSupported: Rn,
    text: Fn,
    copied: Pn,
    copy: zn
  };
}
const _global = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, globalKey = "__vueuse_ssr_handlers__", handlers$2 = /* @__PURE__ */ getHandlers();
function getHandlers() {
  return globalKey in _global || (_global[globalKey] = _global[globalKey] || {}), _global[globalKey];
}
function getSSRHandler(_n, nr) {
  return handlers$2[_n] || nr;
}
function guessSerializerType(_n) {
  return _n == null ? "any" : _n instanceof Set ? "set" : _n instanceof Map ? "map" : _n instanceof Date ? "date" : typeof _n == "boolean" ? "boolean" : typeof _n == "string" ? "string" : typeof _n == "object" ? "object" : Number.isNaN(_n) ? "any" : "number";
}
const StorageSerializers = {
  boolean: {
    read: (_n) => _n === "true",
    write: (_n) => String(_n)
  },
  object: {
    read: (_n) => JSON.parse(_n),
    write: (_n) => JSON.stringify(_n)
  },
  number: {
    read: (_n) => Number.parseFloat(_n),
    write: (_n) => String(_n)
  },
  any: {
    read: (_n) => _n,
    write: (_n) => String(_n)
  },
  string: {
    read: (_n) => _n,
    write: (_n) => String(_n)
  },
  map: {
    read: (_n) => new Map(JSON.parse(_n)),
    write: (_n) => JSON.stringify(Array.from(_n.entries()))
  },
  set: {
    read: (_n) => new Set(JSON.parse(_n)),
    write: (_n) => JSON.stringify(Array.from(_n))
  },
  date: {
    read: (_n) => new Date(_n),
    write: (_n) => _n.toISOString()
  }
}, customStorageEventName = "vueuse-storage";
function useStorage(_n, nr, Cn, Bn = {}) {
  var In;
  const {
    flush: Dn = "pre",
    deep: Ln = !0,
    listenToStorageChanges: $n = !0,
    writeDefaults: Nn = !0,
    mergeDefaults: Rn = !1,
    shallow: Fn,
    window: Pn = defaultWindow,
    eventFilter: Un,
    onError: Hn = (sa) => {
      console.error(sa);
    },
    initOnMounted: zn
  } = Bn, Gn = (Fn ? shallowRef : ref)(typeof nr == "function" ? nr() : nr);
  if (!Cn)
    try {
      Cn = getSSRHandler("getDefaultStorage", () => {
        var sa;
        return (sa = defaultWindow) == null ? void 0 : sa.localStorage;
      })();
    } catch (sa) {
      Hn(sa);
    }
  if (!Cn)
    return Gn;
  const Yn = toValue(nr), Wn = guessSerializerType(Yn), Xn = (In = Bn.serializer) != null ? In : StorageSerializers[Wn], { pause: ea, resume: ta } = watchPausable(
    Gn,
    () => ra(Gn.value),
    { flush: Dn, deep: Ln, eventFilter: Un }
  );
  Pn && $n && tryOnMounted(() => {
    useEventListener(Pn, "storage", ia), useEventListener(Pn, customStorageEventName, Aa), zn && ia();
  }), zn || ia();
  function na(sa, oa) {
    Pn && Pn.dispatchEvent(new CustomEvent(customStorageEventName, {
      detail: {
        key: _n,
        oldValue: sa,
        newValue: oa,
        storageArea: Cn
      }
    }));
  }
  function ra(sa) {
    try {
      const oa = Cn.getItem(_n);
      if (sa == null)
        na(oa, null), Cn.removeItem(_n);
      else {
        const la = Xn.write(sa);
        oa !== la && (Cn.setItem(_n, la), na(oa, la));
      }
    } catch (oa) {
      Hn(oa);
    }
  }
  function aa(sa) {
    const oa = sa ? sa.newValue : Cn.getItem(_n);
    if (oa == null)
      return Nn && Yn != null && Cn.setItem(_n, Xn.write(Yn)), Yn;
    if (!sa && Rn) {
      const la = Xn.read(oa);
      return typeof Rn == "function" ? Rn(la, Yn) : Wn === "object" && !Array.isArray(la) ? { ...Yn, ...la } : la;
    } else
      return typeof oa != "string" ? oa : Xn.read(oa);
  }
  function ia(sa) {
    if (!(sa && sa.storageArea !== Cn)) {
      if (sa && sa.key == null) {
        Gn.value = Yn;
        return;
      }
      if (!(sa && sa.key !== _n)) {
        ea();
        try {
          (sa == null ? void 0 : sa.newValue) !== Xn.write(Gn.value) && (Gn.value = aa(sa));
        } catch (oa) {
          Hn(oa);
        } finally {
          sa ? nextTick(ta) : ta();
        }
      }
    }
  }
  function Aa(sa) {
    ia(sa.detail);
  }
  return Gn;
}
function useLocalStorage(_n, nr, Cn = {}) {
  const { window: Bn = defaultWindow } = Cn;
  return useStorage(_n, nr, Bn == null ? void 0 : Bn.localStorage, Cn);
}
function _typeof(_n) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(nr) {
    return typeof nr;
  } : function(nr) {
    return nr && typeof Symbol == "function" && nr.constructor === Symbol && nr !== Symbol.prototype ? "symbol" : typeof nr;
  }, _typeof(_n);
}
var trimLeft = /^\s+/, trimRight = /\s+$/;
function tinycolor(_n, nr) {
  if (_n = _n || "", nr = nr || {}, _n instanceof tinycolor)
    return _n;
  if (!(this instanceof tinycolor))
    return new tinycolor(_n, nr);
  var Cn = inputToRGB(_n);
  this._originalInput = _n, this._r = Cn.r, this._g = Cn.g, this._b = Cn.b, this._a = Cn.a, this._roundA = Math.round(100 * this._a) / 100, this._format = nr.format || Cn.format, this._gradientType = nr.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = Cn.ok;
}
tinycolor.prototype = {
  isDark: function _n() {
    return this.getBrightness() < 128;
  },
  isLight: function _n() {
    return !this.isDark();
  },
  isValid: function _n() {
    return this._ok;
  },
  getOriginalInput: function _n() {
    return this._originalInput;
  },
  getFormat: function _n() {
    return this._format;
  },
  getAlpha: function _n() {
    return this._a;
  },
  getBrightness: function _n() {
    var nr = this.toRgb();
    return (nr.r * 299 + nr.g * 587 + nr.b * 114) / 1e3;
  },
  getLuminance: function _n() {
    var nr = this.toRgb(), Cn, Bn, In, Dn, Ln, $n;
    return Cn = nr.r / 255, Bn = nr.g / 255, In = nr.b / 255, Cn <= 0.03928 ? Dn = Cn / 12.92 : Dn = Math.pow((Cn + 0.055) / 1.055, 2.4), Bn <= 0.03928 ? Ln = Bn / 12.92 : Ln = Math.pow((Bn + 0.055) / 1.055, 2.4), In <= 0.03928 ? $n = In / 12.92 : $n = Math.pow((In + 0.055) / 1.055, 2.4), 0.2126 * Dn + 0.7152 * Ln + 0.0722 * $n;
  },
  setAlpha: function _n(nr) {
    return this._a = boundAlpha(nr), this._roundA = Math.round(100 * this._a) / 100, this;
  },
  toHsv: function _n() {
    var nr = rgbToHsv(this._r, this._g, this._b);
    return {
      h: nr.h * 360,
      s: nr.s,
      v: nr.v,
      a: this._a
    };
  },
  toHsvString: function _n() {
    var nr = rgbToHsv(this._r, this._g, this._b), Cn = Math.round(nr.h * 360), Bn = Math.round(nr.s * 100), In = Math.round(nr.v * 100);
    return this._a == 1 ? "hsv(" + Cn + ", " + Bn + "%, " + In + "%)" : "hsva(" + Cn + ", " + Bn + "%, " + In + "%, " + this._roundA + ")";
  },
  toHsl: function _n() {
    var nr = rgbToHsl(this._r, this._g, this._b);
    return {
      h: nr.h * 360,
      s: nr.s,
      l: nr.l,
      a: this._a
    };
  },
  toHslString: function _n() {
    var nr = rgbToHsl(this._r, this._g, this._b), Cn = Math.round(nr.h * 360), Bn = Math.round(nr.s * 100), In = Math.round(nr.l * 100);
    return this._a == 1 ? "hsl(" + Cn + ", " + Bn + "%, " + In + "%)" : "hsla(" + Cn + ", " + Bn + "%, " + In + "%, " + this._roundA + ")";
  },
  toHex: function _n(nr) {
    return rgbToHex(this._r, this._g, this._b, nr);
  },
  toHexString: function _n(nr) {
    return "#" + this.toHex(nr);
  },
  toHex8: function _n(nr) {
    return rgbaToHex(this._r, this._g, this._b, this._a, nr);
  },
  toHex8String: function _n(nr) {
    return "#" + this.toHex8(nr);
  },
  toRgb: function _n() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function _n() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function _n() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function _n() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function _n() {
    return this._a === 0 ? "transparent" : this._a < 1 ? !1 : hexNames[rgbToHex(this._r, this._g, this._b, !0)] || !1;
  },
  toFilter: function _n(nr) {
    var Cn = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a), Bn = Cn, In = this._gradientType ? "GradientType = 1, " : "";
    if (nr) {
      var Dn = tinycolor(nr);
      Bn = "#" + rgbaToArgbHex(Dn._r, Dn._g, Dn._b, Dn._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + In + "startColorstr=" + Cn + ",endColorstr=" + Bn + ")";
  },
  toString: function _n(nr) {
    var Cn = !!nr;
    nr = nr || this._format;
    var Bn = !1, In = this._a < 1 && this._a >= 0, Dn = !Cn && In && (nr === "hex" || nr === "hex6" || nr === "hex3" || nr === "hex4" || nr === "hex8" || nr === "name");
    return Dn ? nr === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (nr === "rgb" && (Bn = this.toRgbString()), nr === "prgb" && (Bn = this.toPercentageRgbString()), (nr === "hex" || nr === "hex6") && (Bn = this.toHexString()), nr === "hex3" && (Bn = this.toHexString(!0)), nr === "hex4" && (Bn = this.toHex8String(!0)), nr === "hex8" && (Bn = this.toHex8String()), nr === "name" && (Bn = this.toName()), nr === "hsl" && (Bn = this.toHslString()), nr === "hsv" && (Bn = this.toHsvString()), Bn || this.toHexString());
  },
  clone: function _n() {
    return tinycolor(this.toString());
  },
  _applyModification: function _n(nr, Cn) {
    var Bn = nr.apply(null, [this].concat([].slice.call(Cn)));
    return this._r = Bn._r, this._g = Bn._g, this._b = Bn._b, this.setAlpha(Bn._a), this;
  },
  lighten: function _n() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function _n() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function _n() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function _n() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function _n() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function _n() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function _n() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _n(nr, Cn) {
    return nr.apply(null, [this].concat([].slice.call(Cn)));
  },
  analogous: function _n() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function _n() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function _n() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function _n() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function _n() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function _n() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(_n, nr) {
  if (_typeof(_n) == "object") {
    var Cn = {};
    for (var Bn in _n)
      _n.hasOwnProperty(Bn) && (Bn === "a" ? Cn[Bn] = _n[Bn] : Cn[Bn] = convertToPercentage(_n[Bn]));
    _n = Cn;
  }
  return tinycolor(_n, nr);
};
function inputToRGB(_n) {
  var nr = {
    r: 0,
    g: 0,
    b: 0
  }, Cn = 1, Bn = null, In = null, Dn = null, Ln = !1, $n = !1;
  return typeof _n == "string" && (_n = stringInputToObject(_n)), _typeof(_n) == "object" && (isValidCSSUnit(_n.r) && isValidCSSUnit(_n.g) && isValidCSSUnit(_n.b) ? (nr = rgbToRgb(_n.r, _n.g, _n.b), Ln = !0, $n = String(_n.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(_n.h) && isValidCSSUnit(_n.s) && isValidCSSUnit(_n.v) ? (Bn = convertToPercentage(_n.s), In = convertToPercentage(_n.v), nr = hsvToRgb(_n.h, Bn, In), Ln = !0, $n = "hsv") : isValidCSSUnit(_n.h) && isValidCSSUnit(_n.s) && isValidCSSUnit(_n.l) && (Bn = convertToPercentage(_n.s), Dn = convertToPercentage(_n.l), nr = hslToRgb(_n.h, Bn, Dn), Ln = !0, $n = "hsl"), _n.hasOwnProperty("a") && (Cn = _n.a)), Cn = boundAlpha(Cn), {
    ok: Ln,
    format: _n.format || $n,
    r: Math.min(255, Math.max(nr.r, 0)),
    g: Math.min(255, Math.max(nr.g, 0)),
    b: Math.min(255, Math.max(nr.b, 0)),
    a: Cn
  };
}
function rgbToRgb(_n, nr, Cn) {
  return {
    r: bound01(_n, 255) * 255,
    g: bound01(nr, 255) * 255,
    b: bound01(Cn, 255) * 255
  };
}
function rgbToHsl(_n, nr, Cn) {
  _n = bound01(_n, 255), nr = bound01(nr, 255), Cn = bound01(Cn, 255);
  var Bn = Math.max(_n, nr, Cn), In = Math.min(_n, nr, Cn), Dn, Ln, $n = (Bn + In) / 2;
  if (Bn == In)
    Dn = Ln = 0;
  else {
    var Nn = Bn - In;
    switch (Ln = $n > 0.5 ? Nn / (2 - Bn - In) : Nn / (Bn + In), Bn) {
      case _n:
        Dn = (nr - Cn) / Nn + (nr < Cn ? 6 : 0);
        break;
      case nr:
        Dn = (Cn - _n) / Nn + 2;
        break;
      case Cn:
        Dn = (_n - nr) / Nn + 4;
        break;
    }
    Dn /= 6;
  }
  return {
    h: Dn,
    s: Ln,
    l: $n
  };
}
function hslToRgb(_n, nr, Cn) {
  var Bn, In, Dn;
  _n = bound01(_n, 360), nr = bound01(nr, 100), Cn = bound01(Cn, 100);
  function Ln(Rn, Fn, Pn) {
    return Pn < 0 && (Pn += 1), Pn > 1 && (Pn -= 1), Pn < 1 / 6 ? Rn + (Fn - Rn) * 6 * Pn : Pn < 1 / 2 ? Fn : Pn < 2 / 3 ? Rn + (Fn - Rn) * (2 / 3 - Pn) * 6 : Rn;
  }
  if (nr === 0)
    Bn = In = Dn = Cn;
  else {
    var $n = Cn < 0.5 ? Cn * (1 + nr) : Cn + nr - Cn * nr, Nn = 2 * Cn - $n;
    Bn = Ln(Nn, $n, _n + 1 / 3), In = Ln(Nn, $n, _n), Dn = Ln(Nn, $n, _n - 1 / 3);
  }
  return {
    r: Bn * 255,
    g: In * 255,
    b: Dn * 255
  };
}
function rgbToHsv(_n, nr, Cn) {
  _n = bound01(_n, 255), nr = bound01(nr, 255), Cn = bound01(Cn, 255);
  var Bn = Math.max(_n, nr, Cn), In = Math.min(_n, nr, Cn), Dn, Ln, $n = Bn, Nn = Bn - In;
  if (Ln = Bn === 0 ? 0 : Nn / Bn, Bn == In)
    Dn = 0;
  else {
    switch (Bn) {
      case _n:
        Dn = (nr - Cn) / Nn + (nr < Cn ? 6 : 0);
        break;
      case nr:
        Dn = (Cn - _n) / Nn + 2;
        break;
      case Cn:
        Dn = (_n - nr) / Nn + 4;
        break;
    }
    Dn /= 6;
  }
  return {
    h: Dn,
    s: Ln,
    v: $n
  };
}
function hsvToRgb(_n, nr, Cn) {
  _n = bound01(_n, 360) * 6, nr = bound01(nr, 100), Cn = bound01(Cn, 100);
  var Bn = Math.floor(_n), In = _n - Bn, Dn = Cn * (1 - nr), Ln = Cn * (1 - In * nr), $n = Cn * (1 - (1 - In) * nr), Nn = Bn % 6, Rn = [Cn, Ln, Dn, Dn, $n, Cn][Nn], Fn = [$n, Cn, Cn, Ln, Dn, Dn][Nn], Pn = [Dn, Dn, $n, Cn, Cn, Ln][Nn];
  return {
    r: Rn * 255,
    g: Fn * 255,
    b: Pn * 255
  };
}
function rgbToHex(_n, nr, Cn, Bn) {
  var In = [pad2(Math.round(_n).toString(16)), pad2(Math.round(nr).toString(16)), pad2(Math.round(Cn).toString(16))];
  return Bn && In[0].charAt(0) == In[0].charAt(1) && In[1].charAt(0) == In[1].charAt(1) && In[2].charAt(0) == In[2].charAt(1) ? In[0].charAt(0) + In[1].charAt(0) + In[2].charAt(0) : In.join("");
}
function rgbaToHex(_n, nr, Cn, Bn, In) {
  var Dn = [pad2(Math.round(_n).toString(16)), pad2(Math.round(nr).toString(16)), pad2(Math.round(Cn).toString(16)), pad2(convertDecimalToHex(Bn))];
  return In && Dn[0].charAt(0) == Dn[0].charAt(1) && Dn[1].charAt(0) == Dn[1].charAt(1) && Dn[2].charAt(0) == Dn[2].charAt(1) && Dn[3].charAt(0) == Dn[3].charAt(1) ? Dn[0].charAt(0) + Dn[1].charAt(0) + Dn[2].charAt(0) + Dn[3].charAt(0) : Dn.join("");
}
function rgbaToArgbHex(_n, nr, Cn, Bn) {
  var In = [pad2(convertDecimalToHex(Bn)), pad2(Math.round(_n).toString(16)), pad2(Math.round(nr).toString(16)), pad2(Math.round(Cn).toString(16))];
  return In.join("");
}
tinycolor.equals = function(_n, nr) {
  return !_n || !nr ? !1 : tinycolor(_n).toRgbString() == tinycolor(nr).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(_n, nr) {
  nr = nr === 0 ? 0 : nr || 10;
  var Cn = tinycolor(_n).toHsl();
  return Cn.s -= nr / 100, Cn.s = clamp01(Cn.s), tinycolor(Cn);
}
function _saturate(_n, nr) {
  nr = nr === 0 ? 0 : nr || 10;
  var Cn = tinycolor(_n).toHsl();
  return Cn.s += nr / 100, Cn.s = clamp01(Cn.s), tinycolor(Cn);
}
function _greyscale(_n) {
  return tinycolor(_n).desaturate(100);
}
function _lighten(_n, nr) {
  nr = nr === 0 ? 0 : nr || 10;
  var Cn = tinycolor(_n).toHsl();
  return Cn.l += nr / 100, Cn.l = clamp01(Cn.l), tinycolor(Cn);
}
function _brighten(_n, nr) {
  nr = nr === 0 ? 0 : nr || 10;
  var Cn = tinycolor(_n).toRgb();
  return Cn.r = Math.max(0, Math.min(255, Cn.r - Math.round(255 * -(nr / 100)))), Cn.g = Math.max(0, Math.min(255, Cn.g - Math.round(255 * -(nr / 100)))), Cn.b = Math.max(0, Math.min(255, Cn.b - Math.round(255 * -(nr / 100)))), tinycolor(Cn);
}
function _darken(_n, nr) {
  nr = nr === 0 ? 0 : nr || 10;
  var Cn = tinycolor(_n).toHsl();
  return Cn.l -= nr / 100, Cn.l = clamp01(Cn.l), tinycolor(Cn);
}
function _spin(_n, nr) {
  var Cn = tinycolor(_n).toHsl(), Bn = (Cn.h + nr) % 360;
  return Cn.h = Bn < 0 ? 360 + Bn : Bn, tinycolor(Cn);
}
function _complement(_n) {
  var nr = tinycolor(_n).toHsl();
  return nr.h = (nr.h + 180) % 360, tinycolor(nr);
}
function polyad(_n, nr) {
  if (isNaN(nr) || nr <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var Cn = tinycolor(_n).toHsl(), Bn = [tinycolor(_n)], In = 360 / nr, Dn = 1; Dn < nr; Dn++)
    Bn.push(tinycolor({
      h: (Cn.h + Dn * In) % 360,
      s: Cn.s,
      l: Cn.l
    }));
  return Bn;
}
function _splitcomplement(_n) {
  var nr = tinycolor(_n).toHsl(), Cn = nr.h;
  return [tinycolor(_n), tinycolor({
    h: (Cn + 72) % 360,
    s: nr.s,
    l: nr.l
  }), tinycolor({
    h: (Cn + 216) % 360,
    s: nr.s,
    l: nr.l
  })];
}
function _analogous(_n, nr, Cn) {
  nr = nr || 6, Cn = Cn || 30;
  var Bn = tinycolor(_n).toHsl(), In = 360 / Cn, Dn = [tinycolor(_n)];
  for (Bn.h = (Bn.h - (In * nr >> 1) + 720) % 360; --nr; )
    Bn.h = (Bn.h + In) % 360, Dn.push(tinycolor(Bn));
  return Dn;
}
function _monochromatic(_n, nr) {
  nr = nr || 6;
  for (var Cn = tinycolor(_n).toHsv(), Bn = Cn.h, In = Cn.s, Dn = Cn.v, Ln = [], $n = 1 / nr; nr--; )
    Ln.push(tinycolor({
      h: Bn,
      s: In,
      v: Dn
    })), Dn = (Dn + $n) % 1;
  return Ln;
}
tinycolor.mix = function(_n, nr, Cn) {
  Cn = Cn === 0 ? 0 : Cn || 50;
  var Bn = tinycolor(_n).toRgb(), In = tinycolor(nr).toRgb(), Dn = Cn / 100, Ln = {
    r: (In.r - Bn.r) * Dn + Bn.r,
    g: (In.g - Bn.g) * Dn + Bn.g,
    b: (In.b - Bn.b) * Dn + Bn.b,
    a: (In.a - Bn.a) * Dn + Bn.a
  };
  return tinycolor(Ln);
};
tinycolor.readability = function(_n, nr) {
  var Cn = tinycolor(_n), Bn = tinycolor(nr);
  return (Math.max(Cn.getLuminance(), Bn.getLuminance()) + 0.05) / (Math.min(Cn.getLuminance(), Bn.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(_n, nr, Cn) {
  var Bn = tinycolor.readability(_n, nr), In, Dn;
  switch (Dn = !1, In = validateWCAG2Parms(Cn), In.level + In.size) {
    case "AAsmall":
    case "AAAlarge":
      Dn = Bn >= 4.5;
      break;
    case "AAlarge":
      Dn = Bn >= 3;
      break;
    case "AAAsmall":
      Dn = Bn >= 7;
      break;
  }
  return Dn;
};
tinycolor.mostReadable = function(_n, nr, Cn) {
  var Bn = null, In = 0, Dn, Ln, $n, Nn;
  Cn = Cn || {}, Ln = Cn.includeFallbackColors, $n = Cn.level, Nn = Cn.size;
  for (var Rn = 0; Rn < nr.length; Rn++)
    Dn = tinycolor.readability(_n, nr[Rn]), Dn > In && (In = Dn, Bn = tinycolor(nr[Rn]));
  return tinycolor.isReadable(_n, Bn, {
    level: $n,
    size: Nn
  }) || !Ln ? Bn : (Cn.includeFallbackColors = !1, tinycolor.mostReadable(_n, ["#fff", "#000"], Cn));
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
}, hexNames = tinycolor.hexNames = flip$2(names);
function flip$2(_n) {
  var nr = {};
  for (var Cn in _n)
    _n.hasOwnProperty(Cn) && (nr[_n[Cn]] = Cn);
  return nr;
}
function boundAlpha(_n) {
  return _n = parseFloat(_n), (isNaN(_n) || _n < 0 || _n > 1) && (_n = 1), _n;
}
function bound01(_n, nr) {
  isOnePointZero(_n) && (_n = "100%");
  var Cn = isPercentage(_n);
  return _n = Math.min(nr, Math.max(0, parseFloat(_n))), Cn && (_n = parseInt(_n * nr, 10) / 100), Math.abs(_n - nr) < 1e-6 ? 1 : _n % nr / parseFloat(nr);
}
function clamp01(_n) {
  return Math.min(1, Math.max(0, _n));
}
function parseIntFromHex(_n) {
  return parseInt(_n, 16);
}
function isOnePointZero(_n) {
  return typeof _n == "string" && _n.indexOf(".") != -1 && parseFloat(_n) === 1;
}
function isPercentage(_n) {
  return typeof _n == "string" && _n.indexOf("%") != -1;
}
function pad2(_n) {
  return _n.length == 1 ? "0" + _n : "" + _n;
}
function convertToPercentage(_n) {
  return _n <= 1 && (_n = _n * 100 + "%"), _n;
}
function convertDecimalToHex(_n) {
  return Math.round(parseFloat(_n) * 255).toString(16);
}
function convertHexToDecimal(_n) {
  return parseIntFromHex(_n) / 255;
}
var matchers = function() {
  var _n = "[-\\+]?\\d+%?", nr = "[-\\+]?\\d*\\.\\d+%?", Cn = "(?:" + nr + ")|(?:" + _n + ")", Bn = "[\\s|\\(]+(" + Cn + ")[,|\\s]+(" + Cn + ")[,|\\s]+(" + Cn + ")\\s*\\)?", In = "[\\s|\\(]+(" + Cn + ")[,|\\s]+(" + Cn + ")[,|\\s]+(" + Cn + ")[,|\\s]+(" + Cn + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(Cn),
    rgb: new RegExp("rgb" + Bn),
    rgba: new RegExp("rgba" + In),
    hsl: new RegExp("hsl" + Bn),
    hsla: new RegExp("hsla" + In),
    hsv: new RegExp("hsv" + Bn),
    hsva: new RegExp("hsva" + In),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(_n) {
  return !!matchers.CSS_UNIT.exec(_n);
}
function stringInputToObject(_n) {
  _n = _n.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var nr = !1;
  if (names[_n])
    _n = names[_n], nr = !0;
  else if (_n == "transparent")
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  var Cn;
  return (Cn = matchers.rgb.exec(_n)) ? {
    r: Cn[1],
    g: Cn[2],
    b: Cn[3]
  } : (Cn = matchers.rgba.exec(_n)) ? {
    r: Cn[1],
    g: Cn[2],
    b: Cn[3],
    a: Cn[4]
  } : (Cn = matchers.hsl.exec(_n)) ? {
    h: Cn[1],
    s: Cn[2],
    l: Cn[3]
  } : (Cn = matchers.hsla.exec(_n)) ? {
    h: Cn[1],
    s: Cn[2],
    l: Cn[3],
    a: Cn[4]
  } : (Cn = matchers.hsv.exec(_n)) ? {
    h: Cn[1],
    s: Cn[2],
    v: Cn[3]
  } : (Cn = matchers.hsva.exec(_n)) ? {
    h: Cn[1],
    s: Cn[2],
    v: Cn[3],
    a: Cn[4]
  } : (Cn = matchers.hex8.exec(_n)) ? {
    r: parseIntFromHex(Cn[1]),
    g: parseIntFromHex(Cn[2]),
    b: parseIntFromHex(Cn[3]),
    a: convertHexToDecimal(Cn[4]),
    format: nr ? "name" : "hex8"
  } : (Cn = matchers.hex6.exec(_n)) ? {
    r: parseIntFromHex(Cn[1]),
    g: parseIntFromHex(Cn[2]),
    b: parseIntFromHex(Cn[3]),
    format: nr ? "name" : "hex"
  } : (Cn = matchers.hex4.exec(_n)) ? {
    r: parseIntFromHex(Cn[1] + "" + Cn[1]),
    g: parseIntFromHex(Cn[2] + "" + Cn[2]),
    b: parseIntFromHex(Cn[3] + "" + Cn[3]),
    a: convertHexToDecimal(Cn[4] + "" + Cn[4]),
    format: nr ? "name" : "hex8"
  } : (Cn = matchers.hex3.exec(_n)) ? {
    r: parseIntFromHex(Cn[1] + "" + Cn[1]),
    g: parseIntFromHex(Cn[2] + "" + Cn[2]),
    b: parseIntFromHex(Cn[3] + "" + Cn[3]),
    format: nr ? "name" : "hex"
  } : !1;
}
function validateWCAG2Parms(_n) {
  var nr, Cn;
  return _n = _n || {
    level: "AA",
    size: "small"
  }, nr = (_n.level || "AA").toUpperCase(), Cn = (_n.size || "small").toLowerCase(), nr !== "AA" && nr !== "AAA" && (nr = "AA"), Cn !== "small" && Cn !== "large" && (Cn = "small"), {
    level: nr,
    size: Cn
  };
}
var GradientParser = GradientParser || {};
GradientParser.stringify = function() {
  var _n = {
    "visit_linear-gradient": function(nr) {
      return _n.visit_gradient(nr);
    },
    "visit_repeating-linear-gradient": function(nr) {
      return _n.visit_gradient(nr);
    },
    "visit_radial-gradient": function(nr) {
      return _n.visit_gradient(nr);
    },
    "visit_repeating-radial-gradient": function(nr) {
      return _n.visit_gradient(nr);
    },
    visit_gradient: function(nr) {
      var Cn = _n.visit(nr.orientation);
      return Cn && (Cn += ", "), nr.type + "(" + Cn + _n.visit(nr.colorStops) + ")";
    },
    visit_shape: function(nr) {
      var Cn = nr.value, Bn = _n.visit(nr.at), In = _n.visit(nr.style);
      return In && (Cn += " " + In), Bn && (Cn += " at " + Bn), Cn;
    },
    "visit_default-radial": function(nr) {
      var Cn = "", Bn = _n.visit(nr.at);
      return Bn && (Cn += Bn), Cn;
    },
    "visit_extent-keyword": function(nr) {
      var Cn = nr.value, Bn = _n.visit(nr.at);
      return Bn && (Cn += " at " + Bn), Cn;
    },
    "visit_position-keyword": function(nr) {
      return nr.value;
    },
    visit_position: function(nr) {
      return _n.visit(nr.value.x) + " " + _n.visit(nr.value.y);
    },
    "visit_%": function(nr) {
      return nr.value + "%";
    },
    visit_em: function(nr) {
      return nr.value + "em";
    },
    visit_px: function(nr) {
      return nr.value + "px";
    },
    visit_calc: function(nr) {
      return "calc(" + nr.value + ")";
    },
    visit_literal: function(nr) {
      return _n.visit_color(nr.value, nr);
    },
    visit_hex: function(nr) {
      return _n.visit_color("#" + nr.value, nr);
    },
    visit_rgb: function(nr) {
      return _n.visit_color("rgb(" + nr.value.join(", ") + ")", nr);
    },
    visit_rgba: function(nr) {
      return _n.visit_color("rgba(" + nr.value.join(", ") + ")", nr);
    },
    visit_hsl: function(nr) {
      return _n.visit_color("hsl(" + nr.value[0] + ", " + nr.value[1] + "%, " + nr.value[2] + "%)", nr);
    },
    visit_hsla: function(nr) {
      return _n.visit_color("hsla(" + nr.value[0] + ", " + nr.value[1] + "%, " + nr.value[2] + "%, " + nr.value[3] + ")", nr);
    },
    visit_var: function(nr) {
      return _n.visit_color("var(" + nr.value + ")", nr);
    },
    visit_color: function(nr, Cn) {
      var Bn = nr, In = _n.visit(Cn.length);
      return In && (Bn += " " + In), Bn;
    },
    visit_angular: function(nr) {
      return nr.value + "deg";
    },
    visit_directional: function(nr) {
      return "to " + nr.value;
    },
    visit_array: function(nr) {
      var Cn = "", Bn = nr.length;
      return nr.forEach(function(In, Dn) {
        Cn += _n.visit(In), Dn < Bn - 1 && (Cn += ", ");
      }), Cn;
    },
    visit_object: function(nr) {
      return nr.width && nr.height ? _n.visit(nr.width) + " " + _n.visit(nr.height) : "";
    },
    visit: function(nr) {
      if (!nr)
        return "";
      if (nr instanceof Array)
        return _n.visit_array(nr);
      if (typeof nr == "object" && !nr.type)
        return _n.visit_object(nr);
      if (nr.type) {
        var Cn = _n["visit_" + nr.type];
        if (Cn)
          return Cn(nr);
        throw Error("Missing visitor visit_" + nr.type);
      } else
        throw Error("Invalid node.");
    }
  };
  return function(nr) {
    return _n.visit(nr);
  };
}();
var GradientParser = GradientParser || {};
GradientParser.parse = function() {
  var _n = {
    linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
    repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
    radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
    repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    radianValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))rad/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    varColor: /^var/i,
    calcValue: /^calc/i,
    variableName: /^(--[a-zA-Z0-9-,\s\#]+)/,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/,
    hslColor: /^hsl/i,
    hslaColor: /^hsla/i
  }, nr = "";
  function Cn(va) {
    var ga = new Error(nr + ": " + va);
    throw ga.source = nr, ga;
  }
  function Bn() {
    var va = In();
    return nr.length > 0 && Cn("Invalid input not EOF"), va;
  }
  function In() {
    return ea(Dn);
  }
  function Dn() {
    return Ln(
      "linear-gradient",
      _n.linearGradient,
      Nn
    ) || Ln(
      "repeating-linear-gradient",
      _n.repeatingLinearGradient,
      Nn
    ) || Ln(
      "radial-gradient",
      _n.radialGradient,
      Pn
    ) || Ln(
      "repeating-radial-gradient",
      _n.repeatingRadialGradient,
      Pn
    );
  }
  function Ln(va, ga, xa) {
    return $n(ga, function(wa) {
      var ba = xa();
      return ba && (Ca(_n.comma) || Cn("Missing comma before color stops")), {
        type: va,
        orientation: ba,
        colorStops: ea(ta)
      };
    });
  }
  function $n(va, ga) {
    var xa = Ca(va);
    if (xa) {
      Ca(_n.startCall) || Cn("Missing (");
      var wa = ga(xa);
      return Ca(_n.endCall) || Cn("Missing )"), wa;
    }
  }
  function Nn() {
    var va = Rn();
    if (va)
      return va;
    var ga = da("position-keyword", _n.positionKeywords, 1);
    return ga ? {
      type: "directional",
      value: ga.value
    } : Fn();
  }
  function Rn() {
    return da("directional", _n.sideOrCorner, 1);
  }
  function Fn() {
    return da("angular", _n.angleValue, 1) || da("angular", _n.radianValue, 1);
  }
  function Pn() {
    var va, ga = Un(), xa;
    return ga && (va = [], va.push(ga), xa = nr, Ca(_n.comma) && (ga = Un(), ga ? va.push(ga) : nr = xa)), va;
  }
  function Un() {
    var va = Hn() || zn();
    if (va)
      va.at = Yn();
    else {
      var ga = Gn();
      if (ga) {
        va = ga;
        var xa = Yn();
        xa && (va.at = xa);
      } else {
        var wa = Yn();
        if (wa)
          va = {
            type: "default-radial",
            at: wa
          };
        else {
          var ba = Wn();
          ba && (va = {
            type: "default-radial",
            at: ba
          });
        }
      }
    }
    return va;
  }
  function Hn() {
    var va = da("shape", /^(circle)/i, 0);
    return va && (va.style = ya() || Gn()), va;
  }
  function zn() {
    var va = da("shape", /^(ellipse)/i, 0);
    return va && (va.style = Wn() || fa() || Gn()), va;
  }
  function Gn() {
    return da("extent-keyword", _n.extentKeywords, 1);
  }
  function Yn() {
    if (da("position", /^at/, 0)) {
      var va = Wn();
      return va || Cn("Missing positioning value"), va;
    }
  }
  function Wn() {
    var va = Xn();
    if (va.x || va.y)
      return {
        type: "position",
        value: va
      };
  }
  function Xn() {
    return {
      x: fa(),
      y: fa()
    };
  }
  function ea(va) {
    var ga = va(), xa = [];
    if (ga)
      for (xa.push(ga); Ca(_n.comma); )
        ga = va(), ga ? xa.push(ga) : Cn("One extra comma");
    return xa;
  }
  function ta() {
    var va = na();
    return va || Cn("Expected color definition"), va.length = fa(), va;
  }
  function na() {
    return aa() || la() || oa() || Aa() || ia() || sa() || ra();
  }
  function ra() {
    return da("literal", _n.literalColor, 0);
  }
  function aa() {
    return da("hex", _n.hexColor, 1);
  }
  function ia() {
    return $n(_n.rgbColor, function() {
      return {
        type: "rgb",
        value: ea(ca)
      };
    });
  }
  function Aa() {
    return $n(_n.rgbaColor, function() {
      return {
        type: "rgba",
        value: ea(ca)
      };
    });
  }
  function sa() {
    return $n(_n.varColor, function() {
      return {
        type: "var",
        value: ua()
      };
    });
  }
  function oa() {
    return $n(_n.hslColor, function() {
      var va = Ca(_n.percentageValue);
      va && Cn("HSL hue value must be a number in degrees (0-360) or normalized (-360 to 360), not a percentage");
      var ga = ca();
      Ca(_n.comma);
      var xa = Ca(_n.percentageValue), wa = xa ? xa[1] : null;
      Ca(_n.comma), xa = Ca(_n.percentageValue);
      var ba = xa ? xa[1] : null;
      return (!wa || !ba) && Cn("Expected percentage value for saturation and lightness in HSL"), {
        type: "hsl",
        value: [ga, wa, ba]
      };
    });
  }
  function la() {
    return $n(_n.hslaColor, function() {
      var va = ca();
      Ca(_n.comma);
      var ga = Ca(_n.percentageValue), xa = ga ? ga[1] : null;
      Ca(_n.comma), ga = Ca(_n.percentageValue);
      var wa = ga ? ga[1] : null;
      Ca(_n.comma);
      var ba = ca();
      return (!xa || !wa) && Cn("Expected percentage value for saturation and lightness in HSLA"), {
        type: "hsla",
        value: [va, xa, wa, ba]
      };
    });
  }
  function ua() {
    return Ca(_n.variableName)[1];
  }
  function ca() {
    return Ca(_n.number)[1];
  }
  function fa() {
    return da("%", _n.percentageValue, 1) || ha() || pa() || ya();
  }
  function ha() {
    return da("position-keyword", _n.positionKeywords, 1);
  }
  function pa() {
    return $n(_n.calcValue, function() {
      for (var va = 1, ga = 0; va > 0 && ga < nr.length; ) {
        var xa = nr.charAt(ga);
        xa === "(" ? va++ : xa === ")" && va--, ga++;
      }
      va > 0 && Cn("Missing closing parenthesis in calc() expression");
      var wa = nr.substring(0, ga - 1);
      return ma(ga - 1), {
        type: "calc",
        value: wa
      };
    });
  }
  function ya() {
    return da("px", _n.pixelValue, 1) || da("em", _n.emValue, 1);
  }
  function da(va, ga, xa) {
    var wa = Ca(ga);
    if (wa)
      return {
        type: va,
        value: wa[xa]
      };
  }
  function Ca(va) {
    var ga, xa;
    return xa = /^[\n\r\t\s]+/.exec(nr), xa && ma(xa[0].length), ga = va.exec(nr), ga && ma(ga[0].length), ga;
  }
  function ma(va) {
    nr = nr.substr(va);
  }
  return function(va) {
    return nr = va.toString().trim(), nr.endsWith(";") && (nr = nr.slice(0, -1)), Bn();
  };
}();
var parse = GradientParser.parse, stringify = GradientParser.stringify, top = "top", bottom = "bottom", right = "right", left = "left", auto = "auto", basePlacements = [top, bottom, right, left], start = "start", end = "end", clippingParents = "clippingParents", viewport = "viewport", popper = "popper", reference = "reference", variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(_n, nr) {
  return _n.concat([nr + "-" + start, nr + "-" + end]);
}, []), placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(_n, nr) {
  return _n.concat([nr, nr + "-" + start, nr + "-" + end]);
}, []), beforeRead = "beforeRead", read = "read", afterRead = "afterRead", beforeMain = "beforeMain", main = "main", afterMain = "afterMain", beforeWrite = "beforeWrite", write = "write", afterWrite = "afterWrite", modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(_n) {
  return _n ? (_n.nodeName || "").toLowerCase() : null;
}
function getWindow(_n) {
  if (_n == null)
    return window;
  if (_n.toString() !== "[object Window]") {
    var nr = _n.ownerDocument;
    return nr && nr.defaultView || window;
  }
  return _n;
}
function isElement(_n) {
  var nr = getWindow(_n).Element;
  return _n instanceof nr || _n instanceof Element;
}
function isHTMLElement(_n) {
  var nr = getWindow(_n).HTMLElement;
  return _n instanceof nr || _n instanceof HTMLElement;
}
function isShadowRoot(_n) {
  if (typeof ShadowRoot > "u")
    return !1;
  var nr = getWindow(_n).ShadowRoot;
  return _n instanceof nr || _n instanceof ShadowRoot;
}
function applyStyles(_n) {
  var nr = _n.state;
  Object.keys(nr.elements).forEach(function(Cn) {
    var Bn = nr.styles[Cn] || {}, In = nr.attributes[Cn] || {}, Dn = nr.elements[Cn];
    !isHTMLElement(Dn) || !getNodeName(Dn) || (Object.assign(Dn.style, Bn), Object.keys(In).forEach(function(Ln) {
      var $n = In[Ln];
      $n === !1 ? Dn.removeAttribute(Ln) : Dn.setAttribute(Ln, $n === !0 ? "" : $n);
    }));
  });
}
function effect$2(_n) {
  var nr = _n.state, Cn = {
    popper: {
      position: nr.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(nr.elements.popper.style, Cn.popper), nr.styles = Cn, nr.elements.arrow && Object.assign(nr.elements.arrow.style, Cn.arrow), function() {
    Object.keys(nr.elements).forEach(function(Bn) {
      var In = nr.elements[Bn], Dn = nr.attributes[Bn] || {}, Ln = Object.keys(nr.styles.hasOwnProperty(Bn) ? nr.styles[Bn] : Cn[Bn]), $n = Ln.reduce(function(Nn, Rn) {
        return Nn[Rn] = "", Nn;
      }, {});
      !isHTMLElement(In) || !getNodeName(In) || (Object.assign(In.style, $n), Object.keys(Dn).forEach(function(Nn) {
        In.removeAttribute(Nn);
      }));
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(_n) {
  return _n.split("-")[0];
}
var max$1 = Math.max, min = Math.min, round$2 = Math.round;
function getUAString() {
  var _n = navigator.userAgentData;
  return _n != null && _n.brands && Array.isArray(_n.brands) ? _n.brands.map(function(nr) {
    return nr.brand + "/" + nr.version;
  }).join(" ") : navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(_n, nr, Cn) {
  nr === void 0 && (nr = !1), Cn === void 0 && (Cn = !1);
  var Bn = _n.getBoundingClientRect(), In = 1, Dn = 1;
  nr && isHTMLElement(_n) && (In = _n.offsetWidth > 0 && round$2(Bn.width) / _n.offsetWidth || 1, Dn = _n.offsetHeight > 0 && round$2(Bn.height) / _n.offsetHeight || 1);
  var Ln = isElement(_n) ? getWindow(_n) : window, $n = Ln.visualViewport, Nn = !isLayoutViewport() && Cn, Rn = (Bn.left + (Nn && $n ? $n.offsetLeft : 0)) / In, Fn = (Bn.top + (Nn && $n ? $n.offsetTop : 0)) / Dn, Pn = Bn.width / In, Un = Bn.height / Dn;
  return {
    width: Pn,
    height: Un,
    top: Fn,
    right: Rn + Pn,
    bottom: Fn + Un,
    left: Rn,
    x: Rn,
    y: Fn
  };
}
function getLayoutRect(_n) {
  var nr = getBoundingClientRect(_n), Cn = _n.offsetWidth, Bn = _n.offsetHeight;
  return Math.abs(nr.width - Cn) <= 1 && (Cn = nr.width), Math.abs(nr.height - Bn) <= 1 && (Bn = nr.height), {
    x: _n.offsetLeft,
    y: _n.offsetTop,
    width: Cn,
    height: Bn
  };
}
function contains(_n, nr) {
  var Cn = nr.getRootNode && nr.getRootNode();
  if (_n.contains(nr))
    return !0;
  if (Cn && isShadowRoot(Cn)) {
    var Bn = nr;
    do {
      if (Bn && _n.isSameNode(Bn))
        return !0;
      Bn = Bn.parentNode || Bn.host;
    } while (Bn);
  }
  return !1;
}
function getComputedStyle$2(_n) {
  return getWindow(_n).getComputedStyle(_n);
}
function isTableElement(_n) {
  return ["table", "td", "th"].indexOf(getNodeName(_n)) >= 0;
}
function getDocumentElement(_n) {
  return ((isElement(_n) ? _n.ownerDocument : (
    // $FlowFixMe[prop-missing]
    _n.document
  )) || window.document).documentElement;
}
function getParentNode(_n) {
  return getNodeName(_n) === "html" ? _n : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    _n.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    _n.parentNode || // DOM Element detected
    (isShadowRoot(_n) ? _n.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(_n)
  );
}
function getTrueOffsetParent(_n) {
  return !isHTMLElement(_n) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$2(_n).position === "fixed" ? null : _n.offsetParent;
}
function getContainingBlock(_n) {
  var nr = /firefox/i.test(getUAString()), Cn = /Trident/i.test(getUAString());
  if (Cn && isHTMLElement(_n)) {
    var Bn = getComputedStyle$2(_n);
    if (Bn.position === "fixed")
      return null;
  }
  var In = getParentNode(_n);
  for (isShadowRoot(In) && (In = In.host); isHTMLElement(In) && ["html", "body"].indexOf(getNodeName(In)) < 0; ) {
    var Dn = getComputedStyle$2(In);
    if (Dn.transform !== "none" || Dn.perspective !== "none" || Dn.contain === "paint" || ["transform", "perspective"].indexOf(Dn.willChange) !== -1 || nr && Dn.willChange === "filter" || nr && Dn.filter && Dn.filter !== "none")
      return In;
    In = In.parentNode;
  }
  return null;
}
function getOffsetParent(_n) {
  for (var nr = getWindow(_n), Cn = getTrueOffsetParent(_n); Cn && isTableElement(Cn) && getComputedStyle$2(Cn).position === "static"; )
    Cn = getTrueOffsetParent(Cn);
  return Cn && (getNodeName(Cn) === "html" || getNodeName(Cn) === "body" && getComputedStyle$2(Cn).position === "static") ? nr : Cn || getContainingBlock(_n) || nr;
}
function getMainAxisFromPlacement(_n) {
  return ["top", "bottom"].indexOf(_n) >= 0 ? "x" : "y";
}
function within(_n, nr, Cn) {
  return max$1(_n, min(nr, Cn));
}
function withinMaxClamp(_n, nr, Cn) {
  var Bn = within(_n, nr, Cn);
  return Bn > Cn ? Cn : Bn;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(_n) {
  return Object.assign({}, getFreshSideObject(), _n);
}
function expandToHashMap(_n, nr) {
  return nr.reduce(function(Cn, Bn) {
    return Cn[Bn] = _n, Cn;
  }, {});
}
var toPaddingObject = function _n(nr, Cn) {
  return nr = typeof nr == "function" ? nr(Object.assign({}, Cn.rects, {
    placement: Cn.placement
  })) : nr, mergePaddingObject(typeof nr != "number" ? nr : expandToHashMap(nr, basePlacements));
};
function arrow(_n) {
  var nr, Cn = _n.state, Bn = _n.name, In = _n.options, Dn = Cn.elements.arrow, Ln = Cn.modifiersData.popperOffsets, $n = getBasePlacement(Cn.placement), Nn = getMainAxisFromPlacement($n), Rn = [left, right].indexOf($n) >= 0, Fn = Rn ? "height" : "width";
  if (!(!Dn || !Ln)) {
    var Pn = toPaddingObject(In.padding, Cn), Un = getLayoutRect(Dn), Hn = Nn === "y" ? top : left, zn = Nn === "y" ? bottom : right, Gn = Cn.rects.reference[Fn] + Cn.rects.reference[Nn] - Ln[Nn] - Cn.rects.popper[Fn], Yn = Ln[Nn] - Cn.rects.reference[Nn], Wn = getOffsetParent(Dn), Xn = Wn ? Nn === "y" ? Wn.clientHeight || 0 : Wn.clientWidth || 0 : 0, ea = Gn / 2 - Yn / 2, ta = Pn[Hn], na = Xn - Un[Fn] - Pn[zn], ra = Xn / 2 - Un[Fn] / 2 + ea, aa = within(ta, ra, na), ia = Nn;
    Cn.modifiersData[Bn] = (nr = {}, nr[ia] = aa, nr.centerOffset = aa - ra, nr);
  }
}
function effect$1(_n) {
  var nr = _n.state, Cn = _n.options, Bn = Cn.element, In = Bn === void 0 ? "[data-popper-arrow]" : Bn;
  In != null && (typeof In == "string" && (In = nr.elements.popper.querySelector(In), !In) || contains(nr.elements.popper, In) && (nr.elements.arrow = In));
}
const arrow$1 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(_n) {
  return _n.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_n, nr) {
  var Cn = _n.x, Bn = _n.y, In = nr.devicePixelRatio || 1;
  return {
    x: round$2(Cn * In) / In || 0,
    y: round$2(Bn * In) / In || 0
  };
}
function mapToStyles(_n) {
  var nr, Cn = _n.popper, Bn = _n.popperRect, In = _n.placement, Dn = _n.variation, Ln = _n.offsets, $n = _n.position, Nn = _n.gpuAcceleration, Rn = _n.adaptive, Fn = _n.roundOffsets, Pn = _n.isFixed, Un = Ln.x, Hn = Un === void 0 ? 0 : Un, zn = Ln.y, Gn = zn === void 0 ? 0 : zn, Yn = typeof Fn == "function" ? Fn({
    x: Hn,
    y: Gn
  }) : {
    x: Hn,
    y: Gn
  };
  Hn = Yn.x, Gn = Yn.y;
  var Wn = Ln.hasOwnProperty("x"), Xn = Ln.hasOwnProperty("y"), ea = left, ta = top, na = window;
  if (Rn) {
    var ra = getOffsetParent(Cn), aa = "clientHeight", ia = "clientWidth";
    if (ra === getWindow(Cn) && (ra = getDocumentElement(Cn), getComputedStyle$2(ra).position !== "static" && $n === "absolute" && (aa = "scrollHeight", ia = "scrollWidth")), ra = ra, In === top || (In === left || In === right) && Dn === end) {
      ta = bottom;
      var Aa = Pn && ra === na && na.visualViewport ? na.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        ra[aa]
      );
      Gn -= Aa - Bn.height, Gn *= Nn ? 1 : -1;
    }
    if (In === left || (In === top || In === bottom) && Dn === end) {
      ea = right;
      var sa = Pn && ra === na && na.visualViewport ? na.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        ra[ia]
      );
      Hn -= sa - Bn.width, Hn *= Nn ? 1 : -1;
    }
  }
  var oa = Object.assign({
    position: $n
  }, Rn && unsetSides), la = Fn === !0 ? roundOffsetsByDPR({
    x: Hn,
    y: Gn
  }, getWindow(Cn)) : {
    x: Hn,
    y: Gn
  };
  if (Hn = la.x, Gn = la.y, Nn) {
    var ua;
    return Object.assign({}, oa, (ua = {}, ua[ta] = Xn ? "0" : "", ua[ea] = Wn ? "0" : "", ua.transform = (na.devicePixelRatio || 1) <= 1 ? "translate(" + Hn + "px, " + Gn + "px)" : "translate3d(" + Hn + "px, " + Gn + "px, 0)", ua));
  }
  return Object.assign({}, oa, (nr = {}, nr[ta] = Xn ? Gn + "px" : "", nr[ea] = Wn ? Hn + "px" : "", nr.transform = "", nr));
}
function computeStyles(_n) {
  var nr = _n.state, Cn = _n.options, Bn = Cn.gpuAcceleration, In = Bn === void 0 ? !0 : Bn, Dn = Cn.adaptive, Ln = Dn === void 0 ? !0 : Dn, $n = Cn.roundOffsets, Nn = $n === void 0 ? !0 : $n, Rn = {
    placement: getBasePlacement(nr.placement),
    variation: getVariation(nr.placement),
    popper: nr.elements.popper,
    popperRect: nr.rects.popper,
    gpuAcceleration: In,
    isFixed: nr.options.strategy === "fixed"
  };
  nr.modifiersData.popperOffsets != null && (nr.styles.popper = Object.assign({}, nr.styles.popper, mapToStyles(Object.assign({}, Rn, {
    offsets: nr.modifiersData.popperOffsets,
    position: nr.options.strategy,
    adaptive: Ln,
    roundOffsets: Nn
  })))), nr.modifiersData.arrow != null && (nr.styles.arrow = Object.assign({}, nr.styles.arrow, mapToStyles(Object.assign({}, Rn, {
    offsets: nr.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: Nn
  })))), nr.attributes.popper = Object.assign({}, nr.attributes.popper, {
    "data-popper-placement": nr.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: !0
};
function effect(_n) {
  var nr = _n.state, Cn = _n.instance, Bn = _n.options, In = Bn.scroll, Dn = In === void 0 ? !0 : In, Ln = Bn.resize, $n = Ln === void 0 ? !0 : Ln, Nn = getWindow(nr.elements.popper), Rn = [].concat(nr.scrollParents.reference, nr.scrollParents.popper);
  return Dn && Rn.forEach(function(Fn) {
    Fn.addEventListener("scroll", Cn.update, passive);
  }), $n && Nn.addEventListener("resize", Cn.update, passive), function() {
    Dn && Rn.forEach(function(Fn) {
      Fn.removeEventListener("scroll", Cn.update, passive);
    }), $n && Nn.removeEventListener("resize", Cn.update, passive);
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function _n() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(_n) {
  return _n.replace(/left|right|bottom|top/g, function(nr) {
    return hash$1[nr];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(_n) {
  return _n.replace(/start|end/g, function(nr) {
    return hash[nr];
  });
}
function getWindowScroll(_n) {
  var nr = getWindow(_n), Cn = nr.pageXOffset, Bn = nr.pageYOffset;
  return {
    scrollLeft: Cn,
    scrollTop: Bn
  };
}
function getWindowScrollBarX(_n) {
  return getBoundingClientRect(getDocumentElement(_n)).left + getWindowScroll(_n).scrollLeft;
}
function getViewportRect(_n, nr) {
  var Cn = getWindow(_n), Bn = getDocumentElement(_n), In = Cn.visualViewport, Dn = Bn.clientWidth, Ln = Bn.clientHeight, $n = 0, Nn = 0;
  if (In) {
    Dn = In.width, Ln = In.height;
    var Rn = isLayoutViewport();
    (Rn || !Rn && nr === "fixed") && ($n = In.offsetLeft, Nn = In.offsetTop);
  }
  return {
    width: Dn,
    height: Ln,
    x: $n + getWindowScrollBarX(_n),
    y: Nn
  };
}
function getDocumentRect(_n) {
  var nr, Cn = getDocumentElement(_n), Bn = getWindowScroll(_n), In = (nr = _n.ownerDocument) == null ? void 0 : nr.body, Dn = max$1(Cn.scrollWidth, Cn.clientWidth, In ? In.scrollWidth : 0, In ? In.clientWidth : 0), Ln = max$1(Cn.scrollHeight, Cn.clientHeight, In ? In.scrollHeight : 0, In ? In.clientHeight : 0), $n = -Bn.scrollLeft + getWindowScrollBarX(_n), Nn = -Bn.scrollTop;
  return getComputedStyle$2(In || Cn).direction === "rtl" && ($n += max$1(Cn.clientWidth, In ? In.clientWidth : 0) - Dn), {
    width: Dn,
    height: Ln,
    x: $n,
    y: Nn
  };
}
function isScrollParent(_n) {
  var nr = getComputedStyle$2(_n), Cn = nr.overflow, Bn = nr.overflowX, In = nr.overflowY;
  return /auto|scroll|overlay|hidden/.test(Cn + In + Bn);
}
function getScrollParent(_n) {
  return ["html", "body", "#document"].indexOf(getNodeName(_n)) >= 0 ? _n.ownerDocument.body : isHTMLElement(_n) && isScrollParent(_n) ? _n : getScrollParent(getParentNode(_n));
}
function listScrollParents(_n, nr) {
  var Cn;
  nr === void 0 && (nr = []);
  var Bn = getScrollParent(_n), In = Bn === ((Cn = _n.ownerDocument) == null ? void 0 : Cn.body), Dn = getWindow(Bn), Ln = In ? [Dn].concat(Dn.visualViewport || [], isScrollParent(Bn) ? Bn : []) : Bn, $n = nr.concat(Ln);
  return In ? $n : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    $n.concat(listScrollParents(getParentNode(Ln)))
  );
}
function rectToClientRect(_n) {
  return Object.assign({}, _n, {
    left: _n.x,
    top: _n.y,
    right: _n.x + _n.width,
    bottom: _n.y + _n.height
  });
}
function getInnerBoundingClientRect(_n, nr) {
  var Cn = getBoundingClientRect(_n, !1, nr === "fixed");
  return Cn.top = Cn.top + _n.clientTop, Cn.left = Cn.left + _n.clientLeft, Cn.bottom = Cn.top + _n.clientHeight, Cn.right = Cn.left + _n.clientWidth, Cn.width = _n.clientWidth, Cn.height = _n.clientHeight, Cn.x = Cn.left, Cn.y = Cn.top, Cn;
}
function getClientRectFromMixedType(_n, nr, Cn) {
  return nr === viewport ? rectToClientRect(getViewportRect(_n, Cn)) : isElement(nr) ? getInnerBoundingClientRect(nr, Cn) : rectToClientRect(getDocumentRect(getDocumentElement(_n)));
}
function getClippingParents(_n) {
  var nr = listScrollParents(getParentNode(_n)), Cn = ["absolute", "fixed"].indexOf(getComputedStyle$2(_n).position) >= 0, Bn = Cn && isHTMLElement(_n) ? getOffsetParent(_n) : _n;
  return isElement(Bn) ? nr.filter(function(In) {
    return isElement(In) && contains(In, Bn) && getNodeName(In) !== "body";
  }) : [];
}
function getClippingRect(_n, nr, Cn, Bn) {
  var In = nr === "clippingParents" ? getClippingParents(_n) : [].concat(nr), Dn = [].concat(In, [Cn]), Ln = Dn[0], $n = Dn.reduce(function(Nn, Rn) {
    var Fn = getClientRectFromMixedType(_n, Rn, Bn);
    return Nn.top = max$1(Fn.top, Nn.top), Nn.right = min(Fn.right, Nn.right), Nn.bottom = min(Fn.bottom, Nn.bottom), Nn.left = max$1(Fn.left, Nn.left), Nn;
  }, getClientRectFromMixedType(_n, Ln, Bn));
  return $n.width = $n.right - $n.left, $n.height = $n.bottom - $n.top, $n.x = $n.left, $n.y = $n.top, $n;
}
function computeOffsets(_n) {
  var nr = _n.reference, Cn = _n.element, Bn = _n.placement, In = Bn ? getBasePlacement(Bn) : null, Dn = Bn ? getVariation(Bn) : null, Ln = nr.x + nr.width / 2 - Cn.width / 2, $n = nr.y + nr.height / 2 - Cn.height / 2, Nn;
  switch (In) {
    case top:
      Nn = {
        x: Ln,
        y: nr.y - Cn.height
      };
      break;
    case bottom:
      Nn = {
        x: Ln,
        y: nr.y + nr.height
      };
      break;
    case right:
      Nn = {
        x: nr.x + nr.width,
        y: $n
      };
      break;
    case left:
      Nn = {
        x: nr.x - Cn.width,
        y: $n
      };
      break;
    default:
      Nn = {
        x: nr.x,
        y: nr.y
      };
  }
  var Rn = In ? getMainAxisFromPlacement(In) : null;
  if (Rn != null) {
    var Fn = Rn === "y" ? "height" : "width";
    switch (Dn) {
      case start:
        Nn[Rn] = Nn[Rn] - (nr[Fn] / 2 - Cn[Fn] / 2);
        break;
      case end:
        Nn[Rn] = Nn[Rn] + (nr[Fn] / 2 - Cn[Fn] / 2);
        break;
    }
  }
  return Nn;
}
function detectOverflow(_n, nr) {
  nr === void 0 && (nr = {});
  var Cn = nr, Bn = Cn.placement, In = Bn === void 0 ? _n.placement : Bn, Dn = Cn.strategy, Ln = Dn === void 0 ? _n.strategy : Dn, $n = Cn.boundary, Nn = $n === void 0 ? clippingParents : $n, Rn = Cn.rootBoundary, Fn = Rn === void 0 ? viewport : Rn, Pn = Cn.elementContext, Un = Pn === void 0 ? popper : Pn, Hn = Cn.altBoundary, zn = Hn === void 0 ? !1 : Hn, Gn = Cn.padding, Yn = Gn === void 0 ? 0 : Gn, Wn = mergePaddingObject(typeof Yn != "number" ? Yn : expandToHashMap(Yn, basePlacements)), Xn = Un === popper ? reference : popper, ea = _n.rects.popper, ta = _n.elements[zn ? Xn : Un], na = getClippingRect(isElement(ta) ? ta : ta.contextElement || getDocumentElement(_n.elements.popper), Nn, Fn, Ln), ra = getBoundingClientRect(_n.elements.reference), aa = computeOffsets({
    reference: ra,
    element: ea,
    strategy: "absolute",
    placement: In
  }), ia = rectToClientRect(Object.assign({}, ea, aa)), Aa = Un === popper ? ia : ra, sa = {
    top: na.top - Aa.top + Wn.top,
    bottom: Aa.bottom - na.bottom + Wn.bottom,
    left: na.left - Aa.left + Wn.left,
    right: Aa.right - na.right + Wn.right
  }, oa = _n.modifiersData.offset;
  if (Un === popper && oa) {
    var la = oa[In];
    Object.keys(sa).forEach(function(ua) {
      var ca = [right, bottom].indexOf(ua) >= 0 ? 1 : -1, fa = [top, bottom].indexOf(ua) >= 0 ? "y" : "x";
      sa[ua] += la[fa] * ca;
    });
  }
  return sa;
}
function computeAutoPlacement(_n, nr) {
  nr === void 0 && (nr = {});
  var Cn = nr, Bn = Cn.placement, In = Cn.boundary, Dn = Cn.rootBoundary, Ln = Cn.padding, $n = Cn.flipVariations, Nn = Cn.allowedAutoPlacements, Rn = Nn === void 0 ? placements : Nn, Fn = getVariation(Bn), Pn = Fn ? $n ? variationPlacements : variationPlacements.filter(function(zn) {
    return getVariation(zn) === Fn;
  }) : basePlacements, Un = Pn.filter(function(zn) {
    return Rn.indexOf(zn) >= 0;
  });
  Un.length === 0 && (Un = Pn);
  var Hn = Un.reduce(function(zn, Gn) {
    return zn[Gn] = detectOverflow(_n, {
      placement: Gn,
      boundary: In,
      rootBoundary: Dn,
      padding: Ln
    })[getBasePlacement(Gn)], zn;
  }, {});
  return Object.keys(Hn).sort(function(zn, Gn) {
    return Hn[zn] - Hn[Gn];
  });
}
function getExpandedFallbackPlacements(_n) {
  if (getBasePlacement(_n) === auto)
    return [];
  var nr = getOppositePlacement(_n);
  return [getOppositeVariationPlacement(_n), nr, getOppositeVariationPlacement(nr)];
}
function flip(_n) {
  var nr = _n.state, Cn = _n.options, Bn = _n.name;
  if (!nr.modifiersData[Bn]._skip) {
    for (var In = Cn.mainAxis, Dn = In === void 0 ? !0 : In, Ln = Cn.altAxis, $n = Ln === void 0 ? !0 : Ln, Nn = Cn.fallbackPlacements, Rn = Cn.padding, Fn = Cn.boundary, Pn = Cn.rootBoundary, Un = Cn.altBoundary, Hn = Cn.flipVariations, zn = Hn === void 0 ? !0 : Hn, Gn = Cn.allowedAutoPlacements, Yn = nr.options.placement, Wn = getBasePlacement(Yn), Xn = Wn === Yn, ea = Nn || (Xn || !zn ? [getOppositePlacement(Yn)] : getExpandedFallbackPlacements(Yn)), ta = [Yn].concat(ea).reduce(function(xa, wa) {
      return xa.concat(getBasePlacement(wa) === auto ? computeAutoPlacement(nr, {
        placement: wa,
        boundary: Fn,
        rootBoundary: Pn,
        padding: Rn,
        flipVariations: zn,
        allowedAutoPlacements: Gn
      }) : wa);
    }, []), na = nr.rects.reference, ra = nr.rects.popper, aa = /* @__PURE__ */ new Map(), ia = !0, Aa = ta[0], sa = 0; sa < ta.length; sa++) {
      var oa = ta[sa], la = getBasePlacement(oa), ua = getVariation(oa) === start, ca = [top, bottom].indexOf(la) >= 0, fa = ca ? "width" : "height", ha = detectOverflow(nr, {
        placement: oa,
        boundary: Fn,
        rootBoundary: Pn,
        altBoundary: Un,
        padding: Rn
      }), pa = ca ? ua ? right : left : ua ? bottom : top;
      na[fa] > ra[fa] && (pa = getOppositePlacement(pa));
      var ya = getOppositePlacement(pa), da = [];
      if (Dn && da.push(ha[la] <= 0), $n && da.push(ha[pa] <= 0, ha[ya] <= 0), da.every(function(xa) {
        return xa;
      })) {
        Aa = oa, ia = !1;
        break;
      }
      aa.set(oa, da);
    }
    if (ia)
      for (var Ca = zn ? 3 : 1, ma = function(wa) {
        var ba = ta.find(function(Ta) {
          var Sa = aa.get(Ta);
          if (Sa)
            return Sa.slice(0, wa).every(function(Ea) {
              return Ea;
            });
        });
        if (ba)
          return Aa = ba, "break";
      }, va = Ca; va > 0; va--) {
        var ga = ma(va);
        if (ga === "break")
          break;
      }
    nr.placement !== Aa && (nr.modifiersData[Bn]._skip = !0, nr.placement = Aa, nr.reset = !0);
  }
}
const flip$1 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function getSideOffsets(_n, nr, Cn) {
  return Cn === void 0 && (Cn = {
    x: 0,
    y: 0
  }), {
    top: _n.top - nr.height - Cn.y,
    right: _n.right - nr.width + Cn.x,
    bottom: _n.bottom - nr.height + Cn.y,
    left: _n.left - nr.width - Cn.x
  };
}
function isAnySideFullyClipped(_n) {
  return [top, right, bottom, left].some(function(nr) {
    return _n[nr] >= 0;
  });
}
function hide(_n) {
  var nr = _n.state, Cn = _n.name, Bn = nr.rects.reference, In = nr.rects.popper, Dn = nr.modifiersData.preventOverflow, Ln = detectOverflow(nr, {
    elementContext: "reference"
  }), $n = detectOverflow(nr, {
    altBoundary: !0
  }), Nn = getSideOffsets(Ln, Bn), Rn = getSideOffsets($n, In, Dn), Fn = isAnySideFullyClipped(Nn), Pn = isAnySideFullyClipped(Rn);
  nr.modifiersData[Cn] = {
    referenceClippingOffsets: Nn,
    popperEscapeOffsets: Rn,
    isReferenceHidden: Fn,
    hasPopperEscaped: Pn
  }, nr.attributes.popper = Object.assign({}, nr.attributes.popper, {
    "data-popper-reference-hidden": Fn,
    "data-popper-escaped": Pn
  });
}
const hide$1 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(_n, nr, Cn) {
  var Bn = getBasePlacement(_n), In = [left, top].indexOf(Bn) >= 0 ? -1 : 1, Dn = typeof Cn == "function" ? Cn(Object.assign({}, nr, {
    placement: _n
  })) : Cn, Ln = Dn[0], $n = Dn[1];
  return Ln = Ln || 0, $n = ($n || 0) * In, [left, right].indexOf(Bn) >= 0 ? {
    x: $n,
    y: Ln
  } : {
    x: Ln,
    y: $n
  };
}
function offset(_n) {
  var nr = _n.state, Cn = _n.options, Bn = _n.name, In = Cn.offset, Dn = In === void 0 ? [0, 0] : In, Ln = placements.reduce(function(Fn, Pn) {
    return Fn[Pn] = distanceAndSkiddingToXY(Pn, nr.rects, Dn), Fn;
  }, {}), $n = Ln[nr.placement], Nn = $n.x, Rn = $n.y;
  nr.modifiersData.popperOffsets != null && (nr.modifiersData.popperOffsets.x += Nn, nr.modifiersData.popperOffsets.y += Rn), nr.modifiersData[Bn] = Ln;
}
const offset$1 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_n) {
  var nr = _n.state, Cn = _n.name;
  nr.modifiersData[Cn] = computeOffsets({
    reference: nr.rects.reference,
    element: nr.rects.popper,
    strategy: "absolute",
    placement: nr.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(_n) {
  return _n === "x" ? "y" : "x";
}
function preventOverflow(_n) {
  var nr = _n.state, Cn = _n.options, Bn = _n.name, In = Cn.mainAxis, Dn = In === void 0 ? !0 : In, Ln = Cn.altAxis, $n = Ln === void 0 ? !1 : Ln, Nn = Cn.boundary, Rn = Cn.rootBoundary, Fn = Cn.altBoundary, Pn = Cn.padding, Un = Cn.tether, Hn = Un === void 0 ? !0 : Un, zn = Cn.tetherOffset, Gn = zn === void 0 ? 0 : zn, Yn = detectOverflow(nr, {
    boundary: Nn,
    rootBoundary: Rn,
    padding: Pn,
    altBoundary: Fn
  }), Wn = getBasePlacement(nr.placement), Xn = getVariation(nr.placement), ea = !Xn, ta = getMainAxisFromPlacement(Wn), na = getAltAxis(ta), ra = nr.modifiersData.popperOffsets, aa = nr.rects.reference, ia = nr.rects.popper, Aa = typeof Gn == "function" ? Gn(Object.assign({}, nr.rects, {
    placement: nr.placement
  })) : Gn, sa = typeof Aa == "number" ? {
    mainAxis: Aa,
    altAxis: Aa
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, Aa), oa = nr.modifiersData.offset ? nr.modifiersData.offset[nr.placement] : null, la = {
    x: 0,
    y: 0
  };
  if (ra) {
    if (Dn) {
      var ua, ca = ta === "y" ? top : left, fa = ta === "y" ? bottom : right, ha = ta === "y" ? "height" : "width", pa = ra[ta], ya = pa + Yn[ca], da = pa - Yn[fa], Ca = Hn ? -ia[ha] / 2 : 0, ma = Xn === start ? aa[ha] : ia[ha], va = Xn === start ? -ia[ha] : -aa[ha], ga = nr.elements.arrow, xa = Hn && ga ? getLayoutRect(ga) : {
        width: 0,
        height: 0
      }, wa = nr.modifiersData["arrow#persistent"] ? nr.modifiersData["arrow#persistent"].padding : getFreshSideObject(), ba = wa[ca], Ta = wa[fa], Sa = within(0, aa[ha], xa[ha]), Ea = ea ? aa[ha] / 2 - Ca - Sa - ba - sa.mainAxis : ma - Sa - ba - sa.mainAxis, Ia = ea ? -aa[ha] / 2 + Ca + Sa + Ta + sa.mainAxis : va + Sa + Ta + sa.mainAxis, Ba = nr.elements.arrow && getOffsetParent(nr.elements.arrow), Ma = Ba ? ta === "y" ? Ba.clientTop || 0 : Ba.clientLeft || 0 : 0, La = (ua = oa == null ? void 0 : oa[ta]) != null ? ua : 0, Da = pa + Ea - La - Ma, Na = pa + Ia - La, $a = within(Hn ? min(ya, Da) : ya, pa, Hn ? max$1(da, Na) : da);
      ra[ta] = $a, la[ta] = $a - pa;
    }
    if ($n) {
      var Oa, Pa = ta === "x" ? top : left, ka = ta === "x" ? bottom : right, Ua = ra[na], Fa = na === "y" ? "height" : "width", Ha = Ua + Yn[Pa], Qa = Ua - Yn[ka], Ga = [top, left].indexOf(Wn) !== -1, Wa = (Oa = oa == null ? void 0 : oa[na]) != null ? Oa : 0, za = Ga ? Ha : Ua - aa[Fa] - ia[Fa] - Wa + sa.altAxis, ja = Ga ? Ua + aa[Fa] + ia[Fa] - Wa - sa.altAxis : Qa, Za = Hn && Ga ? withinMaxClamp(za, Ua, ja) : within(Hn ? za : Ha, Ua, Hn ? ja : Qa);
      ra[na] = Za, la[na] = Za - Ua;
    }
    nr.modifiersData[Bn] = la;
  }
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(_n) {
  return {
    scrollLeft: _n.scrollLeft,
    scrollTop: _n.scrollTop
  };
}
function getNodeScroll(_n) {
  return _n === getWindow(_n) || !isHTMLElement(_n) ? getWindowScroll(_n) : getHTMLElementScroll(_n);
}
function isElementScaled(_n) {
  var nr = _n.getBoundingClientRect(), Cn = round$2(nr.width) / _n.offsetWidth || 1, Bn = round$2(nr.height) / _n.offsetHeight || 1;
  return Cn !== 1 || Bn !== 1;
}
function getCompositeRect(_n, nr, Cn) {
  Cn === void 0 && (Cn = !1);
  var Bn = isHTMLElement(nr), In = isHTMLElement(nr) && isElementScaled(nr), Dn = getDocumentElement(nr), Ln = getBoundingClientRect(_n, In, Cn), $n = {
    scrollLeft: 0,
    scrollTop: 0
  }, Nn = {
    x: 0,
    y: 0
  };
  return (Bn || !Bn && !Cn) && ((getNodeName(nr) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  isScrollParent(Dn)) && ($n = getNodeScroll(nr)), isHTMLElement(nr) ? (Nn = getBoundingClientRect(nr, !0), Nn.x += nr.clientLeft, Nn.y += nr.clientTop) : Dn && (Nn.x = getWindowScrollBarX(Dn))), {
    x: Ln.left + $n.scrollLeft - Nn.x,
    y: Ln.top + $n.scrollTop - Nn.y,
    width: Ln.width,
    height: Ln.height
  };
}
function order(_n) {
  var nr = /* @__PURE__ */ new Map(), Cn = /* @__PURE__ */ new Set(), Bn = [];
  _n.forEach(function(Dn) {
    nr.set(Dn.name, Dn);
  });
  function In(Dn) {
    Cn.add(Dn.name);
    var Ln = [].concat(Dn.requires || [], Dn.requiresIfExists || []);
    Ln.forEach(function($n) {
      if (!Cn.has($n)) {
        var Nn = nr.get($n);
        Nn && In(Nn);
      }
    }), Bn.push(Dn);
  }
  return _n.forEach(function(Dn) {
    Cn.has(Dn.name) || In(Dn);
  }), Bn;
}
function orderModifiers(_n) {
  var nr = order(_n);
  return modifierPhases.reduce(function(Cn, Bn) {
    return Cn.concat(nr.filter(function(In) {
      return In.phase === Bn;
    }));
  }, []);
}
function debounce(_n) {
  var nr;
  return function() {
    return nr || (nr = new Promise(function(Cn) {
      Promise.resolve().then(function() {
        nr = void 0, Cn(_n());
      });
    })), nr;
  };
}
function mergeByName(_n) {
  var nr = _n.reduce(function(Cn, Bn) {
    var In = Cn[Bn.name];
    return Cn[Bn.name] = In ? Object.assign({}, In, Bn, {
      options: Object.assign({}, In.options, Bn.options),
      data: Object.assign({}, In.data, Bn.data)
    }) : Bn, Cn;
  }, {});
  return Object.keys(nr).map(function(Cn) {
    return nr[Cn];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _n = arguments.length, nr = new Array(_n), Cn = 0; Cn < _n; Cn++)
    nr[Cn] = arguments[Cn];
  return !nr.some(function(Bn) {
    return !(Bn && typeof Bn.getBoundingClientRect == "function");
  });
}
function popperGenerator(_n) {
  _n === void 0 && (_n = {});
  var nr = _n, Cn = nr.defaultModifiers, Bn = Cn === void 0 ? [] : Cn, In = nr.defaultOptions, Dn = In === void 0 ? DEFAULT_OPTIONS : In;
  return function($n, Nn, Rn) {
    Rn === void 0 && (Rn = Dn);
    var Fn = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, Dn),
      modifiersData: {},
      elements: {
        reference: $n,
        popper: Nn
      },
      attributes: {},
      styles: {}
    }, Pn = [], Un = !1, Hn = {
      state: Fn,
      setOptions: function(Wn) {
        var Xn = typeof Wn == "function" ? Wn(Fn.options) : Wn;
        Gn(), Fn.options = Object.assign({}, Dn, Fn.options, Xn), Fn.scrollParents = {
          reference: isElement($n) ? listScrollParents($n) : $n.contextElement ? listScrollParents($n.contextElement) : [],
          popper: listScrollParents(Nn)
        };
        var ea = orderModifiers(mergeByName([].concat(Bn, Fn.options.modifiers)));
        return Fn.orderedModifiers = ea.filter(function(ta) {
          return ta.enabled;
        }), zn(), Hn.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!Un) {
          var Wn = Fn.elements, Xn = Wn.reference, ea = Wn.popper;
          if (areValidElements(Xn, ea)) {
            Fn.rects = {
              reference: getCompositeRect(Xn, getOffsetParent(ea), Fn.options.strategy === "fixed"),
              popper: getLayoutRect(ea)
            }, Fn.reset = !1, Fn.placement = Fn.options.placement, Fn.orderedModifiers.forEach(function(sa) {
              return Fn.modifiersData[sa.name] = Object.assign({}, sa.data);
            });
            for (var ta = 0; ta < Fn.orderedModifiers.length; ta++) {
              if (Fn.reset === !0) {
                Fn.reset = !1, ta = -1;
                continue;
              }
              var na = Fn.orderedModifiers[ta], ra = na.fn, aa = na.options, ia = aa === void 0 ? {} : aa, Aa = na.name;
              typeof ra == "function" && (Fn = ra({
                state: Fn,
                options: ia,
                name: Aa,
                instance: Hn
              }) || Fn);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(Yn) {
          Hn.forceUpdate(), Yn(Fn);
        });
      }),
      destroy: function() {
        Gn(), Un = !0;
      }
    };
    if (!areValidElements($n, Nn))
      return Hn;
    Hn.setOptions(Rn).then(function(Yn) {
      !Un && Rn.onFirstUpdate && Rn.onFirstUpdate(Yn);
    });
    function zn() {
      Fn.orderedModifiers.forEach(function(Yn) {
        var Wn = Yn.name, Xn = Yn.options, ea = Xn === void 0 ? {} : Xn, ta = Yn.effect;
        if (typeof ta == "function") {
          var na = ta({
            state: Fn,
            name: Wn,
            instance: Hn,
            options: ea
          }), ra = function() {
          };
          Pn.push(na || ra);
        }
      });
    }
    function Gn() {
      Pn.forEach(function(Yn) {
        return Yn();
      }), Pn = [];
    }
    return Hn;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1], createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$2(_n) {
  return Object.prototype.toString.call(_n) === "[object Object]";
}
function isPlainObject$1(_n) {
  var nr, Cn;
  return isObject$2(_n) === !1 ? !1 : (nr = _n.constructor, nr === void 0 ? !0 : (Cn = nr.prototype, !(isObject$2(Cn) === !1 || Cn.hasOwnProperty("isPrototypeOf") === !1)));
}
function t$2() {
  return t$2 = Object.assign ? Object.assign.bind() : function(_n) {
    for (var nr = 1; nr < arguments.length; nr++) {
      var Cn = arguments[nr];
      for (var Bn in Cn)
        Object.prototype.hasOwnProperty.call(Cn, Bn) && (_n[Bn] = Cn[Bn]);
    }
    return _n;
  }, t$2.apply(this, arguments);
}
function r$1(_n, nr) {
  if (_n == null)
    return {};
  var Cn, Bn, In = {}, Dn = Object.keys(_n);
  for (Bn = 0; Bn < Dn.length; Bn++)
    nr.indexOf(Cn = Dn[Bn]) >= 0 || (In[Cn] = _n[Cn]);
  return In;
}
const n$1 = { silent: !1, logLevel: "warn" }, i$2 = ["validator"], o$1 = Object.prototype, a$1 = o$1.toString, s$1 = o$1.hasOwnProperty, u$1 = /^\s*function (\w+)/;
function l$1(_n) {
  var nr;
  const Cn = (nr = _n == null ? void 0 : _n.type) !== null && nr !== void 0 ? nr : _n;
  if (Cn) {
    const Bn = Cn.toString().match(u$1);
    return Bn ? Bn[1] : "";
  }
  return "";
}
const c$1 = isPlainObject$1, f$1 = (_n) => _n;
let d$1 = f$1;
process.env.NODE_ENV !== "production" && (d$1 = typeof console < "u" ? function(nr, Cn = n$1.logLevel) {
  n$1.silent === !1 && console[Cn](`[VueTypes warn]: ${nr}`);
} : f$1);
const p$1 = (_n, nr) => s$1.call(_n, nr), y$1 = Number.isInteger || function(_n) {
  return typeof _n == "number" && isFinite(_n) && Math.floor(_n) === _n;
}, v$1 = Array.isArray || function(_n) {
  return a$1.call(_n) === "[object Array]";
}, h$1 = (_n) => a$1.call(_n) === "[object Function]", b$1 = (_n) => c$1(_n) && p$1(_n, "_vueTypes_name"), g$1 = (_n) => c$1(_n) && (p$1(_n, "type") || ["_vueTypes_name", "validator", "default", "required"].some((nr) => p$1(_n, nr)));
function O$1(_n, nr) {
  return Object.defineProperty(_n.bind(nr), "__original", { value: _n });
}
function m$1(_n, nr, Cn = !1) {
  let Bn, In = !0, Dn = "";
  Bn = c$1(_n) ? _n : { type: _n };
  const Ln = b$1(Bn) ? Bn._vueTypes_name + " - " : "";
  if (g$1(Bn) && Bn.type !== null) {
    if (Bn.type === void 0 || Bn.type === !0 || !Bn.required && nr === void 0)
      return In;
    v$1(Bn.type) ? (In = Bn.type.some(($n) => m$1($n, nr, !0) === !0), Dn = Bn.type.map(($n) => l$1($n)).join(" or ")) : (Dn = l$1(Bn), In = Dn === "Array" ? v$1(nr) : Dn === "Object" ? c$1(nr) : Dn === "String" || Dn === "Number" || Dn === "Boolean" || Dn === "Function" ? function($n) {
      if ($n == null)
        return "";
      const Nn = $n.constructor.toString().match(u$1);
      return Nn ? Nn[1] : "";
    }(nr) === Dn : nr instanceof Bn.type);
  }
  if (!In) {
    const $n = `${Ln}value "${nr}" should be of type "${Dn}"`;
    return Cn === !1 ? (d$1($n), !1) : $n;
  }
  if (p$1(Bn, "validator") && h$1(Bn.validator)) {
    const $n = d$1, Nn = [];
    if (d$1 = (Rn) => {
      Nn.push(Rn);
    }, In = Bn.validator(nr), d$1 = $n, !In) {
      const Rn = (Nn.length > 1 ? "* " : "") + Nn.join(`
* `);
      return Nn.length = 0, Cn === !1 ? (d$1(Rn), In) : Rn;
    }
  }
  return In;
}
function j$1(_n, nr) {
  const Cn = Object.defineProperties(nr, { _vueTypes_name: { value: _n, writable: !0 }, isRequired: { get() {
    return this.required = !0, this;
  } }, def: { value(In) {
    return In === void 0 ? (p$1(this, "default") && delete this.default, this) : h$1(In) || m$1(this, In, !0) === !0 ? (this.default = v$1(In) ? () => [...In] : c$1(In) ? () => Object.assign({}, In) : In, this) : (d$1(`${this._vueTypes_name} - invalid default value: "${In}"`), this);
  } } }), { validator: Bn } = Cn;
  return h$1(Bn) && (Cn.validator = O$1(Bn, Cn)), Cn;
}
function _$1(_n, nr) {
  const Cn = j$1(_n, nr);
  return Object.defineProperty(Cn, "validate", { value(Bn) {
    return h$1(this.validator) && d$1(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = O$1(Bn, this), this;
  } });
}
function T$1(_n, nr, Cn) {
  const Bn = function(Nn) {
    const Rn = {};
    return Object.getOwnPropertyNames(Nn).forEach((Fn) => {
      Rn[Fn] = Object.getOwnPropertyDescriptor(Nn, Fn);
    }), Object.defineProperties({}, Rn);
  }(nr);
  if (Bn._vueTypes_name = _n, !c$1(Cn))
    return Bn;
  const { validator: In } = Cn, Dn = r$1(Cn, i$2);
  if (h$1(In)) {
    let { validator: Nn } = Bn;
    Nn && (Nn = ($n = (Ln = Nn).__original) !== null && $n !== void 0 ? $n : Ln), Bn.validator = O$1(Nn ? function(Rn) {
      return Nn.call(this, Rn) && In.call(this, Rn);
    } : In, Bn);
  }
  var Ln, $n;
  return Object.assign(Bn, Dn);
}
function $$1(_n) {
  return _n.replace(/^(?!\s*$)/gm, "  ");
}
const w$1 = () => _$1("any", {}), P$2 = () => _$1("function", { type: Function }), x$1 = () => _$1("boolean", { type: Boolean }), E$1 = () => _$1("string", { type: String }), N$1 = () => _$1("number", { type: Number }), q$2 = () => _$1("array", { type: Array }), A$2 = () => _$1("object", { type: Object }), V$1 = () => j$1("integer", { type: Number, validator: (_n) => y$1(_n) }), S$1 = () => j$1("symbol", { validator: (_n) => typeof _n == "symbol" });
function D$1(_n, nr = "custom validation failed") {
  if (typeof _n != "function")
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return j$1(_n.name || "<<anonymous function>>", { type: null, validator(Cn) {
    const Bn = _n(Cn);
    return Bn || d$1(`${this._vueTypes_name} - ${nr}`), Bn;
  } });
}
function L$1(_n) {
  if (!v$1(_n))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  const nr = `oneOf - value should be one of "${_n.join('", "')}".`, Cn = _n.reduce((Bn, In) => {
    if (In != null) {
      const Dn = In.constructor;
      Bn.indexOf(Dn) === -1 && Bn.push(Dn);
    }
    return Bn;
  }, []);
  return j$1("oneOf", { type: Cn.length > 0 ? Cn : void 0, validator(Bn) {
    const In = _n.indexOf(Bn) !== -1;
    return In || d$1(nr), In;
  } });
}
function F$1(_n) {
  if (!v$1(_n))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  let nr = !1, Cn = [];
  for (let In = 0; In < _n.length; In += 1) {
    const Dn = _n[In];
    if (g$1(Dn)) {
      if (b$1(Dn) && Dn._vueTypes_name === "oneOf" && Dn.type) {
        Cn = Cn.concat(Dn.type);
        continue;
      }
      if (h$1(Dn.validator) && (nr = !0), Dn.type === !0 || !Dn.type) {
        d$1('oneOfType - invalid usage of "true" or "null" as types.');
        continue;
      }
      Cn = Cn.concat(Dn.type);
    } else
      Cn.push(Dn);
  }
  Cn = Cn.filter((In, Dn) => Cn.indexOf(In) === Dn);
  const Bn = Cn.length > 0 ? Cn : null;
  return j$1("oneOfType", nr ? { type: Bn, validator(In) {
    const Dn = [], Ln = _n.some(($n) => {
      const Nn = m$1(b$1($n) && $n._vueTypes_name === "oneOf" ? $n.type || null : $n, In, !0);
      return typeof Nn == "string" && Dn.push(Nn), Nn === !0;
    });
    return Ln || d$1(`oneOfType - provided value does not match any of the ${Dn.length} passed-in validators:
${$$1(Dn.join(`
`))}`), Ln;
  } } : { type: Bn });
}
function Y$1(_n) {
  return j$1("arrayOf", { type: Array, validator(nr) {
    let Cn = "";
    const Bn = nr.every((In) => (Cn = m$1(_n, In, !0), Cn === !0));
    return Bn || d$1(`arrayOf - value validation error:
${$$1(Cn)}`), Bn;
  } });
}
function B$1(_n) {
  return j$1("instanceOf", { type: _n });
}
function I$1(_n) {
  return j$1("objectOf", { type: Object, validator(nr) {
    let Cn = "";
    const Bn = Object.keys(nr).every((In) => (Cn = m$1(_n, nr[In], !0), Cn === !0));
    return Bn || d$1(`objectOf - value validation error:
${$$1(Cn)}`), Bn;
  } });
}
function J$1(_n) {
  const nr = Object.keys(_n), Cn = nr.filter((In) => {
    var Dn;
    return !((Dn = _n[In]) === null || Dn === void 0 || !Dn.required);
  }), Bn = j$1("shape", { type: Object, validator(In) {
    if (!c$1(In))
      return !1;
    const Dn = Object.keys(In);
    if (Cn.length > 0 && Cn.some((Ln) => Dn.indexOf(Ln) === -1)) {
      const Ln = Cn.filter(($n) => Dn.indexOf($n) === -1);
      return d$1(Ln.length === 1 ? `shape - required property "${Ln[0]}" is not defined.` : `shape - required properties "${Ln.join('", "')}" are not defined.`), !1;
    }
    return Dn.every((Ln) => {
      if (nr.indexOf(Ln) === -1)
        return this._vueTypes_isLoose === !0 || (d$1(`shape - shape definition does not include a "${Ln}" property. Allowed keys: "${nr.join('", "')}".`), !1);
      const $n = m$1(_n[Ln], In[Ln], !0);
      return typeof $n == "string" && d$1(`shape - "${Ln}" property validation error:
 ${$$1($n)}`), $n === !0;
    });
  } });
  return Object.defineProperty(Bn, "_vueTypes_isLoose", { writable: !0, value: !1 }), Object.defineProperty(Bn, "loose", { get() {
    return this._vueTypes_isLoose = !0, this;
  } }), Bn;
}
const M$1 = ["name", "validate", "getter"], R$1 = /* @__PURE__ */ (() => {
  var _n;
  return (_n = class {
    static get any() {
      return w$1();
    }
    static get func() {
      return P$2().def(this.defaults.func);
    }
    static get bool() {
      return x$1().def(this.defaults.bool);
    }
    static get string() {
      return E$1().def(this.defaults.string);
    }
    static get number() {
      return N$1().def(this.defaults.number);
    }
    static get array() {
      return q$2().def(this.defaults.array);
    }
    static get object() {
      return A$2().def(this.defaults.object);
    }
    static get integer() {
      return V$1().def(this.defaults.integer);
    }
    static get symbol() {
      return S$1();
    }
    static get nullable() {
      return { type: null };
    }
    static extend(nr) {
      if (v$1(nr))
        return nr.forEach((Nn) => this.extend(Nn)), this;
      const { name: Cn, validate: Bn = !1, getter: In = !1 } = nr, Dn = r$1(nr, M$1);
      if (p$1(this, Cn))
        throw new TypeError(`[VueTypes error]: Type "${Cn}" already defined`);
      const { type: Ln } = Dn;
      if (b$1(Ln))
        return delete Dn.type, Object.defineProperty(this, Cn, In ? { get: () => T$1(Cn, Ln, Dn) } : { value(...Nn) {
          const Rn = T$1(Cn, Ln, Dn);
          return Rn.validator && (Rn.validator = Rn.validator.bind(Rn, ...Nn)), Rn;
        } });
      let $n;
      return $n = In ? { get() {
        const Nn = Object.assign({}, Dn);
        return Bn ? _$1(Cn, Nn) : j$1(Cn, Nn);
      }, enumerable: !0 } : { value(...Nn) {
        const Rn = Object.assign({}, Dn);
        let Fn;
        return Fn = Bn ? _$1(Cn, Rn) : j$1(Cn, Rn), Rn.validator && (Fn.validator = Rn.validator.bind(Fn, ...Nn)), Fn;
      }, enumerable: !0 }, Object.defineProperty(this, Cn, $n);
    }
  }).defaults = {}, _n.sensibleDefaults = void 0, _n.config = n$1, _n.custom = D$1, _n.oneOf = L$1, _n.instanceOf = B$1, _n.oneOfType = F$1, _n.arrayOf = Y$1, _n.objectOf = I$1, _n.shape = J$1, _n.utils = { validate: (nr, Cn) => m$1(Cn, nr, !0) === !0, toType: (nr, Cn, Bn = !1) => Bn ? _$1(nr, Cn) : j$1(nr, Cn) }, _n;
})();
function z$2(_n = { func: () => {
}, bool: !0, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
  var nr;
  return (nr = class extends R$1 {
    static get sensibleDefaults() {
      return t$2({}, this.defaults);
    }
    static set sensibleDefaults(Cn) {
      this.defaults = Cn !== !1 ? t$2({}, Cn !== !0 ? Cn : _n) : {};
    }
  }).defaults = t$2({}, _n), nr;
}
let C$1 = class extends z$2() {
};
var t$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function e(_n) {
  var nr = { exports: {} };
  return _n(nr, nr.exports), nr.exports;
}
var n = function(_n) {
  return _n && _n.Math == Math && _n;
}, r = n(typeof globalThis == "object" && globalThis) || n(typeof window == "object" && window) || n(typeof self == "object" && self) || n(typeof t$1 == "object" && t$1) || function() {
  return this;
}() || Function("return this")(), o = function(_n) {
  try {
    return !!_n();
  } catch {
    return !0;
  }
}, i$1 = !o(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
}), u = {}.propertyIsEnumerable, a = Object.getOwnPropertyDescriptor, c = { f: a && !u.call({ 1: 2 }, 1) ? function(_n) {
  var nr = a(this, _n);
  return !!nr && nr.enumerable;
} : u }, l = function(_n, nr) {
  return { enumerable: !(1 & _n), configurable: !(2 & _n), writable: !(4 & _n), value: nr };
}, f = {}.toString, s = function(_n) {
  return f.call(_n).slice(8, -1);
}, d = "".split, v = o(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(_n) {
  return s(_n) == "String" ? d.call(_n, "") : Object(_n);
} : Object, p = function(_n) {
  if (_n == null)
    throw TypeError("Can't call method on " + _n);
  return _n;
}, g = function(_n) {
  return v(p(_n));
}, h = function(_n) {
  return typeof _n == "object" ? _n !== null : typeof _n == "function";
}, y = function(_n, nr) {
  if (!h(_n))
    return _n;
  var Cn, Bn;
  if (nr && typeof (Cn = _n.toString) == "function" && !h(Bn = Cn.call(_n)) || typeof (Cn = _n.valueOf) == "function" && !h(Bn = Cn.call(_n)) || !nr && typeof (Cn = _n.toString) == "function" && !h(Bn = Cn.call(_n)))
    return Bn;
  throw TypeError("Can't convert object to primitive value");
}, m = {}.hasOwnProperty, S = function(_n, nr) {
  return m.call(_n, nr);
}, x = r.document, b = h(x) && h(x.createElement), E = function(_n) {
  return b ? x.createElement(_n) : {};
}, w = !i$1 && !o(function() {
  return Object.defineProperty(E("div"), "a", { get: function() {
    return 7;
  } }).a != 7;
}), O = Object.getOwnPropertyDescriptor, T = { f: i$1 ? O : function(_n, nr) {
  if (_n = g(_n), nr = y(nr, !0), w)
    try {
      return O(_n, nr);
    } catch {
    }
  if (S(_n, nr))
    return l(!c.f.call(_n, nr), _n[nr]);
} }, A$1 = function(_n) {
  if (!h(_n))
    throw TypeError(String(_n) + " is not an object");
  return _n;
}, k$1 = Object.defineProperty, R = { f: i$1 ? k$1 : function(_n, nr, Cn) {
  if (A$1(_n), nr = y(nr, !0), A$1(Cn), w)
    try {
      return k$1(_n, nr, Cn);
    } catch {
    }
  if ("get" in Cn || "set" in Cn)
    throw TypeError("Accessors not supported");
  return "value" in Cn && (_n[nr] = Cn.value), _n;
} }, I = i$1 ? function(_n, nr, Cn) {
  return R.f(_n, nr, l(1, Cn));
} : function(_n, nr, Cn) {
  return _n[nr] = Cn, _n;
}, j = function(_n, nr) {
  try {
    I(r, _n, nr);
  } catch {
    r[_n] = nr;
  }
  return nr;
}, C = r["__core-js_shared__"] || j("__core-js_shared__", {}), L = Function.toString;
typeof C.inspectSource != "function" && (C.inspectSource = function(_n) {
  return L.call(_n);
});
var P$1, M, _, D = C.inspectSource, U = r.WeakMap, N = typeof U == "function" && /native code/.test(D(U)), F = e(function(_n) {
  (_n.exports = function(nr, Cn) {
    return C[nr] || (C[nr] = Cn !== void 0 ? Cn : {});
  })("versions", []).push({ version: "3.8.3", mode: "global", copyright: "© 2021 Denis Pushkarev (zloirock.ru)" });
}), W$1 = 0, z$1 = Math.random(), $ = function(_n) {
  return "Symbol(" + String(_n === void 0 ? "" : _n) + ")_" + (++W$1 + z$1).toString(36);
}, B = F("keys"), Y = function(_n) {
  return B[_n] || (B[_n] = $(_n));
}, G = {}, H = r.WeakMap;
if (N) {
  var X = C.state || (C.state = new H()), V = X.get, K = X.has, q$1 = X.set;
  P$1 = function(_n, nr) {
    return nr.facade = _n, q$1.call(X, _n, nr), nr;
  }, M = function(_n) {
    return V.call(X, _n) || {};
  }, _ = function(_n) {
    return K.call(X, _n);
  };
} else {
  var Q = Y("state");
  G[Q] = !0, P$1 = function(_n, nr) {
    return nr.facade = _n, I(_n, Q, nr), nr;
  }, M = function(_n) {
    return S(_n, Q) ? _n[Q] : {};
  }, _ = function(_n) {
    return S(_n, Q);
  };
}
var J = { set: P$1, get: M, has: _, enforce: function(_n) {
  return _(_n) ? M(_n) : P$1(_n, {});
}, getterFor: function(_n) {
  return function(nr) {
    var Cn;
    if (!h(nr) || (Cn = M(nr)).type !== _n)
      throw TypeError("Incompatible receiver, " + _n + " required");
    return Cn;
  };
} }, Z = e(function(_n) {
  var nr = J.get, Cn = J.enforce, Bn = String(String).split("String");
  (_n.exports = function(In, Dn, Ln, $n) {
    var Nn, Rn = !!$n && !!$n.unsafe, Fn = !!$n && !!$n.enumerable, Pn = !!$n && !!$n.noTargetGet;
    typeof Ln == "function" && (typeof Dn != "string" || S(Ln, "name") || I(Ln, "name", Dn), (Nn = Cn(Ln)).source || (Nn.source = Bn.join(typeof Dn == "string" ? Dn : ""))), In !== r ? (Rn ? !Pn && In[Dn] && (Fn = !0) : delete In[Dn], Fn ? In[Dn] = Ln : I(In, Dn, Ln)) : Fn ? In[Dn] = Ln : j(Dn, Ln);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && nr(this).source || D(this);
  });
}), tt = r, et = function(_n) {
  return typeof _n == "function" ? _n : void 0;
}, nt = function(_n, nr) {
  return arguments.length < 2 ? et(tt[_n]) || et(r[_n]) : tt[_n] && tt[_n][nr] || r[_n] && r[_n][nr];
}, rt = Math.ceil, ot = Math.floor, it$1 = function(_n) {
  return isNaN(_n = +_n) ? 0 : (_n > 0 ? ot : rt)(_n);
}, ut$1 = Math.min, at = function(_n) {
  return _n > 0 ? ut$1(it$1(_n), 9007199254740991) : 0;
}, ct$1 = Math.max, lt$1 = Math.min, ft$1 = function(_n, nr) {
  var Cn = it$1(_n);
  return Cn < 0 ? ct$1(Cn + nr, 0) : lt$1(Cn, nr);
}, st$1 = function(_n) {
  return function(nr, Cn, Bn) {
    var In, Dn = g(nr), Ln = at(Dn.length), $n = ft$1(Bn, Ln);
    if (_n && Cn != Cn) {
      for (; Ln > $n; )
        if ((In = Dn[$n++]) != In)
          return !0;
    } else
      for (; Ln > $n; $n++)
        if ((_n || $n in Dn) && Dn[$n] === Cn)
          return _n || $n || 0;
    return !_n && -1;
  };
}, dt$1 = { includes: st$1(!0), indexOf: st$1(!1) }, vt$1 = dt$1.indexOf, pt$1 = function(_n, nr) {
  var Cn, Bn = g(_n), In = 0, Dn = [];
  for (Cn in Bn)
    !S(G, Cn) && S(Bn, Cn) && Dn.push(Cn);
  for (; nr.length > In; )
    S(Bn, Cn = nr[In++]) && (~vt$1(Dn, Cn) || Dn.push(Cn));
  return Dn;
}, gt$1 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], ht$1 = gt$1.concat("length", "prototype"), yt$1 = { f: Object.getOwnPropertyNames || function(_n) {
  return pt$1(_n, ht$1);
} }, mt$1 = { f: Object.getOwnPropertySymbols }, St$1 = nt("Reflect", "ownKeys") || function(_n) {
  var nr = yt$1.f(A$1(_n)), Cn = mt$1.f;
  return Cn ? nr.concat(Cn(_n)) : nr;
}, xt$1 = function(_n, nr) {
  for (var Cn = St$1(nr), Bn = R.f, In = T.f, Dn = 0; Dn < Cn.length; Dn++) {
    var Ln = Cn[Dn];
    S(_n, Ln) || Bn(_n, Ln, In(nr, Ln));
  }
}, bt$1 = /#|\.prototype\./, Et$1 = function(_n, nr) {
  var Cn = Ot$1[wt$1(_n)];
  return Cn == At$1 || Cn != Tt$1 && (typeof nr == "function" ? o(nr) : !!nr);
}, wt$1 = Et$1.normalize = function(_n) {
  return String(_n).replace(bt$1, ".").toLowerCase();
}, Ot$1 = Et$1.data = {}, Tt$1 = Et$1.NATIVE = "N", At$1 = Et$1.POLYFILL = "P", kt$1 = Et$1, Rt$1 = T.f, It$1 = function(_n, nr) {
  var Cn, Bn, In, Dn, Ln, $n = _n.target, Nn = _n.global, Rn = _n.stat;
  if (Cn = Nn ? r : Rn ? r[$n] || j($n, {}) : (r[$n] || {}).prototype)
    for (Bn in nr) {
      if (Dn = nr[Bn], In = _n.noTargetGet ? (Ln = Rt$1(Cn, Bn)) && Ln.value : Cn[Bn], !kt$1(Nn ? Bn : $n + (Rn ? "." : "#") + Bn, _n.forced) && In !== void 0) {
        if (typeof Dn == typeof In)
          continue;
        xt$1(Dn, In);
      }
      (_n.sham || In && In.sham) && I(Dn, "sham", !0), Z(Cn, Bn, Dn, _n);
    }
}, jt$1 = function(_n, nr) {
  var Cn = [][_n];
  return !!Cn && o(function() {
    Cn.call(null, nr || function() {
      throw 1;
    }, 1);
  });
}, Ct$1 = Object.defineProperty, Lt$1 = {}, Pt$1 = function(_n) {
  throw _n;
}, Mt$1 = function(_n, nr) {
  if (S(Lt$1, _n))
    return Lt$1[_n];
  nr || (nr = {});
  var Cn = [][_n], Bn = !!S(nr, "ACCESSORS") && nr.ACCESSORS, In = S(nr, 0) ? nr[0] : Pt$1, Dn = S(nr, 1) ? nr[1] : void 0;
  return Lt$1[_n] = !!Cn && !o(function() {
    if (Bn && !i$1)
      return !0;
    var Ln = { length: -1 };
    Bn ? Ct$1(Ln, 1, { enumerable: !0, get: Pt$1 }) : Ln[1] = 1, Cn.call(Ln, In, Dn);
  });
}, _t$1 = dt$1.indexOf, Dt$1 = [].indexOf, Ut$1 = !!Dt$1 && 1 / [1].indexOf(1, -0) < 0, Nt$1 = jt$1("indexOf"), Ft$1 = Mt$1("indexOf", { ACCESSORS: !0, 1: 0 });
function Wt$1(_n, nr) {
  if (!(_n instanceof nr))
    throw new TypeError("Cannot call a class as a function");
}
function zt$1(_n, nr) {
  for (var Cn = 0; Cn < nr.length; Cn++) {
    var Bn = nr[Cn];
    Bn.enumerable = Bn.enumerable || !1, Bn.configurable = !0, "value" in Bn && (Bn.writable = !0), Object.defineProperty(_n, Bn.key, Bn);
  }
}
function $t$1(_n, nr, Cn) {
  return nr && zt$1(_n.prototype, nr), Cn && zt$1(_n, Cn), _n;
}
It$1({ target: "Array", proto: !0, forced: Ut$1 || !Nt$1 || !Ft$1 }, { indexOf: function(_n) {
  return Ut$1 ? Dt$1.apply(this, arguments) || 0 : _t$1(this, _n, arguments.length > 1 ? arguments[1] : void 0);
} });
(function() {
  function _n() {
    Wt$1(this, _n);
  }
  return $t$1(_n, null, [{ key: "isInBrowser", value: function() {
    return typeof window < "u";
  } }, { key: "isServer", value: function() {
    return typeof window > "u";
  } }, { key: "getUA", value: function() {
    return _n.isInBrowser() ? window.navigator.userAgent.toLowerCase() : "";
  } }, { key: "isMobile", value: function() {
    return /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(navigator.appVersion);
  } }, { key: "isOpera", value: function() {
    return navigator.userAgent.indexOf("Opera") !== -1;
  } }, { key: "isIE", value: function() {
    var nr = _n.getUA();
    return nr !== "" && nr.indexOf("msie") > 0;
  } }, { key: "isIE9", value: function() {
    var nr = _n.getUA();
    return nr !== "" && nr.indexOf("msie 9.0") > 0;
  } }, { key: "isEdge", value: function() {
    var nr = _n.getUA();
    return nr !== "" && nr.indexOf("edge/") > 0;
  } }, { key: "isChrome", value: function() {
    var nr = _n.getUA();
    return nr !== "" && /chrome\/\d+/.test(nr) && !_n.isEdge();
  } }, { key: "isPhantomJS", value: function() {
    var nr = _n.getUA();
    return nr !== "" && /phantomjs/.test(nr);
  } }, { key: "isFirefox", value: function() {
    var nr = _n.getUA();
    return nr !== "" && /firefox/.test(nr);
  } }]), _n;
})();
var Yt$1 = [].join, Gt$1 = v != Object, Ht$1 = jt$1("join", ",");
It$1({ target: "Array", proto: !0, forced: Gt$1 || !Ht$1 }, { join: function(_n) {
  return Yt$1.call(g(this), _n === void 0 ? "," : _n);
} });
var Xt$1, Vt$1, Kt$1 = function(_n) {
  return Object(p(_n));
}, qt$1 = Array.isArray || function(_n) {
  return s(_n) == "Array";
}, Qt$1 = !!Object.getOwnPropertySymbols && !o(function() {
  return !String(Symbol());
}), Jt$1 = Qt$1 && !Symbol.sham && typeof Symbol.iterator == "symbol", Zt$1 = F("wks"), te = r.Symbol, ee = Jt$1 ? te : te && te.withoutSetter || $, ne = function(_n) {
  return S(Zt$1, _n) || (Qt$1 && S(te, _n) ? Zt$1[_n] = te[_n] : Zt$1[_n] = ee("Symbol." + _n)), Zt$1[_n];
}, re$1 = ne("species"), oe = function(_n, nr) {
  var Cn;
  return qt$1(_n) && (typeof (Cn = _n.constructor) != "function" || Cn !== Array && !qt$1(Cn.prototype) ? h(Cn) && (Cn = Cn[re$1]) === null && (Cn = void 0) : Cn = void 0), new (Cn === void 0 ? Array : Cn)(nr === 0 ? 0 : nr);
}, ie$1 = function(_n, nr, Cn) {
  var Bn = y(nr);
  Bn in _n ? R.f(_n, Bn, l(0, Cn)) : _n[Bn] = Cn;
}, ue$1 = nt("navigator", "userAgent") || "", ae = r.process, ce = ae && ae.versions, le = ce && ce.v8;
le ? Vt$1 = (Xt$1 = le.split("."))[0] + Xt$1[1] : ue$1 && (!(Xt$1 = ue$1.match(/Edge\/(\d+)/)) || Xt$1[1] >= 74) && (Xt$1 = ue$1.match(/Chrome\/(\d+)/)) && (Vt$1 = Xt$1[1]);
var fe$1 = Vt$1 && +Vt$1, se = ne("species"), de$1 = function(_n) {
  return fe$1 >= 51 || !o(function() {
    var nr = [];
    return (nr.constructor = {})[se] = function() {
      return { foo: 1 };
    }, nr[_n](Boolean).foo !== 1;
  });
}, ve$1 = de$1("splice"), pe = Mt$1("splice", { ACCESSORS: !0, 0: 0, 1: 2 }), ge = Math.max, he = Math.min;
It$1({ target: "Array", proto: !0, forced: !ve$1 || !pe }, { splice: function(_n, nr) {
  var Cn, Bn, In, Dn, Ln, $n, Nn = Kt$1(this), Rn = at(Nn.length), Fn = ft$1(_n, Rn), Pn = arguments.length;
  if (Pn === 0 ? Cn = Bn = 0 : Pn === 1 ? (Cn = 0, Bn = Rn - Fn) : (Cn = Pn - 2, Bn = he(ge(it$1(nr), 0), Rn - Fn)), Rn + Cn - Bn > 9007199254740991)
    throw TypeError("Maximum allowed length exceeded");
  for (In = oe(Nn, Bn), Dn = 0; Dn < Bn; Dn++)
    (Ln = Fn + Dn) in Nn && ie$1(In, Dn, Nn[Ln]);
  if (In.length = Bn, Cn < Bn) {
    for (Dn = Fn; Dn < Rn - Bn; Dn++)
      $n = Dn + Cn, (Ln = Dn + Bn) in Nn ? Nn[$n] = Nn[Ln] : delete Nn[$n];
    for (Dn = Rn; Dn > Rn - Bn + Cn; Dn--)
      delete Nn[Dn - 1];
  } else if (Cn > Bn)
    for (Dn = Rn - Bn; Dn > Fn; Dn--)
      $n = Dn + Cn - 1, (Ln = Dn + Bn - 1) in Nn ? Nn[$n] = Nn[Ln] : delete Nn[$n];
  for (Dn = 0; Dn < Cn; Dn++)
    Nn[Dn + Fn] = arguments[Dn + 2];
  return Nn.length = Rn - Bn + Cn, In;
} });
var ye$1 = {};
ye$1[ne("toStringTag")] = "z";
var me$1 = String(ye$1) === "[object z]", Se$1 = ne("toStringTag"), xe = s(function() {
  return arguments;
}()) == "Arguments", be$1 = me$1 ? s : function(_n) {
  var nr, Cn, Bn;
  return _n === void 0 ? "Undefined" : _n === null ? "Null" : typeof (Cn = function(In, Dn) {
    try {
      return In[Dn];
    } catch {
    }
  }(nr = Object(_n), Se$1)) == "string" ? Cn : xe ? s(nr) : (Bn = s(nr)) == "Object" && typeof nr.callee == "function" ? "Arguments" : Bn;
}, Ee = me$1 ? {}.toString : function() {
  return "[object " + be$1(this) + "]";
};
me$1 || Z(Object.prototype, "toString", Ee, { unsafe: !0 });
var we = function() {
  var _n = A$1(this), nr = "";
  return _n.global && (nr += "g"), _n.ignoreCase && (nr += "i"), _n.multiline && (nr += "m"), _n.dotAll && (nr += "s"), _n.unicode && (nr += "u"), _n.sticky && (nr += "y"), nr;
};
function Oe(_n, nr) {
  return RegExp(_n, nr);
}
var Te, Ae$1, ke$1 = { UNSUPPORTED_Y: o(function() {
  var _n = Oe("a", "y");
  return _n.lastIndex = 2, _n.exec("abcd") != null;
}), BROKEN_CARET: o(function() {
  var _n = Oe("^r", "gy");
  return _n.lastIndex = 2, _n.exec("str") != null;
}) }, Re = RegExp.prototype.exec, Ie = String.prototype.replace, je = Re, Ce$1 = (Te = /a/, Ae$1 = /b*/g, Re.call(Te, "a"), Re.call(Ae$1, "a"), Te.lastIndex !== 0 || Ae$1.lastIndex !== 0), Le$1 = ke$1.UNSUPPORTED_Y || ke$1.BROKEN_CARET, Pe$1 = /()??/.exec("")[1] !== void 0;
(Ce$1 || Pe$1 || Le$1) && (je = function(_n) {
  var nr, Cn, Bn, In, Dn = this, Ln = Le$1 && Dn.sticky, $n = we.call(Dn), Nn = Dn.source, Rn = 0, Fn = _n;
  return Ln && (($n = $n.replace("y", "")).indexOf("g") === -1 && ($n += "g"), Fn = String(_n).slice(Dn.lastIndex), Dn.lastIndex > 0 && (!Dn.multiline || Dn.multiline && _n[Dn.lastIndex - 1] !== `
`) && (Nn = "(?: " + Nn + ")", Fn = " " + Fn, Rn++), Cn = new RegExp("^(?:" + Nn + ")", $n)), Pe$1 && (Cn = new RegExp("^" + Nn + "$(?!\\s)", $n)), Ce$1 && (nr = Dn.lastIndex), Bn = Re.call(Ln ? Cn : Dn, Fn), Ln ? Bn ? (Bn.input = Bn.input.slice(Rn), Bn[0] = Bn[0].slice(Rn), Bn.index = Dn.lastIndex, Dn.lastIndex += Bn[0].length) : Dn.lastIndex = 0 : Ce$1 && Bn && (Dn.lastIndex = Dn.global ? Bn.index + Bn[0].length : nr), Pe$1 && Bn && Bn.length > 1 && Ie.call(Bn[0], Cn, function() {
    for (In = 1; In < arguments.length - 2; In++)
      arguments[In] === void 0 && (Bn[In] = void 0);
  }), Bn;
});
var Me$1 = je;
It$1({ target: "RegExp", proto: !0, forced: /./.exec !== Me$1 }, { exec: Me$1 });
var _e$1 = RegExp.prototype, De = _e$1.toString, Ue = o(function() {
  return De.call({ source: "a", flags: "b" }) != "/a/b";
}), Ne$1 = De.name != "toString";
(Ue || Ne$1) && Z(RegExp.prototype, "toString", function() {
  var _n = A$1(this), nr = String(_n.source), Cn = _n.flags;
  return "/" + nr + "/" + String(Cn === void 0 && _n instanceof RegExp && !("flags" in _e$1) ? we.call(_n) : Cn);
}, { unsafe: !0 });
var Fe = ne("species"), We = !o(function() {
  var _n = /./;
  return _n.exec = function() {
    var nr = [];
    return nr.groups = { a: "7" }, nr;
  }, "".replace(_n, "$<a>") !== "7";
}), ze = "a".replace(/./, "$0") === "$0", $e = ne("replace"), Be = !!/./[$e] && /./[$e]("a", "$0") === "", Ye$1 = !o(function() {
  var _n = /(?:)/, nr = _n.exec;
  _n.exec = function() {
    return nr.apply(this, arguments);
  };
  var Cn = "ab".split(_n);
  return Cn.length !== 2 || Cn[0] !== "a" || Cn[1] !== "b";
}), Ge = function(_n, nr, Cn, Bn) {
  var In = ne(_n), Dn = !o(function() {
    var Pn = {};
    return Pn[In] = function() {
      return 7;
    }, ""[_n](Pn) != 7;
  }), Ln = Dn && !o(function() {
    var Pn = !1, Un = /a/;
    return _n === "split" && ((Un = {}).constructor = {}, Un.constructor[Fe] = function() {
      return Un;
    }, Un.flags = "", Un[In] = /./[In]), Un.exec = function() {
      return Pn = !0, null;
    }, Un[In](""), !Pn;
  });
  if (!Dn || !Ln || _n === "replace" && (!We || !ze || Be) || _n === "split" && !Ye$1) {
    var $n = /./[In], Nn = Cn(In, ""[_n], function(Pn, Un, Hn, zn, Gn) {
      return Un.exec === Me$1 ? Dn && !Gn ? { done: !0, value: $n.call(Un, Hn, zn) } : { done: !0, value: Pn.call(Hn, Un, zn) } : { done: !1 };
    }, { REPLACE_KEEPS_$0: ze, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Be }), Rn = Nn[0], Fn = Nn[1];
    Z(String.prototype, _n, Rn), Z(RegExp.prototype, In, nr == 2 ? function(Pn, Un) {
      return Fn.call(Pn, this, Un);
    } : function(Pn) {
      return Fn.call(Pn, this);
    });
  }
  Bn && I(RegExp.prototype[In], "sham", !0);
}, He = ne("match"), Xe = function(_n) {
  var nr;
  return h(_n) && ((nr = _n[He]) !== void 0 ? !!nr : s(_n) == "RegExp");
}, Ve$1 = function(_n) {
  if (typeof _n != "function")
    throw TypeError(String(_n) + " is not a function");
  return _n;
}, Ke$1 = ne("species"), qe$1 = function(_n) {
  return function(nr, Cn) {
    var Bn, In, Dn = String(p(nr)), Ln = it$1(Cn), $n = Dn.length;
    return Ln < 0 || Ln >= $n ? _n ? "" : void 0 : (Bn = Dn.charCodeAt(Ln)) < 55296 || Bn > 56319 || Ln + 1 === $n || (In = Dn.charCodeAt(Ln + 1)) < 56320 || In > 57343 ? _n ? Dn.charAt(Ln) : Bn : _n ? Dn.slice(Ln, Ln + 2) : In - 56320 + (Bn - 55296 << 10) + 65536;
  };
}, Qe = { codeAt: qe$1(!1), charAt: qe$1(!0) }, Je = Qe.charAt, Ze = function(_n, nr, Cn) {
  return nr + (Cn ? Je(_n, nr).length : 1);
}, tn = function(_n, nr) {
  var Cn = _n.exec;
  if (typeof Cn == "function") {
    var Bn = Cn.call(_n, nr);
    if (typeof Bn != "object")
      throw TypeError("RegExp exec method returned something other than an Object or null");
    return Bn;
  }
  if (s(_n) !== "RegExp")
    throw TypeError("RegExp#exec called on incompatible receiver");
  return Me$1.call(_n, nr);
}, en = [].push, nn = Math.min, rn = !o(function() {
  return !RegExp(4294967295, "y");
});
Ge("split", 2, function(_n, nr, Cn) {
  var Bn;
  return Bn = "abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(In, Dn) {
    var Ln = String(p(this)), $n = Dn === void 0 ? 4294967295 : Dn >>> 0;
    if ($n === 0)
      return [];
    if (In === void 0)
      return [Ln];
    if (!Xe(In))
      return nr.call(Ln, In, $n);
    for (var Nn, Rn, Fn, Pn = [], Un = (In.ignoreCase ? "i" : "") + (In.multiline ? "m" : "") + (In.unicode ? "u" : "") + (In.sticky ? "y" : ""), Hn = 0, zn = new RegExp(In.source, Un + "g"); (Nn = Me$1.call(zn, Ln)) && !((Rn = zn.lastIndex) > Hn && (Pn.push(Ln.slice(Hn, Nn.index)), Nn.length > 1 && Nn.index < Ln.length && en.apply(Pn, Nn.slice(1)), Fn = Nn[0].length, Hn = Rn, Pn.length >= $n)); )
      zn.lastIndex === Nn.index && zn.lastIndex++;
    return Hn === Ln.length ? !Fn && zn.test("") || Pn.push("") : Pn.push(Ln.slice(Hn)), Pn.length > $n ? Pn.slice(0, $n) : Pn;
  } : "0".split(void 0, 0).length ? function(In, Dn) {
    return In === void 0 && Dn === 0 ? [] : nr.call(this, In, Dn);
  } : nr, [function(In, Dn) {
    var Ln = p(this), $n = In == null ? void 0 : In[_n];
    return $n !== void 0 ? $n.call(In, Ln, Dn) : Bn.call(String(Ln), In, Dn);
  }, function(In, Dn) {
    var Ln = Cn(Bn, In, this, Dn, Bn !== nr);
    if (Ln.done)
      return Ln.value;
    var $n = A$1(In), Nn = String(this), Rn = function(ta, na) {
      var ra, aa = A$1(ta).constructor;
      return aa === void 0 || (ra = A$1(aa)[Ke$1]) == null ? na : Ve$1(ra);
    }($n, RegExp), Fn = $n.unicode, Pn = ($n.ignoreCase ? "i" : "") + ($n.multiline ? "m" : "") + ($n.unicode ? "u" : "") + (rn ? "y" : "g"), Un = new Rn(rn ? $n : "^(?:" + $n.source + ")", Pn), Hn = Dn === void 0 ? 4294967295 : Dn >>> 0;
    if (Hn === 0)
      return [];
    if (Nn.length === 0)
      return tn(Un, Nn) === null ? [Nn] : [];
    for (var zn = 0, Gn = 0, Yn = []; Gn < Nn.length; ) {
      Un.lastIndex = rn ? Gn : 0;
      var Wn, Xn = tn(Un, rn ? Nn : Nn.slice(Gn));
      if (Xn === null || (Wn = nn(at(Un.lastIndex + (rn ? 0 : Gn)), Nn.length)) === zn)
        Gn = Ze(Nn, Gn, Fn);
      else {
        if (Yn.push(Nn.slice(zn, Gn)), Yn.length === Hn)
          return Yn;
        for (var ea = 1; ea <= Xn.length - 1; ea++)
          if (Yn.push(Xn[ea]), Yn.length === Hn)
            return Yn;
        Gn = zn = Wn;
      }
    }
    return Yn.push(Nn.slice(zn)), Yn;
  }];
}, !rn);
var on = `	
\v\f\r                　\u2028\u2029\uFEFF`, un = "[" + on + "]", an = RegExp("^" + un + un + "*"), cn = RegExp(un + un + "*$"), ln = function(_n) {
  return function(nr) {
    var Cn = String(p(nr));
    return 1 & _n && (Cn = Cn.replace(an, "")), 2 & _n && (Cn = Cn.replace(cn, "")), Cn;
  };
}, fn = { start: ln(1), end: ln(2), trim: ln(3) }, sn = fn.trim;
It$1({ target: "String", proto: !0, forced: function(_n) {
  return o(function() {
    return !!on[_n]() || "​᠎"[_n]() != "​᠎" || on[_n].name !== _n;
  });
}("trim") }, { trim: function() {
  return sn(this);
} });
var dn = de$1("slice"), vn = Mt$1("slice", { ACCESSORS: !0, 0: 0, 1: 2 }), pn = ne("species"), gn = [].slice, hn = Math.max;
It$1({ target: "Array", proto: !0, forced: !dn || !vn }, { slice: function(_n, nr) {
  var Cn, Bn, In, Dn = g(this), Ln = at(Dn.length), $n = ft$1(_n, Ln), Nn = ft$1(nr === void 0 ? Ln : nr, Ln);
  if (qt$1(Dn) && (typeof (Cn = Dn.constructor) != "function" || Cn !== Array && !qt$1(Cn.prototype) ? h(Cn) && (Cn = Cn[pn]) === null && (Cn = void 0) : Cn = void 0, Cn === Array || Cn === void 0))
    return gn.call(Dn, $n, Nn);
  for (Bn = new (Cn === void 0 ? Array : Cn)(hn(Nn - $n, 0)), In = 0; $n < Nn; $n++, In++)
    $n in Dn && ie$1(Bn, In, Dn[$n]);
  return Bn.length = In, Bn;
} });
var yn = Object.keys || function(_n) {
  return pt$1(_n, gt$1);
}, mn = o(function() {
  yn(1);
});
It$1({ target: "Object", stat: !0, forced: mn }, { keys: function(_n) {
  return yn(Kt$1(_n));
} });
var Sn, xn = function(_n) {
  if (Xe(_n))
    throw TypeError("The method doesn't accept regular expressions");
  return _n;
}, bn = ne("match"), En = T.f, wn = "".startsWith, On = Math.min, Tn = function(_n) {
  var nr = /./;
  try {
    "/./"[_n](nr);
  } catch {
    try {
      return nr[bn] = !1, "/./"[_n](nr);
    } catch {
    }
  }
  return !1;
}("startsWith"), An = !(Tn || (Sn = En(String.prototype, "startsWith"), !Sn || Sn.writable));
function kn(_n) {
  return (kn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(nr) {
    return typeof nr;
  } : function(nr) {
    return nr && typeof Symbol == "function" && nr.constructor === Symbol && nr !== Symbol.prototype ? "symbol" : typeof nr;
  })(_n);
}
It$1({ target: "String", proto: !0, forced: !An && !Tn }, { startsWith: function(_n) {
  var nr = String(p(this));
  xn(_n);
  var Cn = at(On(arguments.length > 1 ? arguments[1] : void 0, nr.length)), Bn = String(_n);
  return wn ? wn.call(nr, Bn, Cn) : nr.slice(Cn, Cn + Bn.length) === Bn;
} });
var jn = function(_n) {
  return typeof _n == "string";
}, Mn = function(_n) {
  return _n !== null && kn(_n) === "object";
}, Vn = function() {
  function _n() {
    Wt$1(this, _n);
  }
  return $t$1(_n, null, [{ key: "isWindow", value: function(nr) {
    return nr === window;
  } }, { key: "addEventListener", value: function(nr, Cn, Bn) {
    var In = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    nr && Cn && Bn && nr.addEventListener(Cn, Bn, In);
  } }, { key: "removeEventListener", value: function(nr, Cn, Bn) {
    var In = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    nr && Cn && Bn && nr.removeEventListener(Cn, Bn, In);
  } }, { key: "triggerDragEvent", value: function(nr, Cn) {
    var Bn = !1, In = function(Ln) {
      var $n;
      ($n = Cn.drag) === null || $n === void 0 || $n.call(Cn, Ln);
    }, Dn = function Ln($n) {
      var Nn;
      _n.removeEventListener(document, "mousemove", In), _n.removeEventListener(document, "mouseup", Ln), document.onselectstart = null, document.ondragstart = null, Bn = !1, (Nn = Cn.end) === null || Nn === void 0 || Nn.call(Cn, $n);
    };
    _n.addEventListener(nr, "mousedown", function(Ln) {
      var $n;
      Bn || (document.onselectstart = function() {
        return !1;
      }, document.ondragstart = function() {
        return !1;
      }, _n.addEventListener(document, "mousemove", In), _n.addEventListener(document, "mouseup", Dn), Bn = !0, ($n = Cn.start) === null || $n === void 0 || $n.call(Cn, Ln));
    });
  } }, { key: "getBoundingClientRect", value: function(nr) {
    return nr && Mn(nr) && nr.nodeType === 1 ? nr.getBoundingClientRect() : null;
  } }, { key: "hasClass", value: function(nr, Cn) {
    return !!(nr && Mn(nr) && jn(Cn) && nr.nodeType === 1) && nr.classList.contains(Cn.trim());
  } }, { key: "addClass", value: function(nr, Cn) {
    if (nr && Mn(nr) && jn(Cn) && nr.nodeType === 1 && (Cn = Cn.trim(), !_n.hasClass(nr, Cn))) {
      var Bn = nr.className;
      nr.className = Bn ? Bn + " " + Cn : Cn;
    }
  } }, { key: "removeClass", value: function(nr, Cn) {
    if (nr && Mn(nr) && jn(Cn) && nr.nodeType === 1 && typeof nr.className == "string") {
      Cn = Cn.trim();
      for (var Bn = nr.className.trim().split(" "), In = Bn.length - 1; In >= 0; In--)
        Bn[In] = Bn[In].trim(), Bn[In] && Bn[In] !== Cn || Bn.splice(In, 1);
      nr.className = Bn.join(" ");
    }
  } }, { key: "toggleClass", value: function(nr, Cn, Bn) {
    nr && Mn(nr) && jn(Cn) && nr.nodeType === 1 && nr.classList.toggle(Cn, Bn);
  } }, { key: "replaceClass", value: function(nr, Cn, Bn) {
    nr && Mn(nr) && jn(Cn) && jn(Bn) && nr.nodeType === 1 && (Cn = Cn.trim(), Bn = Bn.trim(), _n.removeClass(nr, Cn), _n.addClass(nr, Bn));
  } }, { key: "getScrollTop", value: function(nr) {
    var Cn = "scrollTop" in nr ? nr.scrollTop : nr.pageYOffset;
    return Math.max(Cn, 0);
  } }, { key: "setScrollTop", value: function(nr, Cn) {
    "scrollTop" in nr ? nr.scrollTop = Cn : nr.scrollTo(nr.scrollX, Cn);
  } }, { key: "getRootScrollTop", value: function() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  } }, { key: "setRootScrollTop", value: function(nr) {
    _n.setScrollTop(window, nr), _n.setScrollTop(document.body, nr);
  } }, { key: "getElementTop", value: function(nr, Cn) {
    if (_n.isWindow(nr))
      return 0;
    var Bn = Cn ? _n.getScrollTop(Cn) : _n.getRootScrollTop();
    return nr.getBoundingClientRect().top + Bn;
  } }, { key: "getVisibleHeight", value: function(nr) {
    return _n.isWindow(nr) ? nr.innerHeight : nr.getBoundingClientRect().height;
  } }, { key: "isHidden", value: function(nr) {
    if (!nr)
      return !1;
    var Cn = window.getComputedStyle(nr), Bn = Cn.display === "none", In = nr.offsetParent === null && Cn.position !== "fixed";
    return Bn || In;
  } }, { key: "triggerEvent", value: function(nr, Cn) {
    if ("createEvent" in document) {
      var Bn = document.createEvent("HTMLEvents");
      Bn.initEvent(Cn, !1, !0), nr.dispatchEvent(Bn);
    }
  } }, { key: "calcAngle", value: function(nr, Cn) {
    var Bn = nr.getBoundingClientRect(), In = Bn.left + Bn.width / 2, Dn = Bn.top + Bn.height / 2, Ln = Math.abs(In - Cn.clientX), $n = Math.abs(Dn - Cn.clientY), Nn = $n / Math.sqrt(Math.pow(Ln, 2) + Math.pow($n, 2)), Rn = Math.acos(Nn), Fn = Math.floor(180 / (Math.PI / Rn));
    return Cn.clientX > In && Cn.clientY > Dn && (Fn = 180 - Fn), Cn.clientX == In && Cn.clientY > Dn && (Fn = 180), Cn.clientX > In && Cn.clientY == Dn && (Fn = 90), Cn.clientX < In && Cn.clientY > Dn && (Fn = 180 + Fn), Cn.clientX < In && Cn.clientY == Dn && (Fn = 270), Cn.clientX < In && Cn.clientY < Dn && (Fn = 360 - Fn), Fn;
  } }, { key: "querySelector", value: function(nr, Cn) {
    return Cn ? Cn.querySelector(nr) : document.querySelector(nr);
  } }, { key: "createElement", value: function(nr) {
    for (var Cn = document.createElement(nr), Bn = arguments.length, In = new Array(Bn > 1 ? Bn - 1 : 0), Dn = 1; Dn < Bn; Dn++)
      In[Dn - 1] = arguments[Dn];
    for (var Ln = 0; Ln < In.length; Ln++)
      In[Ln] && Cn.classList.add(In[Ln]);
    return Cn;
  } }, { key: "appendChild", value: function(nr) {
    for (var Cn = 0; Cn < (arguments.length <= 1 ? 0 : arguments.length - 1); Cn++)
      nr.appendChild(Cn + 1 < 1 || arguments.length <= Cn + 1 ? void 0 : arguments[Cn + 1]);
  } }, { key: "getWindow", value: function(nr) {
    if (nr.toString() !== "[object Window]") {
      var Cn = nr.ownerDocument;
      return Cn && Cn.defaultView || window;
    }
    return nr;
  } }, { key: "isElement", value: function(nr) {
    return nr instanceof this.getWindow(nr).Element || nr instanceof Element;
  } }, { key: "isHTMLElement", value: function(nr) {
    return nr instanceof this.getWindow(nr).HTMLElement || nr instanceof HTMLElement;
  } }, { key: "isShadowRoot", value: function(nr) {
    return typeof ShadowRoot < "u" && (nr instanceof this.getWindow(nr).ShadowRoot || nr instanceof ShadowRoot);
  } }, { key: "getWindowScroll", value: function(nr) {
    var Cn = this.getWindow(nr);
    return { scrollLeft: Cn.pageXOffset || 0, scrollTop: Cn.pageYOffset || 0 };
  } }]), _n;
}(), Kn = Math.floor, qn = "".replace, Qn = /\$([$&'`]|\d\d?|<[^>]*>)/g, Jn = /\$([$&'`]|\d\d?)/g, Zn = function(_n, nr, Cn, Bn, In, Dn) {
  var Ln = Cn + _n.length, $n = Bn.length, Nn = Jn;
  return In !== void 0 && (In = Kt$1(In), Nn = Qn), qn.call(Dn, Nn, function(Rn, Fn) {
    var Pn;
    switch (Fn.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return _n;
      case "`":
        return nr.slice(0, Cn);
      case "'":
        return nr.slice(Ln);
      case "<":
        Pn = In[Fn.slice(1, -1)];
        break;
      default:
        var Un = +Fn;
        if (Un === 0)
          return Rn;
        if (Un > $n) {
          var Hn = Kn(Un / 10);
          return Hn === 0 ? Rn : Hn <= $n ? Bn[Hn - 1] === void 0 ? Fn.charAt(1) : Bn[Hn - 1] + Fn.charAt(1) : Rn;
        }
        Pn = Bn[Un - 1];
    }
    return Pn === void 0 ? "" : Pn;
  });
}, tr = Math.max, er = Math.min;
Ge("replace", 2, function(_n, nr, Cn, Bn) {
  var In = Bn.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, Dn = Bn.REPLACE_KEEPS_$0, Ln = In ? "$" : "$0";
  return [function($n, Nn) {
    var Rn = p(this), Fn = $n == null ? void 0 : $n[_n];
    return Fn !== void 0 ? Fn.call($n, Rn, Nn) : nr.call(String(Rn), $n, Nn);
  }, function($n, Nn) {
    if (!In && Dn || typeof Nn == "string" && Nn.indexOf(Ln) === -1) {
      var Rn = Cn(nr, $n, this, Nn);
      if (Rn.done)
        return Rn.value;
    }
    var Fn = A$1($n), Pn = String(this), Un = typeof Nn == "function";
    Un || (Nn = String(Nn));
    var Hn = Fn.global;
    if (Hn) {
      var zn = Fn.unicode;
      Fn.lastIndex = 0;
    }
    for (var Gn = []; ; ) {
      var Yn = tn(Fn, Pn);
      if (Yn === null || (Gn.push(Yn), !Hn))
        break;
      String(Yn[0]) === "" && (Fn.lastIndex = Ze(Pn, at(Fn.lastIndex), zn));
    }
    for (var Wn, Xn = "", ea = 0, ta = 0; ta < Gn.length; ta++) {
      Yn = Gn[ta];
      for (var na = String(Yn[0]), ra = tr(er(it$1(Yn.index), Pn.length), 0), aa = [], ia = 1; ia < Yn.length; ia++)
        aa.push((Wn = Yn[ia]) === void 0 ? Wn : String(Wn));
      var Aa = Yn.groups;
      if (Un) {
        var sa = [na].concat(aa, ra, Pn);
        Aa !== void 0 && sa.push(Aa);
        var oa = String(Nn.apply(void 0, sa));
      } else
        oa = Zn(na, Pn, ra, aa, Aa, Nn);
      ra >= ea && (Xn += Pn.slice(ea, ra) + oa, ea = ra + na.length);
    }
    return Xn + Pn.slice(ea);
  }];
});
(function() {
  function _n() {
    Wt$1(this, _n);
  }
  return $t$1(_n, null, [{ key: "camelize", value: function(nr) {
    return nr.replace(/-(\w)/g, function(Cn, Bn) {
      return Bn ? Bn.toUpperCase() : "";
    });
  } }, { key: "capitalize", value: function(nr) {
    return nr.charAt(0).toUpperCase() + nr.slice(1);
  } }]), _n;
})();
(function() {
  function _n() {
    Wt$1(this, _n);
  }
  return $t$1(_n, null, [{ key: "_clone", value: function() {
  } }]), _n;
})();
var or = ne("isConcatSpreadable"), ir = fe$1 >= 51 || !o(function() {
  var _n = [];
  return _n[or] = !1, _n.concat()[0] !== _n;
}), ur = de$1("concat"), ar = function(_n) {
  if (!h(_n))
    return !1;
  var nr = _n[or];
  return nr !== void 0 ? !!nr : qt$1(_n);
};
It$1({ target: "Array", proto: !0, forced: !ir || !ur }, { concat: function(_n) {
  var nr, Cn, Bn, In, Dn, Ln = Kt$1(this), $n = oe(Ln, 0), Nn = 0;
  for (nr = -1, Bn = arguments.length; nr < Bn; nr++)
    if (ar(Dn = nr === -1 ? Ln : arguments[nr])) {
      if (Nn + (In = at(Dn.length)) > 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      for (Cn = 0; Cn < In; Cn++, Nn++)
        Cn in Dn && ie$1($n, Nn, Dn[Cn]);
    } else {
      if (Nn >= 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      ie$1($n, Nn++, Dn);
    }
  return $n.length = Nn, $n;
} });
var cr, lr = function(_n, nr, Cn) {
  if (Ve$1(_n), nr === void 0)
    return _n;
  switch (Cn) {
    case 0:
      return function() {
        return _n.call(nr);
      };
    case 1:
      return function(Bn) {
        return _n.call(nr, Bn);
      };
    case 2:
      return function(Bn, In) {
        return _n.call(nr, Bn, In);
      };
    case 3:
      return function(Bn, In, Dn) {
        return _n.call(nr, Bn, In, Dn);
      };
  }
  return function() {
    return _n.apply(nr, arguments);
  };
}, fr = [].push, sr = function(_n) {
  var nr = _n == 1, Cn = _n == 2, Bn = _n == 3, In = _n == 4, Dn = _n == 6, Ln = _n == 7, $n = _n == 5 || Dn;
  return function(Nn, Rn, Fn, Pn) {
    for (var Un, Hn, zn = Kt$1(Nn), Gn = v(zn), Yn = lr(Rn, Fn, 3), Wn = at(Gn.length), Xn = 0, ea = Pn || oe, ta = nr ? ea(Nn, Wn) : Cn || Ln ? ea(Nn, 0) : void 0; Wn > Xn; Xn++)
      if (($n || Xn in Gn) && (Hn = Yn(Un = Gn[Xn], Xn, zn), _n))
        if (nr)
          ta[Xn] = Hn;
        else if (Hn)
          switch (_n) {
            case 3:
              return !0;
            case 5:
              return Un;
            case 6:
              return Xn;
            case 2:
              fr.call(ta, Un);
          }
        else
          switch (_n) {
            case 4:
              return !1;
            case 7:
              fr.call(ta, Un);
          }
    return Dn ? -1 : Bn || In ? In : ta;
  };
}, dr = { forEach: sr(0), map: sr(1), filter: sr(2), some: sr(3), every: sr(4), find: sr(5), findIndex: sr(6), filterOut: sr(7) }, vr = i$1 ? Object.defineProperties : function(_n, nr) {
  A$1(_n);
  for (var Cn, Bn = yn(nr), In = Bn.length, Dn = 0; In > Dn; )
    R.f(_n, Cn = Bn[Dn++], nr[Cn]);
  return _n;
}, pr = nt("document", "documentElement"), gr = Y("IE_PROTO"), hr = function() {
}, yr = function(_n) {
  return "<script>" + _n + "<\/script>";
}, mr = function() {
  try {
    cr = document.domain && new ActiveXObject("htmlfile");
  } catch {
  }
  var _n, nr;
  mr = cr ? function(Bn) {
    Bn.write(yr("")), Bn.close();
    var In = Bn.parentWindow.Object;
    return Bn = null, In;
  }(cr) : ((nr = E("iframe")).style.display = "none", pr.appendChild(nr), nr.src = "javascript:", (_n = nr.contentWindow.document).open(), _n.write(yr("document.F=Object")), _n.close(), _n.F);
  for (var Cn = gt$1.length; Cn--; )
    delete mr.prototype[gt$1[Cn]];
  return mr();
};
G[gr] = !0;
var Sr = Object.create || function(_n, nr) {
  var Cn;
  return _n !== null ? (hr.prototype = A$1(_n), Cn = new hr(), hr.prototype = null, Cn[gr] = _n) : Cn = mr(), nr === void 0 ? Cn : vr(Cn, nr);
}, xr = ne("unscopables"), br = Array.prototype;
br[xr] == null && R.f(br, xr, { configurable: !0, value: Sr(null) });
var Er = function(_n) {
  br[xr][_n] = !0;
}, wr = dr.find, Or = !0, Tr = Mt$1("find");
"find" in [] && Array(1).find(function() {
  Or = !1;
}), It$1({ target: "Array", proto: !0, forced: Or || !Tr }, { find: function(_n) {
  return wr(this, _n, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("find");
var Ar = dr.findIndex, kr = !0, Rr = Mt$1("findIndex");
"findIndex" in [] && Array(1).findIndex(function() {
  kr = !1;
}), It$1({ target: "Array", proto: !0, forced: kr || !Rr }, { findIndex: function(_n) {
  return Ar(this, _n, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("findIndex");
var Ir = function(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  for (var Nn, Rn = In, Fn = 0, Pn = !!Ln && lr(Ln, $n, 3); Fn < Bn; ) {
    if (Fn in Cn) {
      if (Nn = Pn ? Pn(Cn[Fn], Fn, nr) : Cn[Fn], Dn > 0 && qt$1(Nn))
        Rn = Ir(_n, nr, Nn, at(Nn.length), Rn, Dn - 1) - 1;
      else {
        if (Rn >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        _n[Rn] = Nn;
      }
      Rn++;
    }
    Fn++;
  }
  return Rn;
}, jr = Ir;
It$1({ target: "Array", proto: !0 }, { flat: function() {
  var _n = arguments.length ? arguments[0] : void 0, nr = Kt$1(this), Cn = at(nr.length), Bn = oe(nr, 0);
  return Bn.length = jr(Bn, nr, nr, Cn, 0, _n === void 0 ? 1 : it$1(_n)), Bn;
} });
var Cr = function(_n) {
  var nr = _n.return;
  if (nr !== void 0)
    return A$1(nr.call(_n)).value;
}, Lr = function(_n, nr, Cn, Bn) {
  try {
    return Bn ? nr(A$1(Cn)[0], Cn[1]) : nr(Cn);
  } catch (In) {
    throw Cr(_n), In;
  }
}, Pr = {}, Mr = ne("iterator"), _r = Array.prototype, Dr = function(_n) {
  return _n !== void 0 && (Pr.Array === _n || _r[Mr] === _n);
}, Ur = ne("iterator"), Nr = function(_n) {
  if (_n != null)
    return _n[Ur] || _n["@@iterator"] || Pr[be$1(_n)];
}, Fr = ne("iterator"), Wr = !1;
try {
  var zr = 0, $r = { next: function() {
    return { done: !!zr++ };
  }, return: function() {
    Wr = !0;
  } };
  $r[Fr] = function() {
    return this;
  }, Array.from($r, function() {
    throw 2;
  });
} catch (_n) {
}
var Br = function(_n, nr) {
  if (!nr && !Wr)
    return !1;
  var Cn = !1;
  try {
    var Bn = {};
    Bn[Fr] = function() {
      return { next: function() {
        return { done: Cn = !0 };
      } };
    }, _n(Bn);
  } catch {
  }
  return Cn;
}, Yr = !Br(function(_n) {
  Array.from(_n);
});
It$1({ target: "Array", stat: !0, forced: Yr }, { from: function(_n) {
  var nr, Cn, Bn, In, Dn, Ln, $n = Kt$1(_n), Nn = typeof this == "function" ? this : Array, Rn = arguments.length, Fn = Rn > 1 ? arguments[1] : void 0, Pn = Fn !== void 0, Un = Nr($n), Hn = 0;
  if (Pn && (Fn = lr(Fn, Rn > 2 ? arguments[2] : void 0, 2)), Un == null || Nn == Array && Dr(Un))
    for (Cn = new Nn(nr = at($n.length)); nr > Hn; Hn++)
      Ln = Pn ? Fn($n[Hn], Hn) : $n[Hn], ie$1(Cn, Hn, Ln);
  else
    for (Dn = (In = Un.call($n)).next, Cn = new Nn(); !(Bn = Dn.call(In)).done; Hn++)
      Ln = Pn ? Lr(In, Fn, [Bn.value, Hn], !0) : Bn.value, ie$1(Cn, Hn, Ln);
  return Cn.length = Hn, Cn;
} });
var Gr = function(_n) {
  return function(nr, Cn, Bn, In) {
    Ve$1(Cn);
    var Dn = Kt$1(nr), Ln = v(Dn), $n = at(Dn.length), Nn = _n ? $n - 1 : 0, Rn = _n ? -1 : 1;
    if (Bn < 2)
      for (; ; ) {
        if (Nn in Ln) {
          In = Ln[Nn], Nn += Rn;
          break;
        }
        if (Nn += Rn, _n ? Nn < 0 : $n <= Nn)
          throw TypeError("Reduce of empty array with no initial value");
      }
    for (; _n ? Nn >= 0 : $n > Nn; Nn += Rn)
      Nn in Ln && (In = Cn(In, Ln[Nn], Nn, Dn));
    return In;
  };
}, Hr = { left: Gr(!1), right: Gr(!0) }, Xr = s(r.process) == "process", Vr = Hr.left, Kr = jt$1("reduce"), qr = Mt$1("reduce", { 1: 0 });
It$1({ target: "Array", proto: !0, forced: !Kr || !qr || !Xr && fe$1 > 79 && fe$1 < 83 }, { reduce: function(_n) {
  return Vr(this, _n, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("flat");
var Qr, Jr, Zr, to$1 = !o(function() {
  return Object.isExtensible(Object.preventExtensions({}));
}), eo$1 = e(function(_n) {
  var nr = R.f, Cn = $("meta"), Bn = 0, In = Object.isExtensible || function() {
    return !0;
  }, Dn = function($n) {
    nr($n, Cn, { value: { objectID: "O" + ++Bn, weakData: {} } });
  }, Ln = _n.exports = { REQUIRED: !1, fastKey: function($n, Nn) {
    if (!h($n))
      return typeof $n == "symbol" ? $n : (typeof $n == "string" ? "S" : "P") + $n;
    if (!S($n, Cn)) {
      if (!In($n))
        return "F";
      if (!Nn)
        return "E";
      Dn($n);
    }
    return $n[Cn].objectID;
  }, getWeakData: function($n, Nn) {
    if (!S($n, Cn)) {
      if (!In($n))
        return !0;
      if (!Nn)
        return !1;
      Dn($n);
    }
    return $n[Cn].weakData;
  }, onFreeze: function($n) {
    return to$1 && Ln.REQUIRED && In($n) && !S($n, Cn) && Dn($n), $n;
  } };
  G[Cn] = !0;
}), no$1 = function(_n, nr) {
  this.stopped = _n, this.result = nr;
}, ro$1 = function(_n, nr, Cn) {
  var Bn, In, Dn, Ln, $n, Nn, Rn, Fn = Cn && Cn.that, Pn = !(!Cn || !Cn.AS_ENTRIES), Un = !(!Cn || !Cn.IS_ITERATOR), Hn = !(!Cn || !Cn.INTERRUPTED), zn = lr(nr, Fn, 1 + Pn + Hn), Gn = function(Wn) {
    return Bn && Cr(Bn), new no$1(!0, Wn);
  }, Yn = function(Wn) {
    return Pn ? (A$1(Wn), Hn ? zn(Wn[0], Wn[1], Gn) : zn(Wn[0], Wn[1])) : Hn ? zn(Wn, Gn) : zn(Wn);
  };
  if (Un)
    Bn = _n;
  else {
    if (typeof (In = Nr(_n)) != "function")
      throw TypeError("Target is not iterable");
    if (Dr(In)) {
      for (Dn = 0, Ln = at(_n.length); Ln > Dn; Dn++)
        if (($n = Yn(_n[Dn])) && $n instanceof no$1)
          return $n;
      return new no$1(!1);
    }
    Bn = In.call(_n);
  }
  for (Nn = Bn.next; !(Rn = Nn.call(Bn)).done; ) {
    try {
      $n = Yn(Rn.value);
    } catch (Wn) {
      throw Cr(Bn), Wn;
    }
    if (typeof $n == "object" && $n && $n instanceof no$1)
      return $n;
  }
  return new no$1(!1);
}, oo$1 = function(_n, nr, Cn) {
  if (!(_n instanceof nr))
    throw TypeError("Incorrect " + (Cn ? Cn + " " : "") + "invocation");
  return _n;
}, io$1 = R.f, uo$1 = ne("toStringTag"), ao$1 = function(_n, nr, Cn) {
  _n && !S(_n = Cn ? _n : _n.prototype, uo$1) && io$1(_n, uo$1, { configurable: !0, value: nr });
}, co$1 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var _n, nr = !1, Cn = {};
  try {
    (_n = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(Cn, []), nr = Cn instanceof Array;
  } catch {
  }
  return function(Bn, In) {
    return A$1(Bn), function(Dn) {
      if (!h(Dn) && Dn !== null)
        throw TypeError("Can't set " + String(Dn) + " as a prototype");
    }(In), nr ? _n.call(Bn, In) : Bn.__proto__ = In, Bn;
  };
}() : void 0), lo$1 = function(_n, nr, Cn) {
  for (var Bn in nr)
    Z(_n, Bn, nr[Bn], Cn);
  return _n;
}, fo$1 = !o(function() {
  function _n() {
  }
  return _n.prototype.constructor = null, Object.getPrototypeOf(new _n()) !== _n.prototype;
}), so$1 = Y("IE_PROTO"), vo$1 = Object.prototype, po$1 = fo$1 ? Object.getPrototypeOf : function(_n) {
  return _n = Kt$1(_n), S(_n, so$1) ? _n[so$1] : typeof _n.constructor == "function" && _n instanceof _n.constructor ? _n.constructor.prototype : _n instanceof Object ? vo$1 : null;
}, go$1 = ne("iterator"), ho$1 = !1;
[].keys && ("next" in (Zr = [].keys()) ? (Jr = po$1(po$1(Zr))) !== Object.prototype && (Qr = Jr) : ho$1 = !0), (Qr == null || o(function() {
  var _n = {};
  return Qr[go$1].call(_n) !== _n;
})) && (Qr = {}), S(Qr, go$1) || I(Qr, go$1, function() {
  return this;
});
var yo$1 = { IteratorPrototype: Qr, BUGGY_SAFARI_ITERATORS: ho$1 }, mo$1 = yo$1.IteratorPrototype, So$1 = function() {
  return this;
}, xo = yo$1.IteratorPrototype, bo$1 = yo$1.BUGGY_SAFARI_ITERATORS, Eo$1 = ne("iterator"), wo$1 = function() {
  return this;
}, Oo$1 = function(_n, nr, Cn, Bn, In, Dn, Ln) {
  (function(Wn, Xn, ea) {
    var ta = Xn + " Iterator";
    Wn.prototype = Sr(mo$1, { next: l(1, ea) }), ao$1(Wn, ta, !1), Pr[ta] = So$1;
  })(Cn, nr, Bn);
  var $n, Nn, Rn, Fn = function(Wn) {
    if (Wn === In && Gn)
      return Gn;
    if (!bo$1 && Wn in Hn)
      return Hn[Wn];
    switch (Wn) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new Cn(this, Wn);
        };
    }
    return function() {
      return new Cn(this);
    };
  }, Pn = nr + " Iterator", Un = !1, Hn = _n.prototype, zn = Hn[Eo$1] || Hn["@@iterator"] || In && Hn[In], Gn = !bo$1 && zn || Fn(In), Yn = nr == "Array" && Hn.entries || zn;
  if (Yn && ($n = po$1(Yn.call(new _n())), xo !== Object.prototype && $n.next && (po$1($n) !== xo && (co$1 ? co$1($n, xo) : typeof $n[Eo$1] != "function" && I($n, Eo$1, wo$1)), ao$1($n, Pn, !0))), In == "values" && zn && zn.name !== "values" && (Un = !0, Gn = function() {
    return zn.call(this);
  }), Hn[Eo$1] !== Gn && I(Hn, Eo$1, Gn), Pr[nr] = Gn, In)
    if (Nn = { values: Fn("values"), keys: Dn ? Gn : Fn("keys"), entries: Fn("entries") }, Ln)
      for (Rn in Nn)
        (bo$1 || Un || !(Rn in Hn)) && Z(Hn, Rn, Nn[Rn]);
    else
      It$1({ target: nr, proto: !0, forced: bo$1 || Un }, Nn);
  return Nn;
}, To$1 = ne("species"), Ao$1 = R.f, ko$1 = eo$1.fastKey, Ro$1 = J.set, Io$1 = J.getterFor;
(function(_n, nr, Cn) {
  var Bn = _n.indexOf("Map") !== -1, In = _n.indexOf("Weak") !== -1, Dn = Bn ? "set" : "add", Ln = r[_n], $n = Ln && Ln.prototype, Nn = Ln, Rn = {}, Fn = function(Yn) {
    var Wn = $n[Yn];
    Z($n, Yn, Yn == "add" ? function(Xn) {
      return Wn.call(this, Xn === 0 ? 0 : Xn), this;
    } : Yn == "delete" ? function(Xn) {
      return !(In && !h(Xn)) && Wn.call(this, Xn === 0 ? 0 : Xn);
    } : Yn == "get" ? function(Xn) {
      return In && !h(Xn) ? void 0 : Wn.call(this, Xn === 0 ? 0 : Xn);
    } : Yn == "has" ? function(Xn) {
      return !(In && !h(Xn)) && Wn.call(this, Xn === 0 ? 0 : Xn);
    } : function(Xn, ea) {
      return Wn.call(this, Xn === 0 ? 0 : Xn, ea), this;
    });
  };
  if (kt$1(_n, typeof Ln != "function" || !(In || $n.forEach && !o(function() {
    new Ln().entries().next();
  }))))
    Nn = Cn.getConstructor(nr, _n, Bn, Dn), eo$1.REQUIRED = !0;
  else if (kt$1(_n, !0)) {
    var Pn = new Nn(), Un = Pn[Dn](In ? {} : -0, 1) != Pn, Hn = o(function() {
      Pn.has(1);
    }), zn = Br(function(Yn) {
      new Ln(Yn);
    }), Gn = !In && o(function() {
      for (var Yn = new Ln(), Wn = 5; Wn--; )
        Yn[Dn](Wn, Wn);
      return !Yn.has(-0);
    });
    zn || ((Nn = nr(function(Yn, Wn) {
      oo$1(Yn, Nn, _n);
      var Xn = function(ea, ta, na) {
        var ra, aa;
        return co$1 && typeof (ra = ta.constructor) == "function" && ra !== na && h(aa = ra.prototype) && aa !== na.prototype && co$1(ea, aa), ea;
      }(new Ln(), Yn, Nn);
      return Wn != null && ro$1(Wn, Xn[Dn], { that: Xn, AS_ENTRIES: Bn }), Xn;
    })).prototype = $n, $n.constructor = Nn), (Hn || Gn) && (Fn("delete"), Fn("has"), Bn && Fn("get")), (Gn || Un) && Fn(Dn), In && $n.clear && delete $n.clear;
  }
  Rn[_n] = Nn, It$1({ global: !0, forced: Nn != Ln }, Rn), ao$1(Nn, _n), In || Cn.setStrong(Nn, _n, Bn);
})("Set", function(_n) {
  return function() {
    return _n(this, arguments.length ? arguments[0] : void 0);
  };
}, { getConstructor: function(_n, nr, Cn, Bn) {
  var In = _n(function(Nn, Rn) {
    oo$1(Nn, In, nr), Ro$1(Nn, { type: nr, index: Sr(null), first: void 0, last: void 0, size: 0 }), i$1 || (Nn.size = 0), Rn != null && ro$1(Rn, Nn[Bn], { that: Nn, AS_ENTRIES: Cn });
  }), Dn = Io$1(nr), Ln = function(Nn, Rn, Fn) {
    var Pn, Un, Hn = Dn(Nn), zn = $n(Nn, Rn);
    return zn ? zn.value = Fn : (Hn.last = zn = { index: Un = ko$1(Rn, !0), key: Rn, value: Fn, previous: Pn = Hn.last, next: void 0, removed: !1 }, Hn.first || (Hn.first = zn), Pn && (Pn.next = zn), i$1 ? Hn.size++ : Nn.size++, Un !== "F" && (Hn.index[Un] = zn)), Nn;
  }, $n = function(Nn, Rn) {
    var Fn, Pn = Dn(Nn), Un = ko$1(Rn);
    if (Un !== "F")
      return Pn.index[Un];
    for (Fn = Pn.first; Fn; Fn = Fn.next)
      if (Fn.key == Rn)
        return Fn;
  };
  return lo$1(In.prototype, { clear: function() {
    for (var Nn = Dn(this), Rn = Nn.index, Fn = Nn.first; Fn; )
      Fn.removed = !0, Fn.previous && (Fn.previous = Fn.previous.next = void 0), delete Rn[Fn.index], Fn = Fn.next;
    Nn.first = Nn.last = void 0, i$1 ? Nn.size = 0 : this.size = 0;
  }, delete: function(Nn) {
    var Rn = this, Fn = Dn(Rn), Pn = $n(Rn, Nn);
    if (Pn) {
      var Un = Pn.next, Hn = Pn.previous;
      delete Fn.index[Pn.index], Pn.removed = !0, Hn && (Hn.next = Un), Un && (Un.previous = Hn), Fn.first == Pn && (Fn.first = Un), Fn.last == Pn && (Fn.last = Hn), i$1 ? Fn.size-- : Rn.size--;
    }
    return !!Pn;
  }, forEach: function(Nn) {
    for (var Rn, Fn = Dn(this), Pn = lr(Nn, arguments.length > 1 ? arguments[1] : void 0, 3); Rn = Rn ? Rn.next : Fn.first; )
      for (Pn(Rn.value, Rn.key, this); Rn && Rn.removed; )
        Rn = Rn.previous;
  }, has: function(Nn) {
    return !!$n(this, Nn);
  } }), lo$1(In.prototype, Cn ? { get: function(Nn) {
    var Rn = $n(this, Nn);
    return Rn && Rn.value;
  }, set: function(Nn, Rn) {
    return Ln(this, Nn === 0 ? 0 : Nn, Rn);
  } } : { add: function(Nn) {
    return Ln(this, Nn = Nn === 0 ? 0 : Nn, Nn);
  } }), i$1 && Ao$1(In.prototype, "size", { get: function() {
    return Dn(this).size;
  } }), In;
}, setStrong: function(_n, nr, Cn) {
  var Bn = nr + " Iterator", In = Io$1(nr), Dn = Io$1(Bn);
  Oo$1(_n, nr, function(Ln, $n) {
    Ro$1(this, { type: Bn, target: Ln, state: In(Ln), kind: $n, last: void 0 });
  }, function() {
    for (var Ln = Dn(this), $n = Ln.kind, Nn = Ln.last; Nn && Nn.removed; )
      Nn = Nn.previous;
    return Ln.target && (Ln.last = Nn = Nn ? Nn.next : Ln.state.first) ? $n == "keys" ? { value: Nn.key, done: !1 } : $n == "values" ? { value: Nn.value, done: !1 } : { value: [Nn.key, Nn.value], done: !1 } : (Ln.target = void 0, { value: void 0, done: !0 });
  }, Cn ? "entries" : "values", !Cn, !0), function(Ln) {
    var $n = nt(Ln), Nn = R.f;
    i$1 && $n && !$n[To$1] && Nn($n, To$1, { configurable: !0, get: function() {
      return this;
    } });
  }(nr);
} });
var jo$1 = Qe.charAt, Co$1 = J.set, Lo$1 = J.getterFor("String Iterator");
Oo$1(String, "String", function(_n) {
  Co$1(this, { type: "String Iterator", string: String(_n), index: 0 });
}, function() {
  var _n, nr = Lo$1(this), Cn = nr.string, Bn = nr.index;
  return Bn >= Cn.length ? { value: void 0, done: !0 } : (_n = jo$1(Cn, Bn), nr.index += _n.length, { value: _n, done: !1 });
});
var Po$1 = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Mo$1 = J.set, _o$1 = J.getterFor("Array Iterator"), Do$1 = Oo$1(Array, "Array", function(_n, nr) {
  Mo$1(this, { type: "Array Iterator", target: g(_n), index: 0, kind: nr });
}, function() {
  var _n = _o$1(this), nr = _n.target, Cn = _n.kind, Bn = _n.index++;
  return !nr || Bn >= nr.length ? (_n.target = void 0, { value: void 0, done: !0 }) : Cn == "keys" ? { value: Bn, done: !1 } : Cn == "values" ? { value: nr[Bn], done: !1 } : { value: [Bn, nr[Bn]], done: !1 };
}, "values");
Pr.Arguments = Pr.Array, Er("keys"), Er("values"), Er("entries");
var Uo$1 = ne("iterator"), No$1 = ne("toStringTag"), Fo$1 = Do$1.values;
for (var Wo$1 in Po$1) {
  var zo$1 = r[Wo$1], $o$1 = zo$1 && zo$1.prototype;
  if ($o$1) {
    if ($o$1[Uo$1] !== Fo$1)
      try {
        I($o$1, Uo$1, Fo$1);
      } catch {
        $o$1[Uo$1] = Fo$1;
      }
    if ($o$1[No$1] || I($o$1, No$1, Wo$1), Po$1[Wo$1]) {
      for (var Bo$1 in Do$1)
        if ($o$1[Bo$1] !== Do$1[Bo$1])
          try {
            I($o$1, Bo$1, Do$1[Bo$1]);
          } catch {
            $o$1[Bo$1] = Do$1[Bo$1];
          }
    }
  }
}
(function() {
  function _n() {
    Wt$1(this, _n);
  }
  return $t$1(_n, null, [{ key: "deduplicate", value: function(nr) {
    return Array.from(new Set(nr));
  } }, { key: "flat", value: function(nr) {
    return nr.reduce(function(Cn, Bn) {
      var In = Array.isArray(Bn) ? _n.flat(Bn) : Bn;
      return Cn.concat(In);
    }, []);
  } }, { key: "find", value: function(nr, Cn) {
    return nr.find(Cn);
  } }, { key: "findIndex", value: function(nr, Cn) {
    return nr.findIndex(Cn);
  } }]), _n;
})();
(function() {
  function _n() {
    Wt$1(this, _n);
  }
  return $t$1(_n, null, [{ key: "today", value: function() {
    return /* @__PURE__ */ new Date();
  } }]), _n;
})();
(function() {
  function _n() {
    Wt$1(this, _n);
  }
  return $t$1(_n, null, [{ key: "range", value: function(nr, Cn, Bn) {
    return Math.min(Math.max(nr, Cn), Bn);
  } }, { key: "clamp", value: function(nr, Cn, Bn) {
    return Cn < Bn ? nr < Cn ? Cn : nr > Bn ? Bn : nr : nr < Bn ? Bn : nr > Cn ? Cn : nr;
  } }]), _n;
})();
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal$1 || freeSelf || Function("return this")();
const root$1 = root;
var Symbol$2 = root$1.Symbol;
const Symbol$3 = Symbol$2;
var objectProto$a = Object.prototype, hasOwnProperty$8 = objectProto$a.hasOwnProperty, nativeObjectToString$1 = objectProto$a.toString, symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag(_n) {
  var nr = hasOwnProperty$8.call(_n, symToStringTag$1), Cn = _n[symToStringTag$1];
  try {
    _n[symToStringTag$1] = void 0;
    var Bn = !0;
  } catch {
  }
  var In = nativeObjectToString$1.call(_n);
  return Bn && (nr ? _n[symToStringTag$1] = Cn : delete _n[symToStringTag$1]), In;
}
var objectProto$9 = Object.prototype, nativeObjectToString = objectProto$9.toString;
function objectToString(_n) {
  return nativeObjectToString.call(_n);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag(_n) {
  return _n == null ? _n === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(_n) ? getRawTag(_n) : objectToString(_n);
}
function isObjectLike(_n) {
  return _n != null && typeof _n == "object";
}
var isArray$1 = Array.isArray;
const isArray$2 = isArray$1;
function isObject$1(_n) {
  var nr = typeof _n;
  return _n != null && (nr == "object" || nr == "function");
}
function identity(_n) {
  return _n;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(_n) {
  if (!isObject$1(_n))
    return !1;
  var nr = baseGetTag(_n);
  return nr == funcTag$1 || nr == genTag || nr == asyncTag || nr == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
const coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var _n = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return _n ? "Symbol(src)_1." + _n : "";
}();
function isMasked(_n) {
  return !!maskSrcKey && maskSrcKey in _n;
}
var funcProto$2 = Function.prototype, funcToString$2 = funcProto$2.toString;
function toSource(_n) {
  if (_n != null) {
    try {
      return funcToString$2.call(_n);
    } catch {
    }
    try {
      return _n + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$1 = Function.prototype, objectProto$8 = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$7 = objectProto$8.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(_n) {
  if (!isObject$1(_n) || isMasked(_n))
    return !1;
  var nr = isFunction(_n) ? reIsNative : reIsHostCtor;
  return nr.test(toSource(_n));
}
function getValue(_n, nr) {
  return _n == null ? void 0 : _n[nr];
}
function getNative(_n, nr) {
  var Cn = getValue(_n, nr);
  return baseIsNative(Cn) ? Cn : void 0;
}
var objectCreate = Object.create, baseCreate = function() {
  function _n() {
  }
  return function(nr) {
    if (!isObject$1(nr))
      return {};
    if (objectCreate)
      return objectCreate(nr);
    _n.prototype = nr;
    var Cn = new _n();
    return _n.prototype = void 0, Cn;
  };
}();
const baseCreate$1 = baseCreate;
function apply(_n, nr, Cn) {
  switch (Cn.length) {
    case 0:
      return _n.call(nr);
    case 1:
      return _n.call(nr, Cn[0]);
    case 2:
      return _n.call(nr, Cn[0], Cn[1]);
    case 3:
      return _n.call(nr, Cn[0], Cn[1], Cn[2]);
  }
  return _n.apply(nr, Cn);
}
function copyArray(_n, nr) {
  var Cn = -1, Bn = _n.length;
  for (nr || (nr = Array(Bn)); ++Cn < Bn; )
    nr[Cn] = _n[Cn];
  return nr;
}
var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut(_n) {
  var nr = 0, Cn = 0;
  return function() {
    var Bn = nativeNow(), In = HOT_SPAN - (Bn - Cn);
    if (Cn = Bn, In > 0) {
      if (++nr >= HOT_COUNT)
        return arguments[0];
    } else
      nr = 0;
    return _n.apply(void 0, arguments);
  };
}
function constant(_n) {
  return function() {
    return _n;
  };
}
var defineProperty = function() {
  try {
    var _n = getNative(Object, "defineProperty");
    return _n({}, "", {}), _n;
  } catch {
  }
}();
const defineProperty$1 = defineProperty;
var baseSetToString = defineProperty$1 ? function(_n, nr) {
  return defineProperty$1(_n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(nr),
    writable: !0
  });
} : identity;
const baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
const setToString$1 = setToString;
var MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(_n, nr) {
  var Cn = typeof _n;
  return nr = nr ?? MAX_SAFE_INTEGER$1, !!nr && (Cn == "number" || Cn != "symbol" && reIsUint.test(_n)) && _n > -1 && _n % 1 == 0 && _n < nr;
}
function baseAssignValue(_n, nr, Cn) {
  nr == "__proto__" && defineProperty$1 ? defineProperty$1(_n, nr, {
    configurable: !0,
    enumerable: !0,
    value: Cn,
    writable: !0
  }) : _n[nr] = Cn;
}
function eq(_n, nr) {
  return _n === nr || _n !== _n && nr !== nr;
}
var objectProto$7 = Object.prototype, hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function assignValue(_n, nr, Cn) {
  var Bn = _n[nr];
  (!(hasOwnProperty$6.call(_n, nr) && eq(Bn, Cn)) || Cn === void 0 && !(nr in _n)) && baseAssignValue(_n, nr, Cn);
}
function copyObject(_n, nr, Cn, Bn) {
  var In = !Cn;
  Cn || (Cn = {});
  for (var Dn = -1, Ln = nr.length; ++Dn < Ln; ) {
    var $n = nr[Dn], Nn = Bn ? Bn(Cn[$n], _n[$n], $n, Cn, _n) : void 0;
    Nn === void 0 && (Nn = _n[$n]), In ? baseAssignValue(Cn, $n, Nn) : assignValue(Cn, $n, Nn);
  }
  return Cn;
}
var nativeMax = Math.max;
function overRest(_n, nr, Cn) {
  return nr = nativeMax(nr === void 0 ? _n.length - 1 : nr, 0), function() {
    for (var Bn = arguments, In = -1, Dn = nativeMax(Bn.length - nr, 0), Ln = Array(Dn); ++In < Dn; )
      Ln[In] = Bn[nr + In];
    In = -1;
    for (var $n = Array(nr + 1); ++In < nr; )
      $n[In] = Bn[In];
    return $n[nr] = Cn(Ln), apply(_n, this, $n);
  };
}
function baseRest(_n, nr) {
  return setToString$1(overRest(_n, nr, identity), _n + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(_n) {
  return typeof _n == "number" && _n > -1 && _n % 1 == 0 && _n <= MAX_SAFE_INTEGER;
}
function isArrayLike(_n) {
  return _n != null && isLength(_n.length) && !isFunction(_n);
}
function isIterateeCall(_n, nr, Cn) {
  if (!isObject$1(Cn))
    return !1;
  var Bn = typeof nr;
  return (Bn == "number" ? isArrayLike(Cn) && isIndex(nr, Cn.length) : Bn == "string" && nr in Cn) ? eq(Cn[nr], _n) : !1;
}
function createAssigner(_n) {
  return baseRest(function(nr, Cn) {
    var Bn = -1, In = Cn.length, Dn = In > 1 ? Cn[In - 1] : void 0, Ln = In > 2 ? Cn[2] : void 0;
    for (Dn = _n.length > 3 && typeof Dn == "function" ? (In--, Dn) : void 0, Ln && isIterateeCall(Cn[0], Cn[1], Ln) && (Dn = In < 3 ? void 0 : Dn, In = 1), nr = Object(nr); ++Bn < In; ) {
      var $n = Cn[Bn];
      $n && _n(nr, $n, Bn, Dn);
    }
    return nr;
  });
}
var objectProto$6 = Object.prototype;
function isPrototype(_n) {
  var nr = _n && _n.constructor, Cn = typeof nr == "function" && nr.prototype || objectProto$6;
  return _n === Cn;
}
function baseTimes(_n, nr) {
  for (var Cn = -1, Bn = Array(_n); ++Cn < _n; )
    Bn[Cn] = nr(Cn);
  return Bn;
}
var argsTag$1 = "[object Arguments]";
function baseIsArguments(_n) {
  return isObjectLike(_n) && baseGetTag(_n) == argsTag$1;
}
var objectProto$5 = Object.prototype, hasOwnProperty$5 = objectProto$5.hasOwnProperty, propertyIsEnumerable = objectProto$5.propertyIsEnumerable, isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(_n) {
  return isObjectLike(_n) && hasOwnProperty$5.call(_n, "callee") && !propertyIsEnumerable.call(_n, "callee");
};
const isArguments$1 = isArguments;
function stubFalse() {
  return !1;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module, moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2, Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0, nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0, isBuffer = nativeIsBuffer || stubFalse;
const isBuffer$1 = isBuffer;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
function baseIsTypedArray(_n) {
  return isObjectLike(_n) && isLength(_n.length) && !!typedArrayTags[baseGetTag(_n)];
}
function baseUnary(_n) {
  return function(nr) {
    return _n(nr);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, freeProcess = moduleExports$1 && freeGlobal$1.process, nodeUtil = function() {
  try {
    var _n = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    return _n || freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch {
  }
}();
const nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$1 = isTypedArray;
var objectProto$4 = Object.prototype, hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function arrayLikeKeys(_n, nr) {
  var Cn = isArray$2(_n), Bn = !Cn && isArguments$1(_n), In = !Cn && !Bn && isBuffer$1(_n), Dn = !Cn && !Bn && !In && isTypedArray$1(_n), Ln = Cn || Bn || In || Dn, $n = Ln ? baseTimes(_n.length, String) : [], Nn = $n.length;
  for (var Rn in _n)
    (nr || hasOwnProperty$4.call(_n, Rn)) && !(Ln && // Safari 9 has enumerable `arguments.length` in strict mode.
    (Rn == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    In && (Rn == "offset" || Rn == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    Dn && (Rn == "buffer" || Rn == "byteLength" || Rn == "byteOffset") || // Skip index properties.
    isIndex(Rn, Nn))) && $n.push(Rn);
  return $n;
}
function overArg(_n, nr) {
  return function(Cn) {
    return _n(nr(Cn));
  };
}
function nativeKeysIn(_n) {
  var nr = [];
  if (_n != null)
    for (var Cn in Object(_n))
      nr.push(Cn);
  return nr;
}
var objectProto$3 = Object.prototype, hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeysIn(_n) {
  if (!isObject$1(_n))
    return nativeKeysIn(_n);
  var nr = isPrototype(_n), Cn = [];
  for (var Bn in _n)
    Bn == "constructor" && (nr || !hasOwnProperty$3.call(_n, Bn)) || Cn.push(Bn);
  return Cn;
}
function keysIn(_n) {
  return isArrayLike(_n) ? arrayLikeKeys(_n, !0) : baseKeysIn(_n);
}
var nativeCreate = getNative(Object, "create");
const nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {}, this.size = 0;
}
function hashDelete(_n) {
  var nr = this.has(_n) && delete this.__data__[_n];
  return this.size -= nr ? 1 : 0, nr;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__", objectProto$2 = Object.prototype, hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function hashGet(_n) {
  var nr = this.__data__;
  if (nativeCreate$1) {
    var Cn = nr[_n];
    return Cn === HASH_UNDEFINED$1 ? void 0 : Cn;
  }
  return hasOwnProperty$2.call(nr, _n) ? nr[_n] : void 0;
}
var objectProto$1 = Object.prototype, hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function hashHas(_n) {
  var nr = this.__data__;
  return nativeCreate$1 ? nr[_n] !== void 0 : hasOwnProperty$1.call(nr, _n);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(_n, nr) {
  var Cn = this.__data__;
  return this.size += this.has(_n) ? 0 : 1, Cn[_n] = nativeCreate$1 && nr === void 0 ? HASH_UNDEFINED : nr, this;
}
function Hash(_n) {
  var nr = -1, Cn = _n == null ? 0 : _n.length;
  for (this.clear(); ++nr < Cn; ) {
    var Bn = _n[nr];
    this.set(Bn[0], Bn[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function assocIndexOf(_n, nr) {
  for (var Cn = _n.length; Cn--; )
    if (eq(_n[Cn][0], nr))
      return Cn;
  return -1;
}
var arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete(_n) {
  var nr = this.__data__, Cn = assocIndexOf(nr, _n);
  if (Cn < 0)
    return !1;
  var Bn = nr.length - 1;
  return Cn == Bn ? nr.pop() : splice.call(nr, Cn, 1), --this.size, !0;
}
function listCacheGet(_n) {
  var nr = this.__data__, Cn = assocIndexOf(nr, _n);
  return Cn < 0 ? void 0 : nr[Cn][1];
}
function listCacheHas(_n) {
  return assocIndexOf(this.__data__, _n) > -1;
}
function listCacheSet(_n, nr) {
  var Cn = this.__data__, Bn = assocIndexOf(Cn, _n);
  return Bn < 0 ? (++this.size, Cn.push([_n, nr])) : Cn[Bn][1] = nr, this;
}
function ListCache(_n) {
  var nr = -1, Cn = _n == null ? 0 : _n.length;
  for (this.clear(); ++nr < Cn; ) {
    var Bn = _n[nr];
    this.set(Bn[0], Bn[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
const Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash(),
    map: new (Map$2 || ListCache)(),
    string: new Hash()
  };
}
function isKeyable(_n) {
  var nr = typeof _n;
  return nr == "string" || nr == "number" || nr == "symbol" || nr == "boolean" ? _n !== "__proto__" : _n === null;
}
function getMapData(_n, nr) {
  var Cn = _n.__data__;
  return isKeyable(nr) ? Cn[typeof nr == "string" ? "string" : "hash"] : Cn.map;
}
function mapCacheDelete(_n) {
  var nr = getMapData(this, _n).delete(_n);
  return this.size -= nr ? 1 : 0, nr;
}
function mapCacheGet(_n) {
  return getMapData(this, _n).get(_n);
}
function mapCacheHas(_n) {
  return getMapData(this, _n).has(_n);
}
function mapCacheSet(_n, nr) {
  var Cn = getMapData(this, _n), Bn = Cn.size;
  return Cn.set(_n, nr), this.size += Cn.size == Bn ? 0 : 1, this;
}
function MapCache(_n) {
  var nr = -1, Cn = _n == null ? 0 : _n.length;
  for (this.clear(); ++nr < Cn; ) {
    var Bn = _n[nr];
    this.set(Bn[0], Bn[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var getPrototype = overArg(Object.getPrototypeOf, Object);
const getPrototype$1 = getPrototype;
var objectTag = "[object Object]", funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectCtorString = funcToString.call(Object);
function isPlainObject(_n) {
  if (!isObjectLike(_n) || baseGetTag(_n) != objectTag)
    return !1;
  var nr = getPrototype$1(_n);
  if (nr === null)
    return !0;
  var Cn = hasOwnProperty.call(nr, "constructor") && nr.constructor;
  return typeof Cn == "function" && Cn instanceof Cn && funcToString.call(Cn) == objectCtorString;
}
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(_n) {
  var nr = this.__data__, Cn = nr.delete(_n);
  return this.size = nr.size, Cn;
}
function stackGet(_n) {
  return this.__data__.get(_n);
}
function stackHas(_n) {
  return this.__data__.has(_n);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(_n, nr) {
  var Cn = this.__data__;
  if (Cn instanceof ListCache) {
    var Bn = Cn.__data__;
    if (!Map$2 || Bn.length < LARGE_ARRAY_SIZE - 1)
      return Bn.push([_n, nr]), this.size = ++Cn.size, this;
    Cn = this.__data__ = new MapCache(Bn);
  }
  return Cn.set(_n, nr), this.size = Cn.size, this;
}
function Stack(_n) {
  var nr = this.__data__ = new ListCache(_n);
  this.size = nr.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(_n, nr) {
  if (nr)
    return _n.slice();
  var Cn = _n.length, Bn = allocUnsafe ? allocUnsafe(Cn) : new _n.constructor(Cn);
  return _n.copy(Bn), Bn;
}
var Uint8Array$1 = root$1.Uint8Array;
const Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(_n) {
  var nr = new _n.constructor(_n.byteLength);
  return new Uint8Array$2(nr).set(new Uint8Array$2(_n)), nr;
}
function cloneTypedArray(_n, nr) {
  var Cn = nr ? cloneArrayBuffer(_n.buffer) : _n.buffer;
  return new _n.constructor(Cn, _n.byteOffset, _n.length);
}
function initCloneObject(_n) {
  return typeof _n.constructor == "function" && !isPrototype(_n) ? baseCreate$1(getPrototype$1(_n)) : {};
}
function createBaseFor(_n) {
  return function(nr, Cn, Bn) {
    for (var In = -1, Dn = Object(nr), Ln = Bn(nr), $n = Ln.length; $n--; ) {
      var Nn = Ln[_n ? $n : ++In];
      if (Cn(Dn[Nn], Nn, Dn) === !1)
        break;
    }
    return nr;
  };
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;
function assignMergeValue(_n, nr, Cn) {
  (Cn !== void 0 && !eq(_n[nr], Cn) || Cn === void 0 && !(nr in _n)) && baseAssignValue(_n, nr, Cn);
}
function isArrayLikeObject(_n) {
  return isObjectLike(_n) && isArrayLike(_n);
}
function safeGet(_n, nr) {
  if (!(nr === "constructor" && typeof _n[nr] == "function") && nr != "__proto__")
    return _n[nr];
}
function toPlainObject(_n) {
  return copyObject(_n, keysIn(_n));
}
function baseMergeDeep(_n, nr, Cn, Bn, In, Dn, Ln) {
  var $n = safeGet(_n, Cn), Nn = safeGet(nr, Cn), Rn = Ln.get(Nn);
  if (Rn) {
    assignMergeValue(_n, Cn, Rn);
    return;
  }
  var Fn = Dn ? Dn($n, Nn, Cn + "", _n, nr, Ln) : void 0, Pn = Fn === void 0;
  if (Pn) {
    var Un = isArray$2(Nn), Hn = !Un && isBuffer$1(Nn), zn = !Un && !Hn && isTypedArray$1(Nn);
    Fn = Nn, Un || Hn || zn ? isArray$2($n) ? Fn = $n : isArrayLikeObject($n) ? Fn = copyArray($n) : Hn ? (Pn = !1, Fn = cloneBuffer(Nn, !0)) : zn ? (Pn = !1, Fn = cloneTypedArray(Nn, !0)) : Fn = [] : isPlainObject(Nn) || isArguments$1(Nn) ? (Fn = $n, isArguments$1($n) ? Fn = toPlainObject($n) : (!isObject$1($n) || isFunction($n)) && (Fn = initCloneObject(Nn))) : Pn = !1;
  }
  Pn && (Ln.set(Nn, Fn), In(Fn, Nn, Bn, Dn, Ln), Ln.delete(Nn)), assignMergeValue(_n, Cn, Fn);
}
function baseMerge(_n, nr, Cn, Bn, In) {
  _n !== nr && baseFor$1(nr, function(Dn, Ln) {
    if (In || (In = new Stack()), isObject$1(Dn))
      baseMergeDeep(_n, nr, Ln, Cn, baseMerge, Bn, In);
    else {
      var $n = Bn ? Bn(safeGet(_n, Ln), Dn, Ln + "", _n, nr, In) : void 0;
      $n === void 0 && ($n = Dn), assignMergeValue(_n, Ln, $n);
    }
  }, keysIn);
}
var merge = createAssigner(function(_n, nr, Cn) {
  baseMerge(_n, nr, Cn);
});
const ie = merge;
var qe = Object.defineProperty, Ye = (_n, nr, Cn) => nr in _n ? qe(_n, nr, { enumerable: !0, configurable: !0, writable: !0, value: Cn }) : _n[nr] = Cn, W = (_n, nr, Cn) => (Ye(_n, typeof nr != "symbol" ? nr + "" : nr, Cn), Cn);
const P = (_n) => Math.round(_n * 100) / 100;
class A {
  constructor(nr) {
    W(this, "instance"), W(this, "alphaValue", 0), W(this, "redValue", 0), W(this, "greenValue", 0), W(this, "blueValue", 0), W(this, "hueValue", 0), W(this, "saturationValue", 0), W(this, "brightnessValue", 0), W(this, "hslSaturationValue", 0), W(this, "lightnessValue", 0), W(this, "initAlpha", () => {
      const Cn = this.instance.getAlpha();
      this.alphaValue = Math.min(1, Cn) * 100;
    }), W(this, "initLightness", () => {
      const { s: Cn, l: Bn } = this.instance.toHsl();
      this.hslSaturationValue = P(Cn), this.lightnessValue = P(Bn);
    }), W(this, "initRgb", () => {
      const { r: Cn, g: Bn, b: In } = this.instance.toRgb();
      this.redValue = P(Cn), this.greenValue = P(Bn), this.blueValue = P(In);
    }), W(this, "initHsb", () => {
      const { h: Cn, s: Bn, v: In } = this.instance.toHsv();
      this.hueValue = Math.min(360, Math.ceil(Cn)), this.saturationValue = P(Bn), this.brightnessValue = P(In);
    }), W(this, "toHexString", () => this.instance.toHexString()), W(this, "toRgbString", () => this.instance.toRgbString()), this.instance = tinycolor(nr), this.initRgb(), this.initHsb(), this.initLightness(), this.initAlpha();
  }
  toString(nr) {
    return this.instance.toString(nr);
  }
  get hex() {
    return this.instance.toHex();
  }
  set hex(nr) {
    this.instance = tinycolor(nr), this.initHsb(), this.initRgb(), this.initAlpha(), this.initLightness();
  }
  // 色调
  set hue(nr) {
    this.saturation === 0 && this.brightness === 0 && (this.saturationValue = 1, this.brightnessValue = 1), this.instance = tinycolor({
      h: P(nr),
      s: this.saturation,
      v: this.brightness,
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.hueValue = P(nr);
  }
  get hue() {
    return this.hueValue;
  }
  // 饱和度
  set saturation(nr) {
    this.instance = tinycolor({
      h: this.hue,
      s: P(nr),
      v: this.brightness,
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.saturationValue = P(nr);
  }
  get saturation() {
    return this.saturationValue;
  }
  // 明度
  set brightness(nr) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.saturation,
      v: P(nr),
      a: this.alphaValue / 100
    }), this.initRgb(), this.initLightness(), this.brightnessValue = P(nr);
  }
  get brightness() {
    return this.brightnessValue;
  }
  // 亮度
  set lightness(nr) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.hslSaturationValue,
      l: P(nr),
      a: this.alphaValue / 100
    }), this.initRgb(), this.initHsb(), this.lightnessValue = P(nr);
  }
  get lightness() {
    return this.lightnessValue;
  }
  // red
  set red(nr) {
    const Cn = this.instance.toRgb();
    this.instance = tinycolor({
      ...Cn,
      r: P(nr),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.redValue = P(nr);
  }
  get red() {
    return this.redValue;
  }
  // green
  set green(nr) {
    const Cn = this.instance.toRgb();
    this.instance = tinycolor({
      ...Cn,
      g: P(nr),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.greenValue = P(nr);
  }
  get green() {
    return this.greenValue;
  }
  // blue
  set blue(nr) {
    const Cn = this.instance.toRgb();
    this.instance = tinycolor({
      ...Cn,
      b: P(nr),
      a: this.alphaValue / 100
    }), this.initHsb(), this.initLightness(), this.blueValue = P(nr);
  }
  get blue() {
    return this.blueValue;
  }
  // alpha
  set alpha(nr) {
    this.instance.setAlpha(nr / 100), this.alphaValue = nr;
  }
  get alpha() {
    return this.alphaValue;
  }
  get RGB() {
    return [this.red, this.green, this.blue, parseFloat((this.alpha / 100).toFixed(2))];
  }
  get HSB() {
    return [this.hue, this.saturation, this.brightness, parseFloat((this.alpha / 100).toFixed(2))];
  }
  get HSL() {
    return [
      this.hue,
      this.hslSaturationValue,
      this.lightness,
      parseFloat((this.alpha / 100).toFixed(2))
    ];
  }
}
function Ae(_n, nr, Cn, Bn) {
  return `rgba(${[_n, nr, Cn, Bn / 100].join(",")})`;
}
const ue = (_n, nr, Cn) => nr < Cn ? _n < nr ? nr : _n > Cn ? Cn : _n : _n < Cn ? Cn : _n > nr ? nr : _n, fe = "color-history", Ce = 8, q = (_n, nr) => {
  const Cn = _n.__vccOpts || _n;
  for (const [Bn, In] of nr)
    Cn[Bn] = In;
  return Cn;
}, lt = defineComponent({
  name: "Alpha",
  props: {
    color: C$1.instanceOf(A),
    size: C$1.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(_n, { emit: nr }) {
    const Cn = ref(null), Bn = ref(null);
    let In = _n.color || new A();
    const Dn = reactive({
      red: In.red,
      green: In.green,
      blue: In.blue,
      alpha: In.alpha
    });
    watch(
      () => _n.color,
      (Pn) => {
        Pn && (In = Pn, ie(Dn, {
          red: Pn.red,
          green: Pn.green,
          blue: Pn.blue,
          alpha: Pn.alpha
        }));
      },
      { deep: !0 }
    );
    const Ln = computed(() => {
      const Pn = Ae(Dn.red, Dn.green, Dn.blue, 0), Un = Ae(Dn.red, Dn.green, Dn.blue, 100);
      return {
        background: `linear-gradient(to right, ${Pn} , ${Un})`
      };
    }), $n = () => {
      if (Cn.value && Bn.value) {
        const Pn = Dn.alpha / 100, Un = Cn.value.getBoundingClientRect(), Hn = Bn.value.offsetWidth;
        return Math.round(Pn * (Un.width - Hn) + Hn / 2);
      }
      return 0;
    }, Nn = computed(() => ({
      left: $n() + "px",
      top: 0
    })), Rn = (Pn) => {
      Pn.target !== Cn.value && Fn(Pn);
    }, Fn = (Pn) => {
      if (Pn.stopPropagation(), Cn.value && Bn.value) {
        const Un = Cn.value.getBoundingClientRect(), Hn = Bn.value.offsetWidth;
        let zn = Pn.clientX - Un.left;
        zn = Math.max(Hn / 2, zn), zn = Math.min(zn, Un.width - Hn / 2);
        const Gn = Math.round((zn - Hn / 2) / (Un.width - Hn) * 100);
        In.alpha = Gn, Dn.alpha = Gn, nr("change", Gn);
      }
    };
    return tryOnMounted(() => {
      const Pn = {
        drag: (Un) => {
          Fn(Un);
        },
        end: (Un) => {
          Fn(Un);
        }
      };
      Cn.value && Bn.value && Vn.triggerDragEvent(Cn.value, Pn);
    }), { barElement: Cn, cursorElement: Bn, getCursorStyle: Nn, getBackgroundStyle: Ln, onClickSider: Rn };
  }
}), st = (_n) => (pushScopeId("data-v-18925ba6"), _n = _n(), popScopeId(), _n), it = /* @__PURE__ */ st(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1)), ct = [
  it
];
function ut(_n, nr, Cn, Bn, In, Dn) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": _n.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-alpha-slider__bar",
      style: normalizeStyle$1(_n.getBackgroundStyle),
      onClick: nr[0] || (nr[0] = (...Ln) => _n.onClickSider && _n.onClickSider(...Ln))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": _n.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle$1(_n.getCursorStyle)
      }, ct, 6)
    ], 4)
  ], 2);
}
const ve = /* @__PURE__ */ q(lt, [["render", ut], ["__scopeId", "data-v-18925ba6"]]), dt = [
  // 第一行
  [
    "#fcc02e",
    "#f67c01",
    "#e64a19",
    "#d81b43",
    "#8e24aa",
    "#512da7",
    "#1f87e8",
    "#008781",
    "#05a045"
  ],
  // 第二行
  [
    "#fed835",
    "#fb8c00",
    "#f5511e",
    "#eb1d4e",
    "#9c28b1",
    "#5d35b0",
    "#2097f3",
    "#029688",
    "#4cb050"
  ],
  // 第三行
  [
    "#ffeb3c",
    "#ffa727",
    "#fe5722",
    "#eb4165",
    "#aa47bc",
    "#673bb7",
    "#42a5f6",
    "#26a59a",
    "#83c683"
  ],
  // 第四行
  [
    "#fff176",
    "#ffb74e",
    "#ff8a66",
    "#f1627e",
    "#b968c7",
    "#7986cc",
    "#64b5f6",
    "#80cbc4",
    "#a5d6a7"
  ],
  // 第五行
  [
    "#fff59c",
    "#ffcc80",
    "#ffab91",
    "#fb879e",
    "#cf93d9",
    "#9ea8db",
    "#90caf8",
    "#b2dfdc",
    "#c8e6ca"
  ],
  // 最后一行
  [
    "transparent",
    "#ffffff",
    "#dedede",
    "#a9a9a9",
    "#4b4b4b",
    "#353535",
    "#212121",
    "#000000",
    "advance"
  ]
], gt = defineComponent({
  name: "Palette",
  emits: ["change"],
  setup(_n, { emit: nr }) {
    return { palettes: dt, computedBgStyle: (Cn) => Cn === "transparent" ? Cn : Cn === "advance" ? {} : { background: tinycolor(Cn).toRgbString() }, onColorChange: (Cn) => {
      nr("change", Cn);
    } };
  }
}), ht = { class: "vc-compact" }, pt = ["onClick"];
function ft(_n, nr, Cn, Bn, In, Dn) {
  return openBlock(), createElementBlock("div", ht, [
    (openBlock(!0), createElementBlock(Fragment, null, renderList(_n.palettes, (Ln, $n) => (openBlock(), createElementBlock("div", {
      key: $n,
      class: "vc-compact__row"
    }, [
      (openBlock(!0), createElementBlock(Fragment, null, renderList(Ln, (Nn, Rn) => (openBlock(), createElementBlock("div", {
        key: Rn,
        class: "vc-compact__color-cube--wrap",
        onClick: (Fn) => _n.onColorChange(Nn)
      }, [
        createElementVNode("div", {
          class: normalizeClass([
            "vc-compact__color_cube",
            {
              advance: Nn === "advance",
              transparent: Nn === "transparent"
            }
          ]),
          style: normalizeStyle$1(_n.computedBgStyle(Nn))
        }, null, 6)
      ], 8, pt))), 128))
    ]))), 128))
  ]);
}
const Ke = /* @__PURE__ */ q(gt, [["render", ft], ["__scopeId", "data-v-b969fd48"]]), Ct = defineComponent({
  name: "Board",
  props: {
    color: C$1.instanceOf(A),
    round: C$1.bool.def(!1),
    hide: C$1.bool.def(!0)
  },
  emits: ["change"],
  setup(_n, { emit: nr }) {
    var Cn, Bn, In;
    const Dn = getCurrentInstance(), Ln = {
      h: ((Cn = _n.color) == null ? void 0 : Cn.hue) || 0,
      s: 1,
      v: 1
    }, $n = new A(Ln).toHexString(), Nn = reactive({
      hueColor: $n,
      saturation: ((Bn = _n.color) == null ? void 0 : Bn.saturation) || 0,
      brightness: ((In = _n.color) == null ? void 0 : In.brightness) || 0
    }), Rn = ref(0), Fn = ref(0), Pn = ref(), Un = computed(() => ({
      top: Rn.value + "px",
      left: Fn.value + "px"
    })), Hn = () => {
      if (Dn) {
        const ea = Dn.vnode.el;
        Fn.value = Nn.saturation * (ea == null ? void 0 : ea.clientWidth), Rn.value = (1 - Nn.brightness) * (ea == null ? void 0 : ea.clientHeight);
      }
    };
    let zn = !1;
    const Gn = (ea) => {
      zn = !0, Xn(ea);
    }, Yn = (ea) => {
      zn && Xn(ea);
    }, Wn = () => {
      zn = !1;
    }, Xn = (ea) => {
      if (Dn) {
        const ta = Dn.vnode.el, na = ta == null ? void 0 : ta.getBoundingClientRect();
        let ra = ea.clientX - na.left, aa = ea.clientY - na.top;
        ra = ue(ra, 0, na.width), aa = ue(aa, 0, na.height);
        const ia = ra / na.width, Aa = ue(-(aa / na.height) + 1, 0, 1);
        Fn.value = ra, Rn.value = aa, Nn.saturation = ia, Nn.brightness = Aa, nr("change", ia, Aa);
      }
    };
    return tryOnMounted(() => {
      Dn && Dn.vnode.el && Pn.value && nextTick(() => {
        Hn();
      });
    }), whenever(
      () => _n.color,
      (ea) => {
        ie(Nn, {
          hueColor: new A({ h: ea.hue, s: 1, v: 1 }).toHexString(),
          saturation: ea.saturation,
          brightness: ea.brightness
        }), Hn();
      },
      { deep: !0 }
    ), { state: Nn, cursorElement: Pn, getCursorStyle: Un, onClickBoard: Gn, onDrag: Yn, onDragEnd: Wn };
  }
}), be = (_n) => (pushScopeId("data-v-7f0cdcdf"), _n = _n(), popScopeId(), _n), vt = /* @__PURE__ */ be(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__white" }, null, -1)), bt = /* @__PURE__ */ be(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__black" }, null, -1)), yt = /* @__PURE__ */ be(() => /* @__PURE__ */ createElementVNode("div", null, null, -1)), _t = [
  yt
];
function mt(_n, nr, Cn, Bn, In, Dn) {
  return openBlock(), createElementBlock("div", {
    ref: "boardElement",
    class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": _n.round, "vc-saturation__hidden": _n.hide }]),
    style: normalizeStyle$1({ backgroundColor: _n.state.hueColor }),
    onMousedown: nr[0] || (nr[0] = (...Ln) => _n.onClickBoard && _n.onClickBoard(...Ln)),
    onMousemove: nr[1] || (nr[1] = (...Ln) => _n.onDrag && _n.onDrag(...Ln)),
    onMouseup: nr[2] || (nr[2] = (...Ln) => _n.onDragEnd && _n.onDragEnd(...Ln))
  }, [
    vt,
    bt,
    createElementVNode("div", {
      class: "vc-saturation__cursor",
      ref: "cursorElement",
      style: normalizeStyle$1(_n.getCursorStyle)
    }, _t, 4)
  ], 38);
}
const ye = /* @__PURE__ */ q(Ct, [["render", mt], ["__scopeId", "data-v-7f0cdcdf"]]), St = defineComponent({
  name: "Hue",
  props: {
    color: C$1.instanceOf(A),
    size: C$1.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(_n, { emit: nr }) {
    const Cn = ref(null), Bn = ref(null);
    let In = _n.color || new A();
    const Dn = reactive({
      hue: In.hue || 0
    });
    watch(
      () => _n.color,
      (Fn) => {
        Fn && (In = Fn, ie(Dn, { hue: In.hue }));
      },
      { deep: !0 }
    );
    const Ln = () => {
      if (Cn.value && Bn.value) {
        const Fn = Cn.value.getBoundingClientRect(), Pn = Bn.value.offsetWidth;
        return Dn.hue === 360 ? Fn.width - Pn / 2 : Dn.hue % 360 * (Fn.width - Pn) / 360 + Pn / 2;
      }
      return 0;
    }, $n = computed(() => ({
      left: Ln() + "px",
      top: 0
    })), Nn = (Fn) => {
      Fn.target !== Cn.value && Rn(Fn);
    }, Rn = (Fn) => {
      if (Fn.stopPropagation(), Cn.value && Bn.value) {
        const Pn = Cn.value.getBoundingClientRect(), Un = Bn.value.offsetWidth;
        let Hn = Fn.clientX - Pn.left;
        Hn = Math.min(Hn, Pn.width - Un / 2), Hn = Math.max(Un / 2, Hn);
        const zn = Math.round((Hn - Un / 2) / (Pn.width - Un) * 360);
        In.hue = zn, Dn.hue = zn, nr("change", zn);
      }
    };
    return tryOnMounted(() => {
      const Fn = {
        drag: (Pn) => {
          Rn(Pn);
        },
        end: (Pn) => {
          Rn(Pn);
        }
      };
      Cn.value && Bn.value && Vn.triggerDragEvent(Cn.value, Fn);
    }), { barElement: Cn, cursorElement: Bn, getCursorStyle: $n, onClickSider: Nn };
  }
}), kt = (_n) => (pushScopeId("data-v-e1a08576"), _n = _n(), popScopeId(), _n), $t = /* @__PURE__ */ kt(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1)), wt = [
  $t
];
function Bt(_n, nr, Cn, Bn, In, Dn) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-hue-slider", { "small-slider": _n.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-hue-slider__bar",
      onClick: nr[0] || (nr[0] = (...Ln) => _n.onClickSider && _n.onClickSider(...Ln))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": _n.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle$1(_n.getCursorStyle)
      }, wt, 6)
    ], 512)
  ], 2);
}
const _e = /* @__PURE__ */ q(St, [["render", Bt], ["__scopeId", "data-v-e1a08576"]]), Ht = defineComponent({
  name: "Lightness",
  props: {
    color: C$1.instanceOf(A),
    size: C$1.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(_n, { emit: nr }) {
    const Cn = ref(null), Bn = ref(null);
    let In = _n.color || new A();
    const [Dn, Ln, $n] = In.HSL, Nn = reactive({
      hue: Dn,
      saturation: Ln,
      lightness: $n
    });
    watch(
      () => _n.color,
      (zn) => {
        if (zn) {
          In = zn;
          const [Gn, Yn, Wn] = In.HSL;
          ie(Nn, {
            hue: Gn,
            saturation: Yn,
            lightness: Wn
          });
        }
      },
      { deep: !0 }
    );
    const Rn = computed(() => {
      const zn = tinycolor({
        h: Nn.hue,
        s: Nn.saturation,
        l: 0.8
      }).toPercentageRgbString(), Gn = tinycolor({
        h: Nn.hue,
        s: Nn.saturation,
        l: 0.6
      }).toPercentageRgbString(), Yn = tinycolor({
        h: Nn.hue,
        s: Nn.saturation,
        l: 0.4
      }).toPercentageRgbString(), Wn = tinycolor({
        h: Nn.hue,
        s: Nn.saturation,
        l: 0.2
      }).toPercentageRgbString();
      return {
        background: [
          `linear-gradient(to right, rgb(255, 255, 255), ${zn}, ${Gn}, ${Yn}, ${Wn}, rgb(0, 0, 0))`,
          `-webkit-linear-gradient(left, rgb(255, 255, 255), ${zn}, ${Gn}, ${Yn}, ${Wn}, rgb(0, 0, 0))`,
          `-moz-linear-gradient(left, rgb(255, 255, 255), ${zn}, ${Gn}, ${Yn}, ${Wn}, rgb(0, 0, 0))`,
          `-ms-linear-gradient(left, rgb(255, 255, 255), ${zn}, ${Gn}, ${Yn}, ${Wn}, rgb(0, 0, 0))`
        ]
      };
    }), Fn = () => {
      if (Cn.value && Bn.value) {
        const zn = Nn.lightness, Gn = Cn.value.getBoundingClientRect(), Yn = Bn.value.offsetWidth;
        return (1 - zn) * (Gn.width - Yn) + Yn / 2;
      }
      return 0;
    }, Pn = computed(() => ({
      left: Fn() + "px",
      top: 0
    })), Un = (zn) => {
      zn.target !== Cn.value && Hn(zn);
    }, Hn = (zn) => {
      if (zn.stopPropagation(), Cn.value && Bn.value) {
        const Gn = Cn.value.getBoundingClientRect(), Yn = Bn.value.offsetWidth;
        let Wn = zn.clientX - Gn.left;
        Wn = Math.max(Yn / 2, Wn), Wn = Math.min(Wn, Gn.width - Yn / 2);
        const Xn = 1 - (Wn - Yn / 2) / (Gn.width - Yn);
        In.lightness = Xn, nr("change", Xn);
      }
    };
    return tryOnMounted(() => {
      const zn = {
        drag: (Gn) => {
          Hn(Gn);
        },
        end: (Gn) => {
          Hn(Gn);
        }
      };
      Cn.value && Bn.value && Vn.triggerDragEvent(Cn.value, zn);
    }), { barElement: Cn, cursorElement: Bn, getCursorStyle: Pn, getBackgroundStyle: Rn, onClickSider: Un };
  }
}), Rt = (_n) => (pushScopeId("data-v-94a50a9e"), _n = _n(), popScopeId(), _n), At = /* @__PURE__ */ Rt(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1)), Pt = [
  At
];
function Vt(_n, nr, Cn, Bn, In, Dn) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-lightness-slider", { "small-slider": _n.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-lightness-slider__bar",
      style: normalizeStyle$1(_n.getBackgroundStyle),
      onClick: nr[0] || (nr[0] = (...Ln) => _n.onClickSider && _n.onClickSider(...Ln))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": _n.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle$1(_n.getCursorStyle)
      }, Pt, 6)
    ], 4)
  ], 2);
}
const Le = /* @__PURE__ */ q(Ht, [["render", Vt], ["__scopeId", "data-v-94a50a9e"]]), Mt = defineComponent({
  name: "History",
  props: {
    colors: C$1.arrayOf(String).def(() => []),
    round: C$1.bool.def(!1)
  },
  emits: ["change"],
  setup(_n, { emit: nr }) {
    return { onColorSelect: (Cn) => {
      nr("change", Cn);
    } };
  }
}), Et = {
  key: 0,
  class: "vc-colorPicker__record"
}, It = { class: "color-list" }, Kt = ["onClick"];
function Lt(_n, nr, Cn, Bn, In, Dn) {
  return _n.colors && _n.colors.length > 0 ? (openBlock(), createElementBlock("div", Et, [
    createElementVNode("div", It, [
      (openBlock(!0), createElementBlock(Fragment, null, renderList(_n.colors, (Ln, $n) => (openBlock(), createElementBlock("div", {
        key: $n,
        class: normalizeClass(["color-item", "transparent", { "color-item__round": _n.round }]),
        onClick: (Nn) => _n.onColorSelect(Ln)
      }, [
        createElementVNode("div", {
          class: "color-item__display",
          style: normalizeStyle$1({ backgroundColor: Ln })
        }, null, 4)
      ], 10, Kt))), 128))
    ])
  ])) : createCommentVNode("", !0);
}
const me = /* @__PURE__ */ q(Mt, [["render", Lt], ["__scopeId", "data-v-0f657238"]]), Nt = defineComponent({
  name: "Display",
  props: {
    color: C$1.instanceOf(A),
    disableAlpha: C$1.bool.def(!1)
  },
  emits: ["update:color", "change"],
  setup(_n, { emit: nr }) {
    var Cn, Bn, In, Dn;
    const { copy: Ln, copied: $n, isSupported: Nn } = useClipboard(), Rn = ref("hex"), Fn = reactive({
      color: _n.color,
      hex: (Cn = _n.color) == null ? void 0 : Cn.hex,
      alpha: Math.round(((Bn = _n.color) == null ? void 0 : Bn.alpha) || 100),
      rgba: (In = _n.color) == null ? void 0 : In.RGB,
      previewBgColor: (Dn = _n.color) == null ? void 0 : Dn.toRgbString()
    }), Pn = computed(() => ({
      background: Fn.previewBgColor
    })), Un = () => {
      Rn.value = Rn.value === "rgba" ? "hex" : "rgba";
    }, Hn = useDebounceFn((Wn) => {
      if (!Wn.target.value)
        return;
      let Xn = parseInt(Wn.target.value.replace("%", ""));
      Xn > 100 && (Wn.target.value = "100", Xn = 100), Xn < 0 && (Wn.target.value = "0", Xn = 0), isNaN(Xn) && (Wn.target.value = "100", Xn = 100), !isNaN(Xn) && Fn.color && (Fn.color.alpha = Xn), nr("change", Fn.color);
    }, 300), zn = useDebounceFn((Wn, Xn) => {
      if (Fn.color) {
        if (Rn.value === "hex") {
          const ea = Wn.target.value.replace("#", "");
          tinycolor(ea).isValid() ? [3, 4].includes(ea.length) && (Fn.color.hex = ea) : Fn.color.hex = "000000", nr("change", Fn.color);
        } else if (Rn.value === "rgba" && Xn === 3 && Wn.target.value.toString() === "0." && Fn.rgba) {
          Fn.rgba[Xn] = Wn.target.value;
          const [ea, ta, na, ra] = Fn.rgba;
          Fn.color.hex = tinycolor({ r: ea, g: ta, b: na }).toHex(), Fn.color.alpha = Math.round(ra * 100), nr("change", Fn.color);
        }
      }
    }, 100), Gn = useDebounceFn((Wn, Xn) => {
      if (Wn.target.value) {
        if (Rn.value === "hex") {
          const ea = Wn.target.value.replace("#", "");
          tinycolor(ea).isValid() && Fn.color && [6, 8].includes(ea.length) && (Fn.color.hex = ea);
        } else if (Xn !== void 0 && Fn.rgba && Fn.color) {
          if (Wn.target.value < 0 && (Wn.target.value = 0), Xn === 3 && ((Wn.target.value > 1 || isNaN(Wn.target.value)) && (Wn.target.value = 1), Wn.target.value.toString() === "0."))
            return;
          Xn < 3 && Wn.target.value > 255 && (Wn.target.value = 255), Fn.rgba[Xn] = Wn.target.value;
          const [ea, ta, na, ra] = Fn.rgba;
          Fn.color.hex = tinycolor({ r: ea, g: ta, b: na }).toHex(), Fn.color.alpha = Math.round(ra * 100);
        }
        nr("change", Fn.color);
      }
    }, 300), Yn = () => {
      if (Nn && Fn.color) {
        const Wn = Rn.value === "hex" ? Fn.color.toString(Fn.color.alpha === 100 ? "hex6" : "hex8") : Fn.color.toRgbString();
        Ln(Wn || "");
      }
    };
    return whenever(
      () => _n.color,
      (Wn) => {
        Wn && (Fn.color = Wn, Fn.alpha = Math.round(Fn.color.alpha), Fn.hex = Fn.color.hex, Fn.rgba = Fn.color.RGB);
      },
      { deep: !0 }
    ), whenever(
      () => Fn.color,
      () => {
        Fn.color && (Fn.previewBgColor = Fn.color.toRgbString());
      },
      { deep: !0 }
    ), {
      state: Fn,
      getBgColorStyle: Pn,
      inputType: Rn,
      copied: $n,
      onInputTypeChange: Un,
      onAlphaBlur: Hn,
      onInputChange: Gn,
      onBlurChange: zn,
      onCopyColorStr: Yn
    };
  }
}), Wt = { class: "vc-display" }, Dt = { class: "vc-current-color vc-transparent" }, Tt = {
  key: 0,
  class: "copy-text"
}, Ot = {
  key: 0,
  style: { display: "flex", flex: "1", gap: "4px", height: "100%" }
}, zt = { class: "vc-color-input" }, Gt = {
  key: 0,
  class: "vc-alpha-input"
}, Ft = ["value"], Xt = {
  key: 1,
  style: { display: "flex", flex: "1", gap: "4px", height: "100%" }
}, qt = ["value", "onInput", "onBlur"];
function Yt(_n, nr, Cn, Bn, In, Dn) {
  return openBlock(), createElementBlock("div", Wt, [
    createElementVNode("div", Dt, [
      createElementVNode("div", {
        class: "color-cube",
        style: normalizeStyle$1(_n.getBgColorStyle),
        onClick: nr[0] || (nr[0] = (...Ln) => _n.onCopyColorStr && _n.onCopyColorStr(...Ln))
      }, [
        _n.copied ? (openBlock(), createElementBlock("span", Tt, "Copied!")) : createCommentVNode("", !0)
      ], 4)
    ]),
    _n.inputType === "hex" ? (openBlock(), createElementBlock("div", Ot, [
      createElementVNode("div", zt, [
        withDirectives(createElementVNode("input", {
          "onUpdate:modelValue": nr[1] || (nr[1] = (Ln) => _n.state.hex = Ln),
          maxlength: "8",
          onInput: nr[2] || (nr[2] = (...Ln) => _n.onInputChange && _n.onInputChange(...Ln)),
          onBlur: nr[3] || (nr[3] = (...Ln) => _n.onBlurChange && _n.onBlurChange(...Ln))
        }, null, 544), [
          [vModelText, _n.state.hex]
        ])
      ]),
      _n.disableAlpha ? createCommentVNode("", !0) : (openBlock(), createElementBlock("div", Gt, [
        createElementVNode("input", {
          class: "vc-alpha-input__inner",
          value: _n.state.alpha,
          onInput: nr[4] || (nr[4] = (...Ln) => _n.onAlphaBlur && _n.onAlphaBlur(...Ln))
        }, null, 40, Ft),
        createTextVNode("% ")
      ]))
    ])) : _n.state.rgba ? (openBlock(), createElementBlock("div", Xt, [
      (openBlock(!0), createElementBlock(Fragment, null, renderList(_n.state.rgba, (Ln, $n) => (openBlock(), createElementBlock("div", {
        class: "vc-color-input",
        key: $n
      }, [
        createElementVNode("input", {
          value: Ln,
          onInput: (Nn) => _n.onInputChange(Nn, $n),
          onBlur: (Nn) => _n.onBlurChange(Nn, $n)
        }, null, 40, qt)
      ]))), 128))
    ])) : createCommentVNode("", !0),
    createElementVNode("div", {
      class: "vc-input-toggle",
      onClick: nr[5] || (nr[5] = (...Ln) => _n.onInputTypeChange && _n.onInputTypeChange(...Ln))
    }, toDisplayString(_n.inputType), 1)
  ]);
}
const Se = /* @__PURE__ */ q(Nt, [["render", Yt], ["__scopeId", "data-v-7334ac20"]]), Ut = defineComponent({
  name: "FkColorPicker",
  components: { Display: Se, Alpha: ve, Palette: Ke, Board: ye, Hue: _e, Lightness: Le, History: me },
  props: {
    color: C$1.instanceOf(A),
    disableHistory: C$1.bool.def(!1),
    roundHistory: C$1.bool.def(!1),
    disableAlpha: C$1.bool.def(!1)
  },
  emits: ["update:color", "change", "advanceChange"],
  setup(_n, { emit: nr }) {
    const Cn = _n.color || new A(), Bn = reactive({
      color: Cn,
      hex: Cn.toHexString(),
      rgb: Cn.toRgbString()
    }), In = ref(!1), Dn = computed(() => ({ background: Bn.rgb })), Ln = () => {
      In.value = !1, nr("advanceChange", !1);
    }, $n = useLocalStorage(fe, [], {}), Nn = useDebounceFn(() => {
      if (_n.disableHistory)
        return;
      const Gn = Bn.color.toRgbString();
      if ($n.value = $n.value.filter((Yn) => !tinycolor.equals(Yn, Gn)), !$n.value.includes(Gn)) {
        for (; $n.value.length > Ce; )
          $n.value.pop();
        $n.value.unshift(Gn);
      }
    }, 500), Rn = (Gn) => {
      Gn === "advance" ? (In.value = !0, nr("advanceChange", !0)) : (Bn.color.hex = Gn, nr("advanceChange", !1));
    }, Fn = (Gn) => {
      Bn.color.alpha = Gn;
    }, Pn = (Gn) => {
      Bn.color.hue = Gn;
    }, Un = (Gn, Yn) => {
      Bn.color.saturation = Gn, Bn.color.brightness = Yn;
    }, Hn = (Gn) => {
      Bn.color.lightness = Gn;
    }, zn = (Gn) => {
      const Yn = Gn.target.value.replace("#", "");
      tinycolor(Yn).isValid() && (Bn.color.hex = Yn);
    };
    return whenever(
      () => _n.color,
      (Gn) => {
        Gn && (Bn.color = Gn);
      },
      { deep: !0 }
    ), whenever(
      () => Bn.color,
      () => {
        Bn.hex = Bn.color.hex, Bn.rgb = Bn.color.toRgbString(), Nn(), nr("update:color", Bn.color), nr("change", Bn.color);
      },
      { deep: !0 }
    ), {
      state: Bn,
      advancePanelShow: In,
      onBack: Ln,
      onCompactChange: Rn,
      onAlphaChange: Fn,
      onHueChange: Pn,
      onBoardChange: Un,
      onLightChange: Hn,
      onInputChange: zn,
      previewStyle: Dn,
      historyColors: $n
    };
  }
}), jt = (_n) => (pushScopeId("data-v-48e3c224"), _n = _n(), popScopeId(), _n), Zt = { class: "vc-fk-colorPicker" }, Jt = { class: "vc-fk-colorPicker__inner" }, Qt = { class: "vc-fk-colorPicker__header" }, xt = /* @__PURE__ */ jt(() => /* @__PURE__ */ createElementVNode("div", { class: "back" }, null, -1)), eo = [
  xt
];
function to(_n, nr, Cn, Bn, In, Dn) {
  const Ln = resolveComponent("Palette"), $n = resolveComponent("Board"), Nn = resolveComponent("Hue"), Rn = resolveComponent("Lightness"), Fn = resolveComponent("Alpha"), Pn = resolveComponent("Display"), Un = resolveComponent("History");
  return openBlock(), createElementBlock("div", Zt, [
    createElementVNode("div", Jt, [
      createElementVNode("div", Qt, [
        _n.advancePanelShow ? (openBlock(), createElementBlock("span", {
          key: 0,
          style: { cursor: "pointer" },
          onClick: nr[0] || (nr[0] = (...Hn) => _n.onBack && _n.onBack(...Hn))
        }, eo)) : createCommentVNode("", !0)
      ]),
      _n.advancePanelShow ? createCommentVNode("", !0) : (openBlock(), createBlock(Ln, {
        key: 0,
        onChange: _n.onCompactChange
      }, null, 8, ["onChange"])),
      _n.advancePanelShow ? (openBlock(), createBlock($n, {
        key: 1,
        color: _n.state.color,
        onChange: _n.onBoardChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", !0),
      _n.advancePanelShow ? (openBlock(), createBlock(Nn, {
        key: 2,
        color: _n.state.color,
        onChange: _n.onHueChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", !0),
      _n.advancePanelShow ? createCommentVNode("", !0) : (openBlock(), createBlock(Rn, {
        key: 3,
        color: _n.state.color,
        onChange: _n.onLightChange
      }, null, 8, ["color", "onChange"])),
      _n.disableAlpha ? createCommentVNode("", !0) : (openBlock(), createBlock(Fn, {
        key: 4,
        color: _n.state.color,
        onChange: _n.onAlphaChange
      }, null, 8, ["color", "onChange"])),
      createVNode$1(Pn, {
        color: _n.state.color,
        "disable-alpha": _n.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      _n.disableHistory ? createCommentVNode("", !0) : (openBlock(), createBlock(Un, {
        key: 5,
        round: _n.roundHistory,
        colors: _n.historyColors,
        onChange: _n.onCompactChange
      }, null, 8, ["round", "colors", "onChange"]))
    ])
  ]);
}
const Pe = /* @__PURE__ */ q(Ut, [["render", to], ["__scopeId", "data-v-48e3c224"]]), oo = defineComponent({
  name: "ChromeColorPicker",
  components: { Display: Se, Alpha: ve, Board: ye, Hue: _e, History: me },
  props: {
    color: C$1.instanceOf(A),
    disableHistory: C$1.bool.def(!1),
    roundHistory: C$1.bool.def(!1),
    disableAlpha: C$1.bool.def(!1)
  },
  emits: ["update:color", "change"],
  setup(_n, { emit: nr }) {
    const Cn = _n.color || new A(), Bn = reactive({
      color: Cn,
      hex: Cn.toHexString(),
      rgb: Cn.toRgbString()
    }), In = computed(() => ({ background: Bn.rgb })), Dn = useLocalStorage(fe, [], {}), Ln = useDebounceFn(() => {
      if (_n.disableHistory)
        return;
      const Un = Bn.color.toRgbString();
      if (Dn.value = Dn.value.filter((Hn) => !tinycolor.equals(Hn, Un)), !Dn.value.includes(Un)) {
        for (; Dn.value.length > Ce; )
          Dn.value.pop();
        Dn.value.unshift(Un);
      }
    }, 500), $n = (Un) => {
      Bn.color.alpha = Un;
    }, Nn = (Un) => {
      Bn.color.hue = Un;
    }, Rn = (Un) => {
      Un.hex !== void 0 && (Bn.color.hex = Un.hex), Un.alpha !== void 0 && (Bn.color.alpha = Un.alpha);
    }, Fn = (Un, Hn) => {
      Bn.color.saturation = Un, Bn.color.brightness = Hn;
    }, Pn = (Un) => {
      Un !== "advance" && (Bn.color.hex = Un);
    };
    return whenever(
      () => _n.color,
      (Un) => {
        Un && (Bn.color = Un);
      },
      { deep: !0 }
    ), whenever(
      () => Bn.color,
      () => {
        Bn.hex = Bn.color.hex, Bn.rgb = Bn.color.toRgbString(), Ln(), nr("update:color", Bn.color), nr("change", Bn.color);
      },
      { deep: !0 }
    ), {
      state: Bn,
      previewStyle: In,
      historyColors: Dn,
      onAlphaChange: $n,
      onHueChange: Nn,
      onBoardChange: Fn,
      onInputChange: Rn,
      onCompactChange: Pn
    };
  }
}), no = { class: "vc-chrome-colorPicker" }, ao = { class: "vc-chrome-colorPicker-body" }, ro = { class: "chrome-controls" }, lo = { class: "chrome-sliders" };
function so(_n, nr, Cn, Bn, In, Dn) {
  const Ln = resolveComponent("Board"), $n = resolveComponent("Hue"), Nn = resolveComponent("Alpha"), Rn = resolveComponent("Display"), Fn = resolveComponent("History");
  return openBlock(), createElementBlock("div", no, [
    createVNode$1(Ln, {
      round: !0,
      hide: !1,
      color: _n.state.color,
      onChange: _n.onBoardChange
    }, null, 8, ["color", "onChange"]),
    createElementVNode("div", ao, [
      createElementVNode("div", ro, [
        createElementVNode("div", lo, [
          createVNode$1($n, {
            size: "small",
            color: _n.state.color,
            onChange: _n.onHueChange
          }, null, 8, ["color", "onChange"]),
          _n.disableAlpha ? createCommentVNode("", !0) : (openBlock(), createBlock(Nn, {
            key: 0,
            size: "small",
            color: _n.state.color,
            onChange: _n.onAlphaChange
          }, null, 8, ["color", "onChange"]))
        ])
      ]),
      createVNode$1(Rn, {
        color: _n.state.color,
        "disable-alpha": _n.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      _n.disableHistory ? createCommentVNode("", !0) : (openBlock(), createBlock(Fn, {
        key: 0,
        round: _n.roundHistory,
        colors: _n.historyColors,
        onChange: _n.onCompactChange
      }, null, 8, ["round", "colors", "onChange"]))
    ])
  ]);
}
const Ve = /* @__PURE__ */ q(oo, [["render", so], ["__scopeId", "data-v-2611d66c"]]), ke = "Vue3ColorPickerProvider", io = (_n, nr) => {
  const Cn = _n.getBoundingClientRect(), Bn = Cn.left + Cn.width / 2, In = Cn.top + Cn.height / 2, Dn = Math.abs(Bn - nr.clientX), Ln = Math.abs(In - nr.clientY), $n = Math.sqrt(Math.pow(Dn, 2) + Math.pow(Ln, 2)), Nn = Ln / $n, Rn = Math.acos(Nn);
  let Fn = Math.floor(180 / (Math.PI / Rn));
  return nr.clientX > Bn && nr.clientY > In && (Fn = 180 - Fn), nr.clientX == Bn && nr.clientY > In && (Fn = 180), nr.clientX > Bn && nr.clientY == In && (Fn = 90), nr.clientX < Bn && nr.clientY > In && (Fn = 180 + Fn), nr.clientX < Bn && nr.clientY == In && (Fn = 270), nr.clientX < Bn && nr.clientY < In && (Fn = 360 - Fn), Fn;
};
let de = !1;
const co = (_n, nr) => {
  const Cn = function(In) {
    var Dn;
    (Dn = nr.drag) == null || Dn.call(nr, In);
  }, Bn = function(In) {
    var Dn;
    document.removeEventListener("mousemove", Cn, !1), document.removeEventListener("mouseup", Bn, !1), document.onselectstart = null, document.ondragstart = null, de = !1, (Dn = nr.end) == null || Dn.call(nr, In);
  };
  _n && _n.addEventListener("mousedown", (In) => {
    var Dn;
    de || (document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", Cn, !1), document.addEventListener("mouseup", Bn, !1), de = !0, (Dn = nr.start) == null || Dn.call(nr, In));
  });
}, uo = {
  angle: {
    type: Number,
    default: 0
  },
  size: {
    type: Number,
    default: 16,
    validator: (_n) => _n >= 16
  },
  borderWidth: {
    type: Number,
    default: 1,
    validator: (_n) => _n >= 1
  },
  borderColor: {
    type: String,
    default: "#666"
  }
}, go = defineComponent({
  name: "Angle",
  props: uo,
  emits: ["update:angle", "change"],
  setup(_n, {
    emit: nr
  }) {
    const Cn = ref(null), Bn = ref(0);
    watch(() => _n.angle, ($n) => {
      Bn.value = $n;
    });
    const In = () => {
      let $n = Number(Bn.value);
      isNaN($n) || ($n = $n > 360 || $n < 0 ? _n.angle : $n, Bn.value = $n === 360 ? 0 : $n, nr("update:angle", Bn.value), nr("change", Bn.value));
    }, Dn = computed(() => ({
      width: _n.size + "px",
      height: _n.size + "px",
      borderWidth: _n.borderWidth + "px",
      borderColor: _n.borderColor,
      transform: `rotate(${Bn.value}deg)`
    })), Ln = ($n) => {
      Cn.value && (Bn.value = io(Cn.value, $n) % 360, In());
    };
    return onMounted(() => {
      const $n = {
        drag: (Nn) => {
          Ln(Nn);
        },
        end: (Nn) => {
          Ln(Nn);
        }
      };
      Cn.value && co(Cn.value, $n);
    }), () => createVNode$1("div", {
      class: "bee-angle"
    }, [createVNode$1("div", {
      class: "bee-angle__round",
      ref: Cn,
      style: Dn.value
    }, null)]);
  }
}), ho = defineComponent({
  name: "GradientColorPicker",
  components: { Angle: go, Display: Se, Alpha: ve, Palette: Ke, Board: ye, Hue: _e, Lightness: Le, History: me },
  props: {
    startColor: C$1.instanceOf(A).isRequired,
    endColor: C$1.instanceOf(A).isRequired,
    startColorStop: C$1.number.def(0),
    endColorStop: C$1.number.def(100),
    angle: C$1.number.def(0),
    type: C$1.oneOf(["linear", "radial"]).def("linear"),
    disableHistory: C$1.bool.def(!1),
    roundHistory: C$1.bool.def(!1),
    disableAlpha: C$1.bool.def(!1),
    pickerType: C$1.oneOf(["fk", "chrome"]).def("fk")
  },
  emits: [
    "update:startColor",
    "update:endColor",
    "update:angle",
    "update:startColorStop",
    "update:endColorStop",
    "startColorChange",
    "endColorChange",
    "advanceChange",
    "angleChange",
    "startColorStopChange",
    "endColorStopChange",
    "typeChange"
  ],
  setup(_n, { emit: nr }) {
    const Cn = reactive({
      startActive: !0,
      startColor: _n.startColor,
      endColor: _n.endColor,
      startColorStop: _n.startColorStop,
      endColorStop: _n.endColorStop,
      angle: _n.angle,
      type: _n.type,
      // rgba
      startColorRgba: _n.startColor.toRgbString(),
      endColorRgba: _n.endColor.toRgbString()
    }), Bn = inject(ke), In = ref(_n.pickerType === "chrome"), Dn = ref(), Ln = ref(), $n = ref();
    watch(
      () => [_n.startColor, _n.endColor, _n.angle],
      (oa) => {
        Cn.startColor = oa[0], Cn.endColor = oa[1], Cn.angle = oa[2];
      }
    ), watch(
      () => _n.type,
      (oa) => {
        Cn.type = oa;
      }
    );
    const Nn = computed({
      get: () => Cn.startActive ? Cn.startColor : Cn.endColor,
      set: (oa) => {
        if (Cn.startActive) {
          Cn.startColor = oa;
          return;
        }
        Cn.endColor = oa;
      }
    }), Rn = computed(() => {
      if ($n.value && Dn.value) {
        const oa = Cn.startColorStop / 100, la = $n.value.getBoundingClientRect(), ua = Dn.value.offsetWidth;
        return Math.round(oa * (la.width - ua) + ua / 2);
      }
      return 0;
    }), Fn = computed(() => {
      if ($n.value && Ln.value) {
        const oa = Cn.endColorStop / 100, la = $n.value.getBoundingClientRect(), ua = Ln.value.offsetWidth;
        return Math.round(oa * (la.width - ua) + ua / 2);
      }
      return 0;
    }), Pn = computed(() => {
      let oa = `background: linear-gradient(${Cn.angle}deg, ${Cn.startColorRgba} ${Cn.startColorStop}%, ${Cn.endColorRgba} ${Cn.endColorStop}%)`;
      return Cn.type === "radial" && (oa = `background: radial-gradient(circle, ${Cn.startColorRgba} ${Cn.startColorStop}%, ${Cn.endColorRgba} ${Cn.endColorStop}%)`), oa;
    }), Un = (oa) => {
      var la;
      if (Cn.startActive = !0, $n.value && Dn.value) {
        const ua = (la = $n.value) == null ? void 0 : la.getBoundingClientRect();
        let ca = oa.clientX - ua.left;
        ca = Math.max(Dn.value.offsetWidth / 2, ca), ca = Math.min(ca, ua.width - Dn.value.offsetWidth / 2), Cn.startColorStop = Math.round(
          (ca - Dn.value.offsetWidth / 2) / (ua.width - Dn.value.offsetWidth) * 100
        ), nr("update:startColorStop", Cn.startColorStop), nr("startColorStopChange", Cn.startColorStop);
      }
    }, Hn = (oa) => {
      var la;
      if (Cn.startActive = !1, $n.value && Ln.value) {
        const ua = (la = $n.value) == null ? void 0 : la.getBoundingClientRect();
        let ca = oa.clientX - ua.left;
        ca = Math.max(Ln.value.offsetWidth / 2, ca), ca = Math.min(ca, ua.width - Ln.value.offsetWidth / 2), Cn.endColorStop = Math.round(
          (ca - Ln.value.offsetWidth / 2) / (ua.width - Ln.value.offsetWidth) * 100
        ), nr("update:endColorStop", Cn.endColorStop), nr("endColorStopChange", Cn.endColorStop);
      }
    }, zn = (oa) => {
      const la = oa.target, ua = parseInt(la.value.replace("°", ""));
      isNaN(ua) || (Cn.angle = ua % 360), nr("update:angle", Cn.angle), nr("angleChange", Cn.angle);
    }, Gn = (oa) => {
      Cn.angle = oa, nr("update:angle", Cn.angle), nr("angleChange", Cn.angle);
    }, Yn = (oa) => {
      oa === "advance" ? (In.value = !0, nr("advanceChange", !0)) : (Nn.value.hex = oa, nr("advanceChange", !1)), ra();
    }, Wn = (oa) => {
      Nn.value.alpha = oa, ra();
    }, Xn = (oa) => {
      Nn.value.hue = oa, ra();
    }, ea = (oa, la) => {
      Nn.value.saturation = oa, Nn.value.brightness = la, ra();
    }, ta = (oa) => {
      Nn.value.lightness = oa, ra();
    }, na = () => {
      ra();
    }, ra = () => {
      Cn.startActive ? (nr("update:startColor", Cn.startColor), nr("startColorChange", Cn.startColor)) : (nr("update:endColor", Cn.endColor), nr("endColorChange", Cn.endColor));
    }, aa = () => {
      In.value = !1, nr("advanceChange", !1);
    }, ia = () => {
      Cn.type = Cn.type === "linear" ? "radial" : "linear", nr("typeChange", Cn.type);
    }, Aa = useLocalStorage(fe, [], {}), sa = useDebounceFn(() => {
      if (_n.disableHistory)
        return;
      const oa = Nn.value.toRgbString();
      if (Aa.value = Aa.value.filter((la) => !tinycolor.equals(la, oa)), !Aa.value.includes(oa)) {
        for (; Aa.value.length > Ce; )
          Aa.value.pop();
        Aa.value.unshift(oa);
      }
    }, 500);
    return tryOnMounted(() => {
      Ln.value && Dn.value && (Vn.triggerDragEvent(Ln.value, {
        drag: (oa) => {
          Hn(oa);
        },
        end: (oa) => {
          Hn(oa);
        }
      }), Vn.triggerDragEvent(Dn.value, {
        drag: (oa) => {
          Un(oa);
        },
        end: (oa) => {
          Un(oa);
        }
      }));
    }), whenever(
      () => Cn.startColor,
      (oa) => {
        Cn.startColorRgba = oa.toRgbString();
      },
      { deep: !0 }
    ), whenever(
      () => Cn.endColor,
      (oa) => {
        Cn.endColorRgba = oa.toRgbString();
      },
      { deep: !0 }
    ), whenever(
      () => Nn.value,
      () => {
        sa();
      },
      { deep: !0 }
    ), {
      startGradientRef: Dn,
      stopGradientRef: Ln,
      colorRangeRef: $n,
      state: Cn,
      currentColor: Nn,
      getStartColorLeft: Rn,
      getEndColorLeft: Fn,
      gradientBg: Pn,
      advancePanelShow: In,
      onDegreeBlur: zn,
      onCompactChange: Yn,
      onAlphaChange: Wn,
      onHueChange: Xn,
      onBoardChange: ea,
      onLightChange: ta,
      historyColors: Aa,
      onBack: aa,
      onDegreeChange: Gn,
      onDisplayChange: na,
      onTypeChange: ia,
      lang: Bn == null ? void 0 : Bn.lang
    };
  }
}), Ne = (_n) => (pushScopeId("data-v-c4d6d6ea"), _n = _n(), popScopeId(), _n), po = { class: "vc-gradient-picker" }, fo = { class: "vc-gradient-picker__header" }, Co = { class: "vc-gradient__types" }, vo = { class: "vc-gradient-wrap__types" }, bo = { class: "vc-picker-degree-input vc-degree-input" }, yo = { class: "vc-degree-input__control" }, _o = ["value"], mo = { class: "vc-degree-input__panel" }, So = { class: "vc-degree-input__disk" }, ko = { class: "vc-gradient-picker__body" }, $o = {
  class: "vc-color-range",
  ref: "colorRangeRef"
}, wo = { class: "vc-color-range__container" }, Bo = { class: "vc-gradient__stop__container" }, Ho = ["title"], Ro = /* @__PURE__ */ Ne(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1)), Ao = [
  Ro
], Po = ["title"], Vo = /* @__PURE__ */ Ne(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1)), Mo = [
  Vo
];
function Eo(_n, nr, Cn, Bn, In, Dn) {
  var Ln, $n;
  const Nn = resolveComponent("Angle"), Rn = resolveComponent("Board"), Fn = resolveComponent("Hue"), Pn = resolveComponent("Palette"), Un = resolveComponent("Lightness"), Hn = resolveComponent("Alpha"), zn = resolveComponent("Display"), Gn = resolveComponent("History");
  return openBlock(), createElementBlock("div", po, [
    createElementVNode("div", fo, [
      createElementVNode("div", null, [
        withDirectives(createElementVNode("div", {
          class: "back",
          style: { cursor: "pointer" },
          onClick: nr[0] || (nr[0] = (...Yn) => _n.onBack && _n.onBack(...Yn))
        }, null, 512), [
          [vShow, _n.pickerType === "fk" && _n.advancePanelShow]
        ])
      ]),
      createElementVNode("div", Co, [
        createElementVNode("div", vo, [
          (openBlock(), createElementBlock(Fragment, null, renderList(["linear", "radial"], (Yn) => createElementVNode("div", {
            class: normalizeClass(["vc-gradient__type", { active: _n.state.type === Yn }]),
            key: Yn,
            onClick: nr[1] || (nr[1] = (...Wn) => _n.onTypeChange && _n.onTypeChange(...Wn))
          }, toDisplayString(_n.lang ? _n.lang[Yn] : Yn), 3)), 64))
        ]),
        withDirectives(createElementVNode("div", bo, [
          createElementVNode("div", yo, [
            createElementVNode("input", {
              value: _n.state.angle,
              onBlur: nr[2] || (nr[2] = (...Yn) => _n.onDegreeBlur && _n.onDegreeBlur(...Yn))
            }, null, 40, _o),
            createTextVNode("deg ")
          ]),
          createElementVNode("div", mo, [
            createElementVNode("div", So, [
              createVNode$1(Nn, {
                angle: _n.state.angle,
                "onUpdate:angle": nr[3] || (nr[3] = (Yn) => _n.state.angle = Yn),
                size: 40,
                onChange: _n.onDegreeChange
              }, null, 8, ["angle", "onChange"])
            ])
          ])
        ], 512), [
          [vShow, _n.state.type === "linear"]
        ])
      ])
    ]),
    createElementVNode("div", ko, [
      createElementVNode("div", $o, [
        createElementVNode("div", wo, [
          createElementVNode("div", {
            class: "vc-background",
            style: normalizeStyle$1(_n.gradientBg)
          }, null, 4),
          createElementVNode("div", Bo, [
            createElementVNode("div", {
              class: normalizeClass(["vc-gradient__stop", {
                "vc-gradient__stop--current": _n.state.startActive
              }]),
              ref: "startGradientRef",
              title: (Ln = _n.lang) == null ? void 0 : Ln.start,
              style: normalizeStyle$1({ left: _n.getStartColorLeft + "px", backgroundColor: _n.state.startColorRgba })
            }, Ao, 14, Ho),
            createElementVNode("div", {
              class: normalizeClass(["vc-gradient__stop", {
                "vc-gradient__stop--current": !_n.state.startActive
              }]),
              ref: "stopGradientRef",
              title: ($n = _n.lang) == null ? void 0 : $n.end,
              style: normalizeStyle$1({ left: _n.getEndColorLeft + "px", backgroundColor: _n.state.endColorRgba })
            }, Mo, 14, Po)
          ])
        ])
      ], 512)
    ]),
    _n.advancePanelShow ? (openBlock(), createBlock(Rn, {
      key: 0,
      color: _n.currentColor,
      onChange: _n.onBoardChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", !0),
    _n.advancePanelShow ? (openBlock(), createBlock(Fn, {
      key: 1,
      color: _n.currentColor,
      onChange: _n.onHueChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", !0),
    _n.advancePanelShow ? createCommentVNode("", !0) : (openBlock(), createBlock(Pn, {
      key: 2,
      onChange: _n.onCompactChange
    }, null, 8, ["onChange"])),
    _n.advancePanelShow ? createCommentVNode("", !0) : (openBlock(), createBlock(Un, {
      key: 3,
      color: _n.currentColor,
      onChange: _n.onLightChange
    }, null, 8, ["color", "onChange"])),
    _n.disableAlpha ? createCommentVNode("", !0) : (openBlock(), createBlock(Hn, {
      key: 4,
      color: _n.currentColor,
      onChange: _n.onAlphaChange
    }, null, 8, ["color", "onChange"])),
    createVNode$1(zn, {
      color: _n.currentColor,
      "disable-alpha": _n.disableAlpha,
      onChange: _n.onDisplayChange
    }, null, 8, ["color", "disable-alpha", "onChange"]),
    _n.disableHistory ? createCommentVNode("", !0) : (openBlock(), createBlock(Gn, {
      key: 5,
      round: _n.roundHistory,
      colors: _n.historyColors,
      onChange: _n.onCompactChange
    }, null, 8, ["round", "colors", "onChange"]))
  ]);
}
const Me = /* @__PURE__ */ q(ho, [["render", Eo], ["__scopeId", "data-v-c4d6d6ea"]]), Io = defineComponent({
  name: "WrapContainer",
  props: {
    theme: C$1.oneOf(["white", "black"]).def("white"),
    showTab: C$1.bool.def(!1),
    activeKey: C$1.oneOf(["pure", "gradient"]).def("pure")
  },
  emits: ["update:activeKey", "change"],
  setup(_n, { emit: nr }) {
    const Cn = reactive({
      activeKey: _n.activeKey
    }), Bn = inject(ke), In = (Dn) => {
      Cn.activeKey = Dn, nr("update:activeKey", Dn), nr("change", Dn);
    };
    return whenever(
      () => _n.activeKey,
      (Dn) => {
        Cn.activeKey = Dn;
      }
    ), { state: Cn, onActiveKeyChange: In, lang: Bn == null ? void 0 : Bn.lang };
  }
}), Ko = { class: "vc-colorpicker--container" }, Lo = {
  key: 0,
  class: "vc-colorpicker--tabs"
}, No = { class: "vc-colorpicker--tabs__inner" }, Wo = { class: "vc-btn__content" }, Do = { class: "vc-btn__content" };
function To(_n, nr, Cn, Bn, In, Dn) {
  var Ln, $n;
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-colorpicker", _n.theme])
  }, [
    createElementVNode("div", Ko, [
      _n.showTab ? (openBlock(), createElementBlock("div", Lo, [
        createElementVNode("div", No, [
          createElementVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": _n.state.activeKey === "pure"
              }
            ]),
            onClick: nr[0] || (nr[0] = (Nn) => _n.onActiveKeyChange("pure"))
          }, [
            createElementVNode("button", null, [
              createElementVNode("div", Wo, toDisplayString((Ln = _n.lang) == null ? void 0 : Ln.pure), 1)
            ])
          ], 2),
          createElementVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": _n.state.activeKey === "gradient"
              }
            ]),
            onClick: nr[1] || (nr[1] = (Nn) => _n.onActiveKeyChange("gradient"))
          }, [
            createElementVNode("button", null, [
              createElementVNode("div", Do, toDisplayString(($n = _n.lang) == null ? void 0 : $n.gradient), 1)
            ])
          ], 2),
          createElementVNode("div", {
            class: "vc-colorpicker--tabs__bg",
            style: normalizeStyle$1({
              width: "50%",
              left: `calc(${_n.state.activeKey === "gradient" ? 50 : 0}%)`
            })
          }, null, 4)
        ])
      ])) : createCommentVNode("", !0),
      renderSlot(_n.$slots, "default", {}, void 0, !0)
    ])
  ], 2);
}
const Oo = /* @__PURE__ */ q(Io, [["render", To], ["__scopeId", "data-v-0492277d"]]), zo = {
  start: "Start",
  end: "End",
  pure: "Pure",
  gradient: "Gradient",
  linear: "linear",
  radial: "radial"
}, Go = {
  start: "开始",
  end: "结束",
  pure: "纯色",
  gradient: "渐变",
  linear: "线性",
  radial: "径向"
}, Fo = {
  En: zo,
  "ZH-cn": Go
}, Xo = {
  isWidget: C$1.bool.def(!1),
  pickerType: C$1.oneOf(["fk", "chrome"]).def("fk"),
  shape: C$1.oneOf(["circle", "square"]).def("square"),
  pureColor: {
    type: [String, Object],
    default: "#000000"
  },
  gradientColor: C$1.string.def(
    "linear-gradient(90deg, rgba(255, 255, 255, 1) 0%, rgba(0, 0, 0, 1) 100%)"
  ),
  format: {
    type: String,
    default: "rgb"
  },
  disableAlpha: C$1.bool.def(!1),
  disableHistory: C$1.bool.def(!1),
  roundHistory: C$1.bool.def(!1),
  useType: C$1.oneOf(["pure", "gradient", "both"]).def("pure"),
  activeKey: C$1.oneOf(["pure", "gradient"]).def("pure"),
  lang: {
    type: String,
    default: "ZH-cn"
  },
  zIndex: C$1.number.def(9999),
  pickerContainer: {
    type: [String, HTMLElement],
    default: "body"
  },
  debounce: C$1.number.def(100),
  theme: C$1.oneOf(["white", "black"]).def("white"),
  blurClose: C$1.bool.def(!1),
  defaultPopup: C$1.bool.def(!1)
}, qo = defineComponent({
  name: "ColorPicker",
  components: { FkColorPicker: Pe, ChromeColorPicker: Ve, GradientColorPicker: Me, WrapContainer: Oo },
  inheritAttrs: !1,
  props: Xo,
  emits: [
    "update:pureColor",
    "pureColorChange",
    "update:gradientColor",
    "gradientColorChange",
    "update:activeKey",
    "activeKeyChange"
  ],
  setup(_n, { emit: nr }) {
    provide(ke, {
      lang: computed(() => Fo[_n.lang || "ZH-cn"])
    });
    const Cn = !!useSlots().extra, Bn = reactive({
      pureColor: _n.pureColor || "",
      activeKey: _n.useType === "gradient" ? "gradient" : _n.activeKey,
      //  "pure" | "gradient"
      isAdvanceMode: !1
    }), In = new A("#000"), Dn = new A("#000"), Ln = new A(Bn.pureColor), $n = reactive({
      startColor: In,
      endColor: Dn,
      startColorStop: 0,
      endColorStop: 100,
      angle: 0,
      type: "linear",
      gradientColor: _n.gradientColor
    }), Nn = ref(Ln), Rn = ref(_n.defaultPopup), Fn = ref(null), Pn = ref(null);
    let Un = null;
    const Hn = computed(() => ({
      background: Bn.activeKey !== "gradient" ? tinycolor(Bn.pureColor).toRgbString() : $n.gradientColor
    })), zn = computed(() => Bn.activeKey === "gradient" ? Me.name : _n.pickerType === "fk" ? Pe.name : Ve.name), Gn = (oa) => {
      Bn.isAdvanceMode = oa;
    }, Yn = computed(() => {
      const oa = {
        disableAlpha: _n.disableAlpha,
        disableHistory: _n.disableHistory,
        roundHistory: _n.roundHistory,
        pickerType: _n.pickerType
      };
      return Bn.activeKey === "gradient" ? {
        ...oa,
        startColor: $n.startColor,
        endColor: $n.endColor,
        angle: $n.angle,
        type: $n.type,
        startColorStop: $n.startColorStop,
        endColorStop: $n.endColorStop,
        onStartColorChange: (la) => {
          $n.startColor = la, na();
        },
        onEndColorChange: (la) => {
          $n.endColor = la, na();
        },
        onStartColorStopChange: (la) => {
          $n.startColorStop = la, na();
        },
        onEndColorStopChange: (la) => {
          $n.endColorStop = la, na();
        },
        onAngleChange: (la) => {
          $n.angle = la, na();
        },
        onTypeChange: (la) => {
          $n.type = la, na();
        },
        onAdvanceChange: Gn
      } : {
        ...oa,
        disableAlpha: _n.disableAlpha,
        disableHistory: _n.disableHistory,
        roundHistory: _n.roundHistory,
        color: Nn.value,
        onChange: ia,
        onAdvanceChange: Gn
      };
    }), Wn = () => {
      Rn.value = !0, Un ? Un.update() : aa();
    }, Xn = () => {
      Rn.value = !1;
    }, ea = useDebounceFn(() => {
      !_n.isWidget && _n.blurClose && Xn();
    }, 100);
    onClickOutside(Pn, () => {
      Xn();
    });
    const ta = () => {
      var oa, la, ua, ca;
      try {
        const [fa] = parse($n.gradientColor);
        if (fa && fa.type.includes("gradient") && fa.colorStops.length >= 2) {
          const ha = fa.colorStops[0], pa = fa.colorStops[1];
          $n.startColorStop = Number((oa = ha.length) == null ? void 0 : oa.value) || 0, $n.endColorStop = Number((la = pa.length) == null ? void 0 : la.value) || 0, fa.type === "linear-gradient" && ((ua = fa.orientation) == null ? void 0 : ua.type) === "angular" && ($n.angle = Number((ca = fa.orientation) == null ? void 0 : ca.value) || 0), $n.type = fa.type.split("-")[0];
          const [ya, da, Ca, ma] = ha.value, [va, ga, xa, wa] = pa.value;
          $n.startColor = new A({
            r: Number(ya),
            g: Number(da),
            b: Number(Ca),
            a: Number(ma)
          }), $n.endColor = new A({
            r: Number(va),
            g: Number(ga),
            b: Number(xa),
            a: Number(wa)
          });
        }
      } catch (fa) {
        console.log(`[Parse Color]: ${fa}`);
      }
    }, na = useDebounceFn(() => {
      const oa = ra();
      try {
        $n.gradientColor = stringify(oa), nr("update:gradientColor", $n.gradientColor), nr("gradientColorChange", $n.gradientColor);
      } catch (la) {
        console.log(la);
      }
    }, _n.debounce), ra = () => {
      const oa = [], la = $n.startColor.RGB.map((fa) => fa.toString()), ua = $n.endColor.RGB.map((fa) => fa.toString()), ca = [
        {
          type: "rgba",
          value: [la[0], la[1], la[2], la[3]],
          length: { value: $n.startColorStop + "", type: "%" }
        },
        {
          type: "rgba",
          value: [ua[0], ua[1], ua[2], ua[3]],
          length: { value: $n.endColorStop + "", type: "%" }
        }
      ];
      return $n.type === "linear" ? oa.push({
        type: "linear-gradient",
        orientation: { type: "angular", value: $n.angle + "" },
        colorStops: ca
      }) : $n.type === "radial" && oa.push({
        type: "radial-gradient",
        orientation: [{ type: "shape", value: "circle" }],
        colorStops: ca
      }), oa;
    }, aa = () => {
      Fn.value && Pn.value && (Un = createPopper(Fn.value, Pn.value, {
        placement: "auto",
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [0, 8]
            }
          },
          {
            name: "flip",
            options: {
              allowedAutoPlacements: ["top", "bottom", "left", "right"],
              rootBoundary: "viewport"
            }
          }
        ]
      }));
    }, ia = (oa) => {
      Nn.value = oa, Bn.pureColor = oa.toString(_n.format), Aa();
    }, Aa = useDebounceFn(() => {
      nr("update:pureColor", Bn.pureColor), nr("pureColorChange", Bn.pureColor);
    }, _n.debounce), sa = (oa) => {
      Bn.activeKey = oa, nr("update:activeKey", oa), nr("activeKeyChange", oa);
    };
    return tryOnMounted(() => {
      ta(), Un || aa();
    }), whenever(
      () => _n.gradientColor,
      (oa) => {
        oa != $n.gradientColor && ($n.gradientColor = oa);
      }
    ), whenever(
      () => $n.gradientColor,
      () => {
        ta();
      }
    ), whenever(
      () => _n.activeKey,
      (oa) => {
        Bn.activeKey = oa;
      }
    ), whenever(
      () => _n.useType,
      (oa) => {
        Bn.activeKey !== "gradient" && oa === "gradient" ? Bn.activeKey = "gradient" : Bn.activeKey = "pure";
      }
    ), whenever(
      () => _n.pureColor,
      (oa) => {
        tinycolor.equals(oa, Bn.pureColor) || (Bn.pureColor = oa, Nn.value = new A(oa));
      },
      { deep: !0 }
    ), {
      colorCubeRef: Fn,
      pickerRef: Pn,
      showPicker: Rn,
      colorInstance: Nn,
      getBgColorStyle: Hn,
      getComponentName: zn,
      getBindArgs: Yn,
      state: Bn,
      hasExtra: Cn,
      onColorChange: ia,
      onShowPicker: Wn,
      onActiveKeyChange: sa,
      onAutoClose: ea
    };
  }
}), Yo = {
  key: 0,
  class: "vc-color-extra"
}, Uo = {
  key: 0,
  class: "vc-color-extra"
};
function jo(_n, nr, Cn, Bn, In, Dn) {
  const Ln = resolveComponent("WrapContainer");
  return openBlock(), createElementBlock(Fragment, null, [
    _n.isWidget ? (openBlock(), createBlock(Ln, {
      key: 0,
      "active-key": _n.state.activeKey,
      "onUpdate:activeKey": nr[0] || (nr[0] = ($n) => _n.state.activeKey = $n),
      "show-tab": _n.useType === "both",
      style: normalizeStyle$1({ zIndex: _n.zIndex }),
      theme: _n.theme,
      onChange: _n.onActiveKeyChange
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(_n.getComponentName), mergeProps({ key: _n.getComponentName }, _n.getBindArgs), null, 16)),
        _n.hasExtra ? (openBlock(), createElementBlock("div", Yo, [
          renderSlot(_n.$slots, "extra", {}, void 0, !0)
        ])) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 8, ["active-key", "show-tab", "style", "theme", "onChange"])) : createCommentVNode("", !0),
    _n.isWidget ? createCommentVNode("", !0) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-color-wrap transparent", { round: _n.shape === "circle" }]),
        ref: "colorCubeRef"
      }, [
        createElementVNode("div", {
          class: "current-color",
          style: normalizeStyle$1(_n.getBgColorStyle),
          onClick: nr[1] || (nr[1] = (...$n) => _n.onShowPicker && _n.onShowPicker(...$n))
        }, null, 4)
      ], 2),
      (openBlock(), createBlock(Teleport, { to: _n.pickerContainer }, [
        withDirectives(createElementVNode("div", {
          ref: "pickerRef",
          style: normalizeStyle$1({ zIndex: _n.zIndex }),
          onMouseleave: nr[3] || (nr[3] = (...$n) => _n.onAutoClose && _n.onAutoClose(...$n))
        }, [
          _n.showPicker ? (openBlock(), createBlock(Ln, {
            key: 0,
            "show-tab": _n.useType === "both" && !_n.state.isAdvanceMode,
            theme: _n.theme,
            "active-key": _n.state.activeKey,
            "onUpdate:activeKey": nr[2] || (nr[2] = ($n) => _n.state.activeKey = $n),
            onChange: _n.onActiveKeyChange
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_n.getComponentName), mergeProps({ key: _n.getComponentName }, _n.getBindArgs), null, 16)),
              _n.hasExtra ? (openBlock(), createElementBlock("div", Uo, [
                renderSlot(_n.$slots, "extra", {}, void 0, !0)
              ])) : createCommentVNode("", !0)
            ]),
            _: 3
          }, 8, ["show-tab", "theme", "active-key", "onChange"])) : createCommentVNode("", !0)
        ], 36), [
          [vShow, _n.showPicker]
        ])
      ], 8, ["to"]))
    ], 64))
  ], 64);
}
const re = /* @__PURE__ */ q(qo, [["render", jo], ["__scopeId", "data-v-354ca836"]]), style = "", index_vue_vue_type_style_index_0_scoped_f811e655_lang = "", RuleSetting_vue_vue_type_style_index_0_scoped_b47820c8_lang = "", StylesSetting_vue_vue_type_style_index_0_scoped_9562908e_lang = "", EchartsGirdSetting_vue_vue_type_style_index_0_scoped_dda3ca43_lang = "", EchartsTitleSetting_vue_vue_type_style_index_0_lang = "", EchartsLegendSetting_vue_vue_type_style_index_0_lang = "", _hoisted_1$6 = { class: "config-item-label" }, _hoisted_2$4 = { class: "config-item-label-text" }, _hoisted_3$2 = {
  key: 0,
  class: "required"
}, _hoisted_4$1 = { class: "config-item-content" }, _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "ConfigItemBox",
  props: {
    name: {
      type: String,
      required: !1
    },
    required: {
      type: Boolean,
      default: !1,
      required: !1
    },
    alone: {
      type: Boolean,
      default: !1,
      required: !1
    }
  },
  setup(_n) {
    return (nr, Cn) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["config-item", { alone: _n.alone }])
    }, [
      renderSlot(nr.$slots, "header", {}, () => [
        createElementVNode("div", _hoisted_1$6, [
          createElementVNode("span", _hoisted_2$4, [
            createTextVNode(toDisplayString(_n.name) + " ", 1),
            _n.required ? (openBlock(), createElementBlock("span", _hoisted_3$2, "*")) : createCommentVNode("", !0)
          ]),
          renderSlot(nr.$slots, "tip", {}, void 0, !0)
        ])
      ], !0),
      createElementVNode("div", _hoisted_4$1, [
        renderSlot(nr.$slots, "default", {}, void 0, !0)
      ])
    ], 2));
  }
}), ConfigItemBox_vue_vue_type_style_index_0_scoped_e78be118_lang = "", ConfigItemBox = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-e78be118"]]), _hoisted_1$5 = { class: "page-filter-panel-header" }, _hoisted_2$3 = { class: "page-filter-switch" }, _hoisted_3$1 = { class: "page-filter-panel-content" }, _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "FilterPanel",
  setup(_n) {
    const nr = useLayoutStore(), Cn = useChartEditStore(), { getFilterConfig: Bn } = toRefs(nr);
    inject("pageData", { name: "", appId: 0, groupId: 0, screenId: 0, list: [] });
    const In = Cn.getEditCanvasConfig, Dn = () => {
      nr.setFilterConfig(!1);
    };
    return (Ln, $n) => {
      const Nn = resolveComponent("el-tag"), Rn = resolveComponent("el-switch"), Fn = resolveComponent("el-slider"), Pn = resolveComponent("el-col"), Un = resolveComponent("el-input-number"), Hn = resolveComponent("el-row"), zn = resolveComponent("el-option"), Gn = resolveComponent("el-select");
      return withDirectives((openBlock(), createElementBlock("div", {
        class: normalizeClass(["page-filter-panel", { show: unref(Bn) }])
      }, [
        createElementVNode("div", _hoisted_1$5, [
          $n[15] || ($n[15] = createElementVNode("span", { class: "page-filter-panel-title" }, "滤镜", -1)),
          createElementVNode("div", _hoisted_2$3, [
            unref(In).filterShow ? createCommentVNode("", !0) : (openBlock(), createBlock(Nn, {
              key: 0,
              type: "warning"
            }, {
              default: withCtx(() => $n[14] || ($n[14] = [
                createTextVNode(" 开启滤镜后配置才生效 ")
              ])),
              _: 1
            })),
            createVNode$1(Rn, {
              size: "small",
              class: "m-l-10",
              modelValue: unref(In).filterShow,
              "onUpdate:modelValue": $n[0] || ($n[0] = (Yn) => unref(In).filterShow = Yn)
            }, null, 8, ["modelValue"])
          ])
        ]),
        createElementVNode("div", _hoisted_3$1, [
          createVNode$1(unref(ConfigItemBox), { name: "色相" }, {
            default: withCtx(() => [
              createVNode$1(Hn, { gutter: 10 }, {
                default: withCtx(() => [
                  createVNode$1(Pn, { span: 16 }, {
                    default: withCtx(() => [
                      createVNode$1(Fn, {
                        class: "slider-style",
                        modelValue: unref(In).hueRotate,
                        "onUpdate:modelValue": $n[1] || ($n[1] = (Yn) => unref(In).hueRotate = Yn),
                        step: 3,
                        min: 0,
                        max: 360
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode$1(Pn, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode$1(Un, {
                        class: "config-input",
                        modelValue: unref(In).hueRotate,
                        "onUpdate:modelValue": $n[2] || ($n[2] = (Yn) => unref(In).hueRotate = Yn),
                        min: 0,
                        max: 360,
                        step: 3,
                        "controls-position": "right"
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode$1(unref(ConfigItemBox), { name: "饱和度" }, {
            default: withCtx(() => [
              createVNode$1(Hn, { gutter: 10 }, {
                default: withCtx(() => [
                  createVNode$1(Pn, { span: 16 }, {
                    default: withCtx(() => [
                      createVNode$1(Fn, {
                        class: "slider-style",
                        modelValue: unref(In).saturate,
                        "onUpdate:modelValue": $n[3] || ($n[3] = (Yn) => unref(In).saturate = Yn),
                        step: 0.1,
                        min: 0,
                        max: 2
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode$1(Pn, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode$1(Un, {
                        class: "config-input",
                        modelValue: unref(In).saturate,
                        "onUpdate:modelValue": $n[4] || ($n[4] = (Yn) => unref(In).saturate = Yn),
                        step: 0.1,
                        min: 0,
                        max: 2,
                        "controls-position": "right"
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode$1(unref(ConfigItemBox), { name: "对比度" }, {
            default: withCtx(() => [
              createVNode$1(Hn, { gutter: 10 }, {
                default: withCtx(() => [
                  createVNode$1(Pn, { span: 16 }, {
                    default: withCtx(() => [
                      createVNode$1(Fn, {
                        class: "slider-style",
                        modelValue: unref(In).contrast,
                        "onUpdate:modelValue": $n[5] || ($n[5] = (Yn) => unref(In).contrast = Yn),
                        step: 0.1,
                        min: 0,
                        max: 2
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode$1(Pn, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode$1(Un, {
                        class: "config-input",
                        modelValue: unref(In).contrast,
                        "onUpdate:modelValue": $n[6] || ($n[6] = (Yn) => unref(In).contrast = Yn),
                        step: 0.1,
                        min: 0,
                        max: 2,
                        "controls-position": "right"
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode$1(unref(ConfigItemBox), { name: "亮度" }, {
            default: withCtx(() => [
              createVNode$1(Hn, { gutter: 10 }, {
                default: withCtx(() => [
                  createVNode$1(Pn, { span: 16 }, {
                    default: withCtx(() => [
                      createVNode$1(Fn, {
                        class: "slider-style",
                        modelValue: unref(In).brightness,
                        "onUpdate:modelValue": $n[7] || ($n[7] = (Yn) => unref(In).brightness = Yn),
                        step: 0.1,
                        min: 0,
                        max: 2
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode$1(Pn, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode$1(Un, {
                        class: "config-input",
                        modelValue: unref(In).brightness,
                        "onUpdate:modelValue": $n[8] || ($n[8] = (Yn) => unref(In).brightness = Yn),
                        step: 0.1,
                        min: 0,
                        max: 2,
                        "controls-position": "right"
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode$1(unref(ConfigItemBox), { name: "透明度" }, {
            default: withCtx(() => [
              createVNode$1(Hn, { gutter: 10 }, {
                default: withCtx(() => [
                  createVNode$1(Pn, { span: 16 }, {
                    default: withCtx(() => [
                      createVNode$1(Fn, {
                        class: "slider-style",
                        modelValue: unref(In).opacity,
                        "onUpdate:modelValue": $n[9] || ($n[9] = (Yn) => unref(In).opacity = Yn),
                        step: 0.1,
                        min: 0,
                        max: 1
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  createVNode$1(Pn, { span: 8 }, {
                    default: withCtx(() => [
                      createVNode$1(Un, {
                        class: "config-input",
                        modelValue: unref(In).opacity,
                        "onUpdate:modelValue": $n[10] || ($n[10] = (Yn) => unref(In).opacity = Yn),
                        step: 0.1,
                        min: 0,
                        max: 1,
                        "controls-position": "right"
                      }, null, 8, ["modelValue"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode$1(unref(ConfigItemBox), { name: "混合" }, {
            default: withCtx(() => [
              createVNode$1(Gn, {
                class: "config-select full",
                "popper-class": "config-select-pop",
                modelValue: unref(In).blendMode,
                "onUpdate:modelValue": $n[13] || ($n[13] = (Yn) => unref(In).blendMode = Yn)
              }, {
                default: withCtx(() => [
                  (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(BlendModeEnumList), (Yn) => (openBlock(), createBlock(zn, {
                    key: Yn.value,
                    label: Yn.label,
                    value: Yn.value,
                    onClick: $n[11] || ($n[11] = withModifiers(() => {
                    }, ["stop"])),
                    onMousedown: $n[12] || ($n[12] = withModifiers(() => {
                    }, ["stop"]))
                  }, null, 8, ["label", "value"]))), 128))
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            _: 1
          })
        ])
      ], 2)), [
        [unref(ClickOutside), Dn]
      ]);
    };
  }
}), FilterPanel_vue_vue_type_style_index_0_scoped_20901761_lang = "", FilterPanel = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-20901761"]]), _hoisted_1$4 = { class: "dms-edit-align-line" }, _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "EditAlignLine",
  setup(_n) {
    const nr = useChartEditStore(), Cn = reactive({
      // 行横向row（上中下），列竖线col（左中右）
      lineArr: ["rowt", "rowc", "rowb", "coll", "colc", "colr"],
      // 展示线
      select: /* @__PURE__ */ new Map(),
      // 已经吸附
      sorptioned: {
        x: !1,
        y: !1
      }
    }), Bn = (Pn) => Pn ? {
      left: `${Pn.x ? Pn.x : 0}px`,
      top: `${Pn.y ? Pn.y : 0}px`
    } : {}, In = computed(() => 20), Dn = computed(() => nr.getEditCanvas[EditCanvasTypeEnum.IS_DRAG]), Ln = (Pn, Un) => Math.abs(Pn - Un) <= In.value, $n = computed(() => nr.getTargetChart.selectId), Nn = computed(() => nr.getComponentList[nr.fetchTargetIndex()]), Rn = computed(() => {
      var Pn;
      return ((Pn = Nn.value) == null ? void 0 : Pn.attr) || {};
    }), Fn = computed(() => ({
      id: "0",
      attr: {
        w: cloneDeep(nr.getEditCanvasConfig.width),
        h: cloneDeep(nr.getEditCanvasConfig.height),
        x: 0,
        y: 0,
        offsetX: 0,
        offsetY: 0,
        zIndex: 0
      }
    }));
    return watch(
      () => nr.getMousePosition,
      throttle$2(() => {
        try {
          if (!Dn.value || $n.value.length !== 1)
            return;
          const Pn = Rn.value.w, Un = Rn.value.h, Hn = Rn.value.x, zn = Hn + Pn / 2, Gn = Hn + Pn, Yn = [Hn, zn, Gn], Wn = Rn.value.y, Xn = Wn + Un / 2, ea = Wn + Un, ta = [Wn, Xn, ea];
          Cn.select.clear(), Cn.sorptioned.y = !1;
          const na = nr.getComponentList.map((ra) => ({
            id: ra.id,
            attr: ra.attr
          }));
          na.push(Fn.value), Cn.lineArr.forEach((ra) => {
            na.forEach((aa) => {
              if ($n.value[0] === aa.id)
                return;
              const ia = aa.attr.w, Aa = aa.attr.h, sa = aa.attr.x, oa = sa + ia / 2, la = sa + ia, ua = [sa, oa, la], ca = aa.attr.y, fa = ca + Aa / 2, ha = ca + Aa, pa = [ca, fa, ha];
              ra.includes("rowt") && (Ln(Wn, ca) && (Cn.select.set(ra, { y: ca }), setComponentPosition(Nn.value, Hn, ca)), Ln(Wn, fa) && (Cn.select.set(ra, { y: fa }), setComponentPosition(Nn.value, Hn, fa)), Ln(Wn, ha) && (Cn.select.set(ra, { y: ha }), setComponentPosition(Nn.value, Hn, ha))), ra.includes("rowc") && (Ln(Xn, ca) && (Cn.select.set(ra, { y: ca }), setComponentPosition(Nn.value, Hn, ca - Un / 2)), Ln(Xn, fa) && (Cn.select.set(ra, { y: fa }), setComponentPosition(Nn.value, Hn, fa - Un / 2)), Ln(Xn, ha) && (Cn.select.set(ra, { y: ha }), setComponentPosition(Nn.value, Hn, ha - Un / 2))), ra.includes("rowb") && (Ln(ea, ca) && (Cn.select.set(ra, { y: ca }), setComponentPosition(Nn.value, Hn, ca - Un)), Ln(ea, fa) && (Cn.select.set(ra, { y: fa }), setComponentPosition(Nn.value, Hn, fa - Un)), Ln(ea, ha) && (Cn.select.set(ra, { y: ha }), setComponentPosition(Nn.value, Hn, ha - Un))), ra.includes("coll") && (Ln(Hn, sa) && (Cn.select.set(ra, { x: sa }), setComponentPosition(Nn.value, sa, Wn)), Ln(Hn, oa) && (Cn.select.set(ra, { x: oa }), setComponentPosition(Nn.value, oa, Wn)), Ln(Hn, la) && (Cn.select.set(ra, { x: la }), setComponentPosition(Nn.value, la, Wn))), ra.includes("colc") && (Ln(zn, sa) && (Cn.select.set(ra, { x: sa }), setComponentPosition(Nn.value, sa - Pn / 2, Wn)), Ln(zn, oa) && (Cn.select.set(ra, { x: oa }), setComponentPosition(Nn.value, oa - Pn / 2, Wn)), Ln(zn, la) && (Cn.select.set(ra, { x: la }), setComponentPosition(Nn.value, la - Pn / 2, Wn))), ra.includes("colr") && (Ln(Gn, sa) && (Cn.select.set(ra, { x: sa }), setComponentPosition(Nn.value, sa - Pn, Wn)), Ln(Gn, oa) && (Cn.select.set(ra, { x: oa }), setComponentPosition(Nn.value, oa - Pn, Wn)), Ln(Gn, la) && (Cn.select.set(ra, { x: la }), setComponentPosition(Nn.value, la - Pn, Wn)));
            });
          });
        } catch (Pn) {
          console.log(Pn);
        }
      }, 200),
      {
        deep: !0
      }
    ), watch(
      () => Dn.value,
      (Pn) => {
        Pn || (Cn.select.clear(), Cn.sorptioned.y = !1);
      }
    ), (Pn, Un) => (openBlock(), createElementBlock("div", _hoisted_1$4, [
      (openBlock(!0), createElementBlock(Fragment, null, renderList(Cn.lineArr, (Hn) => (openBlock(), createElementBlock("div", {
        class: normalizeClass(["line", [Hn.includes("row") ? "row" : "col", Cn.select.has(Hn) && "visible"]]),
        key: Hn,
        style: normalizeStyle$1(Bn(Cn.select.get(Hn)))
      }, null, 6))), 128))
    ]));
  }
}), EditAlignLine_vue_vue_type_style_index_0_scoped_e2e3baa8_lang = "", EditAlignLine = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-e2e3baa8"]]), _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "EditWatermark",
  setup(_n) {
    const nr = reactive({
      color: "rgba(0, 0, 0, .15)",
      lineHeight: 16,
      fontSize: 16
    });
    return (Cn, Bn) => {
      const In = resolveComponent("el-watermark");
      return openBlock(), createBlock(In, {
        class: "dms-edit-watermark",
        font: nr,
        content: "北京数智共舞科技有限公司"
      }, null, 8, ["font"]);
    };
  }
}), EditWatermark_vue_vue_type_style_index_0_scoped_a18b68b3_lang = "", EditWatermark = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-a18b68b3"]]), selectBoxIndex = 9999, _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "EditSelect",
  setup(_n) {
    const nr = useChartEditStore(), { isSelect: Cn, scale: Bn } = toRefs(nr.getEditCanvas), In = ref();
    return watch(
      () => nr.getMousePosition,
      (Dn) => {
        if (!Cn.value)
          return;
        const { startX: Ln, startY: $n, x: Nn, y: Rn } = Dn, Fn = {
          zIndex: selectBoxIndex,
          // left
          x: 0,
          // top
          y: 0,
          // 宽
          w: 0,
          // 高
          h: 0,
          // 偏移
          offsetX: 0,
          offsetY: 0
        };
        Nn > Ln && Rn > $n ? (Fn.x = Ln, Fn.y = $n, Fn.w = Math.round((Nn - Ln) / Bn.value), Fn.h = Math.round((Rn - $n) / Bn.value)) : Nn > Ln && Rn < $n ? (Fn.x = Ln, Fn.w = Math.round((Nn - Ln) / Bn.value), Fn.h = Math.round(($n - Rn) / Bn.value), Fn.y = $n - Fn.h) : Nn < Ln && Rn > $n ? (Fn.y = $n, Fn.w = Math.round((Ln - Nn) / Bn.value), Fn.h = Math.round((Rn - $n) / Bn.value), Fn.x = Ln - Fn.w) : (Fn.w = Math.round((Ln - Nn) / Bn.value), Fn.h = Math.round(($n - Rn) / Bn.value), Fn.x = Ln - Fn.w, Fn.y = $n - Fn.h), In.value = {
          ...useComponentStyle(Fn, selectBoxIndex),
          ...useSizeStyle(Fn)
        };
      },
      {
        deep: !0
      }
    ), (Dn, Ln) => unref(Cn) ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "dms-edit-select",
      style: normalizeStyle$1(In.value)
    }, Ln[0] || (Ln[0] = [
      createElementVNode("div", { class: "select-background" }, null, -1),
      createElementVNode("div", { class: "select-border" }, null, -1)
    ]), 4)) : createCommentVNode("", !0);
  }
}), EditSelect_vue_vue_type_style_index_0_scoped_787005a9_lang = "", EditSelect = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-787005a9"]]);
var ChartLayoutStoreEnum = /* @__PURE__ */ ((_n) => (_n.LAYERS = "layers", _n.CHARTS = "charts", _n.DETAILS = "details", _n.Chart_TYPE = "chartType", _n.LAYER_TYPE = "layerType", _n.PERCENTAGE = "percentage", _n.RE_POSITION_CANVAS = "rePositionCanvas", _n))(ChartLayoutStoreEnum || {});
const canvasVersionUpdatePolyfill = (_n) => _n, componentVersionUpdatePolyfill = (_n, nr) => {
  try {
    if (nr.id) {
      const Cn = "vnodeBeforeMount" in nr.events, Bn = "vnodeMounted" in nr.events;
      return Cn && (_n.events.advancedEvents.vnodeBeforeMount = nr == null ? void 0 : nr.events.vnodeBeforeMount), Bn && (_n.events.advancedEvents.vnodeMounted = nr == null ? void 0 : nr.events.vnodeMounted), (Cn || Bn) && (nr.events = {
        baseEvent: {
          [BaseEvent.ON_CLICK]: void 0,
          [BaseEvent.ON_DBL_CLICK]: void 0,
          [BaseEvent.ON_MOUSE_ENTER]: void 0,
          [BaseEvent.ON_MOUSE_LEAVE]: void 0
        },
        advancedEvents: {
          [EventLife.VNODE_MOUNTED]: void 0,
          [EventLife.VNODE_BEFORE_MOUNT]: void 0
        },
        interactEvents: []
      }), _n;
    }
  } catch {
    return _n;
  }
}, componentMerge = (_n, nr, Cn = !1) => {
  if (componentVersionUpdatePolyfill(_n, nr), Cn)
    return merge$3(_n, nr);
  const Bn = nr.option;
  if (!Bn)
    return merge$3(_n, nr);
  if (nr.option = void 0, Bn)
    return {
      ...merge$3(_n, nr),
      option: Bn
    };
}, useSync = () => {
  const _n = useChartEditStore(), nr = useHistoryStore(), Cn = useLayoutStore(), Bn = (Dn) => {
    let Ln = [];
    return Dn.map(($n, Nn) => {
      Ln.findIndex((Rn) => Rn.id === $n.id) === -1 && Ln.push($n);
    }), Ln;
  };
  return {
    updateComponent: async (Dn, Ln = !1, $n = !1) => {
      Ln && (_n.componentList = [], nr.clearBackStack(), nr.clearForwardStack()), Dn.editCanvasConfig = canvasVersionUpdatePolyfill(Dn.editCanvasConfig), Dn.componentList = Bn(Dn.componentList);
      const Nn = [];
      Dn.componentList.forEach(async (Fn) => {
        const Pn = async (Un) => {
          Nn.indexOf(Un.id) === -1 && (Nn.push(Un.id), componentInstall(Un.chartConfig.chartKey, await fetchChartComponent(Un.chartConfig)), componentInstall(Un.chartConfig.conKey, await fetchConfigComponent(Un.chartConfig)));
        };
        Fn.isTemplate ? (Fn.groupList.forEach((Un) => {
          Pn(Un);
        }), Pn(Fn)) : Fn.isGroup ? Fn.groupList.forEach((Un) => {
          Pn(Un);
        }) : (Fn.key === "Page" && Fn.componentList && Fn.componentList.forEach(async (Un) => {
          Un.isGroup ? Un.groupList.forEach((Hn) => {
            Pn(Hn);
          }) : Pn(Un);
        }), Pn(Fn));
      });
      const Rn = async (Fn, Pn) => {
        let Un = await createComponent(Fn.chartConfig);
        Un && (Pn ? Pn($n ? componentMerge(Un, { ...Fn, id: getUUID$1() }) : componentMerge(Un, Fn)) : $n ? _n.addComponentList(
          componentMerge(Un, { ...Fn, id: getUUID$1() }),
          !1,
          !0
        ) : _n.addComponentList(componentMerge(Un, Fn), !1, !0));
      };
      for (const Fn in Dn)
        if (Fn === ChartEditStoreEnum.COMPONENT_LIST) {
          let Pn = 0;
          const Un = Dn[Fn].length;
          for (const Hn of Dn[Fn]) {
            let zn = parseInt((parseFloat(`${++Pn / Un}`) * 100).toString());
            if (Cn.setItemUnHandle(ChartLayoutStoreEnum.PERCENTAGE, zn), Hn.key === "Page")
              await Rn(Hn);
            else if (Hn.isGroup || Hn.isTemplate) {
              let Gn = new PublicGroupConfigClass();
              $n ? Gn = componentMerge(Gn, { ...Hn, id: getUUID$1() }) : Gn = componentMerge(Gn, Hn);
              const Yn = [];
              for (const Wn of Hn.groupList)
                await Rn(Wn, (Xn) => {
                  Yn.push(Xn);
                });
              Gn.groupList = Yn, _n.addComponentList(Gn, !1, !0);
            } else
              await Rn(Hn);
          }
        } else {
          if (Fn !== "editCanvasConfig" && Fn !== "requestGlobalConfig" && Fn !== "globalEvent")
            return;
          componentMerge(_n[Fn], Dn[Fn], !0);
        }
      Cn.setItemUnHandle(ChartLayoutStoreEnum.PERCENTAGE, 0);
    }
  };
}, _hoisted_1$3 = ["element-loading-text"], _hoisted_2$2 = { class: "main" }, _hoisted_3 = { class: "main-middle" }, _hoisted_4 = {
  key: 0,
  class: "resource-lib-dialog"
}, _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    widgets: {
      type: Array,
      default: []
    }
  },
  setup(_n) {
    const nr = ref(!1), { updateComponent: Cn } = useSync();
    let Bn = null;
    nr.value && (Bn = defineAsyncComponent(() => import("./PageListPanel-8eb210a3.js")));
    const In = defineAsyncComponent({
      loader: () => import("./index-f4484628.js"),
      loadingComponent: AsyncLoading,
      delay: 20
    }), Dn = _n, Ln = useLayoutStore(), $n = useChartEditStore(), { getSidebar: Nn, getConfig: Rn, getResource: Fn } = toRefs(Ln), Pn = reactive({
      loadRes: !1,
      firstLoad: !0
    });
    watch(() => Fn.value, () => {
      Fn.value && (Pn.loadRes = !0);
    });
    const Un = useRoute();
    let Hn = 0;
    isString(Un.query.appId) ? Hn = parseInt(Un.query.appId) : isArray$3(Un.query.appId) && (Hn = parseInt(Un.query.appId[0]));
    const zn = ref(!0), Gn = ref("页面数据加载中..."), Yn = reactive({ name: "" }), Wn = reactive({
      appId: Hn,
      groupId: Hn,
      screenId: 0,
      loginPageId: 0,
      name: "",
      list: []
    });
    provide("screenId", Wn.screenId), provide("widgets", Dn.widgets), provide("pageData", Wn), provide("changeScreenId", Xn), provide("changeGroupId", ea), provide(SCALE_KEY, null);
    function Xn(ra) {
      Wn.screenId = ra, na();
    }
    function ea(ra) {
      Wn.groupId = ra;
    }
    const ta = () => {
      getScreenList({ appId: Wn.appId }).then((ra) => {
        const { code: aa, data: ia } = ra;
        if (zn.value = !1, aa === 200) {
          if (!Wn.screenId && ia && ia.length > 0) {
            for (let Aa = 0; Aa < ia.length; Aa++)
              if (ia[Aa].version !== void 0) {
                Wn.screenId = ia[Aa].id;
                break;
              } else if (ia[Aa].data && ia[Aa].data.length > 0) {
                Wn.screenId = ia[Aa].data[0].id;
                break;
              }
          }
          Wn.list = ia, Wn.list.length === 0 && (Wn.name = "未命名", Wn.screenId = 0), Gn.value = "页面数据加载中...", Pn.firstLoad && (Pn.firstLoad = !1, na());
        }
      }).catch(() => {
        zn.value = !1;
      });
    };
    if (nr.value)
      ta();
    else {
      zn.value = !0, Wn.name = "未命名", $n.editCanvasConfig.projectName = Wn.name;
      let ra = getLocalStorage("localData");
      ra ? (Wn.name = ra.name, Wn.loginPageId = ra.editCanvasConfig.loginPageId, typeof ra == "object" ? setTimeout(async () => {
        await Cn(ra, !0, !1), zn.value = !1;
      }, 300) : zn.value = !1) : zn.value = !1;
    }
    provide("getPageList", ta);
    const na = () => {
      if (!Wn.screenId)
        return $n.editCanvasConfig.projectName = Wn.name, !1;
      zn.value = !0, getScreenInfo$1(Wn.screenId).then(async (ra) => {
        Gn.value = "页面组件加载中...";
        const { code: aa, data: ia } = ra;
        if (aa === 200 && ia && ia.content) {
          Wn.name = ia.name;
          const Aa = JSONParse(ia.content);
          Wn.loginPageId = Aa.editCanvasConfig.loginPageId, typeof Aa == "object" && (Aa.editCanvasConfig.appId = ia.appId, Aa.editCanvasConfig.groupId = ia.groupId, Aa.editCanvasConfig.nodeId = ia.nodeId, Aa.editCanvasConfig.id = ia.id, Aa.editCanvasConfig.projectName = ia.name, Aa.editCanvasConfig.needLogin = ia.needLogin, Aa.editCanvasConfig.projectSummary = ia.remark, Aa.editCanvasConfig.width = ia.width, Aa.editCanvasConfig.height = ia.height, await Cn(Aa, !0, !1), zn.value = !1);
        } else
          ia && (Wn.name = ia.name, $n.editCanvasConfig.appId = ia.appId, $n.editCanvasConfig.groupId = ia.groupId, $n.editCanvasConfig.nodeId = ia.nodeId, $n.editCanvasConfig.id = ia.id, $n.editCanvasConfig.projectName = ia.name, $n.editCanvasConfig.needLogin = ia.needLogin, $n.editCanvasConfig.projectSummary = ia.remark, $n.editCanvasConfig.width = ia.width || 1920, $n.editCanvasConfig.height = ia.height || 1080, ia.content || ($n.componentList = [])), zn.value = !1;
      }).catch(() => {
        zn.value = !1;
      });
    };
    return (ra, aa) => {
      const ia = resolveDirective("loading");
      return withDirectives((openBlock(), createElementBlock("div", {
        class: "designer-page",
        "element-loading-text": Gn.value,
        "element-loading-background": "rgba(0, 0, 0, 0.2)"
      }, [
        createVNode$1(unref(Header), { data: Yn }, null, 8, ["data"]),
        createElementVNode("div", _hoisted_2$2, [
          createVNode$1(unref(Sidebar), {
            class: normalizeClass({ scoped: !unref(Nn) })
          }, null, 8, ["class"]),
          createElementVNode("div", _hoisted_3, [
            createVNode$1(unref(CanvasEdit))
          ]),
          createElementVNode("div", {
            class: normalizeClass(["config", { hide: !unref(Rn) }])
          }, [
            nr.value ? (openBlock(), createBlock(unref(Bn), { key: 0 })) : createCommentVNode("", !0),
            createVNode$1(unref(Configuration)),
            createVNode$1(unref(FilterPanel))
          ], 2),
          nr.value && Pn.loadRes ? withDirectives((openBlock(), createElementBlock("div", _hoisted_4, [
            createVNode$1(unref(In))
          ], 512)), [
            [vShow, unref(Fn)]
          ]) : createCommentVNode("", !0)
        ])
      ], 8, _hoisted_1$3)), [
        [ia, zn.value]
      ]);
    };
  }
}), index_scss_vue_type_style_index_0_src_d0519ddf_scoped_d0519ddf_lang = "", index = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-d0519ddf"]]), index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: index
}, Symbol.toStringTag, { value: "Module" })), getComponentAttrStyle = (_n, nr) => {
  const Cn = {
    zIndex: `${_n.zIndex <= -1 ? nr + 1 : _n.zIndex}`,
    left: `${_n.x}px`,
    top: `${_n.y}px`,
    width: `${_n.w}px`,
    height: `${_n.h}px`
  };
  return _n.overflow && (Cn.overflow = _n.overflow), _n.openScroll && (Cn.overflow = "auto"), _n.style && (_n.style.borderWidth && (Cn.borderWidth = _n.style.borderWidth[0] + "px " + _n.style.borderWidth[1] + "px " + _n.style.borderWidth[2] + "px " + _n.style.borderWidth[3] + "px"), _n.style.borderStyle && (Cn.borderStyle = _n.style.borderStyle), _n.style.borderColor && (Cn.borderColor = _n.style.borderColor), _n.style.borderRadius && (Cn.borderRadius = _n.style.borderRadius[0] + "px " + _n.style.borderRadius[1] + "px " + _n.style.borderRadius[2] + "px " + _n.style.borderRadius[3] + "px"), _n.style.backgroundColor && (Cn.backgroundColor = _n.style.backgroundColor), _n.style.backgroundImage && (Cn.backgroundImage = "url(" + _n.style.backgroundImage + ")"), _n.style.fit && (Cn.backgroundSize = _n.style.fit), _n.style.boxShadow && (Cn.boxShadow = _n.style.boxShadow ? (_n.style.boxShadow[0] || 0) + "px " + (_n.style.boxShadow[1] || 0) + "px " + (_n.style.boxShadow[2] || 0) + "px " + (_n.style.boxShadow[3] || 0) + "px " + _n.style.boxShadow[4] + (_n.style.boxShadow[5] === "inset" ? _n.style.boxShadow[5] : "") : "")), Cn;
}, getSizeStyle = (_n) => ({
  width: `${_n.w}px`,
  height: `${_n.h}px`
}), getStatusStyle = (_n, nr) => nr && (nr.key === "FormContainer" || nr.key === "ChartContainer") ? {
  display: "none"
} : {
  display: _n.hide ? "none" : "block"
}, getPreviewConfigStyle = (_n) => {
  const nr = {};
  return _n && _n.overFlowHidden && (nr.overflow = "hidden"), nr;
}, getEditCanvasConfigStyle = (_n) => ({
  position: "relative",
  width: _n.width ? `${_n.width || 100}px` : "100%",
  height: _n.height ? `${_n.height}px` : "100%"
});
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
function int2char(_n) {
  return BI_RM.charAt(_n);
}
function op_and(_n, nr) {
  return _n & nr;
}
function op_or(_n, nr) {
  return _n | nr;
}
function op_xor(_n, nr) {
  return _n ^ nr;
}
function op_andnot(_n, nr) {
  return _n & ~nr;
}
function lbit(_n) {
  if (_n == 0)
    return -1;
  var nr = 0;
  return _n & 65535 || (_n >>= 16, nr += 16), _n & 255 || (_n >>= 8, nr += 8), _n & 15 || (_n >>= 4, nr += 4), _n & 3 || (_n >>= 2, nr += 2), _n & 1 || ++nr, nr;
}
function cbit(_n) {
  for (var nr = 0; _n != 0; )
    _n &= _n - 1, ++nr;
  return nr;
}
var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", b64pad = "=";
function hex2b64(_n) {
  var nr, Cn, Bn = "";
  for (nr = 0; nr + 3 <= _n.length; nr += 3)
    Cn = parseInt(_n.substring(nr, nr + 3), 16), Bn += b64map.charAt(Cn >> 6) + b64map.charAt(Cn & 63);
  for (nr + 1 == _n.length ? (Cn = parseInt(_n.substring(nr, nr + 1), 16), Bn += b64map.charAt(Cn << 2)) : nr + 2 == _n.length && (Cn = parseInt(_n.substring(nr, nr + 2), 16), Bn += b64map.charAt(Cn >> 2) + b64map.charAt((Cn & 3) << 4)); (Bn.length & 3) > 0; )
    Bn += b64pad;
  return Bn;
}
function b64tohex(_n) {
  var nr = "", Cn, Bn = 0, In = 0;
  for (Cn = 0; Cn < _n.length && _n.charAt(Cn) != b64pad; ++Cn) {
    var Dn = b64map.indexOf(_n.charAt(Cn));
    Dn < 0 || (Bn == 0 ? (nr += int2char(Dn >> 2), In = Dn & 3, Bn = 1) : Bn == 1 ? (nr += int2char(In << 2 | Dn >> 4), In = Dn & 15, Bn = 2) : Bn == 2 ? (nr += int2char(In), nr += int2char(Dn >> 2), In = Dn & 3, Bn = 3) : (nr += int2char(In << 2 | Dn >> 4), nr += int2char(Dn & 15), Bn = 0));
  }
  return Bn == 1 && (nr += int2char(In << 2)), nr;
}
var decoder$1, Hex = {
  decode: function(_n) {
    var nr;
    if (decoder$1 === void 0) {
      var Cn = "0123456789ABCDEF", Bn = ` \f
\r	 \u2028\u2029`;
      for (decoder$1 = {}, nr = 0; nr < 16; ++nr)
        decoder$1[Cn.charAt(nr)] = nr;
      for (Cn = Cn.toLowerCase(), nr = 10; nr < 16; ++nr)
        decoder$1[Cn.charAt(nr)] = nr;
      for (nr = 0; nr < Bn.length; ++nr)
        decoder$1[Bn.charAt(nr)] = -1;
    }
    var In = [], Dn = 0, Ln = 0;
    for (nr = 0; nr < _n.length; ++nr) {
      var $n = _n.charAt(nr);
      if ($n == "=")
        break;
      if ($n = decoder$1[$n], $n != -1) {
        if ($n === void 0)
          throw new Error("Illegal character at offset " + nr);
        Dn |= $n, ++Ln >= 2 ? (In[In.length] = Dn, Dn = 0, Ln = 0) : Dn <<= 4;
      }
    }
    if (Ln)
      throw new Error("Hex encoding incomplete: 4 bits missing");
    return In;
  }
}, decoder, Base64 = {
  decode: function(_n) {
    var nr;
    if (decoder === void 0) {
      var Cn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Bn = `= \f
\r	 \u2028\u2029`;
      for (decoder = /* @__PURE__ */ Object.create(null), nr = 0; nr < 64; ++nr)
        decoder[Cn.charAt(nr)] = nr;
      for (decoder["-"] = 62, decoder._ = 63, nr = 0; nr < Bn.length; ++nr)
        decoder[Bn.charAt(nr)] = -1;
    }
    var In = [], Dn = 0, Ln = 0;
    for (nr = 0; nr < _n.length; ++nr) {
      var $n = _n.charAt(nr);
      if ($n == "=")
        break;
      if ($n = decoder[$n], $n != -1) {
        if ($n === void 0)
          throw new Error("Illegal character at offset " + nr);
        Dn |= $n, ++Ln >= 4 ? (In[In.length] = Dn >> 16, In[In.length] = Dn >> 8 & 255, In[In.length] = Dn & 255, Dn = 0, Ln = 0) : Dn <<= 6;
      }
    }
    switch (Ln) {
      case 1:
        throw new Error("Base64 encoding incomplete: at least 2 bits missing");
      case 2:
        In[In.length] = Dn >> 10;
        break;
      case 3:
        In[In.length] = Dn >> 16, In[In.length] = Dn >> 8 & 255;
        break;
    }
    return In;
  },
  re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
  unarmor: function(_n) {
    var nr = Base64.re.exec(_n);
    if (nr)
      if (nr[1])
        _n = nr[1];
      else if (nr[2])
        _n = nr[2];
      else
        throw new Error("RegExp out of sync");
    return Base64.decode(_n);
  }
}, max = 1e13, Int10 = (
  /** @class */
  function() {
    function _n(nr) {
      this.buf = [+nr || 0];
    }
    return _n.prototype.mulAdd = function(nr, Cn) {
      var Bn = this.buf, In = Bn.length, Dn, Ln;
      for (Dn = 0; Dn < In; ++Dn)
        Ln = Bn[Dn] * nr + Cn, Ln < max ? Cn = 0 : (Cn = 0 | Ln / max, Ln -= Cn * max), Bn[Dn] = Ln;
      Cn > 0 && (Bn[Dn] = Cn);
    }, _n.prototype.sub = function(nr) {
      var Cn = this.buf, Bn = Cn.length, In, Dn;
      for (In = 0; In < Bn; ++In)
        Dn = Cn[In] - nr, Dn < 0 ? (Dn += max, nr = 1) : nr = 0, Cn[In] = Dn;
      for (; Cn[Cn.length - 1] === 0; )
        Cn.pop();
    }, _n.prototype.toString = function(nr) {
      if ((nr || 10) != 10)
        throw new Error("only base 10 is supported");
      for (var Cn = this.buf, Bn = Cn[Cn.length - 1].toString(), In = Cn.length - 2; In >= 0; --In)
        Bn += (max + Cn[In]).toString().substring(1);
      return Bn;
    }, _n.prototype.valueOf = function() {
      for (var nr = this.buf, Cn = 0, Bn = nr.length - 1; Bn >= 0; --Bn)
        Cn = Cn * max + nr[Bn];
      return Cn;
    }, _n.prototype.simplify = function() {
      var nr = this.buf;
      return nr.length == 1 ? nr[0] : this;
    }, _n;
  }()
), ellipsis = "…", reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/, reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
function stringCut(_n, nr) {
  return _n.length > nr && (_n = _n.substring(0, nr) + ellipsis), _n;
}
var Stream = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.hexDigits = "0123456789ABCDEF", nr instanceof _n ? (this.enc = nr.enc, this.pos = nr.pos) : (this.enc = nr, this.pos = Cn);
    }
    return _n.prototype.get = function(nr) {
      if (nr === void 0 && (nr = this.pos++), nr >= this.enc.length)
        throw new Error("Requesting byte offset ".concat(nr, " on a stream of length ").concat(this.enc.length));
      return typeof this.enc == "string" ? this.enc.charCodeAt(nr) : this.enc[nr];
    }, _n.prototype.hexByte = function(nr) {
      return this.hexDigits.charAt(nr >> 4 & 15) + this.hexDigits.charAt(nr & 15);
    }, _n.prototype.hexDump = function(nr, Cn, Bn) {
      for (var In = "", Dn = nr; Dn < Cn; ++Dn)
        if (In += this.hexByte(this.get(Dn)), Bn !== !0)
          switch (Dn & 15) {
            case 7:
              In += "  ";
              break;
            case 15:
              In += `
`;
              break;
            default:
              In += " ";
          }
      return In;
    }, _n.prototype.isASCII = function(nr, Cn) {
      for (var Bn = nr; Bn < Cn; ++Bn) {
        var In = this.get(Bn);
        if (In < 32 || In > 176)
          return !1;
      }
      return !0;
    }, _n.prototype.parseStringISO = function(nr, Cn) {
      for (var Bn = "", In = nr; In < Cn; ++In)
        Bn += String.fromCharCode(this.get(In));
      return Bn;
    }, _n.prototype.parseStringUTF = function(nr, Cn) {
      for (var Bn = "", In = nr; In < Cn; ) {
        var Dn = this.get(In++);
        Dn < 128 ? Bn += String.fromCharCode(Dn) : Dn > 191 && Dn < 224 ? Bn += String.fromCharCode((Dn & 31) << 6 | this.get(In++) & 63) : Bn += String.fromCharCode((Dn & 15) << 12 | (this.get(In++) & 63) << 6 | this.get(In++) & 63);
      }
      return Bn;
    }, _n.prototype.parseStringBMP = function(nr, Cn) {
      for (var Bn = "", In, Dn, Ln = nr; Ln < Cn; )
        In = this.get(Ln++), Dn = this.get(Ln++), Bn += String.fromCharCode(In << 8 | Dn);
      return Bn;
    }, _n.prototype.parseTime = function(nr, Cn, Bn) {
      var In = this.parseStringISO(nr, Cn), Dn = (Bn ? reTimeS : reTimeL).exec(In);
      return Dn ? (Bn && (Dn[1] = +Dn[1], Dn[1] += +Dn[1] < 70 ? 2e3 : 1900), In = Dn[1] + "-" + Dn[2] + "-" + Dn[3] + " " + Dn[4], Dn[5] && (In += ":" + Dn[5], Dn[6] && (In += ":" + Dn[6], Dn[7] && (In += "." + Dn[7]))), Dn[8] && (In += " UTC", Dn[8] != "Z" && (In += Dn[8], Dn[9] && (In += ":" + Dn[9]))), In) : "Unrecognized time: " + In;
    }, _n.prototype.parseInteger = function(nr, Cn) {
      for (var Bn = this.get(nr), In = Bn > 127, Dn = In ? 255 : 0, Ln, $n = ""; Bn == Dn && ++nr < Cn; )
        Bn = this.get(nr);
      if (Ln = Cn - nr, Ln === 0)
        return In ? -1 : 0;
      if (Ln > 4) {
        for ($n = Bn, Ln <<= 3; !((+$n ^ Dn) & 128); )
          $n = +$n << 1, --Ln;
        $n = "(" + Ln + ` bit)
`;
      }
      In && (Bn = Bn - 256);
      for (var Nn = new Int10(Bn), Rn = nr + 1; Rn < Cn; ++Rn)
        Nn.mulAdd(256, this.get(Rn));
      return $n + Nn.toString();
    }, _n.prototype.parseBitString = function(nr, Cn, Bn) {
      for (var In = this.get(nr), Dn = (Cn - nr - 1 << 3) - In, Ln = "(" + Dn + ` bit)
`, $n = "", Nn = nr + 1; Nn < Cn; ++Nn) {
        for (var Rn = this.get(Nn), Fn = Nn == Cn - 1 ? In : 0, Pn = 7; Pn >= Fn; --Pn)
          $n += Rn >> Pn & 1 ? "1" : "0";
        if ($n.length > Bn)
          return Ln + stringCut($n, Bn);
      }
      return Ln + $n;
    }, _n.prototype.parseOctetString = function(nr, Cn, Bn) {
      if (this.isASCII(nr, Cn))
        return stringCut(this.parseStringISO(nr, Cn), Bn);
      var In = Cn - nr, Dn = "(" + In + ` byte)
`;
      Bn /= 2, In > Bn && (Cn = nr + Bn);
      for (var Ln = nr; Ln < Cn; ++Ln)
        Dn += this.hexByte(this.get(Ln));
      return In > Bn && (Dn += ellipsis), Dn;
    }, _n.prototype.parseOID = function(nr, Cn, Bn) {
      for (var In = "", Dn = new Int10(), Ln = 0, $n = nr; $n < Cn; ++$n) {
        var Nn = this.get($n);
        if (Dn.mulAdd(128, Nn & 127), Ln += 7, !(Nn & 128)) {
          if (In === "")
            if (Dn = Dn.simplify(), Dn instanceof Int10)
              Dn.sub(80), In = "2." + Dn.toString();
            else {
              var Rn = Dn < 80 ? Dn < 40 ? 0 : 1 : 2;
              In = Rn + "." + (Dn - Rn * 40);
            }
          else
            In += "." + Dn.toString();
          if (In.length > Bn)
            return stringCut(In, Bn);
          Dn = new Int10(), Ln = 0;
        }
      }
      return Ln > 0 && (In += ".incomplete"), In;
    }, _n;
  }()
), ASN1 = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn, In, Dn) {
      if (!(In instanceof ASN1Tag))
        throw new Error("Invalid tag value.");
      this.stream = nr, this.header = Cn, this.length = Bn, this.tag = In, this.sub = Dn;
    }
    return _n.prototype.typeName = function() {
      switch (this.tag.tagClass) {
        case 0:
          switch (this.tag.tagNumber) {
            case 0:
              return "EOC";
            case 1:
              return "BOOLEAN";
            case 2:
              return "INTEGER";
            case 3:
              return "BIT_STRING";
            case 4:
              return "OCTET_STRING";
            case 5:
              return "NULL";
            case 6:
              return "OBJECT_IDENTIFIER";
            case 7:
              return "ObjectDescriptor";
            case 8:
              return "EXTERNAL";
            case 9:
              return "REAL";
            case 10:
              return "ENUMERATED";
            case 11:
              return "EMBEDDED_PDV";
            case 12:
              return "UTF8String";
            case 16:
              return "SEQUENCE";
            case 17:
              return "SET";
            case 18:
              return "NumericString";
            case 19:
              return "PrintableString";
            case 20:
              return "TeletexString";
            case 21:
              return "VideotexString";
            case 22:
              return "IA5String";
            case 23:
              return "UTCTime";
            case 24:
              return "GeneralizedTime";
            case 25:
              return "GraphicString";
            case 26:
              return "VisibleString";
            case 27:
              return "GeneralString";
            case 28:
              return "UniversalString";
            case 30:
              return "BMPString";
          }
          return "Universal_" + this.tag.tagNumber.toString();
        case 1:
          return "Application_" + this.tag.tagNumber.toString();
        case 2:
          return "[" + this.tag.tagNumber.toString() + "]";
        case 3:
          return "Private_" + this.tag.tagNumber.toString();
      }
    }, _n.prototype.content = function(nr) {
      if (this.tag === void 0)
        return null;
      nr === void 0 && (nr = 1 / 0);
      var Cn = this.posContent(), Bn = Math.abs(this.length);
      if (!this.tag.isUniversal())
        return this.sub !== null ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(Cn, Cn + Bn, nr);
      switch (this.tag.tagNumber) {
        case 1:
          return this.stream.get(Cn) === 0 ? "false" : "true";
        case 2:
          return this.stream.parseInteger(Cn, Cn + Bn);
        case 3:
          return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseBitString(Cn, Cn + Bn, nr);
        case 4:
          return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(Cn, Cn + Bn, nr);
        case 6:
          return this.stream.parseOID(Cn, Cn + Bn, nr);
        case 16:
        case 17:
          return this.sub !== null ? "(" + this.sub.length + " elem)" : "(no elem)";
        case 12:
          return stringCut(this.stream.parseStringUTF(Cn, Cn + Bn), nr);
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 26:
          return stringCut(this.stream.parseStringISO(Cn, Cn + Bn), nr);
        case 30:
          return stringCut(this.stream.parseStringBMP(Cn, Cn + Bn), nr);
        case 23:
        case 24:
          return this.stream.parseTime(Cn, Cn + Bn, this.tag.tagNumber == 23);
      }
      return null;
    }, _n.prototype.toString = function() {
      return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + (this.sub === null ? "null" : this.sub.length) + "]";
    }, _n.prototype.toPrettyString = function(nr) {
      nr === void 0 && (nr = "");
      var Cn = nr + this.typeName() + " @" + this.stream.pos;
      if (this.length >= 0 && (Cn += "+"), Cn += this.length, this.tag.tagConstructed ? Cn += " (constructed)" : this.tag.isUniversal() && (this.tag.tagNumber == 3 || this.tag.tagNumber == 4) && this.sub !== null && (Cn += " (encapsulates)"), Cn += `
`, this.sub !== null) {
        nr += "  ";
        for (var Bn = 0, In = this.sub.length; Bn < In; ++Bn)
          Cn += this.sub[Bn].toPrettyString(nr);
      }
      return Cn;
    }, _n.prototype.posStart = function() {
      return this.stream.pos;
    }, _n.prototype.posContent = function() {
      return this.stream.pos + this.header;
    }, _n.prototype.posEnd = function() {
      return this.stream.pos + this.header + Math.abs(this.length);
    }, _n.prototype.toHexString = function() {
      return this.stream.hexDump(this.posStart(), this.posEnd(), !0);
    }, _n.decodeLength = function(nr) {
      var Cn = nr.get(), Bn = Cn & 127;
      if (Bn == Cn)
        return Bn;
      if (Bn > 6)
        throw new Error("Length over 48 bits not supported at position " + (nr.pos - 1));
      if (Bn === 0)
        return null;
      Cn = 0;
      for (var In = 0; In < Bn; ++In)
        Cn = Cn * 256 + nr.get();
      return Cn;
    }, _n.prototype.getHexStringValue = function() {
      var nr = this.toHexString(), Cn = this.header * 2, Bn = this.length * 2;
      return nr.substr(Cn, Bn);
    }, _n.decode = function(nr) {
      var Cn;
      nr instanceof Stream ? Cn = nr : Cn = new Stream(nr, 0);
      var Bn = new Stream(Cn), In = new ASN1Tag(Cn), Dn = _n.decodeLength(Cn), Ln = Cn.pos, $n = Ln - Bn.pos, Nn = null, Rn = function() {
        var Pn = [];
        if (Dn !== null) {
          for (var Un = Ln + Dn; Cn.pos < Un; )
            Pn[Pn.length] = _n.decode(Cn);
          if (Cn.pos != Un)
            throw new Error("Content size is not correct for container starting at offset " + Ln);
        } else
          try {
            for (; ; ) {
              var Hn = _n.decode(Cn);
              if (Hn.tag.isEOC())
                break;
              Pn[Pn.length] = Hn;
            }
            Dn = Ln - Cn.pos;
          } catch (zn) {
            throw new Error("Exception while decoding undefined length content: " + zn);
          }
        return Pn;
      };
      if (In.tagConstructed)
        Nn = Rn();
      else if (In.isUniversal() && (In.tagNumber == 3 || In.tagNumber == 4))
        try {
          if (In.tagNumber == 3 && Cn.get() != 0)
            throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
          Nn = Rn();
          for (var Fn = 0; Fn < Nn.length; ++Fn)
            if (Nn[Fn].tag.isEOC())
              throw new Error("EOC is not supposed to be actual content.");
        } catch {
          Nn = null;
        }
      if (Nn === null) {
        if (Dn === null)
          throw new Error("We can't skip over an invalid tag with undefined length at offset " + Ln);
        Cn.pos = Ln + Math.abs(Dn);
      }
      return new _n(Bn, $n, Dn, In, Nn);
    }, _n;
  }()
), ASN1Tag = (
  /** @class */
  function() {
    function _n(nr) {
      var Cn = nr.get();
      if (this.tagClass = Cn >> 6, this.tagConstructed = (Cn & 32) !== 0, this.tagNumber = Cn & 31, this.tagNumber == 31) {
        var Bn = new Int10();
        do
          Cn = nr.get(), Bn.mulAdd(128, Cn & 127);
        while (Cn & 128);
        this.tagNumber = Bn.simplify();
      }
    }
    return _n.prototype.isUniversal = function() {
      return this.tagClass === 0;
    }, _n.prototype.isEOC = function() {
      return this.tagClass === 0 && this.tagNumber === 0;
    }, _n;
  }()
), dbits, canary = 244837814094590, j_lm = (canary & 16777215) == 15715070, lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], lplim = (1 << 26) / lowprimes[lowprimes.length - 1], BigInteger = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      nr != null && (typeof nr == "number" ? this.fromNumber(nr, Cn, Bn) : Cn == null && typeof nr != "string" ? this.fromString(nr, 256) : this.fromString(nr, Cn));
    }
    return _n.prototype.toString = function(nr) {
      if (this.s < 0)
        return "-" + this.negate().toString(nr);
      var Cn;
      if (nr == 16)
        Cn = 4;
      else if (nr == 8)
        Cn = 3;
      else if (nr == 2)
        Cn = 1;
      else if (nr == 32)
        Cn = 5;
      else if (nr == 4)
        Cn = 2;
      else
        return this.toRadix(nr);
      var Bn = (1 << Cn) - 1, In, Dn = !1, Ln = "", $n = this.t, Nn = this.DB - $n * this.DB % Cn;
      if ($n-- > 0)
        for (Nn < this.DB && (In = this[$n] >> Nn) > 0 && (Dn = !0, Ln = int2char(In)); $n >= 0; )
          Nn < Cn ? (In = (this[$n] & (1 << Nn) - 1) << Cn - Nn, In |= this[--$n] >> (Nn += this.DB - Cn)) : (In = this[$n] >> (Nn -= Cn) & Bn, Nn <= 0 && (Nn += this.DB, --$n)), In > 0 && (Dn = !0), Dn && (Ln += int2char(In));
      return Dn ? Ln : "0";
    }, _n.prototype.negate = function() {
      var nr = nbi();
      return _n.ZERO.subTo(this, nr), nr;
    }, _n.prototype.abs = function() {
      return this.s < 0 ? this.negate() : this;
    }, _n.prototype.compareTo = function(nr) {
      var Cn = this.s - nr.s;
      if (Cn != 0)
        return Cn;
      var Bn = this.t;
      if (Cn = Bn - nr.t, Cn != 0)
        return this.s < 0 ? -Cn : Cn;
      for (; --Bn >= 0; )
        if ((Cn = this[Bn] - nr[Bn]) != 0)
          return Cn;
      return 0;
    }, _n.prototype.bitLength = function() {
      return this.t <= 0 ? 0 : this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }, _n.prototype.mod = function(nr) {
      var Cn = nbi();
      return this.abs().divRemTo(nr, null, Cn), this.s < 0 && Cn.compareTo(_n.ZERO) > 0 && nr.subTo(Cn, Cn), Cn;
    }, _n.prototype.modPowInt = function(nr, Cn) {
      var Bn;
      return nr < 256 || Cn.isEven() ? Bn = new Classic(Cn) : Bn = new Montgomery(Cn), this.exp(nr, Bn);
    }, _n.prototype.clone = function() {
      var nr = nbi();
      return this.copyTo(nr), nr;
    }, _n.prototype.intValue = function() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        if (this.t == 0)
          return -1;
      } else {
        if (this.t == 1)
          return this[0];
        if (this.t == 0)
          return 0;
      }
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }, _n.prototype.byteValue = function() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }, _n.prototype.shortValue = function() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }, _n.prototype.signum = function() {
      return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1;
    }, _n.prototype.toByteArray = function() {
      var nr = this.t, Cn = [];
      Cn[0] = this.s;
      var Bn = this.DB - nr * this.DB % 8, In, Dn = 0;
      if (nr-- > 0)
        for (Bn < this.DB && (In = this[nr] >> Bn) != (this.s & this.DM) >> Bn && (Cn[Dn++] = In | this.s << this.DB - Bn); nr >= 0; )
          Bn < 8 ? (In = (this[nr] & (1 << Bn) - 1) << 8 - Bn, In |= this[--nr] >> (Bn += this.DB - 8)) : (In = this[nr] >> (Bn -= 8) & 255, Bn <= 0 && (Bn += this.DB, --nr)), In & 128 && (In |= -256), Dn == 0 && (this.s & 128) != (In & 128) && ++Dn, (Dn > 0 || In != this.s) && (Cn[Dn++] = In);
      return Cn;
    }, _n.prototype.equals = function(nr) {
      return this.compareTo(nr) == 0;
    }, _n.prototype.min = function(nr) {
      return this.compareTo(nr) < 0 ? this : nr;
    }, _n.prototype.max = function(nr) {
      return this.compareTo(nr) > 0 ? this : nr;
    }, _n.prototype.and = function(nr) {
      var Cn = nbi();
      return this.bitwiseTo(nr, op_and, Cn), Cn;
    }, _n.prototype.or = function(nr) {
      var Cn = nbi();
      return this.bitwiseTo(nr, op_or, Cn), Cn;
    }, _n.prototype.xor = function(nr) {
      var Cn = nbi();
      return this.bitwiseTo(nr, op_xor, Cn), Cn;
    }, _n.prototype.andNot = function(nr) {
      var Cn = nbi();
      return this.bitwiseTo(nr, op_andnot, Cn), Cn;
    }, _n.prototype.not = function() {
      for (var nr = nbi(), Cn = 0; Cn < this.t; ++Cn)
        nr[Cn] = this.DM & ~this[Cn];
      return nr.t = this.t, nr.s = ~this.s, nr;
    }, _n.prototype.shiftLeft = function(nr) {
      var Cn = nbi();
      return nr < 0 ? this.rShiftTo(-nr, Cn) : this.lShiftTo(nr, Cn), Cn;
    }, _n.prototype.shiftRight = function(nr) {
      var Cn = nbi();
      return nr < 0 ? this.lShiftTo(-nr, Cn) : this.rShiftTo(nr, Cn), Cn;
    }, _n.prototype.getLowestSetBit = function() {
      for (var nr = 0; nr < this.t; ++nr)
        if (this[nr] != 0)
          return nr * this.DB + lbit(this[nr]);
      return this.s < 0 ? this.t * this.DB : -1;
    }, _n.prototype.bitCount = function() {
      for (var nr = 0, Cn = this.s & this.DM, Bn = 0; Bn < this.t; ++Bn)
        nr += cbit(this[Bn] ^ Cn);
      return nr;
    }, _n.prototype.testBit = function(nr) {
      var Cn = Math.floor(nr / this.DB);
      return Cn >= this.t ? this.s != 0 : (this[Cn] & 1 << nr % this.DB) != 0;
    }, _n.prototype.setBit = function(nr) {
      return this.changeBit(nr, op_or);
    }, _n.prototype.clearBit = function(nr) {
      return this.changeBit(nr, op_andnot);
    }, _n.prototype.flipBit = function(nr) {
      return this.changeBit(nr, op_xor);
    }, _n.prototype.add = function(nr) {
      var Cn = nbi();
      return this.addTo(nr, Cn), Cn;
    }, _n.prototype.subtract = function(nr) {
      var Cn = nbi();
      return this.subTo(nr, Cn), Cn;
    }, _n.prototype.multiply = function(nr) {
      var Cn = nbi();
      return this.multiplyTo(nr, Cn), Cn;
    }, _n.prototype.divide = function(nr) {
      var Cn = nbi();
      return this.divRemTo(nr, Cn, null), Cn;
    }, _n.prototype.remainder = function(nr) {
      var Cn = nbi();
      return this.divRemTo(nr, null, Cn), Cn;
    }, _n.prototype.divideAndRemainder = function(nr) {
      var Cn = nbi(), Bn = nbi();
      return this.divRemTo(nr, Cn, Bn), [Cn, Bn];
    }, _n.prototype.modPow = function(nr, Cn) {
      var Bn = nr.bitLength(), In, Dn = nbv(1), Ln;
      if (Bn <= 0)
        return Dn;
      Bn < 18 ? In = 1 : Bn < 48 ? In = 3 : Bn < 144 ? In = 4 : Bn < 768 ? In = 5 : In = 6, Bn < 8 ? Ln = new Classic(Cn) : Cn.isEven() ? Ln = new Barrett(Cn) : Ln = new Montgomery(Cn);
      var $n = [], Nn = 3, Rn = In - 1, Fn = (1 << In) - 1;
      if ($n[1] = Ln.convert(this), In > 1) {
        var Pn = nbi();
        for (Ln.sqrTo($n[1], Pn); Nn <= Fn; )
          $n[Nn] = nbi(), Ln.mulTo(Pn, $n[Nn - 2], $n[Nn]), Nn += 2;
      }
      var Un = nr.t - 1, Hn, zn = !0, Gn = nbi(), Yn;
      for (Bn = nbits(nr[Un]) - 1; Un >= 0; ) {
        for (Bn >= Rn ? Hn = nr[Un] >> Bn - Rn & Fn : (Hn = (nr[Un] & (1 << Bn + 1) - 1) << Rn - Bn, Un > 0 && (Hn |= nr[Un - 1] >> this.DB + Bn - Rn)), Nn = In; !(Hn & 1); )
          Hn >>= 1, --Nn;
        if ((Bn -= Nn) < 0 && (Bn += this.DB, --Un), zn)
          $n[Hn].copyTo(Dn), zn = !1;
        else {
          for (; Nn > 1; )
            Ln.sqrTo(Dn, Gn), Ln.sqrTo(Gn, Dn), Nn -= 2;
          Nn > 0 ? Ln.sqrTo(Dn, Gn) : (Yn = Dn, Dn = Gn, Gn = Yn), Ln.mulTo(Gn, $n[Hn], Dn);
        }
        for (; Un >= 0 && !(nr[Un] & 1 << Bn); )
          Ln.sqrTo(Dn, Gn), Yn = Dn, Dn = Gn, Gn = Yn, --Bn < 0 && (Bn = this.DB - 1, --Un);
      }
      return Ln.revert(Dn);
    }, _n.prototype.modInverse = function(nr) {
      var Cn = nr.isEven();
      if (this.isEven() && Cn || nr.signum() == 0)
        return _n.ZERO;
      for (var Bn = nr.clone(), In = this.clone(), Dn = nbv(1), Ln = nbv(0), $n = nbv(0), Nn = nbv(1); Bn.signum() != 0; ) {
        for (; Bn.isEven(); )
          Bn.rShiftTo(1, Bn), Cn ? ((!Dn.isEven() || !Ln.isEven()) && (Dn.addTo(this, Dn), Ln.subTo(nr, Ln)), Dn.rShiftTo(1, Dn)) : Ln.isEven() || Ln.subTo(nr, Ln), Ln.rShiftTo(1, Ln);
        for (; In.isEven(); )
          In.rShiftTo(1, In), Cn ? ((!$n.isEven() || !Nn.isEven()) && ($n.addTo(this, $n), Nn.subTo(nr, Nn)), $n.rShiftTo(1, $n)) : Nn.isEven() || Nn.subTo(nr, Nn), Nn.rShiftTo(1, Nn);
        Bn.compareTo(In) >= 0 ? (Bn.subTo(In, Bn), Cn && Dn.subTo($n, Dn), Ln.subTo(Nn, Ln)) : (In.subTo(Bn, In), Cn && $n.subTo(Dn, $n), Nn.subTo(Ln, Nn));
      }
      if (In.compareTo(_n.ONE) != 0)
        return _n.ZERO;
      if (Nn.compareTo(nr) >= 0)
        return Nn.subtract(nr);
      if (Nn.signum() < 0)
        Nn.addTo(nr, Nn);
      else
        return Nn;
      return Nn.signum() < 0 ? Nn.add(nr) : Nn;
    }, _n.prototype.pow = function(nr) {
      return this.exp(nr, new NullExp());
    }, _n.prototype.gcd = function(nr) {
      var Cn = this.s < 0 ? this.negate() : this.clone(), Bn = nr.s < 0 ? nr.negate() : nr.clone();
      if (Cn.compareTo(Bn) < 0) {
        var In = Cn;
        Cn = Bn, Bn = In;
      }
      var Dn = Cn.getLowestSetBit(), Ln = Bn.getLowestSetBit();
      if (Ln < 0)
        return Cn;
      for (Dn < Ln && (Ln = Dn), Ln > 0 && (Cn.rShiftTo(Ln, Cn), Bn.rShiftTo(Ln, Bn)); Cn.signum() > 0; )
        (Dn = Cn.getLowestSetBit()) > 0 && Cn.rShiftTo(Dn, Cn), (Dn = Bn.getLowestSetBit()) > 0 && Bn.rShiftTo(Dn, Bn), Cn.compareTo(Bn) >= 0 ? (Cn.subTo(Bn, Cn), Cn.rShiftTo(1, Cn)) : (Bn.subTo(Cn, Bn), Bn.rShiftTo(1, Bn));
      return Ln > 0 && Bn.lShiftTo(Ln, Bn), Bn;
    }, _n.prototype.isProbablePrime = function(nr) {
      var Cn, Bn = this.abs();
      if (Bn.t == 1 && Bn[0] <= lowprimes[lowprimes.length - 1]) {
        for (Cn = 0; Cn < lowprimes.length; ++Cn)
          if (Bn[0] == lowprimes[Cn])
            return !0;
        return !1;
      }
      if (Bn.isEven())
        return !1;
      for (Cn = 1; Cn < lowprimes.length; ) {
        for (var In = lowprimes[Cn], Dn = Cn + 1; Dn < lowprimes.length && In < lplim; )
          In *= lowprimes[Dn++];
        for (In = Bn.modInt(In); Cn < Dn; )
          if (In % lowprimes[Cn++] == 0)
            return !1;
      }
      return Bn.millerRabin(nr);
    }, _n.prototype.copyTo = function(nr) {
      for (var Cn = this.t - 1; Cn >= 0; --Cn)
        nr[Cn] = this[Cn];
      nr.t = this.t, nr.s = this.s;
    }, _n.prototype.fromInt = function(nr) {
      this.t = 1, this.s = nr < 0 ? -1 : 0, nr > 0 ? this[0] = nr : nr < -1 ? this[0] = nr + this.DV : this.t = 0;
    }, _n.prototype.fromString = function(nr, Cn) {
      var Bn;
      if (Cn == 16)
        Bn = 4;
      else if (Cn == 8)
        Bn = 3;
      else if (Cn == 256)
        Bn = 8;
      else if (Cn == 2)
        Bn = 1;
      else if (Cn == 32)
        Bn = 5;
      else if (Cn == 4)
        Bn = 2;
      else {
        this.fromRadix(nr, Cn);
        return;
      }
      this.t = 0, this.s = 0;
      for (var In = nr.length, Dn = !1, Ln = 0; --In >= 0; ) {
        var $n = Bn == 8 ? +nr[In] & 255 : intAt(nr, In);
        if ($n < 0) {
          nr.charAt(In) == "-" && (Dn = !0);
          continue;
        }
        Dn = !1, Ln == 0 ? this[this.t++] = $n : Ln + Bn > this.DB ? (this[this.t - 1] |= ($n & (1 << this.DB - Ln) - 1) << Ln, this[this.t++] = $n >> this.DB - Ln) : this[this.t - 1] |= $n << Ln, Ln += Bn, Ln >= this.DB && (Ln -= this.DB);
      }
      Bn == 8 && +nr[0] & 128 && (this.s = -1, Ln > 0 && (this[this.t - 1] |= (1 << this.DB - Ln) - 1 << Ln)), this.clamp(), Dn && _n.ZERO.subTo(this, this);
    }, _n.prototype.clamp = function() {
      for (var nr = this.s & this.DM; this.t > 0 && this[this.t - 1] == nr; )
        --this.t;
    }, _n.prototype.dlShiftTo = function(nr, Cn) {
      var Bn;
      for (Bn = this.t - 1; Bn >= 0; --Bn)
        Cn[Bn + nr] = this[Bn];
      for (Bn = nr - 1; Bn >= 0; --Bn)
        Cn[Bn] = 0;
      Cn.t = this.t + nr, Cn.s = this.s;
    }, _n.prototype.drShiftTo = function(nr, Cn) {
      for (var Bn = nr; Bn < this.t; ++Bn)
        Cn[Bn - nr] = this[Bn];
      Cn.t = Math.max(this.t - nr, 0), Cn.s = this.s;
    }, _n.prototype.lShiftTo = function(nr, Cn) {
      for (var Bn = nr % this.DB, In = this.DB - Bn, Dn = (1 << In) - 1, Ln = Math.floor(nr / this.DB), $n = this.s << Bn & this.DM, Nn = this.t - 1; Nn >= 0; --Nn)
        Cn[Nn + Ln + 1] = this[Nn] >> In | $n, $n = (this[Nn] & Dn) << Bn;
      for (var Nn = Ln - 1; Nn >= 0; --Nn)
        Cn[Nn] = 0;
      Cn[Ln] = $n, Cn.t = this.t + Ln + 1, Cn.s = this.s, Cn.clamp();
    }, _n.prototype.rShiftTo = function(nr, Cn) {
      Cn.s = this.s;
      var Bn = Math.floor(nr / this.DB);
      if (Bn >= this.t) {
        Cn.t = 0;
        return;
      }
      var In = nr % this.DB, Dn = this.DB - In, Ln = (1 << In) - 1;
      Cn[0] = this[Bn] >> In;
      for (var $n = Bn + 1; $n < this.t; ++$n)
        Cn[$n - Bn - 1] |= (this[$n] & Ln) << Dn, Cn[$n - Bn] = this[$n] >> In;
      In > 0 && (Cn[this.t - Bn - 1] |= (this.s & Ln) << Dn), Cn.t = this.t - Bn, Cn.clamp();
    }, _n.prototype.subTo = function(nr, Cn) {
      for (var Bn = 0, In = 0, Dn = Math.min(nr.t, this.t); Bn < Dn; )
        In += this[Bn] - nr[Bn], Cn[Bn++] = In & this.DM, In >>= this.DB;
      if (nr.t < this.t) {
        for (In -= nr.s; Bn < this.t; )
          In += this[Bn], Cn[Bn++] = In & this.DM, In >>= this.DB;
        In += this.s;
      } else {
        for (In += this.s; Bn < nr.t; )
          In -= nr[Bn], Cn[Bn++] = In & this.DM, In >>= this.DB;
        In -= nr.s;
      }
      Cn.s = In < 0 ? -1 : 0, In < -1 ? Cn[Bn++] = this.DV + In : In > 0 && (Cn[Bn++] = In), Cn.t = Bn, Cn.clamp();
    }, _n.prototype.multiplyTo = function(nr, Cn) {
      var Bn = this.abs(), In = nr.abs(), Dn = Bn.t;
      for (Cn.t = Dn + In.t; --Dn >= 0; )
        Cn[Dn] = 0;
      for (Dn = 0; Dn < In.t; ++Dn)
        Cn[Dn + Bn.t] = Bn.am(0, In[Dn], Cn, Dn, 0, Bn.t);
      Cn.s = 0, Cn.clamp(), this.s != nr.s && _n.ZERO.subTo(Cn, Cn);
    }, _n.prototype.squareTo = function(nr) {
      for (var Cn = this.abs(), Bn = nr.t = 2 * Cn.t; --Bn >= 0; )
        nr[Bn] = 0;
      for (Bn = 0; Bn < Cn.t - 1; ++Bn) {
        var In = Cn.am(Bn, Cn[Bn], nr, 2 * Bn, 0, 1);
        (nr[Bn + Cn.t] += Cn.am(Bn + 1, 2 * Cn[Bn], nr, 2 * Bn + 1, In, Cn.t - Bn - 1)) >= Cn.DV && (nr[Bn + Cn.t] -= Cn.DV, nr[Bn + Cn.t + 1] = 1);
      }
      nr.t > 0 && (nr[nr.t - 1] += Cn.am(Bn, Cn[Bn], nr, 2 * Bn, 0, 1)), nr.s = 0, nr.clamp();
    }, _n.prototype.divRemTo = function(nr, Cn, Bn) {
      var In = nr.abs();
      if (!(In.t <= 0)) {
        var Dn = this.abs();
        if (Dn.t < In.t) {
          Cn != null && Cn.fromInt(0), Bn != null && this.copyTo(Bn);
          return;
        }
        Bn == null && (Bn = nbi());
        var Ln = nbi(), $n = this.s, Nn = nr.s, Rn = this.DB - nbits(In[In.t - 1]);
        Rn > 0 ? (In.lShiftTo(Rn, Ln), Dn.lShiftTo(Rn, Bn)) : (In.copyTo(Ln), Dn.copyTo(Bn));
        var Fn = Ln.t, Pn = Ln[Fn - 1];
        if (Pn != 0) {
          var Un = Pn * (1 << this.F1) + (Fn > 1 ? Ln[Fn - 2] >> this.F2 : 0), Hn = this.FV / Un, zn = (1 << this.F1) / Un, Gn = 1 << this.F2, Yn = Bn.t, Wn = Yn - Fn, Xn = Cn ?? nbi();
          for (Ln.dlShiftTo(Wn, Xn), Bn.compareTo(Xn) >= 0 && (Bn[Bn.t++] = 1, Bn.subTo(Xn, Bn)), _n.ONE.dlShiftTo(Fn, Xn), Xn.subTo(Ln, Ln); Ln.t < Fn; )
            Ln[Ln.t++] = 0;
          for (; --Wn >= 0; ) {
            var ea = Bn[--Yn] == Pn ? this.DM : Math.floor(Bn[Yn] * Hn + (Bn[Yn - 1] + Gn) * zn);
            if ((Bn[Yn] += Ln.am(0, ea, Bn, Wn, 0, Fn)) < ea)
              for (Ln.dlShiftTo(Wn, Xn), Bn.subTo(Xn, Bn); Bn[Yn] < --ea; )
                Bn.subTo(Xn, Bn);
          }
          Cn != null && (Bn.drShiftTo(Fn, Cn), $n != Nn && _n.ZERO.subTo(Cn, Cn)), Bn.t = Fn, Bn.clamp(), Rn > 0 && Bn.rShiftTo(Rn, Bn), $n < 0 && _n.ZERO.subTo(Bn, Bn);
        }
      }
    }, _n.prototype.invDigit = function() {
      if (this.t < 1)
        return 0;
      var nr = this[0];
      if (!(nr & 1))
        return 0;
      var Cn = nr & 3;
      return Cn = Cn * (2 - (nr & 15) * Cn) & 15, Cn = Cn * (2 - (nr & 255) * Cn) & 255, Cn = Cn * (2 - ((nr & 65535) * Cn & 65535)) & 65535, Cn = Cn * (2 - nr * Cn % this.DV) % this.DV, Cn > 0 ? this.DV - Cn : -Cn;
    }, _n.prototype.isEven = function() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }, _n.prototype.exp = function(nr, Cn) {
      if (nr > 4294967295 || nr < 1)
        return _n.ONE;
      var Bn = nbi(), In = nbi(), Dn = Cn.convert(this), Ln = nbits(nr) - 1;
      for (Dn.copyTo(Bn); --Ln >= 0; )
        if (Cn.sqrTo(Bn, In), (nr & 1 << Ln) > 0)
          Cn.mulTo(In, Dn, Bn);
        else {
          var $n = Bn;
          Bn = In, In = $n;
        }
      return Cn.revert(Bn);
    }, _n.prototype.chunkSize = function(nr) {
      return Math.floor(Math.LN2 * this.DB / Math.log(nr));
    }, _n.prototype.toRadix = function(nr) {
      if (nr == null && (nr = 10), this.signum() == 0 || nr < 2 || nr > 36)
        return "0";
      var Cn = this.chunkSize(nr), Bn = Math.pow(nr, Cn), In = nbv(Bn), Dn = nbi(), Ln = nbi(), $n = "";
      for (this.divRemTo(In, Dn, Ln); Dn.signum() > 0; )
        $n = (Bn + Ln.intValue()).toString(nr).substr(1) + $n, Dn.divRemTo(In, Dn, Ln);
      return Ln.intValue().toString(nr) + $n;
    }, _n.prototype.fromRadix = function(nr, Cn) {
      this.fromInt(0), Cn == null && (Cn = 10);
      for (var Bn = this.chunkSize(Cn), In = Math.pow(Cn, Bn), Dn = !1, Ln = 0, $n = 0, Nn = 0; Nn < nr.length; ++Nn) {
        var Rn = intAt(nr, Nn);
        if (Rn < 0) {
          nr.charAt(Nn) == "-" && this.signum() == 0 && (Dn = !0);
          continue;
        }
        $n = Cn * $n + Rn, ++Ln >= Bn && (this.dMultiply(In), this.dAddOffset($n, 0), Ln = 0, $n = 0);
      }
      Ln > 0 && (this.dMultiply(Math.pow(Cn, Ln)), this.dAddOffset($n, 0)), Dn && _n.ZERO.subTo(this, this);
    }, _n.prototype.fromNumber = function(nr, Cn, Bn) {
      if (typeof Cn == "number")
        if (nr < 2)
          this.fromInt(1);
        else
          for (this.fromNumber(nr, Bn), this.testBit(nr - 1) || this.bitwiseTo(_n.ONE.shiftLeft(nr - 1), op_or, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(Cn); )
            this.dAddOffset(2, 0), this.bitLength() > nr && this.subTo(_n.ONE.shiftLeft(nr - 1), this);
      else {
        var In = [], Dn = nr & 7;
        In.length = (nr >> 3) + 1, Cn.nextBytes(In), Dn > 0 ? In[0] &= (1 << Dn) - 1 : In[0] = 0, this.fromString(In, 256);
      }
    }, _n.prototype.bitwiseTo = function(nr, Cn, Bn) {
      var In, Dn, Ln = Math.min(nr.t, this.t);
      for (In = 0; In < Ln; ++In)
        Bn[In] = Cn(this[In], nr[In]);
      if (nr.t < this.t) {
        for (Dn = nr.s & this.DM, In = Ln; In < this.t; ++In)
          Bn[In] = Cn(this[In], Dn);
        Bn.t = this.t;
      } else {
        for (Dn = this.s & this.DM, In = Ln; In < nr.t; ++In)
          Bn[In] = Cn(Dn, nr[In]);
        Bn.t = nr.t;
      }
      Bn.s = Cn(this.s, nr.s), Bn.clamp();
    }, _n.prototype.changeBit = function(nr, Cn) {
      var Bn = _n.ONE.shiftLeft(nr);
      return this.bitwiseTo(Bn, Cn, Bn), Bn;
    }, _n.prototype.addTo = function(nr, Cn) {
      for (var Bn = 0, In = 0, Dn = Math.min(nr.t, this.t); Bn < Dn; )
        In += this[Bn] + nr[Bn], Cn[Bn++] = In & this.DM, In >>= this.DB;
      if (nr.t < this.t) {
        for (In += nr.s; Bn < this.t; )
          In += this[Bn], Cn[Bn++] = In & this.DM, In >>= this.DB;
        In += this.s;
      } else {
        for (In += this.s; Bn < nr.t; )
          In += nr[Bn], Cn[Bn++] = In & this.DM, In >>= this.DB;
        In += nr.s;
      }
      Cn.s = In < 0 ? -1 : 0, In > 0 ? Cn[Bn++] = In : In < -1 && (Cn[Bn++] = this.DV + In), Cn.t = Bn, Cn.clamp();
    }, _n.prototype.dMultiply = function(nr) {
      this[this.t] = this.am(0, nr - 1, this, 0, 0, this.t), ++this.t, this.clamp();
    }, _n.prototype.dAddOffset = function(nr, Cn) {
      if (nr != 0) {
        for (; this.t <= Cn; )
          this[this.t++] = 0;
        for (this[Cn] += nr; this[Cn] >= this.DV; )
          this[Cn] -= this.DV, ++Cn >= this.t && (this[this.t++] = 0), ++this[Cn];
      }
    }, _n.prototype.multiplyLowerTo = function(nr, Cn, Bn) {
      var In = Math.min(this.t + nr.t, Cn);
      for (Bn.s = 0, Bn.t = In; In > 0; )
        Bn[--In] = 0;
      for (var Dn = Bn.t - this.t; In < Dn; ++In)
        Bn[In + this.t] = this.am(0, nr[In], Bn, In, 0, this.t);
      for (var Dn = Math.min(nr.t, Cn); In < Dn; ++In)
        this.am(0, nr[In], Bn, In, 0, Cn - In);
      Bn.clamp();
    }, _n.prototype.multiplyUpperTo = function(nr, Cn, Bn) {
      --Cn;
      var In = Bn.t = this.t + nr.t - Cn;
      for (Bn.s = 0; --In >= 0; )
        Bn[In] = 0;
      for (In = Math.max(Cn - this.t, 0); In < nr.t; ++In)
        Bn[this.t + In - Cn] = this.am(Cn - In, nr[In], Bn, 0, 0, this.t + In - Cn);
      Bn.clamp(), Bn.drShiftTo(1, Bn);
    }, _n.prototype.modInt = function(nr) {
      if (nr <= 0)
        return 0;
      var Cn = this.DV % nr, Bn = this.s < 0 ? nr - 1 : 0;
      if (this.t > 0)
        if (Cn == 0)
          Bn = this[0] % nr;
        else
          for (var In = this.t - 1; In >= 0; --In)
            Bn = (Cn * Bn + this[In]) % nr;
      return Bn;
    }, _n.prototype.millerRabin = function(nr) {
      var Cn = this.subtract(_n.ONE), Bn = Cn.getLowestSetBit();
      if (Bn <= 0)
        return !1;
      var In = Cn.shiftRight(Bn);
      nr = nr + 1 >> 1, nr > lowprimes.length && (nr = lowprimes.length);
      for (var Dn = nbi(), Ln = 0; Ln < nr; ++Ln) {
        Dn.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var $n = Dn.modPow(In, this);
        if ($n.compareTo(_n.ONE) != 0 && $n.compareTo(Cn) != 0) {
          for (var Nn = 1; Nn++ < Bn && $n.compareTo(Cn) != 0; )
            if ($n = $n.modPowInt(2, this), $n.compareTo(_n.ONE) == 0)
              return !1;
          if ($n.compareTo(Cn) != 0)
            return !1;
        }
      }
      return !0;
    }, _n.prototype.square = function() {
      var nr = nbi();
      return this.squareTo(nr), nr;
    }, _n.prototype.gcda = function(nr, Cn) {
      var Bn = this.s < 0 ? this.negate() : this.clone(), In = nr.s < 0 ? nr.negate() : nr.clone();
      if (Bn.compareTo(In) < 0) {
        var Dn = Bn;
        Bn = In, In = Dn;
      }
      var Ln = Bn.getLowestSetBit(), $n = In.getLowestSetBit();
      if ($n < 0) {
        Cn(Bn);
        return;
      }
      Ln < $n && ($n = Ln), $n > 0 && (Bn.rShiftTo($n, Bn), In.rShiftTo($n, In));
      var Nn = function() {
        (Ln = Bn.getLowestSetBit()) > 0 && Bn.rShiftTo(Ln, Bn), (Ln = In.getLowestSetBit()) > 0 && In.rShiftTo(Ln, In), Bn.compareTo(In) >= 0 ? (Bn.subTo(In, Bn), Bn.rShiftTo(1, Bn)) : (In.subTo(Bn, In), In.rShiftTo(1, In)), Bn.signum() > 0 ? setTimeout(Nn, 0) : ($n > 0 && In.lShiftTo($n, In), setTimeout(function() {
          Cn(In);
        }, 0));
      };
      setTimeout(Nn, 10);
    }, _n.prototype.fromNumberAsync = function(nr, Cn, Bn, In) {
      if (typeof Cn == "number")
        if (nr < 2)
          this.fromInt(1);
        else {
          this.fromNumber(nr, Bn), this.testBit(nr - 1) || this.bitwiseTo(_n.ONE.shiftLeft(nr - 1), op_or, this), this.isEven() && this.dAddOffset(1, 0);
          var Dn = this, Ln = function() {
            Dn.dAddOffset(2, 0), Dn.bitLength() > nr && Dn.subTo(_n.ONE.shiftLeft(nr - 1), Dn), Dn.isProbablePrime(Cn) ? setTimeout(function() {
              In();
            }, 0) : setTimeout(Ln, 0);
          };
          setTimeout(Ln, 0);
        }
      else {
        var $n = [], Nn = nr & 7;
        $n.length = (nr >> 3) + 1, Cn.nextBytes($n), Nn > 0 ? $n[0] &= (1 << Nn) - 1 : $n[0] = 0, this.fromString($n, 256);
      }
    }, _n;
  }()
), NullExp = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.convert = function(nr) {
      return nr;
    }, _n.prototype.revert = function(nr) {
      return nr;
    }, _n.prototype.mulTo = function(nr, Cn, Bn) {
      nr.multiplyTo(Cn, Bn);
    }, _n.prototype.sqrTo = function(nr, Cn) {
      nr.squareTo(Cn);
    }, _n;
  }()
), Classic = (
  /** @class */
  function() {
    function _n(nr) {
      this.m = nr;
    }
    return _n.prototype.convert = function(nr) {
      return nr.s < 0 || nr.compareTo(this.m) >= 0 ? nr.mod(this.m) : nr;
    }, _n.prototype.revert = function(nr) {
      return nr;
    }, _n.prototype.reduce = function(nr) {
      nr.divRemTo(this.m, null, nr);
    }, _n.prototype.mulTo = function(nr, Cn, Bn) {
      nr.multiplyTo(Cn, Bn), this.reduce(Bn);
    }, _n.prototype.sqrTo = function(nr, Cn) {
      nr.squareTo(Cn), this.reduce(Cn);
    }, _n;
  }()
), Montgomery = (
  /** @class */
  function() {
    function _n(nr) {
      this.m = nr, this.mp = nr.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << nr.DB - 15) - 1, this.mt2 = 2 * nr.t;
    }
    return _n.prototype.convert = function(nr) {
      var Cn = nbi();
      return nr.abs().dlShiftTo(this.m.t, Cn), Cn.divRemTo(this.m, null, Cn), nr.s < 0 && Cn.compareTo(BigInteger.ZERO) > 0 && this.m.subTo(Cn, Cn), Cn;
    }, _n.prototype.revert = function(nr) {
      var Cn = nbi();
      return nr.copyTo(Cn), this.reduce(Cn), Cn;
    }, _n.prototype.reduce = function(nr) {
      for (; nr.t <= this.mt2; )
        nr[nr.t++] = 0;
      for (var Cn = 0; Cn < this.m.t; ++Cn) {
        var Bn = nr[Cn] & 32767, In = Bn * this.mpl + ((Bn * this.mph + (nr[Cn] >> 15) * this.mpl & this.um) << 15) & nr.DM;
        for (Bn = Cn + this.m.t, nr[Bn] += this.m.am(0, In, nr, Cn, 0, this.m.t); nr[Bn] >= nr.DV; )
          nr[Bn] -= nr.DV, nr[++Bn]++;
      }
      nr.clamp(), nr.drShiftTo(this.m.t, nr), nr.compareTo(this.m) >= 0 && nr.subTo(this.m, nr);
    }, _n.prototype.mulTo = function(nr, Cn, Bn) {
      nr.multiplyTo(Cn, Bn), this.reduce(Bn);
    }, _n.prototype.sqrTo = function(nr, Cn) {
      nr.squareTo(Cn), this.reduce(Cn);
    }, _n;
  }()
), Barrett = (
  /** @class */
  function() {
    function _n(nr) {
      this.m = nr, this.r2 = nbi(), this.q3 = nbi(), BigInteger.ONE.dlShiftTo(2 * nr.t, this.r2), this.mu = this.r2.divide(nr);
    }
    return _n.prototype.convert = function(nr) {
      if (nr.s < 0 || nr.t > 2 * this.m.t)
        return nr.mod(this.m);
      if (nr.compareTo(this.m) < 0)
        return nr;
      var Cn = nbi();
      return nr.copyTo(Cn), this.reduce(Cn), Cn;
    }, _n.prototype.revert = function(nr) {
      return nr;
    }, _n.prototype.reduce = function(nr) {
      for (nr.drShiftTo(this.m.t - 1, this.r2), nr.t > this.m.t + 1 && (nr.t = this.m.t + 1, nr.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); nr.compareTo(this.r2) < 0; )
        nr.dAddOffset(1, this.m.t + 1);
      for (nr.subTo(this.r2, nr); nr.compareTo(this.m) >= 0; )
        nr.subTo(this.m, nr);
    }, _n.prototype.mulTo = function(nr, Cn, Bn) {
      nr.multiplyTo(Cn, Bn), this.reduce(Bn);
    }, _n.prototype.sqrTo = function(nr, Cn) {
      nr.squareTo(Cn), this.reduce(Cn);
    }, _n;
  }()
);
function nbi() {
  return new BigInteger(null);
}
function parseBigInt(_n, nr) {
  return new BigInteger(_n, nr);
}
var inBrowser = typeof navigator < "u";
inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer" ? (BigInteger.prototype.am = function(nr, Cn, Bn, In, Dn, Ln) {
  for (var $n = Cn & 32767, Nn = Cn >> 15; --Ln >= 0; ) {
    var Rn = this[nr] & 32767, Fn = this[nr++] >> 15, Pn = Nn * Rn + Fn * $n;
    Rn = $n * Rn + ((Pn & 32767) << 15) + Bn[In] + (Dn & 1073741823), Dn = (Rn >>> 30) + (Pn >>> 15) + Nn * Fn + (Dn >>> 30), Bn[In++] = Rn & 1073741823;
  }
  return Dn;
}, dbits = 30) : inBrowser && j_lm && navigator.appName != "Netscape" ? (BigInteger.prototype.am = function(nr, Cn, Bn, In, Dn, Ln) {
  for (; --Ln >= 0; ) {
    var $n = Cn * this[nr++] + Bn[In] + Dn;
    Dn = Math.floor($n / 67108864), Bn[In++] = $n & 67108863;
  }
  return Dn;
}, dbits = 26) : (BigInteger.prototype.am = function(nr, Cn, Bn, In, Dn, Ln) {
  for (var $n = Cn & 16383, Nn = Cn >> 14; --Ln >= 0; ) {
    var Rn = this[nr] & 16383, Fn = this[nr++] >> 14, Pn = Nn * Rn + Fn * $n;
    Rn = $n * Rn + ((Pn & 16383) << 14) + Bn[In] + Dn, Dn = (Rn >> 28) + (Pn >> 14) + Nn * Fn, Bn[In++] = Rn & 268435455;
  }
  return Dn;
}, dbits = 28);
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = (1 << dbits) - 1;
BigInteger.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
var BI_RC = [], rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv)
  BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
function intAt(_n, nr) {
  var Cn = BI_RC[_n.charCodeAt(nr)];
  return Cn ?? -1;
}
function nbv(_n) {
  var nr = nbi();
  return nr.fromInt(_n), nr;
}
function nbits(_n) {
  var nr = 1, Cn;
  return (Cn = _n >>> 16) != 0 && (_n = Cn, nr += 16), (Cn = _n >> 8) != 0 && (_n = Cn, nr += 8), (Cn = _n >> 4) != 0 && (_n = Cn, nr += 4), (Cn = _n >> 2) != 0 && (_n = Cn, nr += 2), (Cn = _n >> 1) != 0 && (_n = Cn, nr += 1), nr;
}
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);
var Arcfour = (
  /** @class */
  function() {
    function _n() {
      this.i = 0, this.j = 0, this.S = [];
    }
    return _n.prototype.init = function(nr) {
      var Cn, Bn, In;
      for (Cn = 0; Cn < 256; ++Cn)
        this.S[Cn] = Cn;
      for (Bn = 0, Cn = 0; Cn < 256; ++Cn)
        Bn = Bn + this.S[Cn] + nr[Cn % nr.length] & 255, In = this.S[Cn], this.S[Cn] = this.S[Bn], this.S[Bn] = In;
      this.i = 0, this.j = 0;
    }, _n.prototype.next = function() {
      var nr;
      return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, nr = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = nr, this.S[nr + this.S[this.i] & 255];
    }, _n;
  }()
);
function prng_newstate() {
  return new Arcfour();
}
var rng_psize = 256, rng_state, rng_pool = null, rng_pptr;
if (rng_pool == null) {
  rng_pool = [], rng_pptr = 0;
  var t = void 0;
  if (typeof window < "u" && window.crypto && window.crypto.getRandomValues) {
    var z = new Uint32Array(256);
    for (window.crypto.getRandomValues(z), t = 0; t < z.length; ++t)
      rng_pool[rng_pptr++] = z[t] & 255;
  }
  var count$1 = 0, onMouseMoveListener_1 = function(_n) {
    if (count$1 = count$1 || 0, count$1 >= 256 || rng_pptr >= rng_psize) {
      window.removeEventListener ? window.removeEventListener("mousemove", onMouseMoveListener_1, !1) : window.detachEvent && window.detachEvent("onmousemove", onMouseMoveListener_1);
      return;
    }
    try {
      var nr = _n.x + _n.y;
      rng_pool[rng_pptr++] = nr & 255, count$1 += 1;
    } catch {
    }
  };
  typeof window < "u" && (window.addEventListener ? window.addEventListener("mousemove", onMouseMoveListener_1, !1) : window.attachEvent && window.attachEvent("onmousemove", onMouseMoveListener_1));
}
function rng_get_byte() {
  if (rng_state == null) {
    for (rng_state = prng_newstate(); rng_pptr < rng_psize; ) {
      var _n = Math.floor(65536 * Math.random());
      rng_pool[rng_pptr++] = _n & 255;
    }
    for (rng_state.init(rng_pool), rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
      rng_pool[rng_pptr] = 0;
    rng_pptr = 0;
  }
  return rng_state.next();
}
var SecureRandom = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.nextBytes = function(nr) {
      for (var Cn = 0; Cn < nr.length; ++Cn)
        nr[Cn] = rng_get_byte();
    }, _n;
  }()
);
function pkcs1pad1(_n, nr) {
  if (nr < _n.length + 22)
    return console.error("Message too long for RSA"), null;
  for (var Cn = nr - _n.length - 6, Bn = "", In = 0; In < Cn; In += 2)
    Bn += "ff";
  var Dn = "0001" + Bn + "00" + _n;
  return parseBigInt(Dn, 16);
}
function pkcs1pad2(_n, nr) {
  if (nr < _n.length + 11)
    return console.error("Message too long for RSA"), null;
  for (var Cn = [], Bn = _n.length - 1; Bn >= 0 && nr > 0; ) {
    var In = _n.charCodeAt(Bn--);
    In < 128 ? Cn[--nr] = In : In > 127 && In < 2048 ? (Cn[--nr] = In & 63 | 128, Cn[--nr] = In >> 6 | 192) : (Cn[--nr] = In & 63 | 128, Cn[--nr] = In >> 6 & 63 | 128, Cn[--nr] = In >> 12 | 224);
  }
  Cn[--nr] = 0;
  for (var Dn = new SecureRandom(), Ln = []; nr > 2; ) {
    for (Ln[0] = 0; Ln[0] == 0; )
      Dn.nextBytes(Ln);
    Cn[--nr] = Ln[0];
  }
  return Cn[--nr] = 2, Cn[--nr] = 0, new BigInteger(Cn);
}
var RSAKey = (
  /** @class */
  function() {
    function _n() {
      this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null;
    }
    return _n.prototype.doPublic = function(nr) {
      return nr.modPowInt(this.e, this.n);
    }, _n.prototype.doPrivate = function(nr) {
      if (this.p == null || this.q == null)
        return nr.modPow(this.d, this.n);
      for (var Cn = nr.mod(this.p).modPow(this.dmp1, this.p), Bn = nr.mod(this.q).modPow(this.dmq1, this.q); Cn.compareTo(Bn) < 0; )
        Cn = Cn.add(this.p);
      return Cn.subtract(Bn).multiply(this.coeff).mod(this.p).multiply(this.q).add(Bn);
    }, _n.prototype.setPublic = function(nr, Cn) {
      nr != null && Cn != null && nr.length > 0 && Cn.length > 0 ? (this.n = parseBigInt(nr, 16), this.e = parseInt(Cn, 16)) : console.error("Invalid RSA public key");
    }, _n.prototype.encrypt = function(nr) {
      var Cn = this.n.bitLength() + 7 >> 3, Bn = pkcs1pad2(nr, Cn);
      if (Bn == null)
        return null;
      var In = this.doPublic(Bn);
      if (In == null)
        return null;
      for (var Dn = In.toString(16), Ln = Dn.length, $n = 0; $n < Cn * 2 - Ln; $n++)
        Dn = "0" + Dn;
      return Dn;
    }, _n.prototype.setPrivate = function(nr, Cn, Bn) {
      nr != null && Cn != null && nr.length > 0 && Cn.length > 0 ? (this.n = parseBigInt(nr, 16), this.e = parseInt(Cn, 16), this.d = parseBigInt(Bn, 16)) : console.error("Invalid RSA private key");
    }, _n.prototype.setPrivateEx = function(nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
      nr != null && Cn != null && nr.length > 0 && Cn.length > 0 ? (this.n = parseBigInt(nr, 16), this.e = parseInt(Cn, 16), this.d = parseBigInt(Bn, 16), this.p = parseBigInt(In, 16), this.q = parseBigInt(Dn, 16), this.dmp1 = parseBigInt(Ln, 16), this.dmq1 = parseBigInt($n, 16), this.coeff = parseBigInt(Nn, 16)) : console.error("Invalid RSA private key");
    }, _n.prototype.generate = function(nr, Cn) {
      var Bn = new SecureRandom(), In = nr >> 1;
      this.e = parseInt(Cn, 16);
      for (var Dn = new BigInteger(Cn, 16); ; ) {
        for (; this.p = new BigInteger(nr - In, 1, Bn), !(this.p.subtract(BigInteger.ONE).gcd(Dn).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)); )
          ;
        for (; this.q = new BigInteger(In, 1, Bn), !(this.q.subtract(BigInteger.ONE).gcd(Dn).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)); )
          ;
        if (this.p.compareTo(this.q) <= 0) {
          var Ln = this.p;
          this.p = this.q, this.q = Ln;
        }
        var $n = this.p.subtract(BigInteger.ONE), Nn = this.q.subtract(BigInteger.ONE), Rn = $n.multiply(Nn);
        if (Rn.gcd(Dn).compareTo(BigInteger.ONE) == 0) {
          this.n = this.p.multiply(this.q), this.d = Dn.modInverse(Rn), this.dmp1 = this.d.mod($n), this.dmq1 = this.d.mod(Nn), this.coeff = this.q.modInverse(this.p);
          break;
        }
      }
    }, _n.prototype.decrypt = function(nr) {
      var Cn = parseBigInt(nr, 16), Bn = this.doPrivate(Cn);
      return Bn == null ? null : pkcs1unpad2(Bn, this.n.bitLength() + 7 >> 3);
    }, _n.prototype.generateAsync = function(nr, Cn, Bn) {
      var In = new SecureRandom(), Dn = nr >> 1;
      this.e = parseInt(Cn, 16);
      var Ln = new BigInteger(Cn, 16), $n = this, Nn = function() {
        var Rn = function() {
          if ($n.p.compareTo($n.q) <= 0) {
            var Un = $n.p;
            $n.p = $n.q, $n.q = Un;
          }
          var Hn = $n.p.subtract(BigInteger.ONE), zn = $n.q.subtract(BigInteger.ONE), Gn = Hn.multiply(zn);
          Gn.gcd(Ln).compareTo(BigInteger.ONE) == 0 ? ($n.n = $n.p.multiply($n.q), $n.d = Ln.modInverse(Gn), $n.dmp1 = $n.d.mod(Hn), $n.dmq1 = $n.d.mod(zn), $n.coeff = $n.q.modInverse($n.p), setTimeout(function() {
            Bn();
          }, 0)) : setTimeout(Nn, 0);
        }, Fn = function() {
          $n.q = nbi(), $n.q.fromNumberAsync(Dn, 1, In, function() {
            $n.q.subtract(BigInteger.ONE).gcda(Ln, function(Un) {
              Un.compareTo(BigInteger.ONE) == 0 && $n.q.isProbablePrime(10) ? setTimeout(Rn, 0) : setTimeout(Fn, 0);
            });
          });
        }, Pn = function() {
          $n.p = nbi(), $n.p.fromNumberAsync(nr - Dn, 1, In, function() {
            $n.p.subtract(BigInteger.ONE).gcda(Ln, function(Un) {
              Un.compareTo(BigInteger.ONE) == 0 && $n.p.isProbablePrime(10) ? setTimeout(Fn, 0) : setTimeout(Pn, 0);
            });
          });
        };
        setTimeout(Pn, 0);
      };
      setTimeout(Nn, 0);
    }, _n.prototype.sign = function(nr, Cn, Bn) {
      var In = getDigestHeader(Bn), Dn = In + Cn(nr).toString(), Ln = pkcs1pad1(Dn, this.n.bitLength() / 4);
      if (Ln == null)
        return null;
      var $n = this.doPrivate(Ln);
      if ($n == null)
        return null;
      var Nn = $n.toString(16);
      return Nn.length & 1 ? "0" + Nn : Nn;
    }, _n.prototype.verify = function(nr, Cn, Bn) {
      var In = parseBigInt(Cn, 16), Dn = this.doPublic(In);
      if (Dn == null)
        return null;
      var Ln = Dn.toString(16).replace(/^1f+00/, ""), $n = removeDigestHeader(Ln);
      return $n == Bn(nr).toString();
    }, _n;
  }()
);
function pkcs1unpad2(_n, nr) {
  for (var Cn = _n.toByteArray(), Bn = 0; Bn < Cn.length && Cn[Bn] == 0; )
    ++Bn;
  if (Cn.length - Bn != nr - 1 || Cn[Bn] != 2)
    return null;
  for (++Bn; Cn[Bn] != 0; )
    if (++Bn >= Cn.length)
      return null;
  for (var In = ""; ++Bn < Cn.length; ) {
    var Dn = Cn[Bn] & 255;
    Dn < 128 ? In += String.fromCharCode(Dn) : Dn > 191 && Dn < 224 ? (In += String.fromCharCode((Dn & 31) << 6 | Cn[Bn + 1] & 63), ++Bn) : (In += String.fromCharCode((Dn & 15) << 12 | (Cn[Bn + 1] & 63) << 6 | Cn[Bn + 2] & 63), Bn += 2);
  }
  return In;
}
var DIGEST_HEADERS = {
  md2: "3020300c06082a864886f70d020205000410",
  md5: "3020300c06082a864886f70d020505000410",
  sha1: "3021300906052b0e03021a05000414",
  sha224: "302d300d06096086480165030402040500041c",
  sha256: "3031300d060960864801650304020105000420",
  sha384: "3041300d060960864801650304020205000430",
  sha512: "3051300d060960864801650304020305000440",
  ripemd160: "3021300906052b2403020105000414"
};
function getDigestHeader(_n) {
  return DIGEST_HEADERS[_n] || "";
}
function removeDigestHeader(_n) {
  for (var nr in DIGEST_HEADERS)
    if (DIGEST_HEADERS.hasOwnProperty(nr)) {
      var Cn = DIGEST_HEADERS[nr], Bn = Cn.length;
      if (_n.substr(0, Bn) == Cn)
        return _n.substr(Bn);
    }
  return _n;
}
/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
var YAHOO = {};
YAHOO.lang = {
  /**
   * Utility to set up the prototype, constructor and superclass properties to
   * support an inheritance strategy that can chain constructors and methods.
   * Static members will not be inherited.
   *
   * @method extend
   * @static
   * @param {Function} subc   the object to modify
   * @param {Function} superc the object to inherit
   * @param {Object} overrides  additional properties/methods to add to the
   *                              subclass prototype.  These will override the
   *                              matching items obtained from the superclass
   *                              if present.
   */
  extend: function(_n, nr, Cn) {
    if (!nr || !_n)
      throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included.");
    var Bn = function() {
    };
    if (Bn.prototype = nr.prototype, _n.prototype = new Bn(), _n.prototype.constructor = _n, _n.superclass = nr.prototype, nr.prototype.constructor == Object.prototype.constructor && (nr.prototype.constructor = nr), Cn) {
      var In;
      for (In in Cn)
        _n.prototype[In] = Cn[In];
      var Dn = function() {
      }, Ln = ["toString", "valueOf"];
      try {
        /MSIE/.test(navigator.userAgent) && (Dn = function($n, Nn) {
          for (In = 0; In < Ln.length; In = In + 1) {
            var Rn = Ln[In], Fn = Nn[Rn];
            typeof Fn == "function" && Fn != Object.prototype[Rn] && ($n[Rn] = Fn);
          }
        });
      } catch {
      }
      Dn(_n.prototype, Cn);
    }
  }
};
/**
 * @fileOverview
 * @name asn1-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version asn1 1.0.13 (2017-Jun-02)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */
var KJUR = {};
(typeof KJUR.asn1 > "u" || !KJUR.asn1) && (KJUR.asn1 = {});
KJUR.asn1.ASN1Util = new function() {
  this.integerToByteHex = function(_n) {
    var nr = _n.toString(16);
    return nr.length % 2 == 1 && (nr = "0" + nr), nr;
  }, this.bigIntToMinTwosComplementsHex = function(_n) {
    var nr = _n.toString(16);
    if (nr.substr(0, 1) != "-")
      nr.length % 2 == 1 ? nr = "0" + nr : nr.match(/^[0-7]/) || (nr = "00" + nr);
    else {
      var Cn = nr.substr(1), Bn = Cn.length;
      Bn % 2 == 1 ? Bn += 1 : nr.match(/^[0-7]/) || (Bn += 2);
      for (var In = "", Dn = 0; Dn < Bn; Dn++)
        In += "f";
      var Ln = new BigInteger(In, 16), $n = Ln.xor(_n).add(BigInteger.ONE);
      nr = $n.toString(16).replace(/^-/, "");
    }
    return nr;
  }, this.getPEMStringFromHex = function(_n, nr) {
    return hextopem(_n, nr);
  }, this.newObject = function(_n) {
    var nr = KJUR, Cn = nr.asn1, Bn = Cn.DERBoolean, In = Cn.DERInteger, Dn = Cn.DERBitString, Ln = Cn.DEROctetString, $n = Cn.DERNull, Nn = Cn.DERObjectIdentifier, Rn = Cn.DEREnumerated, Fn = Cn.DERUTF8String, Pn = Cn.DERNumericString, Un = Cn.DERPrintableString, Hn = Cn.DERTeletexString, zn = Cn.DERIA5String, Gn = Cn.DERUTCTime, Yn = Cn.DERGeneralizedTime, Wn = Cn.DERSequence, Xn = Cn.DERSet, ea = Cn.DERTaggedObject, ta = Cn.ASN1Util.newObject, na = Object.keys(_n);
    if (na.length != 1)
      throw "key of param shall be only one.";
    var ra = na[0];
    if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + ra + ":") == -1)
      throw "undefined key: " + ra;
    if (ra == "bool")
      return new Bn(_n[ra]);
    if (ra == "int")
      return new In(_n[ra]);
    if (ra == "bitstr")
      return new Dn(_n[ra]);
    if (ra == "octstr")
      return new Ln(_n[ra]);
    if (ra == "null")
      return new $n(_n[ra]);
    if (ra == "oid")
      return new Nn(_n[ra]);
    if (ra == "enum")
      return new Rn(_n[ra]);
    if (ra == "utf8str")
      return new Fn(_n[ra]);
    if (ra == "numstr")
      return new Pn(_n[ra]);
    if (ra == "prnstr")
      return new Un(_n[ra]);
    if (ra == "telstr")
      return new Hn(_n[ra]);
    if (ra == "ia5str")
      return new zn(_n[ra]);
    if (ra == "utctime")
      return new Gn(_n[ra]);
    if (ra == "gentime")
      return new Yn(_n[ra]);
    if (ra == "seq") {
      for (var aa = _n[ra], ia = [], Aa = 0; Aa < aa.length; Aa++) {
        var sa = ta(aa[Aa]);
        ia.push(sa);
      }
      return new Wn({ array: ia });
    }
    if (ra == "set") {
      for (var aa = _n[ra], ia = [], Aa = 0; Aa < aa.length; Aa++) {
        var sa = ta(aa[Aa]);
        ia.push(sa);
      }
      return new Xn({ array: ia });
    }
    if (ra == "tag") {
      var oa = _n[ra];
      if (Object.prototype.toString.call(oa) === "[object Array]" && oa.length == 3) {
        var la = ta(oa[2]);
        return new ea({
          tag: oa[0],
          explicit: oa[1],
          obj: la
        });
      } else {
        var ua = {};
        if (oa.explicit !== void 0 && (ua.explicit = oa.explicit), oa.tag !== void 0 && (ua.tag = oa.tag), oa.obj === void 0)
          throw "obj shall be specified for 'tag'.";
        return ua.obj = ta(oa.obj), new ea(ua);
      }
    }
  }, this.jsonToASN1HEX = function(_n) {
    var nr = this.newObject(_n);
    return nr.getEncodedHex();
  };
}();
KJUR.asn1.ASN1Util.oidHexToInt = function(_n) {
  for (var In = "", nr = parseInt(_n.substr(0, 2), 16), Cn = Math.floor(nr / 40), Bn = nr % 40, In = Cn + "." + Bn, Dn = "", Ln = 2; Ln < _n.length; Ln += 2) {
    var $n = parseInt(_n.substr(Ln, 2), 16), Nn = ("00000000" + $n.toString(2)).slice(-8);
    if (Dn = Dn + Nn.substr(1, 7), Nn.substr(0, 1) == "0") {
      var Rn = new BigInteger(Dn, 2);
      In = In + "." + Rn.toString(10), Dn = "";
    }
  }
  return In;
};
KJUR.asn1.ASN1Util.oidIntToHex = function(_n) {
  var nr = function($n) {
    var Nn = $n.toString(16);
    return Nn.length == 1 && (Nn = "0" + Nn), Nn;
  }, Cn = function($n) {
    var Nn = "", Rn = new BigInteger($n, 10), Fn = Rn.toString(2), Pn = 7 - Fn.length % 7;
    Pn == 7 && (Pn = 0);
    for (var Un = "", Hn = 0; Hn < Pn; Hn++)
      Un += "0";
    Fn = Un + Fn;
    for (var Hn = 0; Hn < Fn.length - 1; Hn += 7) {
      var zn = Fn.substr(Hn, 7);
      Hn != Fn.length - 7 && (zn = "1" + zn), Nn += nr(parseInt(zn, 2));
    }
    return Nn;
  };
  if (!_n.match(/^[0-9.]+$/))
    throw "malformed oid string: " + _n;
  var Bn = "", In = _n.split("."), Dn = parseInt(In[0]) * 40 + parseInt(In[1]);
  Bn += nr(Dn), In.splice(0, 2);
  for (var Ln = 0; Ln < In.length; Ln++)
    Bn += Cn(In[Ln]);
  return Bn;
};
KJUR.asn1.ASN1Object = function() {
  var _n = "";
  this.getLengthHexFromValue = function() {
    if (typeof this.hV > "u" || this.hV == null)
      throw "this.hV is null or undefined.";
    if (this.hV.length % 2 == 1)
      throw "value hex must be even length: n=" + _n.length + ",v=" + this.hV;
    var nr = this.hV.length / 2, Cn = nr.toString(16);
    if (Cn.length % 2 == 1 && (Cn = "0" + Cn), nr < 128)
      return Cn;
    var Bn = Cn.length / 2;
    if (Bn > 15)
      throw "ASN.1 length too long to represent by 8x: n = " + nr.toString(16);
    var In = 128 + Bn;
    return In.toString(16) + Cn;
  }, this.getEncodedHex = function() {
    return (this.hTLV == null || this.isModified) && (this.hV = this.getFreshValueHex(), this.hL = this.getLengthHexFromValue(), this.hTLV = this.hT + this.hL + this.hV, this.isModified = !1), this.hTLV;
  }, this.getValueHex = function() {
    return this.getEncodedHex(), this.hV;
  }, this.getFreshValueHex = function() {
    return "";
  };
};
KJUR.asn1.DERAbstractString = function(_n) {
  KJUR.asn1.DERAbstractString.superclass.constructor.call(this), this.getString = function() {
    return this.s;
  }, this.setString = function(nr) {
    this.hTLV = null, this.isModified = !0, this.s = nr, this.hV = stohex(this.s);
  }, this.setStringHex = function(nr) {
    this.hTLV = null, this.isModified = !0, this.s = null, this.hV = nr;
  }, this.getFreshValueHex = function() {
    return this.hV;
  }, typeof _n < "u" && (typeof _n == "string" ? this.setString(_n) : typeof _n.str < "u" ? this.setString(_n.str) : typeof _n.hex < "u" && this.setStringHex(_n.hex));
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
KJUR.asn1.DERAbstractTime = function(_n) {
  KJUR.asn1.DERAbstractTime.superclass.constructor.call(this), this.localDateToUTC = function(nr) {
    utc = nr.getTime() + nr.getTimezoneOffset() * 6e4;
    var Cn = new Date(utc);
    return Cn;
  }, this.formatDate = function(nr, Cn, Bn) {
    var In = this.zeroPadding, Dn = this.localDateToUTC(nr), Ln = String(Dn.getFullYear());
    Cn == "utc" && (Ln = Ln.substr(2, 2));
    var $n = In(String(Dn.getMonth() + 1), 2), Nn = In(String(Dn.getDate()), 2), Rn = In(String(Dn.getHours()), 2), Fn = In(String(Dn.getMinutes()), 2), Pn = In(String(Dn.getSeconds()), 2), Un = Ln + $n + Nn + Rn + Fn + Pn;
    if (Bn === !0) {
      var Hn = Dn.getMilliseconds();
      if (Hn != 0) {
        var zn = In(String(Hn), 3);
        zn = zn.replace(/[0]+$/, ""), Un = Un + "." + zn;
      }
    }
    return Un + "Z";
  }, this.zeroPadding = function(nr, Cn) {
    return nr.length >= Cn ? nr : new Array(Cn - nr.length + 1).join("0") + nr;
  }, this.getString = function() {
    return this.s;
  }, this.setString = function(nr) {
    this.hTLV = null, this.isModified = !0, this.s = nr, this.hV = stohex(nr);
  }, this.setByDateValue = function(nr, Cn, Bn, In, Dn, Ln) {
    var $n = new Date(Date.UTC(nr, Cn - 1, Bn, In, Dn, Ln, 0));
    this.setByDate($n);
  }, this.getFreshValueHex = function() {
    return this.hV;
  };
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
KJUR.asn1.DERAbstractStructured = function(_n) {
  KJUR.asn1.DERAbstractString.superclass.constructor.call(this), this.setByASN1ObjectArray = function(nr) {
    this.hTLV = null, this.isModified = !0, this.asn1Array = nr;
  }, this.appendASN1Object = function(nr) {
    this.hTLV = null, this.isModified = !0, this.asn1Array.push(nr);
  }, this.asn1Array = new Array(), typeof _n < "u" && typeof _n.array < "u" && (this.asn1Array = _n.array);
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);
KJUR.asn1.DERBoolean = function() {
  KJUR.asn1.DERBoolean.superclass.constructor.call(this), this.hT = "01", this.hTLV = "0101ff";
};
YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);
KJUR.asn1.DERInteger = function(_n) {
  KJUR.asn1.DERInteger.superclass.constructor.call(this), this.hT = "02", this.setByBigInteger = function(nr) {
    this.hTLV = null, this.isModified = !0, this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(nr);
  }, this.setByInteger = function(nr) {
    var Cn = new BigInteger(String(nr), 10);
    this.setByBigInteger(Cn);
  }, this.setValueHex = function(nr) {
    this.hV = nr;
  }, this.getFreshValueHex = function() {
    return this.hV;
  }, typeof _n < "u" && (typeof _n.bigint < "u" ? this.setByBigInteger(_n.bigint) : typeof _n.int < "u" ? this.setByInteger(_n.int) : typeof _n == "number" ? this.setByInteger(_n) : typeof _n.hex < "u" && this.setValueHex(_n.hex));
};
YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);
KJUR.asn1.DERBitString = function(_n) {
  if (_n !== void 0 && typeof _n.obj < "u") {
    var nr = KJUR.asn1.ASN1Util.newObject(_n.obj);
    _n.hex = "00" + nr.getEncodedHex();
  }
  KJUR.asn1.DERBitString.superclass.constructor.call(this), this.hT = "03", this.setHexValueIncludingUnusedBits = function(Cn) {
    this.hTLV = null, this.isModified = !0, this.hV = Cn;
  }, this.setUnusedBitsAndHexValue = function(Cn, Bn) {
    if (Cn < 0 || 7 < Cn)
      throw "unused bits shall be from 0 to 7: u = " + Cn;
    var In = "0" + Cn;
    this.hTLV = null, this.isModified = !0, this.hV = In + Bn;
  }, this.setByBinaryString = function(Cn) {
    Cn = Cn.replace(/0+$/, "");
    var Bn = 8 - Cn.length % 8;
    Bn == 8 && (Bn = 0);
    for (var In = 0; In <= Bn; In++)
      Cn += "0";
    for (var Dn = "", In = 0; In < Cn.length - 1; In += 8) {
      var Ln = Cn.substr(In, 8), $n = parseInt(Ln, 2).toString(16);
      $n.length == 1 && ($n = "0" + $n), Dn += $n;
    }
    this.hTLV = null, this.isModified = !0, this.hV = "0" + Bn + Dn;
  }, this.setByBooleanArray = function(Cn) {
    for (var Bn = "", In = 0; In < Cn.length; In++)
      Cn[In] == !0 ? Bn += "1" : Bn += "0";
    this.setByBinaryString(Bn);
  }, this.newFalseArray = function(Cn) {
    for (var Bn = new Array(Cn), In = 0; In < Cn; In++)
      Bn[In] = !1;
    return Bn;
  }, this.getFreshValueHex = function() {
    return this.hV;
  }, typeof _n < "u" && (typeof _n == "string" && _n.toLowerCase().match(/^[0-9a-f]+$/) ? this.setHexValueIncludingUnusedBits(_n) : typeof _n.hex < "u" ? this.setHexValueIncludingUnusedBits(_n.hex) : typeof _n.bin < "u" ? this.setByBinaryString(_n.bin) : typeof _n.array < "u" && this.setByBooleanArray(_n.array));
};
YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);
KJUR.asn1.DEROctetString = function(_n) {
  if (_n !== void 0 && typeof _n.obj < "u") {
    var nr = KJUR.asn1.ASN1Util.newObject(_n.obj);
    _n.hex = nr.getEncodedHex();
  }
  KJUR.asn1.DEROctetString.superclass.constructor.call(this, _n), this.hT = "04";
};
YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERNull = function() {
  KJUR.asn1.DERNull.superclass.constructor.call(this), this.hT = "05", this.hTLV = "0500";
};
YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);
KJUR.asn1.DERObjectIdentifier = function(_n) {
  var nr = function(Bn) {
    var In = Bn.toString(16);
    return In.length == 1 && (In = "0" + In), In;
  }, Cn = function(Bn) {
    var In = "", Dn = new BigInteger(Bn, 10), Ln = Dn.toString(2), $n = 7 - Ln.length % 7;
    $n == 7 && ($n = 0);
    for (var Nn = "", Rn = 0; Rn < $n; Rn++)
      Nn += "0";
    Ln = Nn + Ln;
    for (var Rn = 0; Rn < Ln.length - 1; Rn += 7) {
      var Fn = Ln.substr(Rn, 7);
      Rn != Ln.length - 7 && (Fn = "1" + Fn), In += nr(parseInt(Fn, 2));
    }
    return In;
  };
  KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this), this.hT = "06", this.setValueHex = function(Bn) {
    this.hTLV = null, this.isModified = !0, this.s = null, this.hV = Bn;
  }, this.setValueOidString = function(Bn) {
    if (!Bn.match(/^[0-9.]+$/))
      throw "malformed oid string: " + Bn;
    var In = "", Dn = Bn.split("."), Ln = parseInt(Dn[0]) * 40 + parseInt(Dn[1]);
    In += nr(Ln), Dn.splice(0, 2);
    for (var $n = 0; $n < Dn.length; $n++)
      In += Cn(Dn[$n]);
    this.hTLV = null, this.isModified = !0, this.s = null, this.hV = In;
  }, this.setValueName = function(Bn) {
    var In = KJUR.asn1.x509.OID.name2oid(Bn);
    if (In !== "")
      this.setValueOidString(In);
    else
      throw "DERObjectIdentifier oidName undefined: " + Bn;
  }, this.getFreshValueHex = function() {
    return this.hV;
  }, _n !== void 0 && (typeof _n == "string" ? _n.match(/^[0-2].[0-9.]+$/) ? this.setValueOidString(_n) : this.setValueName(_n) : _n.oid !== void 0 ? this.setValueOidString(_n.oid) : _n.hex !== void 0 ? this.setValueHex(_n.hex) : _n.name !== void 0 && this.setValueName(_n.name));
};
YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);
KJUR.asn1.DEREnumerated = function(_n) {
  KJUR.asn1.DEREnumerated.superclass.constructor.call(this), this.hT = "0a", this.setByBigInteger = function(nr) {
    this.hTLV = null, this.isModified = !0, this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(nr);
  }, this.setByInteger = function(nr) {
    var Cn = new BigInteger(String(nr), 10);
    this.setByBigInteger(Cn);
  }, this.setValueHex = function(nr) {
    this.hV = nr;
  }, this.getFreshValueHex = function() {
    return this.hV;
  }, typeof _n < "u" && (typeof _n.int < "u" ? this.setByInteger(_n.int) : typeof _n == "number" ? this.setByInteger(_n) : typeof _n.hex < "u" && this.setValueHex(_n.hex));
};
YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);
KJUR.asn1.DERUTF8String = function(_n) {
  KJUR.asn1.DERUTF8String.superclass.constructor.call(this, _n), this.hT = "0c";
};
YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERNumericString = function(_n) {
  KJUR.asn1.DERNumericString.superclass.constructor.call(this, _n), this.hT = "12";
};
YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERPrintableString = function(_n) {
  KJUR.asn1.DERPrintableString.superclass.constructor.call(this, _n), this.hT = "13";
};
YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERTeletexString = function(_n) {
  KJUR.asn1.DERTeletexString.superclass.constructor.call(this, _n), this.hT = "14";
};
YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERIA5String = function(_n) {
  KJUR.asn1.DERIA5String.superclass.constructor.call(this, _n), this.hT = "16";
};
YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERUTCTime = function(_n) {
  KJUR.asn1.DERUTCTime.superclass.constructor.call(this, _n), this.hT = "17", this.setByDate = function(nr) {
    this.hTLV = null, this.isModified = !0, this.date = nr, this.s = this.formatDate(this.date, "utc"), this.hV = stohex(this.s);
  }, this.getFreshValueHex = function() {
    return typeof this.date > "u" && typeof this.s > "u" && (this.date = /* @__PURE__ */ new Date(), this.s = this.formatDate(this.date, "utc"), this.hV = stohex(this.s)), this.hV;
  }, _n !== void 0 && (_n.str !== void 0 ? this.setString(_n.str) : typeof _n == "string" && _n.match(/^[0-9]{12}Z$/) ? this.setString(_n) : _n.hex !== void 0 ? this.setStringHex(_n.hex) : _n.date !== void 0 && this.setByDate(_n.date));
};
YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);
KJUR.asn1.DERGeneralizedTime = function(_n) {
  KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, _n), this.hT = "18", this.withMillis = !1, this.setByDate = function(nr) {
    this.hTLV = null, this.isModified = !0, this.date = nr, this.s = this.formatDate(this.date, "gen", this.withMillis), this.hV = stohex(this.s);
  }, this.getFreshValueHex = function() {
    return this.date === void 0 && this.s === void 0 && (this.date = /* @__PURE__ */ new Date(), this.s = this.formatDate(this.date, "gen", this.withMillis), this.hV = stohex(this.s)), this.hV;
  }, _n !== void 0 && (_n.str !== void 0 ? this.setString(_n.str) : typeof _n == "string" && _n.match(/^[0-9]{14}Z$/) ? this.setString(_n) : _n.hex !== void 0 ? this.setStringHex(_n.hex) : _n.date !== void 0 && this.setByDate(_n.date), _n.millis === !0 && (this.withMillis = !0));
};
YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);
KJUR.asn1.DERSequence = function(_n) {
  KJUR.asn1.DERSequence.superclass.constructor.call(this, _n), this.hT = "30", this.getFreshValueHex = function() {
    for (var nr = "", Cn = 0; Cn < this.asn1Array.length; Cn++) {
      var Bn = this.asn1Array[Cn];
      nr += Bn.getEncodedHex();
    }
    return this.hV = nr, this.hV;
  };
};
YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);
KJUR.asn1.DERSet = function(_n) {
  KJUR.asn1.DERSet.superclass.constructor.call(this, _n), this.hT = "31", this.sortFlag = !0, this.getFreshValueHex = function() {
    for (var nr = new Array(), Cn = 0; Cn < this.asn1Array.length; Cn++) {
      var Bn = this.asn1Array[Cn];
      nr.push(Bn.getEncodedHex());
    }
    return this.sortFlag == !0 && nr.sort(), this.hV = nr.join(""), this.hV;
  }, typeof _n < "u" && typeof _n.sortflag < "u" && _n.sortflag == !1 && (this.sortFlag = !1);
};
YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);
KJUR.asn1.DERTaggedObject = function(_n) {
  KJUR.asn1.DERTaggedObject.superclass.constructor.call(this), this.hT = "a0", this.hV = "", this.isExplicit = !0, this.asn1Object = null, this.setASN1Object = function(nr, Cn, Bn) {
    this.hT = Cn, this.isExplicit = nr, this.asn1Object = Bn, this.isExplicit ? (this.hV = this.asn1Object.getEncodedHex(), this.hTLV = null, this.isModified = !0) : (this.hV = null, this.hTLV = Bn.getEncodedHex(), this.hTLV = this.hTLV.replace(/^../, Cn), this.isModified = !1);
  }, this.getFreshValueHex = function() {
    return this.hV;
  }, typeof _n < "u" && (typeof _n.tag < "u" && (this.hT = _n.tag), typeof _n.explicit < "u" && (this.isExplicit = _n.explicit), typeof _n.obj < "u" && (this.asn1Object = _n.obj, this.setASN1Object(this.isExplicit, this.hT, this.asn1Object)));
};
YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);
var __extends = globalThis && globalThis.__extends || function() {
  var _n = function(nr, Cn) {
    return _n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Bn, In) {
      Bn.__proto__ = In;
    } || function(Bn, In) {
      for (var Dn in In)
        Object.prototype.hasOwnProperty.call(In, Dn) && (Bn[Dn] = In[Dn]);
    }, _n(nr, Cn);
  };
  return function(nr, Cn) {
    if (typeof Cn != "function" && Cn !== null)
      throw new TypeError("Class extends value " + String(Cn) + " is not a constructor or null");
    _n(nr, Cn);
    function Bn() {
      this.constructor = nr;
    }
    nr.prototype = Cn === null ? Object.create(Cn) : (Bn.prototype = Cn.prototype, new Bn());
  };
}(), JSEncryptRSAKey = (
  /** @class */
  function(_n) {
    __extends(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this) || this;
      return Cn && (typeof Cn == "string" ? Bn.parseKey(Cn) : (nr.hasPrivateKeyProperty(Cn) || nr.hasPublicKeyProperty(Cn)) && Bn.parsePropertiesFrom(Cn)), Bn;
    }
    return nr.prototype.parseKey = function(Cn) {
      try {
        var Bn = 0, In = 0, Dn = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/, Ln = Dn.test(Cn) ? Hex.decode(Cn) : Base64.unarmor(Cn), $n = ASN1.decode(Ln);
        if ($n.sub.length === 3 && ($n = $n.sub[2].sub[0]), $n.sub.length === 9) {
          Bn = $n.sub[1].getHexStringValue(), this.n = parseBigInt(Bn, 16), In = $n.sub[2].getHexStringValue(), this.e = parseInt(In, 16);
          var Nn = $n.sub[3].getHexStringValue();
          this.d = parseBigInt(Nn, 16);
          var Rn = $n.sub[4].getHexStringValue();
          this.p = parseBigInt(Rn, 16);
          var Fn = $n.sub[5].getHexStringValue();
          this.q = parseBigInt(Fn, 16);
          var Pn = $n.sub[6].getHexStringValue();
          this.dmp1 = parseBigInt(Pn, 16);
          var Un = $n.sub[7].getHexStringValue();
          this.dmq1 = parseBigInt(Un, 16);
          var Hn = $n.sub[8].getHexStringValue();
          this.coeff = parseBigInt(Hn, 16);
        } else if ($n.sub.length === 2)
          if ($n.sub[0].sub) {
            var zn = $n.sub[1], Gn = zn.sub[0];
            Bn = Gn.sub[0].getHexStringValue(), this.n = parseBigInt(Bn, 16), In = Gn.sub[1].getHexStringValue(), this.e = parseInt(In, 16);
          } else
            Bn = $n.sub[0].getHexStringValue(), this.n = parseBigInt(Bn, 16), In = $n.sub[1].getHexStringValue(), this.e = parseInt(In, 16);
        else
          return !1;
        return !0;
      } catch {
        return !1;
      }
    }, nr.prototype.getPrivateBaseKey = function() {
      var Cn = {
        array: [
          new KJUR.asn1.DERInteger({ int: 0 }),
          new KJUR.asn1.DERInteger({ bigint: this.n }),
          new KJUR.asn1.DERInteger({ int: this.e }),
          new KJUR.asn1.DERInteger({ bigint: this.d }),
          new KJUR.asn1.DERInteger({ bigint: this.p }),
          new KJUR.asn1.DERInteger({ bigint: this.q }),
          new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),
          new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),
          new KJUR.asn1.DERInteger({ bigint: this.coeff })
        ]
      }, Bn = new KJUR.asn1.DERSequence(Cn);
      return Bn.getEncodedHex();
    }, nr.prototype.getPrivateBaseKeyB64 = function() {
      return hex2b64(this.getPrivateBaseKey());
    }, nr.prototype.getPublicBaseKey = function() {
      var Cn = new KJUR.asn1.DERSequence({
        array: [
          new KJUR.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }),
          new KJUR.asn1.DERNull()
        ]
      }), Bn = new KJUR.asn1.DERSequence({
        array: [
          new KJUR.asn1.DERInteger({ bigint: this.n }),
          new KJUR.asn1.DERInteger({ int: this.e })
        ]
      }), In = new KJUR.asn1.DERBitString({
        hex: "00" + Bn.getEncodedHex()
      }), Dn = new KJUR.asn1.DERSequence({
        array: [Cn, In]
      });
      return Dn.getEncodedHex();
    }, nr.prototype.getPublicBaseKeyB64 = function() {
      return hex2b64(this.getPublicBaseKey());
    }, nr.wordwrap = function(Cn, Bn) {
      if (Bn = Bn || 64, !Cn)
        return Cn;
      var In = "(.{1," + Bn + `})( +|$
?)|(.{1,` + Bn + "})";
      return Cn.match(RegExp(In, "g")).join(`
`);
    }, nr.prototype.getPrivateKey = function() {
      var Cn = `-----BEGIN RSA PRIVATE KEY-----
`;
      return Cn += nr.wordwrap(this.getPrivateBaseKeyB64()) + `
`, Cn += "-----END RSA PRIVATE KEY-----", Cn;
    }, nr.prototype.getPublicKey = function() {
      var Cn = `-----BEGIN PUBLIC KEY-----
`;
      return Cn += nr.wordwrap(this.getPublicBaseKeyB64()) + `
`, Cn += "-----END PUBLIC KEY-----", Cn;
    }, nr.hasPublicKeyProperty = function(Cn) {
      return Cn = Cn || {}, Cn.hasOwnProperty("n") && Cn.hasOwnProperty("e");
    }, nr.hasPrivateKeyProperty = function(Cn) {
      return Cn = Cn || {}, Cn.hasOwnProperty("n") && Cn.hasOwnProperty("e") && Cn.hasOwnProperty("d") && Cn.hasOwnProperty("p") && Cn.hasOwnProperty("q") && Cn.hasOwnProperty("dmp1") && Cn.hasOwnProperty("dmq1") && Cn.hasOwnProperty("coeff");
    }, nr.prototype.parsePropertiesFrom = function(Cn) {
      this.n = Cn.n, this.e = Cn.e, Cn.hasOwnProperty("d") && (this.d = Cn.d, this.p = Cn.p, this.q = Cn.q, this.dmp1 = Cn.dmp1, this.dmq1 = Cn.dmq1, this.coeff = Cn.coeff);
    }, nr;
  }(RSAKey)
), _a, version$1 = typeof process < "u" ? (_a = process.env) === null || _a === void 0 ? void 0 : _a.npm_package_version : void 0, JSEncrypt = (
  /** @class */
  function() {
    function _n(nr) {
      nr === void 0 && (nr = {}), nr = nr || {}, this.default_key_size = nr.default_key_size ? parseInt(nr.default_key_size, 10) : 1024, this.default_public_exponent = nr.default_public_exponent || "010001", this.log = nr.log || !1, this.key = null;
    }
    return _n.prototype.setKey = function(nr) {
      this.log && this.key && console.warn("A key was already set, overriding existing."), this.key = new JSEncryptRSAKey(nr);
    }, _n.prototype.setPrivateKey = function(nr) {
      this.setKey(nr);
    }, _n.prototype.setPublicKey = function(nr) {
      this.setKey(nr);
    }, _n.prototype.decrypt = function(nr) {
      try {
        return this.getKey().decrypt(b64tohex(nr));
      } catch {
        return !1;
      }
    }, _n.prototype.encrypt = function(nr) {
      try {
        return hex2b64(this.getKey().encrypt(nr));
      } catch {
        return !1;
      }
    }, _n.prototype.sign = function(nr, Cn, Bn) {
      try {
        return hex2b64(this.getKey().sign(nr, Cn, Bn));
      } catch {
        return !1;
      }
    }, _n.prototype.verify = function(nr, Cn, Bn) {
      try {
        return this.getKey().verify(nr, b64tohex(Cn), Bn);
      } catch {
        return !1;
      }
    }, _n.prototype.getKey = function(nr) {
      if (!this.key) {
        if (this.key = new JSEncryptRSAKey(), nr && {}.toString.call(nr) === "[object Function]") {
          this.key.generateAsync(this.default_key_size, this.default_public_exponent, nr);
          return;
        }
        this.key.generate(this.default_key_size, this.default_public_exponent);
      }
      return this.key;
    }, _n.prototype.getPrivateKey = function() {
      return this.getKey().getPrivateKey();
    }, _n.prototype.getPrivateKeyB64 = function() {
      return this.getKey().getPrivateBaseKeyB64();
    }, _n.prototype.getPublicKey = function() {
      return this.getKey().getPublicKey();
    }, _n.prototype.getPublicKeyB64 = function() {
      return this.getKey().getPublicBaseKeyB64();
    }, _n.version = version$1, _n;
  }()
);
function encryptWithRSA(_n, nr) {
  const Cn = new JSEncrypt();
  return Cn.setPublicKey(_n), Cn.encrypt(nr);
}
var cryptoJs = { exports: {} };
function commonjsRequire(_n) {
  throw new Error('Could not dynamically require "' + _n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredCore;
function requireCore() {
  return hasRequiredCore || (hasRequiredCore = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn();
    })(commonjsGlobal, function() {
      var Cn = Cn || function(Bn, In) {
        var Dn;
        if (typeof window < "u" && window.crypto && (Dn = window.crypto), typeof self < "u" && self.crypto && (Dn = self.crypto), typeof globalThis < "u" && globalThis.crypto && (Dn = globalThis.crypto), !Dn && typeof window < "u" && window.msCrypto && (Dn = window.msCrypto), !Dn && typeof commonjsGlobal < "u" && commonjsGlobal.crypto && (Dn = commonjsGlobal.crypto), !Dn && typeof commonjsRequire == "function")
          try {
            Dn = require$$0;
          } catch {
          }
        var Ln = function() {
          if (Dn) {
            if (typeof Dn.getRandomValues == "function")
              try {
                return Dn.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof Dn.randomBytes == "function")
              try {
                return Dn.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, $n = Object.create || function() {
          function Xn() {
          }
          return function(ea) {
            var ta;
            return Xn.prototype = ea, ta = new Xn(), Xn.prototype = null, ta;
          };
        }(), Nn = {}, Rn = Nn.lib = {}, Fn = Rn.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(Xn) {
              var ea = $n(this);
              return Xn && ea.mixIn(Xn), (!ea.hasOwnProperty("init") || this.init === ea.init) && (ea.init = function() {
                ea.$super.init.apply(this, arguments);
              }), ea.init.prototype = ea, ea.$super = this, ea;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var Xn = this.extend();
              return Xn.init.apply(Xn, arguments), Xn;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(Xn) {
              for (var ea in Xn)
                Xn.hasOwnProperty(ea) && (this[ea] = Xn[ea]);
              Xn.hasOwnProperty("toString") && (this.toString = Xn.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), Pn = Rn.WordArray = Fn.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(Xn, ea) {
            Xn = this.words = Xn || [], ea != In ? this.sigBytes = ea : this.sigBytes = Xn.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(Xn) {
            return (Xn || Hn).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(Xn) {
            var ea = this.words, ta = Xn.words, na = this.sigBytes, ra = Xn.sigBytes;
            if (this.clamp(), na % 4)
              for (var aa = 0; aa < ra; aa++) {
                var ia = ta[aa >>> 2] >>> 24 - aa % 4 * 8 & 255;
                ea[na + aa >>> 2] |= ia << 24 - (na + aa) % 4 * 8;
              }
            else
              for (var Aa = 0; Aa < ra; Aa += 4)
                ea[na + Aa >>> 2] = ta[Aa >>> 2];
            return this.sigBytes += ra, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var Xn = this.words, ea = this.sigBytes;
            Xn[ea >>> 2] &= 4294967295 << 32 - ea % 4 * 8, Xn.length = Bn.ceil(ea / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var Xn = Fn.clone.call(this);
            return Xn.words = this.words.slice(0), Xn;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(Xn) {
            for (var ea = [], ta = 0; ta < Xn; ta += 4)
              ea.push(Ln());
            return new Pn.init(ea, Xn);
          }
        }), Un = Nn.enc = {}, Hn = Un.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(Xn) {
            for (var ea = Xn.words, ta = Xn.sigBytes, na = [], ra = 0; ra < ta; ra++) {
              var aa = ea[ra >>> 2] >>> 24 - ra % 4 * 8 & 255;
              na.push((aa >>> 4).toString(16)), na.push((aa & 15).toString(16));
            }
            return na.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(Xn) {
            for (var ea = Xn.length, ta = [], na = 0; na < ea; na += 2)
              ta[na >>> 3] |= parseInt(Xn.substr(na, 2), 16) << 24 - na % 8 * 4;
            return new Pn.init(ta, ea / 2);
          }
        }, zn = Un.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(Xn) {
            for (var ea = Xn.words, ta = Xn.sigBytes, na = [], ra = 0; ra < ta; ra++) {
              var aa = ea[ra >>> 2] >>> 24 - ra % 4 * 8 & 255;
              na.push(String.fromCharCode(aa));
            }
            return na.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(Xn) {
            for (var ea = Xn.length, ta = [], na = 0; na < ea; na++)
              ta[na >>> 2] |= (Xn.charCodeAt(na) & 255) << 24 - na % 4 * 8;
            return new Pn.init(ta, ea);
          }
        }, Gn = Un.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(Xn) {
            try {
              return decodeURIComponent(escape(zn.stringify(Xn)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(Xn) {
            return zn.parse(unescape(encodeURIComponent(Xn)));
          }
        }, Yn = Rn.BufferedBlockAlgorithm = Fn.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new Pn.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(Xn) {
            typeof Xn == "string" && (Xn = Gn.parse(Xn)), this._data.concat(Xn), this._nDataBytes += Xn.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(Xn) {
            var ea, ta = this._data, na = ta.words, ra = ta.sigBytes, aa = this.blockSize, ia = aa * 4, Aa = ra / ia;
            Xn ? Aa = Bn.ceil(Aa) : Aa = Bn.max((Aa | 0) - this._minBufferSize, 0);
            var sa = Aa * aa, oa = Bn.min(sa * 4, ra);
            if (sa) {
              for (var la = 0; la < sa; la += aa)
                this._doProcessBlock(na, la);
              ea = na.splice(0, sa), ta.sigBytes -= oa;
            }
            return new Pn.init(ea, oa);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var Xn = Fn.clone.call(this);
            return Xn._data = this._data.clone(), Xn;
          },
          _minBufferSize: 0
        });
        Rn.Hasher = Yn.extend({
          /**
           * Configuration options.
           */
          cfg: Fn.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(Xn) {
            this.cfg = this.cfg.extend(Xn), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            Yn.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(Xn) {
            return this._append(Xn), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(Xn) {
            Xn && this._append(Xn);
            var ea = this._doFinalize();
            return ea;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(Xn) {
            return function(ea, ta) {
              return new Xn.init(ta).finalize(ea);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(Xn) {
            return function(ea, ta) {
              return new Wn.HMAC.init(Xn, ta).finalize(ea);
            };
          }
        });
        var Wn = Nn.algo = {};
        return Nn;
      }(Math);
      return Cn;
    });
  }(core)), core.exports;
}
var x64Core = { exports: {} }, hasRequiredX64Core;
function requireX64Core() {
  return hasRequiredX64Core || (hasRequiredX64Core = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      return function(Bn) {
        var In = Cn, Dn = In.lib, Ln = Dn.Base, $n = Dn.WordArray, Nn = In.x64 = {};
        Nn.Word = Ln.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(Rn, Fn) {
            this.high = Rn, this.low = Fn;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        }), Nn.WordArray = Ln.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(Rn, Fn) {
            Rn = this.words = Rn || [], Fn != Bn ? this.sigBytes = Fn : this.sigBytes = Rn.length * 8;
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            for (var Rn = this.words, Fn = Rn.length, Pn = [], Un = 0; Un < Fn; Un++) {
              var Hn = Rn[Un];
              Pn.push(Hn.high), Pn.push(Hn.low);
            }
            return $n.create(Pn, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            for (var Rn = Ln.clone.call(this), Fn = Rn.words = this.words.slice(0), Pn = Fn.length, Un = 0; Un < Pn; Un++)
              Fn[Un] = Fn[Un].clone();
            return Rn;
          }
        });
      }(), Cn;
    });
  }(x64Core)), x64Core.exports;
}
var libTypedarrays = { exports: {} }, hasRequiredLibTypedarrays;
function requireLibTypedarrays() {
  return hasRequiredLibTypedarrays || (hasRequiredLibTypedarrays = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        if (typeof ArrayBuffer == "function") {
          var Bn = Cn, In = Bn.lib, Dn = In.WordArray, Ln = Dn.init, $n = Dn.init = function(Nn) {
            if (Nn instanceof ArrayBuffer && (Nn = new Uint8Array(Nn)), (Nn instanceof Int8Array || typeof Uint8ClampedArray < "u" && Nn instanceof Uint8ClampedArray || Nn instanceof Int16Array || Nn instanceof Uint16Array || Nn instanceof Int32Array || Nn instanceof Uint32Array || Nn instanceof Float32Array || Nn instanceof Float64Array) && (Nn = new Uint8Array(Nn.buffer, Nn.byteOffset, Nn.byteLength)), Nn instanceof Uint8Array) {
              for (var Rn = Nn.byteLength, Fn = [], Pn = 0; Pn < Rn; Pn++)
                Fn[Pn >>> 2] |= Nn[Pn] << 24 - Pn % 4 * 8;
              Ln.call(this, Fn, Rn);
            } else
              Ln.apply(this, arguments);
          };
          $n.prototype = Dn;
        }
      }(), Cn.lib.WordArray;
    });
  }(libTypedarrays)), libTypedarrays.exports;
}
var encUtf16 = { exports: {} }, hasRequiredEncUtf16;
function requireEncUtf16() {
  return hasRequiredEncUtf16 || (hasRequiredEncUtf16 = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.WordArray, Ln = Bn.enc;
        Ln.Utf16 = Ln.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(Nn) {
            for (var Rn = Nn.words, Fn = Nn.sigBytes, Pn = [], Un = 0; Un < Fn; Un += 2) {
              var Hn = Rn[Un >>> 2] >>> 16 - Un % 4 * 8 & 65535;
              Pn.push(String.fromCharCode(Hn));
            }
            return Pn.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(Nn) {
            for (var Rn = Nn.length, Fn = [], Pn = 0; Pn < Rn; Pn++)
              Fn[Pn >>> 1] |= Nn.charCodeAt(Pn) << 16 - Pn % 2 * 16;
            return Dn.create(Fn, Rn * 2);
          }
        }, Ln.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(Nn) {
            for (var Rn = Nn.words, Fn = Nn.sigBytes, Pn = [], Un = 0; Un < Fn; Un += 2) {
              var Hn = $n(Rn[Un >>> 2] >>> 16 - Un % 4 * 8 & 65535);
              Pn.push(String.fromCharCode(Hn));
            }
            return Pn.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(Nn) {
            for (var Rn = Nn.length, Fn = [], Pn = 0; Pn < Rn; Pn++)
              Fn[Pn >>> 1] |= $n(Nn.charCodeAt(Pn) << 16 - Pn % 2 * 16);
            return Dn.create(Fn, Rn * 2);
          }
        };
        function $n(Nn) {
          return Nn << 8 & 4278255360 | Nn >>> 8 & 16711935;
        }
      }(), Cn.enc.Utf16;
    });
  }(encUtf16)), encUtf16.exports;
}
var encBase64 = { exports: {} }, hasRequiredEncBase64;
function requireEncBase64() {
  return hasRequiredEncBase64 || (hasRequiredEncBase64 = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.WordArray, Ln = Bn.enc;
        Ln.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(Nn) {
            var Rn = Nn.words, Fn = Nn.sigBytes, Pn = this._map;
            Nn.clamp();
            for (var Un = [], Hn = 0; Hn < Fn; Hn += 3)
              for (var zn = Rn[Hn >>> 2] >>> 24 - Hn % 4 * 8 & 255, Gn = Rn[Hn + 1 >>> 2] >>> 24 - (Hn + 1) % 4 * 8 & 255, Yn = Rn[Hn + 2 >>> 2] >>> 24 - (Hn + 2) % 4 * 8 & 255, Wn = zn << 16 | Gn << 8 | Yn, Xn = 0; Xn < 4 && Hn + Xn * 0.75 < Fn; Xn++)
                Un.push(Pn.charAt(Wn >>> 6 * (3 - Xn) & 63));
            var ea = Pn.charAt(64);
            if (ea)
              for (; Un.length % 4; )
                Un.push(ea);
            return Un.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(Nn) {
            var Rn = Nn.length, Fn = this._map, Pn = this._reverseMap;
            if (!Pn) {
              Pn = this._reverseMap = [];
              for (var Un = 0; Un < Fn.length; Un++)
                Pn[Fn.charCodeAt(Un)] = Un;
            }
            var Hn = Fn.charAt(64);
            if (Hn) {
              var zn = Nn.indexOf(Hn);
              zn !== -1 && (Rn = zn);
            }
            return $n(Nn, Rn, Pn);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function $n(Nn, Rn, Fn) {
          for (var Pn = [], Un = 0, Hn = 0; Hn < Rn; Hn++)
            if (Hn % 4) {
              var zn = Fn[Nn.charCodeAt(Hn - 1)] << Hn % 4 * 2, Gn = Fn[Nn.charCodeAt(Hn)] >>> 6 - Hn % 4 * 2, Yn = zn | Gn;
              Pn[Un >>> 2] |= Yn << 24 - Un % 4 * 8, Un++;
            }
          return Dn.create(Pn, Un);
        }
      }(), Cn.enc.Base64;
    });
  }(encBase64)), encBase64.exports;
}
var encBase64url = { exports: {} }, hasRequiredEncBase64url;
function requireEncBase64url() {
  return hasRequiredEncBase64url || (hasRequiredEncBase64url = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.WordArray, Ln = Bn.enc;
        Ln.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(Nn, Rn) {
            Rn === void 0 && (Rn = !0);
            var Fn = Nn.words, Pn = Nn.sigBytes, Un = Rn ? this._safe_map : this._map;
            Nn.clamp();
            for (var Hn = [], zn = 0; zn < Pn; zn += 3)
              for (var Gn = Fn[zn >>> 2] >>> 24 - zn % 4 * 8 & 255, Yn = Fn[zn + 1 >>> 2] >>> 24 - (zn + 1) % 4 * 8 & 255, Wn = Fn[zn + 2 >>> 2] >>> 24 - (zn + 2) % 4 * 8 & 255, Xn = Gn << 16 | Yn << 8 | Wn, ea = 0; ea < 4 && zn + ea * 0.75 < Pn; ea++)
                Hn.push(Un.charAt(Xn >>> 6 * (3 - ea) & 63));
            var ta = Un.charAt(64);
            if (ta)
              for (; Hn.length % 4; )
                Hn.push(ta);
            return Hn.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(Nn, Rn) {
            Rn === void 0 && (Rn = !0);
            var Fn = Nn.length, Pn = Rn ? this._safe_map : this._map, Un = this._reverseMap;
            if (!Un) {
              Un = this._reverseMap = [];
              for (var Hn = 0; Hn < Pn.length; Hn++)
                Un[Pn.charCodeAt(Hn)] = Hn;
            }
            var zn = Pn.charAt(64);
            if (zn) {
              var Gn = Nn.indexOf(zn);
              Gn !== -1 && (Fn = Gn);
            }
            return $n(Nn, Fn, Un);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function $n(Nn, Rn, Fn) {
          for (var Pn = [], Un = 0, Hn = 0; Hn < Rn; Hn++)
            if (Hn % 4) {
              var zn = Fn[Nn.charCodeAt(Hn - 1)] << Hn % 4 * 2, Gn = Fn[Nn.charCodeAt(Hn)] >>> 6 - Hn % 4 * 2, Yn = zn | Gn;
              Pn[Un >>> 2] |= Yn << 24 - Un % 4 * 8, Un++;
            }
          return Dn.create(Pn, Un);
        }
      }(), Cn.enc.Base64url;
    });
  }(encBase64url)), encBase64url.exports;
}
var md5 = { exports: {} }, hasRequiredMd5;
function requireMd5() {
  return hasRequiredMd5 || (hasRequiredMd5 = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      return function(Bn) {
        var In = Cn, Dn = In.lib, Ln = Dn.WordArray, $n = Dn.Hasher, Nn = In.algo, Rn = [];
        (function() {
          for (var Gn = 0; Gn < 64; Gn++)
            Rn[Gn] = Bn.abs(Bn.sin(Gn + 1)) * 4294967296 | 0;
        })();
        var Fn = Nn.MD5 = $n.extend({
          _doReset: function() {
            this._hash = new Ln.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(Gn, Yn) {
            for (var Wn = 0; Wn < 16; Wn++) {
              var Xn = Yn + Wn, ea = Gn[Xn];
              Gn[Xn] = (ea << 8 | ea >>> 24) & 16711935 | (ea << 24 | ea >>> 8) & 4278255360;
            }
            var ta = this._hash.words, na = Gn[Yn + 0], ra = Gn[Yn + 1], aa = Gn[Yn + 2], ia = Gn[Yn + 3], Aa = Gn[Yn + 4], sa = Gn[Yn + 5], oa = Gn[Yn + 6], la = Gn[Yn + 7], ua = Gn[Yn + 8], ca = Gn[Yn + 9], fa = Gn[Yn + 10], ha = Gn[Yn + 11], pa = Gn[Yn + 12], ya = Gn[Yn + 13], da = Gn[Yn + 14], Ca = Gn[Yn + 15], ma = ta[0], va = ta[1], ga = ta[2], xa = ta[3];
            ma = Pn(ma, va, ga, xa, na, 7, Rn[0]), xa = Pn(xa, ma, va, ga, ra, 12, Rn[1]), ga = Pn(ga, xa, ma, va, aa, 17, Rn[2]), va = Pn(va, ga, xa, ma, ia, 22, Rn[3]), ma = Pn(ma, va, ga, xa, Aa, 7, Rn[4]), xa = Pn(xa, ma, va, ga, sa, 12, Rn[5]), ga = Pn(ga, xa, ma, va, oa, 17, Rn[6]), va = Pn(va, ga, xa, ma, la, 22, Rn[7]), ma = Pn(ma, va, ga, xa, ua, 7, Rn[8]), xa = Pn(xa, ma, va, ga, ca, 12, Rn[9]), ga = Pn(ga, xa, ma, va, fa, 17, Rn[10]), va = Pn(va, ga, xa, ma, ha, 22, Rn[11]), ma = Pn(ma, va, ga, xa, pa, 7, Rn[12]), xa = Pn(xa, ma, va, ga, ya, 12, Rn[13]), ga = Pn(ga, xa, ma, va, da, 17, Rn[14]), va = Pn(va, ga, xa, ma, Ca, 22, Rn[15]), ma = Un(ma, va, ga, xa, ra, 5, Rn[16]), xa = Un(xa, ma, va, ga, oa, 9, Rn[17]), ga = Un(ga, xa, ma, va, ha, 14, Rn[18]), va = Un(va, ga, xa, ma, na, 20, Rn[19]), ma = Un(ma, va, ga, xa, sa, 5, Rn[20]), xa = Un(xa, ma, va, ga, fa, 9, Rn[21]), ga = Un(ga, xa, ma, va, Ca, 14, Rn[22]), va = Un(va, ga, xa, ma, Aa, 20, Rn[23]), ma = Un(ma, va, ga, xa, ca, 5, Rn[24]), xa = Un(xa, ma, va, ga, da, 9, Rn[25]), ga = Un(ga, xa, ma, va, ia, 14, Rn[26]), va = Un(va, ga, xa, ma, ua, 20, Rn[27]), ma = Un(ma, va, ga, xa, ya, 5, Rn[28]), xa = Un(xa, ma, va, ga, aa, 9, Rn[29]), ga = Un(ga, xa, ma, va, la, 14, Rn[30]), va = Un(va, ga, xa, ma, pa, 20, Rn[31]), ma = Hn(ma, va, ga, xa, sa, 4, Rn[32]), xa = Hn(xa, ma, va, ga, ua, 11, Rn[33]), ga = Hn(ga, xa, ma, va, ha, 16, Rn[34]), va = Hn(va, ga, xa, ma, da, 23, Rn[35]), ma = Hn(ma, va, ga, xa, ra, 4, Rn[36]), xa = Hn(xa, ma, va, ga, Aa, 11, Rn[37]), ga = Hn(ga, xa, ma, va, la, 16, Rn[38]), va = Hn(va, ga, xa, ma, fa, 23, Rn[39]), ma = Hn(ma, va, ga, xa, ya, 4, Rn[40]), xa = Hn(xa, ma, va, ga, na, 11, Rn[41]), ga = Hn(ga, xa, ma, va, ia, 16, Rn[42]), va = Hn(va, ga, xa, ma, oa, 23, Rn[43]), ma = Hn(ma, va, ga, xa, ca, 4, Rn[44]), xa = Hn(xa, ma, va, ga, pa, 11, Rn[45]), ga = Hn(ga, xa, ma, va, Ca, 16, Rn[46]), va = Hn(va, ga, xa, ma, aa, 23, Rn[47]), ma = zn(ma, va, ga, xa, na, 6, Rn[48]), xa = zn(xa, ma, va, ga, la, 10, Rn[49]), ga = zn(ga, xa, ma, va, da, 15, Rn[50]), va = zn(va, ga, xa, ma, sa, 21, Rn[51]), ma = zn(ma, va, ga, xa, pa, 6, Rn[52]), xa = zn(xa, ma, va, ga, ia, 10, Rn[53]), ga = zn(ga, xa, ma, va, fa, 15, Rn[54]), va = zn(va, ga, xa, ma, ra, 21, Rn[55]), ma = zn(ma, va, ga, xa, ua, 6, Rn[56]), xa = zn(xa, ma, va, ga, Ca, 10, Rn[57]), ga = zn(ga, xa, ma, va, oa, 15, Rn[58]), va = zn(va, ga, xa, ma, ya, 21, Rn[59]), ma = zn(ma, va, ga, xa, Aa, 6, Rn[60]), xa = zn(xa, ma, va, ga, ha, 10, Rn[61]), ga = zn(ga, xa, ma, va, aa, 15, Rn[62]), va = zn(va, ga, xa, ma, ca, 21, Rn[63]), ta[0] = ta[0] + ma | 0, ta[1] = ta[1] + va | 0, ta[2] = ta[2] + ga | 0, ta[3] = ta[3] + xa | 0;
          },
          _doFinalize: function() {
            var Gn = this._data, Yn = Gn.words, Wn = this._nDataBytes * 8, Xn = Gn.sigBytes * 8;
            Yn[Xn >>> 5] |= 128 << 24 - Xn % 32;
            var ea = Bn.floor(Wn / 4294967296), ta = Wn;
            Yn[(Xn + 64 >>> 9 << 4) + 15] = (ea << 8 | ea >>> 24) & 16711935 | (ea << 24 | ea >>> 8) & 4278255360, Yn[(Xn + 64 >>> 9 << 4) + 14] = (ta << 8 | ta >>> 24) & 16711935 | (ta << 24 | ta >>> 8) & 4278255360, Gn.sigBytes = (Yn.length + 1) * 4, this._process();
            for (var na = this._hash, ra = na.words, aa = 0; aa < 4; aa++) {
              var ia = ra[aa];
              ra[aa] = (ia << 8 | ia >>> 24) & 16711935 | (ia << 24 | ia >>> 8) & 4278255360;
            }
            return na;
          },
          clone: function() {
            var Gn = $n.clone.call(this);
            return Gn._hash = this._hash.clone(), Gn;
          }
        });
        function Pn(Gn, Yn, Wn, Xn, ea, ta, na) {
          var ra = Gn + (Yn & Wn | ~Yn & Xn) + ea + na;
          return (ra << ta | ra >>> 32 - ta) + Yn;
        }
        function Un(Gn, Yn, Wn, Xn, ea, ta, na) {
          var ra = Gn + (Yn & Xn | Wn & ~Xn) + ea + na;
          return (ra << ta | ra >>> 32 - ta) + Yn;
        }
        function Hn(Gn, Yn, Wn, Xn, ea, ta, na) {
          var ra = Gn + (Yn ^ Wn ^ Xn) + ea + na;
          return (ra << ta | ra >>> 32 - ta) + Yn;
        }
        function zn(Gn, Yn, Wn, Xn, ea, ta, na) {
          var ra = Gn + (Wn ^ (Yn | ~Xn)) + ea + na;
          return (ra << ta | ra >>> 32 - ta) + Yn;
        }
        In.MD5 = $n._createHelper(Fn), In.HmacMD5 = $n._createHmacHelper(Fn);
      }(Math), Cn.MD5;
    });
  }(md5)), md5.exports;
}
var sha1 = { exports: {} }, hasRequiredSha1;
function requireSha1() {
  return hasRequiredSha1 || (hasRequiredSha1 = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.WordArray, Ln = In.Hasher, $n = Bn.algo, Nn = [], Rn = $n.SHA1 = Ln.extend({
          _doReset: function() {
            this._hash = new Dn.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(Fn, Pn) {
            for (var Un = this._hash.words, Hn = Un[0], zn = Un[1], Gn = Un[2], Yn = Un[3], Wn = Un[4], Xn = 0; Xn < 80; Xn++) {
              if (Xn < 16)
                Nn[Xn] = Fn[Pn + Xn] | 0;
              else {
                var ea = Nn[Xn - 3] ^ Nn[Xn - 8] ^ Nn[Xn - 14] ^ Nn[Xn - 16];
                Nn[Xn] = ea << 1 | ea >>> 31;
              }
              var ta = (Hn << 5 | Hn >>> 27) + Wn + Nn[Xn];
              Xn < 20 ? ta += (zn & Gn | ~zn & Yn) + 1518500249 : Xn < 40 ? ta += (zn ^ Gn ^ Yn) + 1859775393 : Xn < 60 ? ta += (zn & Gn | zn & Yn | Gn & Yn) - 1894007588 : ta += (zn ^ Gn ^ Yn) - 899497514, Wn = Yn, Yn = Gn, Gn = zn << 30 | zn >>> 2, zn = Hn, Hn = ta;
            }
            Un[0] = Un[0] + Hn | 0, Un[1] = Un[1] + zn | 0, Un[2] = Un[2] + Gn | 0, Un[3] = Un[3] + Yn | 0, Un[4] = Un[4] + Wn | 0;
          },
          _doFinalize: function() {
            var Fn = this._data, Pn = Fn.words, Un = this._nDataBytes * 8, Hn = Fn.sigBytes * 8;
            return Pn[Hn >>> 5] |= 128 << 24 - Hn % 32, Pn[(Hn + 64 >>> 9 << 4) + 14] = Math.floor(Un / 4294967296), Pn[(Hn + 64 >>> 9 << 4) + 15] = Un, Fn.sigBytes = Pn.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var Fn = Ln.clone.call(this);
            return Fn._hash = this._hash.clone(), Fn;
          }
        });
        Bn.SHA1 = Ln._createHelper(Rn), Bn.HmacSHA1 = Ln._createHmacHelper(Rn);
      }(), Cn.SHA1;
    });
  }(sha1)), sha1.exports;
}
var sha256 = { exports: {} }, hasRequiredSha256;
function requireSha256() {
  return hasRequiredSha256 || (hasRequiredSha256 = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      return function(Bn) {
        var In = Cn, Dn = In.lib, Ln = Dn.WordArray, $n = Dn.Hasher, Nn = In.algo, Rn = [], Fn = [];
        (function() {
          function Hn(Wn) {
            for (var Xn = Bn.sqrt(Wn), ea = 2; ea <= Xn; ea++)
              if (!(Wn % ea))
                return !1;
            return !0;
          }
          function zn(Wn) {
            return (Wn - (Wn | 0)) * 4294967296 | 0;
          }
          for (var Gn = 2, Yn = 0; Yn < 64; )
            Hn(Gn) && (Yn < 8 && (Rn[Yn] = zn(Bn.pow(Gn, 1 / 2))), Fn[Yn] = zn(Bn.pow(Gn, 1 / 3)), Yn++), Gn++;
        })();
        var Pn = [], Un = Nn.SHA256 = $n.extend({
          _doReset: function() {
            this._hash = new Ln.init(Rn.slice(0));
          },
          _doProcessBlock: function(Hn, zn) {
            for (var Gn = this._hash.words, Yn = Gn[0], Wn = Gn[1], Xn = Gn[2], ea = Gn[3], ta = Gn[4], na = Gn[5], ra = Gn[6], aa = Gn[7], ia = 0; ia < 64; ia++) {
              if (ia < 16)
                Pn[ia] = Hn[zn + ia] | 0;
              else {
                var Aa = Pn[ia - 15], sa = (Aa << 25 | Aa >>> 7) ^ (Aa << 14 | Aa >>> 18) ^ Aa >>> 3, oa = Pn[ia - 2], la = (oa << 15 | oa >>> 17) ^ (oa << 13 | oa >>> 19) ^ oa >>> 10;
                Pn[ia] = sa + Pn[ia - 7] + la + Pn[ia - 16];
              }
              var ua = ta & na ^ ~ta & ra, ca = Yn & Wn ^ Yn & Xn ^ Wn & Xn, fa = (Yn << 30 | Yn >>> 2) ^ (Yn << 19 | Yn >>> 13) ^ (Yn << 10 | Yn >>> 22), ha = (ta << 26 | ta >>> 6) ^ (ta << 21 | ta >>> 11) ^ (ta << 7 | ta >>> 25), pa = aa + ha + ua + Fn[ia] + Pn[ia], ya = fa + ca;
              aa = ra, ra = na, na = ta, ta = ea + pa | 0, ea = Xn, Xn = Wn, Wn = Yn, Yn = pa + ya | 0;
            }
            Gn[0] = Gn[0] + Yn | 0, Gn[1] = Gn[1] + Wn | 0, Gn[2] = Gn[2] + Xn | 0, Gn[3] = Gn[3] + ea | 0, Gn[4] = Gn[4] + ta | 0, Gn[5] = Gn[5] + na | 0, Gn[6] = Gn[6] + ra | 0, Gn[7] = Gn[7] + aa | 0;
          },
          _doFinalize: function() {
            var Hn = this._data, zn = Hn.words, Gn = this._nDataBytes * 8, Yn = Hn.sigBytes * 8;
            return zn[Yn >>> 5] |= 128 << 24 - Yn % 32, zn[(Yn + 64 >>> 9 << 4) + 14] = Bn.floor(Gn / 4294967296), zn[(Yn + 64 >>> 9 << 4) + 15] = Gn, Hn.sigBytes = zn.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var Hn = $n.clone.call(this);
            return Hn._hash = this._hash.clone(), Hn;
          }
        });
        In.SHA256 = $n._createHelper(Un), In.HmacSHA256 = $n._createHmacHelper(Un);
      }(Math), Cn.SHA256;
    });
  }(sha256)), sha256.exports;
}
var sha224 = { exports: {} }, hasRequiredSha224;
function requireSha224() {
  return hasRequiredSha224 || (hasRequiredSha224 = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireSha256());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.WordArray, Ln = Bn.algo, $n = Ln.SHA256, Nn = Ln.SHA224 = $n.extend({
          _doReset: function() {
            this._hash = new Dn.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var Rn = $n._doFinalize.call(this);
            return Rn.sigBytes -= 4, Rn;
          }
        });
        Bn.SHA224 = $n._createHelper(Nn), Bn.HmacSHA224 = $n._createHmacHelper(Nn);
      }(), Cn.SHA224;
    });
  }(sha224)), sha224.exports;
}
var sha512 = { exports: {} }, hasRequiredSha512;
function requireSha512() {
  return hasRequiredSha512 || (hasRequiredSha512 = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireX64Core());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.Hasher, Ln = Bn.x64, $n = Ln.Word, Nn = Ln.WordArray, Rn = Bn.algo;
        function Fn() {
          return $n.create.apply($n, arguments);
        }
        var Pn = [
          Fn(1116352408, 3609767458),
          Fn(1899447441, 602891725),
          Fn(3049323471, 3964484399),
          Fn(3921009573, 2173295548),
          Fn(961987163, 4081628472),
          Fn(1508970993, 3053834265),
          Fn(2453635748, 2937671579),
          Fn(2870763221, 3664609560),
          Fn(3624381080, 2734883394),
          Fn(310598401, 1164996542),
          Fn(607225278, 1323610764),
          Fn(1426881987, 3590304994),
          Fn(1925078388, 4068182383),
          Fn(2162078206, 991336113),
          Fn(2614888103, 633803317),
          Fn(3248222580, 3479774868),
          Fn(3835390401, 2666613458),
          Fn(4022224774, 944711139),
          Fn(264347078, 2341262773),
          Fn(604807628, 2007800933),
          Fn(770255983, 1495990901),
          Fn(1249150122, 1856431235),
          Fn(1555081692, 3175218132),
          Fn(1996064986, 2198950837),
          Fn(2554220882, 3999719339),
          Fn(2821834349, 766784016),
          Fn(2952996808, 2566594879),
          Fn(3210313671, 3203337956),
          Fn(3336571891, 1034457026),
          Fn(3584528711, 2466948901),
          Fn(113926993, 3758326383),
          Fn(338241895, 168717936),
          Fn(666307205, 1188179964),
          Fn(773529912, 1546045734),
          Fn(1294757372, 1522805485),
          Fn(1396182291, 2643833823),
          Fn(1695183700, 2343527390),
          Fn(1986661051, 1014477480),
          Fn(2177026350, 1206759142),
          Fn(2456956037, 344077627),
          Fn(2730485921, 1290863460),
          Fn(2820302411, 3158454273),
          Fn(3259730800, 3505952657),
          Fn(3345764771, 106217008),
          Fn(3516065817, 3606008344),
          Fn(3600352804, 1432725776),
          Fn(4094571909, 1467031594),
          Fn(275423344, 851169720),
          Fn(430227734, 3100823752),
          Fn(506948616, 1363258195),
          Fn(659060556, 3750685593),
          Fn(883997877, 3785050280),
          Fn(958139571, 3318307427),
          Fn(1322822218, 3812723403),
          Fn(1537002063, 2003034995),
          Fn(1747873779, 3602036899),
          Fn(1955562222, 1575990012),
          Fn(2024104815, 1125592928),
          Fn(2227730452, 2716904306),
          Fn(2361852424, 442776044),
          Fn(2428436474, 593698344),
          Fn(2756734187, 3733110249),
          Fn(3204031479, 2999351573),
          Fn(3329325298, 3815920427),
          Fn(3391569614, 3928383900),
          Fn(3515267271, 566280711),
          Fn(3940187606, 3454069534),
          Fn(4118630271, 4000239992),
          Fn(116418474, 1914138554),
          Fn(174292421, 2731055270),
          Fn(289380356, 3203993006),
          Fn(460393269, 320620315),
          Fn(685471733, 587496836),
          Fn(852142971, 1086792851),
          Fn(1017036298, 365543100),
          Fn(1126000580, 2618297676),
          Fn(1288033470, 3409855158),
          Fn(1501505948, 4234509866),
          Fn(1607167915, 987167468),
          Fn(1816402316, 1246189591)
        ], Un = [];
        (function() {
          for (var zn = 0; zn < 80; zn++)
            Un[zn] = Fn();
        })();
        var Hn = Rn.SHA512 = Dn.extend({
          _doReset: function() {
            this._hash = new Nn.init([
              new $n.init(1779033703, 4089235720),
              new $n.init(3144134277, 2227873595),
              new $n.init(1013904242, 4271175723),
              new $n.init(2773480762, 1595750129),
              new $n.init(1359893119, 2917565137),
              new $n.init(2600822924, 725511199),
              new $n.init(528734635, 4215389547),
              new $n.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(zn, Gn) {
            for (var Yn = this._hash.words, Wn = Yn[0], Xn = Yn[1], ea = Yn[2], ta = Yn[3], na = Yn[4], ra = Yn[5], aa = Yn[6], ia = Yn[7], Aa = Wn.high, sa = Wn.low, oa = Xn.high, la = Xn.low, ua = ea.high, ca = ea.low, fa = ta.high, ha = ta.low, pa = na.high, ya = na.low, da = ra.high, Ca = ra.low, ma = aa.high, va = aa.low, ga = ia.high, xa = ia.low, wa = Aa, ba = sa, Ta = oa, Sa = la, Ea = ua, Ia = ca, Ba = fa, Ma = ha, La = pa, Da = ya, Na = da, $a = Ca, Oa = ma, Pa = va, ka = ga, Ua = xa, Fa = 0; Fa < 80; Fa++) {
              var Ha, Qa, Ga = Un[Fa];
              if (Fa < 16)
                Qa = Ga.high = zn[Gn + Fa * 2] | 0, Ha = Ga.low = zn[Gn + Fa * 2 + 1] | 0;
              else {
                var Wa = Un[Fa - 15], za = Wa.high, ja = Wa.low, Za = (za >>> 1 | ja << 31) ^ (za >>> 8 | ja << 24) ^ za >>> 7, qa = (ja >>> 1 | za << 31) ^ (ja >>> 8 | za << 24) ^ (ja >>> 7 | za << 25), Ja = Un[Fa - 2], Ya = Ja.high, Xa = Ja.low, li = (Ya >>> 19 | Xa << 13) ^ (Ya << 3 | Xa >>> 29) ^ Ya >>> 6, ei = (Xa >>> 19 | Ya << 13) ^ (Xa << 3 | Ya >>> 29) ^ (Xa >>> 6 | Ya << 26), ti = Un[Fa - 7], ui = ti.high, ci = ti.low, ri = Un[Fa - 16], fi = ri.high, ni = ri.low;
                Ha = qa + ci, Qa = Za + ui + (Ha >>> 0 < qa >>> 0 ? 1 : 0), Ha = Ha + ei, Qa = Qa + li + (Ha >>> 0 < ei >>> 0 ? 1 : 0), Ha = Ha + ni, Qa = Qa + fi + (Ha >>> 0 < ni >>> 0 ? 1 : 0), Ga.high = Qa, Ga.low = Ha;
              }
              var hi = La & Na ^ ~La & Oa, ai = Da & $a ^ ~Da & Pa, di = wa & Ta ^ wa & Ea ^ Ta & Ea, pi = ba & Sa ^ ba & Ia ^ Sa & Ia, vi = (wa >>> 28 | ba << 4) ^ (wa << 30 | ba >>> 2) ^ (wa << 25 | ba >>> 7), ii = (ba >>> 28 | wa << 4) ^ (ba << 30 | wa >>> 2) ^ (ba << 25 | wa >>> 7), gi = (La >>> 14 | Da << 18) ^ (La >>> 18 | Da << 14) ^ (La << 23 | Da >>> 9), mi = (Da >>> 14 | La << 18) ^ (Da >>> 18 | La << 14) ^ (Da << 23 | La >>> 9), oi = Pn[Fa], yi = oi.high, si = oi.low, Va = Ua + mi, Ka = ka + gi + (Va >>> 0 < Ua >>> 0 ? 1 : 0), Va = Va + ai, Ka = Ka + hi + (Va >>> 0 < ai >>> 0 ? 1 : 0), Va = Va + si, Ka = Ka + yi + (Va >>> 0 < si >>> 0 ? 1 : 0), Va = Va + Ha, Ka = Ka + Qa + (Va >>> 0 < Ha >>> 0 ? 1 : 0), Ai = ii + pi, xi = vi + di + (Ai >>> 0 < ii >>> 0 ? 1 : 0);
              ka = Oa, Ua = Pa, Oa = Na, Pa = $a, Na = La, $a = Da, Da = Ma + Va | 0, La = Ba + Ka + (Da >>> 0 < Ma >>> 0 ? 1 : 0) | 0, Ba = Ea, Ma = Ia, Ea = Ta, Ia = Sa, Ta = wa, Sa = ba, ba = Va + Ai | 0, wa = Ka + xi + (ba >>> 0 < Va >>> 0 ? 1 : 0) | 0;
            }
            sa = Wn.low = sa + ba, Wn.high = Aa + wa + (sa >>> 0 < ba >>> 0 ? 1 : 0), la = Xn.low = la + Sa, Xn.high = oa + Ta + (la >>> 0 < Sa >>> 0 ? 1 : 0), ca = ea.low = ca + Ia, ea.high = ua + Ea + (ca >>> 0 < Ia >>> 0 ? 1 : 0), ha = ta.low = ha + Ma, ta.high = fa + Ba + (ha >>> 0 < Ma >>> 0 ? 1 : 0), ya = na.low = ya + Da, na.high = pa + La + (ya >>> 0 < Da >>> 0 ? 1 : 0), Ca = ra.low = Ca + $a, ra.high = da + Na + (Ca >>> 0 < $a >>> 0 ? 1 : 0), va = aa.low = va + Pa, aa.high = ma + Oa + (va >>> 0 < Pa >>> 0 ? 1 : 0), xa = ia.low = xa + Ua, ia.high = ga + ka + (xa >>> 0 < Ua >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var zn = this._data, Gn = zn.words, Yn = this._nDataBytes * 8, Wn = zn.sigBytes * 8;
            Gn[Wn >>> 5] |= 128 << 24 - Wn % 32, Gn[(Wn + 128 >>> 10 << 5) + 30] = Math.floor(Yn / 4294967296), Gn[(Wn + 128 >>> 10 << 5) + 31] = Yn, zn.sigBytes = Gn.length * 4, this._process();
            var Xn = this._hash.toX32();
            return Xn;
          },
          clone: function() {
            var zn = Dn.clone.call(this);
            return zn._hash = this._hash.clone(), zn;
          },
          blockSize: 1024 / 32
        });
        Bn.SHA512 = Dn._createHelper(Hn), Bn.HmacSHA512 = Dn._createHmacHelper(Hn);
      }(), Cn.SHA512;
    });
  }(sha512)), sha512.exports;
}
var sha384 = { exports: {} }, hasRequiredSha384;
function requireSha384() {
  return hasRequiredSha384 || (hasRequiredSha384 = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireX64Core(), requireSha512());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.x64, Dn = In.Word, Ln = In.WordArray, $n = Bn.algo, Nn = $n.SHA512, Rn = $n.SHA384 = Nn.extend({
          _doReset: function() {
            this._hash = new Ln.init([
              new Dn.init(3418070365, 3238371032),
              new Dn.init(1654270250, 914150663),
              new Dn.init(2438529370, 812702999),
              new Dn.init(355462360, 4144912697),
              new Dn.init(1731405415, 4290775857),
              new Dn.init(2394180231, 1750603025),
              new Dn.init(3675008525, 1694076839),
              new Dn.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var Fn = Nn._doFinalize.call(this);
            return Fn.sigBytes -= 16, Fn;
          }
        });
        Bn.SHA384 = Nn._createHelper(Rn), Bn.HmacSHA384 = Nn._createHmacHelper(Rn);
      }(), Cn.SHA384;
    });
  }(sha384)), sha384.exports;
}
var sha3 = { exports: {} }, hasRequiredSha3;
function requireSha3() {
  return hasRequiredSha3 || (hasRequiredSha3 = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireX64Core());
    })(commonjsGlobal, function(Cn) {
      return function(Bn) {
        var In = Cn, Dn = In.lib, Ln = Dn.WordArray, $n = Dn.Hasher, Nn = In.x64, Rn = Nn.Word, Fn = In.algo, Pn = [], Un = [], Hn = [];
        (function() {
          for (var Yn = 1, Wn = 0, Xn = 0; Xn < 24; Xn++) {
            Pn[Yn + 5 * Wn] = (Xn + 1) * (Xn + 2) / 2 % 64;
            var ea = Wn % 5, ta = (2 * Yn + 3 * Wn) % 5;
            Yn = ea, Wn = ta;
          }
          for (var Yn = 0; Yn < 5; Yn++)
            for (var Wn = 0; Wn < 5; Wn++)
              Un[Yn + 5 * Wn] = Wn + (2 * Yn + 3 * Wn) % 5 * 5;
          for (var na = 1, ra = 0; ra < 24; ra++) {
            for (var aa = 0, ia = 0, Aa = 0; Aa < 7; Aa++) {
              if (na & 1) {
                var sa = (1 << Aa) - 1;
                sa < 32 ? ia ^= 1 << sa : aa ^= 1 << sa - 32;
              }
              na & 128 ? na = na << 1 ^ 113 : na <<= 1;
            }
            Hn[ra] = Rn.create(aa, ia);
          }
        })();
        var zn = [];
        (function() {
          for (var Yn = 0; Yn < 25; Yn++)
            zn[Yn] = Rn.create();
        })();
        var Gn = Fn.SHA3 = $n.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: $n.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            for (var Yn = this._state = [], Wn = 0; Wn < 25; Wn++)
              Yn[Wn] = new Rn.init();
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(Yn, Wn) {
            for (var Xn = this._state, ea = this.blockSize / 2, ta = 0; ta < ea; ta++) {
              var na = Yn[Wn + 2 * ta], ra = Yn[Wn + 2 * ta + 1];
              na = (na << 8 | na >>> 24) & 16711935 | (na << 24 | na >>> 8) & 4278255360, ra = (ra << 8 | ra >>> 24) & 16711935 | (ra << 24 | ra >>> 8) & 4278255360;
              var aa = Xn[ta];
              aa.high ^= ra, aa.low ^= na;
            }
            for (var ia = 0; ia < 24; ia++) {
              for (var Aa = 0; Aa < 5; Aa++) {
                for (var sa = 0, oa = 0, la = 0; la < 5; la++) {
                  var aa = Xn[Aa + 5 * la];
                  sa ^= aa.high, oa ^= aa.low;
                }
                var ua = zn[Aa];
                ua.high = sa, ua.low = oa;
              }
              for (var Aa = 0; Aa < 5; Aa++)
                for (var ca = zn[(Aa + 4) % 5], fa = zn[(Aa + 1) % 5], ha = fa.high, pa = fa.low, sa = ca.high ^ (ha << 1 | pa >>> 31), oa = ca.low ^ (pa << 1 | ha >>> 31), la = 0; la < 5; la++) {
                  var aa = Xn[Aa + 5 * la];
                  aa.high ^= sa, aa.low ^= oa;
                }
              for (var ya = 1; ya < 25; ya++) {
                var sa, oa, aa = Xn[ya], da = aa.high, Ca = aa.low, ma = Pn[ya];
                ma < 32 ? (sa = da << ma | Ca >>> 32 - ma, oa = Ca << ma | da >>> 32 - ma) : (sa = Ca << ma - 32 | da >>> 64 - ma, oa = da << ma - 32 | Ca >>> 64 - ma);
                var va = zn[Un[ya]];
                va.high = sa, va.low = oa;
              }
              var ga = zn[0], xa = Xn[0];
              ga.high = xa.high, ga.low = xa.low;
              for (var Aa = 0; Aa < 5; Aa++)
                for (var la = 0; la < 5; la++) {
                  var ya = Aa + 5 * la, aa = Xn[ya], wa = zn[ya], ba = zn[(Aa + 1) % 5 + 5 * la], Ta = zn[(Aa + 2) % 5 + 5 * la];
                  aa.high = wa.high ^ ~ba.high & Ta.high, aa.low = wa.low ^ ~ba.low & Ta.low;
                }
              var aa = Xn[0], Sa = Hn[ia];
              aa.high ^= Sa.high, aa.low ^= Sa.low;
            }
          },
          _doFinalize: function() {
            var Yn = this._data, Wn = Yn.words;
            this._nDataBytes * 8;
            var Xn = Yn.sigBytes * 8, ea = this.blockSize * 32;
            Wn[Xn >>> 5] |= 1 << 24 - Xn % 32, Wn[(Bn.ceil((Xn + 1) / ea) * ea >>> 5) - 1] |= 128, Yn.sigBytes = Wn.length * 4, this._process();
            for (var ta = this._state, na = this.cfg.outputLength / 8, ra = na / 8, aa = [], ia = 0; ia < ra; ia++) {
              var Aa = ta[ia], sa = Aa.high, oa = Aa.low;
              sa = (sa << 8 | sa >>> 24) & 16711935 | (sa << 24 | sa >>> 8) & 4278255360, oa = (oa << 8 | oa >>> 24) & 16711935 | (oa << 24 | oa >>> 8) & 4278255360, aa.push(oa), aa.push(sa);
            }
            return new Ln.init(aa, na);
          },
          clone: function() {
            for (var Yn = $n.clone.call(this), Wn = Yn._state = this._state.slice(0), Xn = 0; Xn < 25; Xn++)
              Wn[Xn] = Wn[Xn].clone();
            return Yn;
          }
        });
        In.SHA3 = $n._createHelper(Gn), In.HmacSHA3 = $n._createHmacHelper(Gn);
      }(Math), Cn.SHA3;
    });
  }(sha3)), sha3.exports;
}
var ripemd160 = { exports: {} }, hasRequiredRipemd160;
function requireRipemd160() {
  return hasRequiredRipemd160 || (hasRequiredRipemd160 = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      /** @preserve
      			(c) 2012 by Cédric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      return function(Bn) {
        var In = Cn, Dn = In.lib, Ln = Dn.WordArray, $n = Dn.Hasher, Nn = In.algo, Rn = Ln.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]), Fn = Ln.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]), Pn = Ln.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]), Un = Ln.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]), Hn = Ln.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), zn = Ln.create([1352829926, 1548603684, 1836072691, 2053994217, 0]), Gn = Nn.RIPEMD160 = $n.extend({
          _doReset: function() {
            this._hash = Ln.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(ra, aa) {
            for (var ia = 0; ia < 16; ia++) {
              var Aa = aa + ia, sa = ra[Aa];
              ra[Aa] = (sa << 8 | sa >>> 24) & 16711935 | (sa << 24 | sa >>> 8) & 4278255360;
            }
            var oa = this._hash.words, la = Hn.words, ua = zn.words, ca = Rn.words, fa = Fn.words, ha = Pn.words, pa = Un.words, ya, da, Ca, ma, va, ga, xa, wa, ba, Ta;
            ga = ya = oa[0], xa = da = oa[1], wa = Ca = oa[2], ba = ma = oa[3], Ta = va = oa[4];
            for (var Sa, ia = 0; ia < 80; ia += 1)
              Sa = ya + ra[aa + ca[ia]] | 0, ia < 16 ? Sa += Yn(da, Ca, ma) + la[0] : ia < 32 ? Sa += Wn(da, Ca, ma) + la[1] : ia < 48 ? Sa += Xn(da, Ca, ma) + la[2] : ia < 64 ? Sa += ea(da, Ca, ma) + la[3] : Sa += ta(da, Ca, ma) + la[4], Sa = Sa | 0, Sa = na(Sa, ha[ia]), Sa = Sa + va | 0, ya = va, va = ma, ma = na(Ca, 10), Ca = da, da = Sa, Sa = ga + ra[aa + fa[ia]] | 0, ia < 16 ? Sa += ta(xa, wa, ba) + ua[0] : ia < 32 ? Sa += ea(xa, wa, ba) + ua[1] : ia < 48 ? Sa += Xn(xa, wa, ba) + ua[2] : ia < 64 ? Sa += Wn(xa, wa, ba) + ua[3] : Sa += Yn(xa, wa, ba) + ua[4], Sa = Sa | 0, Sa = na(Sa, pa[ia]), Sa = Sa + Ta | 0, ga = Ta, Ta = ba, ba = na(wa, 10), wa = xa, xa = Sa;
            Sa = oa[1] + Ca + ba | 0, oa[1] = oa[2] + ma + Ta | 0, oa[2] = oa[3] + va + ga | 0, oa[3] = oa[4] + ya + xa | 0, oa[4] = oa[0] + da + wa | 0, oa[0] = Sa;
          },
          _doFinalize: function() {
            var ra = this._data, aa = ra.words, ia = this._nDataBytes * 8, Aa = ra.sigBytes * 8;
            aa[Aa >>> 5] |= 128 << 24 - Aa % 32, aa[(Aa + 64 >>> 9 << 4) + 14] = (ia << 8 | ia >>> 24) & 16711935 | (ia << 24 | ia >>> 8) & 4278255360, ra.sigBytes = (aa.length + 1) * 4, this._process();
            for (var sa = this._hash, oa = sa.words, la = 0; la < 5; la++) {
              var ua = oa[la];
              oa[la] = (ua << 8 | ua >>> 24) & 16711935 | (ua << 24 | ua >>> 8) & 4278255360;
            }
            return sa;
          },
          clone: function() {
            var ra = $n.clone.call(this);
            return ra._hash = this._hash.clone(), ra;
          }
        });
        function Yn(ra, aa, ia) {
          return ra ^ aa ^ ia;
        }
        function Wn(ra, aa, ia) {
          return ra & aa | ~ra & ia;
        }
        function Xn(ra, aa, ia) {
          return (ra | ~aa) ^ ia;
        }
        function ea(ra, aa, ia) {
          return ra & ia | aa & ~ia;
        }
        function ta(ra, aa, ia) {
          return ra ^ (aa | ~ia);
        }
        function na(ra, aa) {
          return ra << aa | ra >>> 32 - aa;
        }
        In.RIPEMD160 = $n._createHelper(Gn), In.HmacRIPEMD160 = $n._createHmacHelper(Gn);
      }(), Cn.RIPEMD160;
    });
  }(ripemd160)), ripemd160.exports;
}
var hmac = { exports: {} }, hasRequiredHmac;
function requireHmac() {
  return hasRequiredHmac || (hasRequiredHmac = 1, function(_n, nr) {
    (function(Cn, Bn) {
      _n.exports = Bn(requireCore());
    })(commonjsGlobal, function(Cn) {
      (function() {
        var Bn = Cn, In = Bn.lib, Dn = In.Base, Ln = Bn.enc, $n = Ln.Utf8, Nn = Bn.algo;
        Nn.HMAC = Dn.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(Rn, Fn) {
            Rn = this._hasher = new Rn.init(), typeof Fn == "string" && (Fn = $n.parse(Fn));
            var Pn = Rn.blockSize, Un = Pn * 4;
            Fn.sigBytes > Un && (Fn = Rn.finalize(Fn)), Fn.clamp();
            for (var Hn = this._oKey = Fn.clone(), zn = this._iKey = Fn.clone(), Gn = Hn.words, Yn = zn.words, Wn = 0; Wn < Pn; Wn++)
              Gn[Wn] ^= 1549556828, Yn[Wn] ^= 909522486;
            Hn.sigBytes = zn.sigBytes = Un, this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var Rn = this._hasher;
            Rn.reset(), Rn.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(Rn) {
            return this._hasher.update(Rn), this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(Rn) {
            var Fn = this._hasher, Pn = Fn.finalize(Rn);
            Fn.reset();
            var Un = Fn.finalize(this._oKey.clone().concat(Pn));
            return Un;
          }
        });
      })();
    });
  }(hmac)), hmac.exports;
}
var pbkdf2 = { exports: {} }, hasRequiredPbkdf2;
function requirePbkdf2() {
  return hasRequiredPbkdf2 || (hasRequiredPbkdf2 = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireSha256(), requireHmac());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.Base, Ln = In.WordArray, $n = Bn.algo, Nn = $n.SHA256, Rn = $n.HMAC, Fn = $n.PBKDF2 = Dn.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Dn.extend({
            keySize: 128 / 32,
            hasher: Nn,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(Pn) {
            this.cfg = this.cfg.extend(Pn);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(Pn, Un) {
            for (var Hn = this.cfg, zn = Rn.create(Hn.hasher, Pn), Gn = Ln.create(), Yn = Ln.create([1]), Wn = Gn.words, Xn = Yn.words, ea = Hn.keySize, ta = Hn.iterations; Wn.length < ea; ) {
              var na = zn.update(Un).finalize(Yn);
              zn.reset();
              for (var ra = na.words, aa = ra.length, ia = na, Aa = 1; Aa < ta; Aa++) {
                ia = zn.finalize(ia), zn.reset();
                for (var sa = ia.words, oa = 0; oa < aa; oa++)
                  ra[oa] ^= sa[oa];
              }
              Gn.concat(na), Xn[0]++;
            }
            return Gn.sigBytes = ea * 4, Gn;
          }
        });
        Bn.PBKDF2 = function(Pn, Un, Hn) {
          return Fn.create(Hn).compute(Pn, Un);
        };
      }(), Cn.PBKDF2;
    });
  }(pbkdf2)), pbkdf2.exports;
}
var evpkdf = { exports: {} }, hasRequiredEvpkdf;
function requireEvpkdf() {
  return hasRequiredEvpkdf || (hasRequiredEvpkdf = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireSha1(), requireHmac());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.Base, Ln = In.WordArray, $n = Bn.algo, Nn = $n.MD5, Rn = $n.EvpKDF = Dn.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Dn.extend({
            keySize: 128 / 32,
            hasher: Nn,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(Fn) {
            this.cfg = this.cfg.extend(Fn);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(Fn, Pn) {
            for (var Un, Hn = this.cfg, zn = Hn.hasher.create(), Gn = Ln.create(), Yn = Gn.words, Wn = Hn.keySize, Xn = Hn.iterations; Yn.length < Wn; ) {
              Un && zn.update(Un), Un = zn.update(Fn).finalize(Pn), zn.reset();
              for (var ea = 1; ea < Xn; ea++)
                Un = zn.finalize(Un), zn.reset();
              Gn.concat(Un);
            }
            return Gn.sigBytes = Wn * 4, Gn;
          }
        });
        Bn.EvpKDF = function(Fn, Pn, Un) {
          return Rn.create(Un).compute(Fn, Pn);
        };
      }(), Cn.EvpKDF;
    });
  }(evpkdf)), evpkdf.exports;
}
var cipherCore = { exports: {} }, hasRequiredCipherCore;
function requireCipherCore() {
  return hasRequiredCipherCore || (hasRequiredCipherCore = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireEvpkdf());
    })(commonjsGlobal, function(Cn) {
      Cn.lib.Cipher || function(Bn) {
        var In = Cn, Dn = In.lib, Ln = Dn.Base, $n = Dn.WordArray, Nn = Dn.BufferedBlockAlgorithm, Rn = In.enc;
        Rn.Utf8;
        var Fn = Rn.Base64, Pn = In.algo, Un = Pn.EvpKDF, Hn = Dn.Cipher = Nn.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Ln.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(sa, oa) {
            return this.create(this._ENC_XFORM_MODE, sa, oa);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(sa, oa) {
            return this.create(this._DEC_XFORM_MODE, sa, oa);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(sa, oa, la) {
            this.cfg = this.cfg.extend(la), this._xformMode = sa, this._key = oa, this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            Nn.reset.call(this), this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(sa) {
            return this._append(sa), this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(sa) {
            sa && this._append(sa);
            var oa = this._doFinalize();
            return oa;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: function() {
            function sa(oa) {
              return typeof oa == "string" ? Aa : ra;
            }
            return function(oa) {
              return {
                encrypt: function(la, ua, ca) {
                  return sa(ua).encrypt(oa, la, ua, ca);
                },
                decrypt: function(la, ua, ca) {
                  return sa(ua).decrypt(oa, la, ua, ca);
                }
              };
            };
          }()
        });
        Dn.StreamCipher = Hn.extend({
          _doFinalize: function() {
            var sa = this._process(!0);
            return sa;
          },
          blockSize: 1
        });
        var zn = In.mode = {}, Gn = Dn.BlockCipherMode = Ln.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(sa, oa) {
            return this.Encryptor.create(sa, oa);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(sa, oa) {
            return this.Decryptor.create(sa, oa);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(sa, oa) {
            this._cipher = sa, this._iv = oa;
          }
        }), Yn = zn.CBC = function() {
          var sa = Gn.extend();
          sa.Encryptor = sa.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(la, ua) {
              var ca = this._cipher, fa = ca.blockSize;
              oa.call(this, la, ua, fa), ca.encryptBlock(la, ua), this._prevBlock = la.slice(ua, ua + fa);
            }
          }), sa.Decryptor = sa.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(la, ua) {
              var ca = this._cipher, fa = ca.blockSize, ha = la.slice(ua, ua + fa);
              ca.decryptBlock(la, ua), oa.call(this, la, ua, fa), this._prevBlock = ha;
            }
          });
          function oa(la, ua, ca) {
            var fa, ha = this._iv;
            ha ? (fa = ha, this._iv = Bn) : fa = this._prevBlock;
            for (var pa = 0; pa < ca; pa++)
              la[ua + pa] ^= fa[pa];
          }
          return sa;
        }(), Wn = In.pad = {}, Xn = Wn.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(sa, oa) {
            for (var la = oa * 4, ua = la - sa.sigBytes % la, ca = ua << 24 | ua << 16 | ua << 8 | ua, fa = [], ha = 0; ha < ua; ha += 4)
              fa.push(ca);
            var pa = $n.create(fa, ua);
            sa.concat(pa);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(sa) {
            var oa = sa.words[sa.sigBytes - 1 >>> 2] & 255;
            sa.sigBytes -= oa;
          }
        };
        Dn.BlockCipher = Hn.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Hn.cfg.extend({
            mode: Yn,
            padding: Xn
          }),
          reset: function() {
            var sa;
            Hn.reset.call(this);
            var oa = this.cfg, la = oa.iv, ua = oa.mode;
            this._xformMode == this._ENC_XFORM_MODE ? sa = ua.createEncryptor : (sa = ua.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == sa ? this._mode.init(this, la && la.words) : (this._mode = sa.call(ua, this, la && la.words), this._mode.__creator = sa);
          },
          _doProcessBlock: function(sa, oa) {
            this._mode.processBlock(sa, oa);
          },
          _doFinalize: function() {
            var sa, oa = this.cfg.padding;
            return this._xformMode == this._ENC_XFORM_MODE ? (oa.pad(this._data, this.blockSize), sa = this._process(!0)) : (sa = this._process(!0), oa.unpad(sa)), sa;
          },
          blockSize: 128 / 32
        });
        var ea = Dn.CipherParams = Ln.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(sa) {
            this.mixIn(sa);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(sa) {
            return (sa || this.formatter).stringify(this);
          }
        }), ta = In.format = {}, na = ta.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(sa) {
            var oa, la = sa.ciphertext, ua = sa.salt;
            return ua ? oa = $n.create([1398893684, 1701076831]).concat(ua).concat(la) : oa = la, oa.toString(Fn);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(sa) {
            var oa, la = Fn.parse(sa), ua = la.words;
            return ua[0] == 1398893684 && ua[1] == 1701076831 && (oa = $n.create(ua.slice(2, 4)), ua.splice(0, 4), la.sigBytes -= 16), ea.create({ ciphertext: la, salt: oa });
          }
        }, ra = Dn.SerializableCipher = Ln.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Ln.extend({
            format: na
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(sa, oa, la, ua) {
            ua = this.cfg.extend(ua);
            var ca = sa.createEncryptor(la, ua), fa = ca.finalize(oa), ha = ca.cfg;
            return ea.create({
              ciphertext: fa,
              key: la,
              iv: ha.iv,
              algorithm: sa,
              mode: ha.mode,
              padding: ha.padding,
              blockSize: sa.blockSize,
              formatter: ua.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(sa, oa, la, ua) {
            ua = this.cfg.extend(ua), oa = this._parse(oa, ua.format);
            var ca = sa.createDecryptor(la, ua).finalize(oa.ciphertext);
            return ca;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(sa, oa) {
            return typeof sa == "string" ? oa.parse(sa, this) : sa;
          }
        }), aa = In.kdf = {}, ia = aa.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(sa, oa, la, ua, ca) {
            if (ua || (ua = $n.random(64 / 8)), ca)
              var fa = Un.create({ keySize: oa + la, hasher: ca }).compute(sa, ua);
            else
              var fa = Un.create({ keySize: oa + la }).compute(sa, ua);
            var ha = $n.create(fa.words.slice(oa), la * 4);
            return fa.sigBytes = oa * 4, ea.create({ key: fa, iv: ha, salt: ua });
          }
        }, Aa = Dn.PasswordBasedCipher = ra.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: ra.cfg.extend({
            kdf: ia
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(sa, oa, la, ua) {
            ua = this.cfg.extend(ua);
            var ca = ua.kdf.execute(la, sa.keySize, sa.ivSize, ua.salt, ua.hasher);
            ua.iv = ca.iv;
            var fa = ra.encrypt.call(this, sa, oa, ca.key, ua);
            return fa.mixIn(ca), fa;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(sa, oa, la, ua) {
            ua = this.cfg.extend(ua), oa = this._parse(oa, ua.format);
            var ca = ua.kdf.execute(la, sa.keySize, sa.ivSize, oa.salt, ua.hasher);
            ua.iv = ca.iv;
            var fa = ra.decrypt.call(this, sa, oa, ca.key, ua);
            return fa;
          }
        });
      }();
    });
  }(cipherCore)), cipherCore.exports;
}
var modeCfb = { exports: {} }, hasRequiredModeCfb;
function requireModeCfb() {
  return hasRequiredModeCfb || (hasRequiredModeCfb = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return Cn.mode.CFB = function() {
        var Bn = Cn.lib.BlockCipherMode.extend();
        Bn.Encryptor = Bn.extend({
          processBlock: function(Dn, Ln) {
            var $n = this._cipher, Nn = $n.blockSize;
            In.call(this, Dn, Ln, Nn, $n), this._prevBlock = Dn.slice(Ln, Ln + Nn);
          }
        }), Bn.Decryptor = Bn.extend({
          processBlock: function(Dn, Ln) {
            var $n = this._cipher, Nn = $n.blockSize, Rn = Dn.slice(Ln, Ln + Nn);
            In.call(this, Dn, Ln, Nn, $n), this._prevBlock = Rn;
          }
        });
        function In(Dn, Ln, $n, Nn) {
          var Rn, Fn = this._iv;
          Fn ? (Rn = Fn.slice(0), this._iv = void 0) : Rn = this._prevBlock, Nn.encryptBlock(Rn, 0);
          for (var Pn = 0; Pn < $n; Pn++)
            Dn[Ln + Pn] ^= Rn[Pn];
        }
        return Bn;
      }(), Cn.mode.CFB;
    });
  }(modeCfb)), modeCfb.exports;
}
var modeCtr = { exports: {} }, hasRequiredModeCtr;
function requireModeCtr() {
  return hasRequiredModeCtr || (hasRequiredModeCtr = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return Cn.mode.CTR = function() {
        var Bn = Cn.lib.BlockCipherMode.extend(), In = Bn.Encryptor = Bn.extend({
          processBlock: function(Dn, Ln) {
            var $n = this._cipher, Nn = $n.blockSize, Rn = this._iv, Fn = this._counter;
            Rn && (Fn = this._counter = Rn.slice(0), this._iv = void 0);
            var Pn = Fn.slice(0);
            $n.encryptBlock(Pn, 0), Fn[Nn - 1] = Fn[Nn - 1] + 1 | 0;
            for (var Un = 0; Un < Nn; Un++)
              Dn[Ln + Un] ^= Pn[Un];
          }
        });
        return Bn.Decryptor = In, Bn;
      }(), Cn.mode.CTR;
    });
  }(modeCtr)), modeCtr.exports;
}
var modeCtrGladman = { exports: {} }, hasRequiredModeCtrGladman;
function requireModeCtrGladman() {
  return hasRequiredModeCtrGladman || (hasRequiredModeCtrGladman = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      return Cn.mode.CTRGladman = function() {
        var Bn = Cn.lib.BlockCipherMode.extend();
        function In($n) {
          if (($n >> 24 & 255) === 255) {
            var Nn = $n >> 16 & 255, Rn = $n >> 8 & 255, Fn = $n & 255;
            Nn === 255 ? (Nn = 0, Rn === 255 ? (Rn = 0, Fn === 255 ? Fn = 0 : ++Fn) : ++Rn) : ++Nn, $n = 0, $n += Nn << 16, $n += Rn << 8, $n += Fn;
          } else
            $n += 1 << 24;
          return $n;
        }
        function Dn($n) {
          return ($n[0] = In($n[0])) === 0 && ($n[1] = In($n[1])), $n;
        }
        var Ln = Bn.Encryptor = Bn.extend({
          processBlock: function($n, Nn) {
            var Rn = this._cipher, Fn = Rn.blockSize, Pn = this._iv, Un = this._counter;
            Pn && (Un = this._counter = Pn.slice(0), this._iv = void 0), Dn(Un);
            var Hn = Un.slice(0);
            Rn.encryptBlock(Hn, 0);
            for (var zn = 0; zn < Fn; zn++)
              $n[Nn + zn] ^= Hn[zn];
          }
        });
        return Bn.Decryptor = Ln, Bn;
      }(), Cn.mode.CTRGladman;
    });
  }(modeCtrGladman)), modeCtrGladman.exports;
}
var modeOfb = { exports: {} }, hasRequiredModeOfb;
function requireModeOfb() {
  return hasRequiredModeOfb || (hasRequiredModeOfb = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return Cn.mode.OFB = function() {
        var Bn = Cn.lib.BlockCipherMode.extend(), In = Bn.Encryptor = Bn.extend({
          processBlock: function(Dn, Ln) {
            var $n = this._cipher, Nn = $n.blockSize, Rn = this._iv, Fn = this._keystream;
            Rn && (Fn = this._keystream = Rn.slice(0), this._iv = void 0), $n.encryptBlock(Fn, 0);
            for (var Pn = 0; Pn < Nn; Pn++)
              Dn[Ln + Pn] ^= Fn[Pn];
          }
        });
        return Bn.Decryptor = In, Bn;
      }(), Cn.mode.OFB;
    });
  }(modeOfb)), modeOfb.exports;
}
var modeEcb = { exports: {} }, hasRequiredModeEcb;
function requireModeEcb() {
  return hasRequiredModeEcb || (hasRequiredModeEcb = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return Cn.mode.ECB = function() {
        var Bn = Cn.lib.BlockCipherMode.extend();
        return Bn.Encryptor = Bn.extend({
          processBlock: function(In, Dn) {
            this._cipher.encryptBlock(In, Dn);
          }
        }), Bn.Decryptor = Bn.extend({
          processBlock: function(In, Dn) {
            this._cipher.decryptBlock(In, Dn);
          }
        }), Bn;
      }(), Cn.mode.ECB;
    });
  }(modeEcb)), modeEcb.exports;
}
var padAnsix923 = { exports: {} }, hasRequiredPadAnsix923;
function requirePadAnsix923() {
  return hasRequiredPadAnsix923 || (hasRequiredPadAnsix923 = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return Cn.pad.AnsiX923 = {
        pad: function(Bn, In) {
          var Dn = Bn.sigBytes, Ln = In * 4, $n = Ln - Dn % Ln, Nn = Dn + $n - 1;
          Bn.clamp(), Bn.words[Nn >>> 2] |= $n << 24 - Nn % 4 * 8, Bn.sigBytes += $n;
        },
        unpad: function(Bn) {
          var In = Bn.words[Bn.sigBytes - 1 >>> 2] & 255;
          Bn.sigBytes -= In;
        }
      }, Cn.pad.Ansix923;
    });
  }(padAnsix923)), padAnsix923.exports;
}
var padIso10126 = { exports: {} }, hasRequiredPadIso10126;
function requirePadIso10126() {
  return hasRequiredPadIso10126 || (hasRequiredPadIso10126 = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return Cn.pad.Iso10126 = {
        pad: function(Bn, In) {
          var Dn = In * 4, Ln = Dn - Bn.sigBytes % Dn;
          Bn.concat(Cn.lib.WordArray.random(Ln - 1)).concat(Cn.lib.WordArray.create([Ln << 24], 1));
        },
        unpad: function(Bn) {
          var In = Bn.words[Bn.sigBytes - 1 >>> 2] & 255;
          Bn.sigBytes -= In;
        }
      }, Cn.pad.Iso10126;
    });
  }(padIso10126)), padIso10126.exports;
}
var padIso97971 = { exports: {} }, hasRequiredPadIso97971;
function requirePadIso97971() {
  return hasRequiredPadIso97971 || (hasRequiredPadIso97971 = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return Cn.pad.Iso97971 = {
        pad: function(Bn, In) {
          Bn.concat(Cn.lib.WordArray.create([2147483648], 1)), Cn.pad.ZeroPadding.pad(Bn, In);
        },
        unpad: function(Bn) {
          Cn.pad.ZeroPadding.unpad(Bn), Bn.sigBytes--;
        }
      }, Cn.pad.Iso97971;
    });
  }(padIso97971)), padIso97971.exports;
}
var padZeropadding = { exports: {} }, hasRequiredPadZeropadding;
function requirePadZeropadding() {
  return hasRequiredPadZeropadding || (hasRequiredPadZeropadding = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return Cn.pad.ZeroPadding = {
        pad: function(Bn, In) {
          var Dn = In * 4;
          Bn.clamp(), Bn.sigBytes += Dn - (Bn.sigBytes % Dn || Dn);
        },
        unpad: function(Bn) {
          for (var In = Bn.words, Dn = Bn.sigBytes - 1, Dn = Bn.sigBytes - 1; Dn >= 0; Dn--)
            if (In[Dn >>> 2] >>> 24 - Dn % 4 * 8 & 255) {
              Bn.sigBytes = Dn + 1;
              break;
            }
        }
      }, Cn.pad.ZeroPadding;
    });
  }(padZeropadding)), padZeropadding.exports;
}
var padNopadding = { exports: {} }, hasRequiredPadNopadding;
function requirePadNopadding() {
  return hasRequiredPadNopadding || (hasRequiredPadNopadding = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return Cn.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      }, Cn.pad.NoPadding;
    });
  }(padNopadding)), padNopadding.exports;
}
var formatHex = { exports: {} }, hasRequiredFormatHex;
function requireFormatHex() {
  return hasRequiredFormatHex || (hasRequiredFormatHex = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return function(Bn) {
        var In = Cn, Dn = In.lib, Ln = Dn.CipherParams, $n = In.enc, Nn = $n.Hex, Rn = In.format;
        Rn.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(Fn) {
            return Fn.ciphertext.toString(Nn);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(Fn) {
            var Pn = Nn.parse(Fn);
            return Ln.create({ ciphertext: Pn });
          }
        };
      }(), Cn.format.Hex;
    });
  }(formatHex)), formatHex.exports;
}
var aes = { exports: {} }, hasRequiredAes;
function requireAes() {
  return hasRequiredAes || (hasRequiredAes = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.BlockCipher, Ln = Bn.algo, $n = [], Nn = [], Rn = [], Fn = [], Pn = [], Un = [], Hn = [], zn = [], Gn = [], Yn = [];
        (function() {
          for (var ea = [], ta = 0; ta < 256; ta++)
            ta < 128 ? ea[ta] = ta << 1 : ea[ta] = ta << 1 ^ 283;
          for (var na = 0, ra = 0, ta = 0; ta < 256; ta++) {
            var aa = ra ^ ra << 1 ^ ra << 2 ^ ra << 3 ^ ra << 4;
            aa = aa >>> 8 ^ aa & 255 ^ 99, $n[na] = aa, Nn[aa] = na;
            var ia = ea[na], Aa = ea[ia], sa = ea[Aa], oa = ea[aa] * 257 ^ aa * 16843008;
            Rn[na] = oa << 24 | oa >>> 8, Fn[na] = oa << 16 | oa >>> 16, Pn[na] = oa << 8 | oa >>> 24, Un[na] = oa;
            var oa = sa * 16843009 ^ Aa * 65537 ^ ia * 257 ^ na * 16843008;
            Hn[aa] = oa << 24 | oa >>> 8, zn[aa] = oa << 16 | oa >>> 16, Gn[aa] = oa << 8 | oa >>> 24, Yn[aa] = oa, na ? (na = ia ^ ea[ea[ea[sa ^ ia]]], ra ^= ea[ea[ra]]) : na = ra = 1;
          }
        })();
        var Wn = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Xn = Ln.AES = Dn.extend({
          _doReset: function() {
            var ea;
            if (!(this._nRounds && this._keyPriorReset === this._key)) {
              for (var ta = this._keyPriorReset = this._key, na = ta.words, ra = ta.sigBytes / 4, aa = this._nRounds = ra + 6, ia = (aa + 1) * 4, Aa = this._keySchedule = [], sa = 0; sa < ia; sa++)
                sa < ra ? Aa[sa] = na[sa] : (ea = Aa[sa - 1], sa % ra ? ra > 6 && sa % ra == 4 && (ea = $n[ea >>> 24] << 24 | $n[ea >>> 16 & 255] << 16 | $n[ea >>> 8 & 255] << 8 | $n[ea & 255]) : (ea = ea << 8 | ea >>> 24, ea = $n[ea >>> 24] << 24 | $n[ea >>> 16 & 255] << 16 | $n[ea >>> 8 & 255] << 8 | $n[ea & 255], ea ^= Wn[sa / ra | 0] << 24), Aa[sa] = Aa[sa - ra] ^ ea);
              for (var oa = this._invKeySchedule = [], la = 0; la < ia; la++) {
                var sa = ia - la;
                if (la % 4)
                  var ea = Aa[sa];
                else
                  var ea = Aa[sa - 4];
                la < 4 || sa <= 4 ? oa[la] = ea : oa[la] = Hn[$n[ea >>> 24]] ^ zn[$n[ea >>> 16 & 255]] ^ Gn[$n[ea >>> 8 & 255]] ^ Yn[$n[ea & 255]];
              }
            }
          },
          encryptBlock: function(ea, ta) {
            this._doCryptBlock(ea, ta, this._keySchedule, Rn, Fn, Pn, Un, $n);
          },
          decryptBlock: function(ea, ta) {
            var na = ea[ta + 1];
            ea[ta + 1] = ea[ta + 3], ea[ta + 3] = na, this._doCryptBlock(ea, ta, this._invKeySchedule, Hn, zn, Gn, Yn, Nn);
            var na = ea[ta + 1];
            ea[ta + 1] = ea[ta + 3], ea[ta + 3] = na;
          },
          _doCryptBlock: function(ea, ta, na, ra, aa, ia, Aa, sa) {
            for (var oa = this._nRounds, la = ea[ta] ^ na[0], ua = ea[ta + 1] ^ na[1], ca = ea[ta + 2] ^ na[2], fa = ea[ta + 3] ^ na[3], ha = 4, pa = 1; pa < oa; pa++) {
              var ya = ra[la >>> 24] ^ aa[ua >>> 16 & 255] ^ ia[ca >>> 8 & 255] ^ Aa[fa & 255] ^ na[ha++], da = ra[ua >>> 24] ^ aa[ca >>> 16 & 255] ^ ia[fa >>> 8 & 255] ^ Aa[la & 255] ^ na[ha++], Ca = ra[ca >>> 24] ^ aa[fa >>> 16 & 255] ^ ia[la >>> 8 & 255] ^ Aa[ua & 255] ^ na[ha++], ma = ra[fa >>> 24] ^ aa[la >>> 16 & 255] ^ ia[ua >>> 8 & 255] ^ Aa[ca & 255] ^ na[ha++];
              la = ya, ua = da, ca = Ca, fa = ma;
            }
            var ya = (sa[la >>> 24] << 24 | sa[ua >>> 16 & 255] << 16 | sa[ca >>> 8 & 255] << 8 | sa[fa & 255]) ^ na[ha++], da = (sa[ua >>> 24] << 24 | sa[ca >>> 16 & 255] << 16 | sa[fa >>> 8 & 255] << 8 | sa[la & 255]) ^ na[ha++], Ca = (sa[ca >>> 24] << 24 | sa[fa >>> 16 & 255] << 16 | sa[la >>> 8 & 255] << 8 | sa[ua & 255]) ^ na[ha++], ma = (sa[fa >>> 24] << 24 | sa[la >>> 16 & 255] << 16 | sa[ua >>> 8 & 255] << 8 | sa[ca & 255]) ^ na[ha++];
            ea[ta] = ya, ea[ta + 1] = da, ea[ta + 2] = Ca, ea[ta + 3] = ma;
          },
          keySize: 256 / 32
        });
        Bn.AES = Dn._createHelper(Xn);
      }(), Cn.AES;
    });
  }(aes)), aes.exports;
}
var tripledes = { exports: {} }, hasRequiredTripledes;
function requireTripledes() {
  return hasRequiredTripledes || (hasRequiredTripledes = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.WordArray, Ln = In.BlockCipher, $n = Bn.algo, Nn = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ], Rn = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ], Fn = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], Pn = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ], Un = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ], Hn = $n.DES = Ln.extend({
          _doReset: function() {
            for (var Wn = this._key, Xn = Wn.words, ea = [], ta = 0; ta < 56; ta++) {
              var na = Nn[ta] - 1;
              ea[ta] = Xn[na >>> 5] >>> 31 - na % 32 & 1;
            }
            for (var ra = this._subKeys = [], aa = 0; aa < 16; aa++) {
              for (var ia = ra[aa] = [], Aa = Fn[aa], ta = 0; ta < 24; ta++)
                ia[ta / 6 | 0] |= ea[(Rn[ta] - 1 + Aa) % 28] << 31 - ta % 6, ia[4 + (ta / 6 | 0)] |= ea[28 + (Rn[ta + 24] - 1 + Aa) % 28] << 31 - ta % 6;
              ia[0] = ia[0] << 1 | ia[0] >>> 31;
              for (var ta = 1; ta < 7; ta++)
                ia[ta] = ia[ta] >>> (ta - 1) * 4 + 3;
              ia[7] = ia[7] << 5 | ia[7] >>> 27;
            }
            for (var sa = this._invSubKeys = [], ta = 0; ta < 16; ta++)
              sa[ta] = ra[15 - ta];
          },
          encryptBlock: function(Wn, Xn) {
            this._doCryptBlock(Wn, Xn, this._subKeys);
          },
          decryptBlock: function(Wn, Xn) {
            this._doCryptBlock(Wn, Xn, this._invSubKeys);
          },
          _doCryptBlock: function(Wn, Xn, ea) {
            this._lBlock = Wn[Xn], this._rBlock = Wn[Xn + 1], zn.call(this, 4, 252645135), zn.call(this, 16, 65535), Gn.call(this, 2, 858993459), Gn.call(this, 8, 16711935), zn.call(this, 1, 1431655765);
            for (var ta = 0; ta < 16; ta++) {
              for (var na = ea[ta], ra = this._lBlock, aa = this._rBlock, ia = 0, Aa = 0; Aa < 8; Aa++)
                ia |= Pn[Aa][((aa ^ na[Aa]) & Un[Aa]) >>> 0];
              this._lBlock = aa, this._rBlock = ra ^ ia;
            }
            var sa = this._lBlock;
            this._lBlock = this._rBlock, this._rBlock = sa, zn.call(this, 1, 1431655765), Gn.call(this, 8, 16711935), Gn.call(this, 2, 858993459), zn.call(this, 16, 65535), zn.call(this, 4, 252645135), Wn[Xn] = this._lBlock, Wn[Xn + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function zn(Wn, Xn) {
          var ea = (this._lBlock >>> Wn ^ this._rBlock) & Xn;
          this._rBlock ^= ea, this._lBlock ^= ea << Wn;
        }
        function Gn(Wn, Xn) {
          var ea = (this._rBlock >>> Wn ^ this._lBlock) & Xn;
          this._lBlock ^= ea, this._rBlock ^= ea << Wn;
        }
        Bn.DES = Ln._createHelper(Hn);
        var Yn = $n.TripleDES = Ln.extend({
          _doReset: function() {
            var Wn = this._key, Xn = Wn.words;
            if (Xn.length !== 2 && Xn.length !== 4 && Xn.length < 6)
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            var ea = Xn.slice(0, 2), ta = Xn.length < 4 ? Xn.slice(0, 2) : Xn.slice(2, 4), na = Xn.length < 6 ? Xn.slice(0, 2) : Xn.slice(4, 6);
            this._des1 = Hn.createEncryptor(Dn.create(ea)), this._des2 = Hn.createEncryptor(Dn.create(ta)), this._des3 = Hn.createEncryptor(Dn.create(na));
          },
          encryptBlock: function(Wn, Xn) {
            this._des1.encryptBlock(Wn, Xn), this._des2.decryptBlock(Wn, Xn), this._des3.encryptBlock(Wn, Xn);
          },
          decryptBlock: function(Wn, Xn) {
            this._des3.decryptBlock(Wn, Xn), this._des2.encryptBlock(Wn, Xn), this._des1.decryptBlock(Wn, Xn);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        Bn.TripleDES = Ln._createHelper(Yn);
      }(), Cn.TripleDES;
    });
  }(tripledes)), tripledes.exports;
}
var rc4 = { exports: {} }, hasRequiredRc4;
function requireRc4() {
  return hasRequiredRc4 || (hasRequiredRc4 = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.StreamCipher, Ln = Bn.algo, $n = Ln.RC4 = Dn.extend({
          _doReset: function() {
            for (var Fn = this._key, Pn = Fn.words, Un = Fn.sigBytes, Hn = this._S = [], zn = 0; zn < 256; zn++)
              Hn[zn] = zn;
            for (var zn = 0, Gn = 0; zn < 256; zn++) {
              var Yn = zn % Un, Wn = Pn[Yn >>> 2] >>> 24 - Yn % 4 * 8 & 255;
              Gn = (Gn + Hn[zn] + Wn) % 256;
              var Xn = Hn[zn];
              Hn[zn] = Hn[Gn], Hn[Gn] = Xn;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(Fn, Pn) {
            Fn[Pn] ^= Nn.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function Nn() {
          for (var Fn = this._S, Pn = this._i, Un = this._j, Hn = 0, zn = 0; zn < 4; zn++) {
            Pn = (Pn + 1) % 256, Un = (Un + Fn[Pn]) % 256;
            var Gn = Fn[Pn];
            Fn[Pn] = Fn[Un], Fn[Un] = Gn, Hn |= Fn[(Fn[Pn] + Fn[Un]) % 256] << 24 - zn * 8;
          }
          return this._i = Pn, this._j = Un, Hn;
        }
        Bn.RC4 = Dn._createHelper($n);
        var Rn = Ln.RC4Drop = $n.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: $n.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            $n._doReset.call(this);
            for (var Fn = this.cfg.drop; Fn > 0; Fn--)
              Nn.call(this);
          }
        });
        Bn.RC4Drop = Dn._createHelper(Rn);
      }(), Cn.RC4;
    });
  }(rc4)), rc4.exports;
}
var rabbit = { exports: {} }, hasRequiredRabbit;
function requireRabbit() {
  return hasRequiredRabbit || (hasRequiredRabbit = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.StreamCipher, Ln = Bn.algo, $n = [], Nn = [], Rn = [], Fn = Ln.Rabbit = Dn.extend({
          _doReset: function() {
            for (var Un = this._key.words, Hn = this.cfg.iv, zn = 0; zn < 4; zn++)
              Un[zn] = (Un[zn] << 8 | Un[zn] >>> 24) & 16711935 | (Un[zn] << 24 | Un[zn] >>> 8) & 4278255360;
            var Gn = this._X = [
              Un[0],
              Un[3] << 16 | Un[2] >>> 16,
              Un[1],
              Un[0] << 16 | Un[3] >>> 16,
              Un[2],
              Un[1] << 16 | Un[0] >>> 16,
              Un[3],
              Un[2] << 16 | Un[1] >>> 16
            ], Yn = this._C = [
              Un[2] << 16 | Un[2] >>> 16,
              Un[0] & 4294901760 | Un[1] & 65535,
              Un[3] << 16 | Un[3] >>> 16,
              Un[1] & 4294901760 | Un[2] & 65535,
              Un[0] << 16 | Un[0] >>> 16,
              Un[2] & 4294901760 | Un[3] & 65535,
              Un[1] << 16 | Un[1] >>> 16,
              Un[3] & 4294901760 | Un[0] & 65535
            ];
            this._b = 0;
            for (var zn = 0; zn < 4; zn++)
              Pn.call(this);
            for (var zn = 0; zn < 8; zn++)
              Yn[zn] ^= Gn[zn + 4 & 7];
            if (Hn) {
              var Wn = Hn.words, Xn = Wn[0], ea = Wn[1], ta = (Xn << 8 | Xn >>> 24) & 16711935 | (Xn << 24 | Xn >>> 8) & 4278255360, na = (ea << 8 | ea >>> 24) & 16711935 | (ea << 24 | ea >>> 8) & 4278255360, ra = ta >>> 16 | na & 4294901760, aa = na << 16 | ta & 65535;
              Yn[0] ^= ta, Yn[1] ^= ra, Yn[2] ^= na, Yn[3] ^= aa, Yn[4] ^= ta, Yn[5] ^= ra, Yn[6] ^= na, Yn[7] ^= aa;
              for (var zn = 0; zn < 4; zn++)
                Pn.call(this);
            }
          },
          _doProcessBlock: function(Un, Hn) {
            var zn = this._X;
            Pn.call(this), $n[0] = zn[0] ^ zn[5] >>> 16 ^ zn[3] << 16, $n[1] = zn[2] ^ zn[7] >>> 16 ^ zn[5] << 16, $n[2] = zn[4] ^ zn[1] >>> 16 ^ zn[7] << 16, $n[3] = zn[6] ^ zn[3] >>> 16 ^ zn[1] << 16;
            for (var Gn = 0; Gn < 4; Gn++)
              $n[Gn] = ($n[Gn] << 8 | $n[Gn] >>> 24) & 16711935 | ($n[Gn] << 24 | $n[Gn] >>> 8) & 4278255360, Un[Hn + Gn] ^= $n[Gn];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function Pn() {
          for (var Un = this._X, Hn = this._C, zn = 0; zn < 8; zn++)
            Nn[zn] = Hn[zn];
          Hn[0] = Hn[0] + 1295307597 + this._b | 0, Hn[1] = Hn[1] + 3545052371 + (Hn[0] >>> 0 < Nn[0] >>> 0 ? 1 : 0) | 0, Hn[2] = Hn[2] + 886263092 + (Hn[1] >>> 0 < Nn[1] >>> 0 ? 1 : 0) | 0, Hn[3] = Hn[3] + 1295307597 + (Hn[2] >>> 0 < Nn[2] >>> 0 ? 1 : 0) | 0, Hn[4] = Hn[4] + 3545052371 + (Hn[3] >>> 0 < Nn[3] >>> 0 ? 1 : 0) | 0, Hn[5] = Hn[5] + 886263092 + (Hn[4] >>> 0 < Nn[4] >>> 0 ? 1 : 0) | 0, Hn[6] = Hn[6] + 1295307597 + (Hn[5] >>> 0 < Nn[5] >>> 0 ? 1 : 0) | 0, Hn[7] = Hn[7] + 3545052371 + (Hn[6] >>> 0 < Nn[6] >>> 0 ? 1 : 0) | 0, this._b = Hn[7] >>> 0 < Nn[7] >>> 0 ? 1 : 0;
          for (var zn = 0; zn < 8; zn++) {
            var Gn = Un[zn] + Hn[zn], Yn = Gn & 65535, Wn = Gn >>> 16, Xn = ((Yn * Yn >>> 17) + Yn * Wn >>> 15) + Wn * Wn, ea = ((Gn & 4294901760) * Gn | 0) + ((Gn & 65535) * Gn | 0);
            Rn[zn] = Xn ^ ea;
          }
          Un[0] = Rn[0] + (Rn[7] << 16 | Rn[7] >>> 16) + (Rn[6] << 16 | Rn[6] >>> 16) | 0, Un[1] = Rn[1] + (Rn[0] << 8 | Rn[0] >>> 24) + Rn[7] | 0, Un[2] = Rn[2] + (Rn[1] << 16 | Rn[1] >>> 16) + (Rn[0] << 16 | Rn[0] >>> 16) | 0, Un[3] = Rn[3] + (Rn[2] << 8 | Rn[2] >>> 24) + Rn[1] | 0, Un[4] = Rn[4] + (Rn[3] << 16 | Rn[3] >>> 16) + (Rn[2] << 16 | Rn[2] >>> 16) | 0, Un[5] = Rn[5] + (Rn[4] << 8 | Rn[4] >>> 24) + Rn[3] | 0, Un[6] = Rn[6] + (Rn[5] << 16 | Rn[5] >>> 16) + (Rn[4] << 16 | Rn[4] >>> 16) | 0, Un[7] = Rn[7] + (Rn[6] << 8 | Rn[6] >>> 24) + Rn[5] | 0;
        }
        Bn.Rabbit = Dn._createHelper(Fn);
      }(), Cn.Rabbit;
    });
  }(rabbit)), rabbit.exports;
}
var rabbitLegacy = { exports: {} }, hasRequiredRabbitLegacy;
function requireRabbitLegacy() {
  return hasRequiredRabbitLegacy || (hasRequiredRabbitLegacy = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.StreamCipher, Ln = Bn.algo, $n = [], Nn = [], Rn = [], Fn = Ln.RabbitLegacy = Dn.extend({
          _doReset: function() {
            var Un = this._key.words, Hn = this.cfg.iv, zn = this._X = [
              Un[0],
              Un[3] << 16 | Un[2] >>> 16,
              Un[1],
              Un[0] << 16 | Un[3] >>> 16,
              Un[2],
              Un[1] << 16 | Un[0] >>> 16,
              Un[3],
              Un[2] << 16 | Un[1] >>> 16
            ], Gn = this._C = [
              Un[2] << 16 | Un[2] >>> 16,
              Un[0] & 4294901760 | Un[1] & 65535,
              Un[3] << 16 | Un[3] >>> 16,
              Un[1] & 4294901760 | Un[2] & 65535,
              Un[0] << 16 | Un[0] >>> 16,
              Un[2] & 4294901760 | Un[3] & 65535,
              Un[1] << 16 | Un[1] >>> 16,
              Un[3] & 4294901760 | Un[0] & 65535
            ];
            this._b = 0;
            for (var Yn = 0; Yn < 4; Yn++)
              Pn.call(this);
            for (var Yn = 0; Yn < 8; Yn++)
              Gn[Yn] ^= zn[Yn + 4 & 7];
            if (Hn) {
              var Wn = Hn.words, Xn = Wn[0], ea = Wn[1], ta = (Xn << 8 | Xn >>> 24) & 16711935 | (Xn << 24 | Xn >>> 8) & 4278255360, na = (ea << 8 | ea >>> 24) & 16711935 | (ea << 24 | ea >>> 8) & 4278255360, ra = ta >>> 16 | na & 4294901760, aa = na << 16 | ta & 65535;
              Gn[0] ^= ta, Gn[1] ^= ra, Gn[2] ^= na, Gn[3] ^= aa, Gn[4] ^= ta, Gn[5] ^= ra, Gn[6] ^= na, Gn[7] ^= aa;
              for (var Yn = 0; Yn < 4; Yn++)
                Pn.call(this);
            }
          },
          _doProcessBlock: function(Un, Hn) {
            var zn = this._X;
            Pn.call(this), $n[0] = zn[0] ^ zn[5] >>> 16 ^ zn[3] << 16, $n[1] = zn[2] ^ zn[7] >>> 16 ^ zn[5] << 16, $n[2] = zn[4] ^ zn[1] >>> 16 ^ zn[7] << 16, $n[3] = zn[6] ^ zn[3] >>> 16 ^ zn[1] << 16;
            for (var Gn = 0; Gn < 4; Gn++)
              $n[Gn] = ($n[Gn] << 8 | $n[Gn] >>> 24) & 16711935 | ($n[Gn] << 24 | $n[Gn] >>> 8) & 4278255360, Un[Hn + Gn] ^= $n[Gn];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function Pn() {
          for (var Un = this._X, Hn = this._C, zn = 0; zn < 8; zn++)
            Nn[zn] = Hn[zn];
          Hn[0] = Hn[0] + 1295307597 + this._b | 0, Hn[1] = Hn[1] + 3545052371 + (Hn[0] >>> 0 < Nn[0] >>> 0 ? 1 : 0) | 0, Hn[2] = Hn[2] + 886263092 + (Hn[1] >>> 0 < Nn[1] >>> 0 ? 1 : 0) | 0, Hn[3] = Hn[3] + 1295307597 + (Hn[2] >>> 0 < Nn[2] >>> 0 ? 1 : 0) | 0, Hn[4] = Hn[4] + 3545052371 + (Hn[3] >>> 0 < Nn[3] >>> 0 ? 1 : 0) | 0, Hn[5] = Hn[5] + 886263092 + (Hn[4] >>> 0 < Nn[4] >>> 0 ? 1 : 0) | 0, Hn[6] = Hn[6] + 1295307597 + (Hn[5] >>> 0 < Nn[5] >>> 0 ? 1 : 0) | 0, Hn[7] = Hn[7] + 3545052371 + (Hn[6] >>> 0 < Nn[6] >>> 0 ? 1 : 0) | 0, this._b = Hn[7] >>> 0 < Nn[7] >>> 0 ? 1 : 0;
          for (var zn = 0; zn < 8; zn++) {
            var Gn = Un[zn] + Hn[zn], Yn = Gn & 65535, Wn = Gn >>> 16, Xn = ((Yn * Yn >>> 17) + Yn * Wn >>> 15) + Wn * Wn, ea = ((Gn & 4294901760) * Gn | 0) + ((Gn & 65535) * Gn | 0);
            Rn[zn] = Xn ^ ea;
          }
          Un[0] = Rn[0] + (Rn[7] << 16 | Rn[7] >>> 16) + (Rn[6] << 16 | Rn[6] >>> 16) | 0, Un[1] = Rn[1] + (Rn[0] << 8 | Rn[0] >>> 24) + Rn[7] | 0, Un[2] = Rn[2] + (Rn[1] << 16 | Rn[1] >>> 16) + (Rn[0] << 16 | Rn[0] >>> 16) | 0, Un[3] = Rn[3] + (Rn[2] << 8 | Rn[2] >>> 24) + Rn[1] | 0, Un[4] = Rn[4] + (Rn[3] << 16 | Rn[3] >>> 16) + (Rn[2] << 16 | Rn[2] >>> 16) | 0, Un[5] = Rn[5] + (Rn[4] << 8 | Rn[4] >>> 24) + Rn[3] | 0, Un[6] = Rn[6] + (Rn[5] << 16 | Rn[5] >>> 16) + (Rn[4] << 16 | Rn[4] >>> 16) | 0, Un[7] = Rn[7] + (Rn[6] << 8 | Rn[6] >>> 24) + Rn[5] | 0;
        }
        Bn.RabbitLegacy = Dn._createHelper(Fn);
      }(), Cn.RabbitLegacy;
    });
  }(rabbitLegacy)), rabbitLegacy.exports;
}
var blowfish = { exports: {} }, hasRequiredBlowfish;
function requireBlowfish() {
  return hasRequiredBlowfish || (hasRequiredBlowfish = 1, function(_n, nr) {
    (function(Cn, Bn, In) {
      _n.exports = Bn(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
    })(commonjsGlobal, function(Cn) {
      return function() {
        var Bn = Cn, In = Bn.lib, Dn = In.BlockCipher, Ln = Bn.algo;
        const $n = 16, Nn = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ], Rn = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var Fn = {
          pbox: [],
          sbox: []
        };
        function Pn(Yn, Wn) {
          let Xn = Wn >> 24 & 255, ea = Wn >> 16 & 255, ta = Wn >> 8 & 255, na = Wn & 255, ra = Yn.sbox[0][Xn] + Yn.sbox[1][ea];
          return ra = ra ^ Yn.sbox[2][ta], ra = ra + Yn.sbox[3][na], ra;
        }
        function Un(Yn, Wn, Xn) {
          let ea = Wn, ta = Xn, na;
          for (let ra = 0; ra < $n; ++ra)
            ea = ea ^ Yn.pbox[ra], ta = Pn(Yn, ea) ^ ta, na = ea, ea = ta, ta = na;
          return na = ea, ea = ta, ta = na, ta = ta ^ Yn.pbox[$n], ea = ea ^ Yn.pbox[$n + 1], { left: ea, right: ta };
        }
        function Hn(Yn, Wn, Xn) {
          let ea = Wn, ta = Xn, na;
          for (let ra = $n + 1; ra > 1; --ra)
            ea = ea ^ Yn.pbox[ra], ta = Pn(Yn, ea) ^ ta, na = ea, ea = ta, ta = na;
          return na = ea, ea = ta, ta = na, ta = ta ^ Yn.pbox[1], ea = ea ^ Yn.pbox[0], { left: ea, right: ta };
        }
        function zn(Yn, Wn, Xn) {
          for (let aa = 0; aa < 4; aa++) {
            Yn.sbox[aa] = [];
            for (let ia = 0; ia < 256; ia++)
              Yn.sbox[aa][ia] = Rn[aa][ia];
          }
          let ea = 0;
          for (let aa = 0; aa < $n + 2; aa++)
            Yn.pbox[aa] = Nn[aa] ^ Wn[ea], ea++, ea >= Xn && (ea = 0);
          let ta = 0, na = 0, ra = 0;
          for (let aa = 0; aa < $n + 2; aa += 2)
            ra = Un(Yn, ta, na), ta = ra.left, na = ra.right, Yn.pbox[aa] = ta, Yn.pbox[aa + 1] = na;
          for (let aa = 0; aa < 4; aa++)
            for (let ia = 0; ia < 256; ia += 2)
              ra = Un(Yn, ta, na), ta = ra.left, na = ra.right, Yn.sbox[aa][ia] = ta, Yn.sbox[aa][ia + 1] = na;
          return !0;
        }
        var Gn = Ln.Blowfish = Dn.extend({
          _doReset: function() {
            if (this._keyPriorReset !== this._key) {
              var Yn = this._keyPriorReset = this._key, Wn = Yn.words, Xn = Yn.sigBytes / 4;
              zn(Fn, Wn, Xn);
            }
          },
          encryptBlock: function(Yn, Wn) {
            var Xn = Un(Fn, Yn[Wn], Yn[Wn + 1]);
            Yn[Wn] = Xn.left, Yn[Wn + 1] = Xn.right;
          },
          decryptBlock: function(Yn, Wn) {
            var Xn = Hn(Fn, Yn[Wn], Yn[Wn + 1]);
            Yn[Wn] = Xn.left, Yn[Wn + 1] = Xn.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        Bn.Blowfish = Dn._createHelper(Gn);
      }(), Cn.Blowfish;
    });
  }(blowfish)), blowfish.exports;
}
(function(_n, nr) {
  (function(Cn, Bn, In) {
    _n.exports = Bn(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
  })(commonjsGlobal, function(Cn) {
    return Cn;
  });
})(cryptoJs);
var cryptoJsExports = cryptoJs.exports;
const CryptoJS = /* @__PURE__ */ getDefaultExportFromCjs(cryptoJsExports), version = "3.7.7", VERSION = version, _hasBuffer = typeof Buffer == "function", _TD = typeof TextDecoder == "function" ? new TextDecoder() : void 0, _TE = typeof TextEncoder == "function" ? new TextEncoder() : void 0, b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", b64chs = Array.prototype.slice.call(b64ch), b64tab = ((_n) => {
  let nr = {};
  return _n.forEach((Cn, Bn) => nr[Cn] = Bn), nr;
})(b64chs), b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, _fromCC = String.fromCharCode.bind(String), _U8Afrom = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : (_n) => new Uint8Array(Array.prototype.slice.call(_n, 0)), _mkUriSafe = (_n) => _n.replace(/=/g, "").replace(/[+\/]/g, (nr) => nr == "+" ? "-" : "_"), _tidyB64 = (_n) => _n.replace(/[^A-Za-z0-9\+\/]/g, ""), btoaPolyfill = (_n) => {
  let nr, Cn, Bn, In, Dn = "";
  const Ln = _n.length % 3;
  for (let $n = 0; $n < _n.length; ) {
    if ((Cn = _n.charCodeAt($n++)) > 255 || (Bn = _n.charCodeAt($n++)) > 255 || (In = _n.charCodeAt($n++)) > 255)
      throw new TypeError("invalid character found");
    nr = Cn << 16 | Bn << 8 | In, Dn += b64chs[nr >> 18 & 63] + b64chs[nr >> 12 & 63] + b64chs[nr >> 6 & 63] + b64chs[nr & 63];
  }
  return Ln ? Dn.slice(0, Ln - 3) + "===".substring(Ln) : Dn;
}, _btoa = typeof btoa == "function" ? (_n) => btoa(_n) : _hasBuffer ? (_n) => Buffer.from(_n, "binary").toString("base64") : btoaPolyfill, _fromUint8Array = _hasBuffer ? (_n) => Buffer.from(_n).toString("base64") : (_n) => {
  let Cn = [];
  for (let Bn = 0, In = _n.length; Bn < In; Bn += 4096)
    Cn.push(_fromCC.apply(null, _n.subarray(Bn, Bn + 4096)));
  return _btoa(Cn.join(""));
}, fromUint8Array = (_n, nr = !1) => nr ? _mkUriSafe(_fromUint8Array(_n)) : _fromUint8Array(_n), cb_utob = (_n) => {
  if (_n.length < 2) {
    var nr = _n.charCodeAt(0);
    return nr < 128 ? _n : nr < 2048 ? _fromCC(192 | nr >>> 6) + _fromCC(128 | nr & 63) : _fromCC(224 | nr >>> 12 & 15) + _fromCC(128 | nr >>> 6 & 63) + _fromCC(128 | nr & 63);
  } else {
    var nr = 65536 + (_n.charCodeAt(0) - 55296) * 1024 + (_n.charCodeAt(1) - 56320);
    return _fromCC(240 | nr >>> 18 & 7) + _fromCC(128 | nr >>> 12 & 63) + _fromCC(128 | nr >>> 6 & 63) + _fromCC(128 | nr & 63);
  }
}, re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, utob = (_n) => _n.replace(re_utob, cb_utob), _encode = _hasBuffer ? (_n) => Buffer.from(_n, "utf8").toString("base64") : _TE ? (_n) => _fromUint8Array(_TE.encode(_n)) : (_n) => _btoa(utob(_n)), encode = (_n, nr = !1) => nr ? _mkUriSafe(_encode(_n)) : _encode(_n), encodeURI = (_n) => encode(_n, !0), re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, cb_btou = (_n) => {
  switch (_n.length) {
    case 4:
      var nr = (7 & _n.charCodeAt(0)) << 18 | (63 & _n.charCodeAt(1)) << 12 | (63 & _n.charCodeAt(2)) << 6 | 63 & _n.charCodeAt(3), Cn = nr - 65536;
      return _fromCC((Cn >>> 10) + 55296) + _fromCC((Cn & 1023) + 56320);
    case 3:
      return _fromCC((15 & _n.charCodeAt(0)) << 12 | (63 & _n.charCodeAt(1)) << 6 | 63 & _n.charCodeAt(2));
    default:
      return _fromCC((31 & _n.charCodeAt(0)) << 6 | 63 & _n.charCodeAt(1));
  }
}, btou = (_n) => _n.replace(re_btou, cb_btou), atobPolyfill = (_n) => {
  if (_n = _n.replace(/\s+/g, ""), !b64re.test(_n))
    throw new TypeError("malformed base64.");
  _n += "==".slice(2 - (_n.length & 3));
  let nr, Cn = "", Bn, In;
  for (let Dn = 0; Dn < _n.length; )
    nr = b64tab[_n.charAt(Dn++)] << 18 | b64tab[_n.charAt(Dn++)] << 12 | (Bn = b64tab[_n.charAt(Dn++)]) << 6 | (In = b64tab[_n.charAt(Dn++)]), Cn += Bn === 64 ? _fromCC(nr >> 16 & 255) : In === 64 ? _fromCC(nr >> 16 & 255, nr >> 8 & 255) : _fromCC(nr >> 16 & 255, nr >> 8 & 255, nr & 255);
  return Cn;
}, _atob = typeof atob == "function" ? (_n) => atob(_tidyB64(_n)) : _hasBuffer ? (_n) => Buffer.from(_n, "base64").toString("binary") : atobPolyfill, _toUint8Array = _hasBuffer ? (_n) => _U8Afrom(Buffer.from(_n, "base64")) : (_n) => _U8Afrom(_atob(_n).split("").map((nr) => nr.charCodeAt(0))), toUint8Array = (_n) => _toUint8Array(_unURI(_n)), _decode = _hasBuffer ? (_n) => Buffer.from(_n, "base64").toString("utf8") : _TD ? (_n) => _TD.decode(_toUint8Array(_n)) : (_n) => btou(_atob(_n)), _unURI = (_n) => _tidyB64(_n.replace(/[-_]/g, (nr) => nr == "-" ? "+" : "/")), decode = (_n) => _decode(_unURI(_n)), isValid = (_n) => {
  if (typeof _n != "string")
    return !1;
  const nr = _n.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(nr) || !/[^\s0-9a-zA-Z\-_]/.test(nr);
}, _noEnum = (_n) => ({
  value: _n,
  enumerable: !1,
  writable: !0,
  configurable: !0
}), extendString = function() {
  const _n = (nr, Cn) => Object.defineProperty(String.prototype, nr, _noEnum(Cn));
  _n("fromBase64", function() {
    return decode(this);
  }), _n("toBase64", function(nr) {
    return encode(this, nr);
  }), _n("toBase64URI", function() {
    return encode(this, !0);
  }), _n("toBase64URL", function() {
    return encode(this, !0);
  }), _n("toUint8Array", function() {
    return toUint8Array(this);
  });
}, extendUint8Array = function() {
  const _n = (nr, Cn) => Object.defineProperty(Uint8Array.prototype, nr, _noEnum(Cn));
  _n("toBase64", function(nr) {
    return fromUint8Array(this, nr);
  }), _n("toBase64URI", function() {
    return fromUint8Array(this, !0);
  }), _n("toBase64URL", function() {
    return fromUint8Array(this, !0);
  });
}, extendBuiltins = () => {
  extendString(), extendUint8Array();
}, gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI,
  encodeURL: encodeURI,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
}, newFunctionHandle = (_n, nr, Cn, Bn, In, Dn) => {
  try {
    if (!Cn)
      return _n;
    const $n = new Function("data", "res", Cn)(cloneDeep(_n), cloneDeep(nr)), Nn = Bn ? toString($n) : $n;
    return Dn && Dn(Nn), Nn;
  } catch (Ln) {
    return In && In(Ln), "函数执行错误";
  }
};
function runFunc(_n, nr, Cn, Bn, In) {
  try {
    if (!nr)
      return;
    const Ln = new Function("currentUserInfo", nr)(cloneDeep(_n)), $n = Cn ? toString(Ln) : Ln;
    return In && In($n), $n;
  } catch (Dn) {
    return Bn && Bn(Dn), "函数执行错误";
  }
}
const formatParam = (_n, nr, Cn) => {
  let Bn;
  return nr === "array" ? Bn = [] : Bn = {}, _n.forEach((In) => {
    let Dn = In.value;
    if (In.valueType === ValueTypeEnum.COUSTOM)
      Dn = In.value;
    else if (In.valueType === ValueTypeEnum.FORM) {
      if (Dn = Cn.formData[In.value], In.key === "password")
        if (Cn.encryptionType === 1)
          Dn = gBase64.encode(Cn.formData[In.value]);
        else if (Cn.encryptionType === 2) {
          let Ln = Cn.rsaPublicKey || "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCDL0F4Zy+o2s5Yx9DLyJyVS30EO6+cTRx12DDqiXhtJS+LmEzkJnHQ4aC0quCjePiB8tPK0EsLsRyXg1ZksIZQNW94M85D7N8RpG83oxJYYGgHm/n6llrZPuGJzj1jj8JuH86QvDLU5IUb3V0fnGADSj2RtmaTRswN5moJbillYQIDAQAB";
          Dn = encryptWithRSA(Ln, Dn + "");
        } else
          Cn.encryptionType === 4 && (Dn = CryptoJS.SHA1(Dn).toString());
    } else
      In.valueType === ValueTypeEnum.LINK ? window.$components[Dn] && (Dn = window.$components[Dn].props.chartConfig.option.value) : In.valueType === ValueTypeEnum.GLOBAL ? (Cn.loginInfo && (Dn === "token" ? Dn = Cn.loginInfo.token : Dn === "userId" ? Dn = Cn.loginInfo.id : Dn === "roles" ? Dn = JSONStringify(Cn.loginInfo.roles) : Dn === "groups" && (Dn = JSONStringify(Cn.loginInfo.groups))), Dn === "projectId" && (Dn = Cn.groupId)) : In.valueType === ValueTypeEnum.OBJECT ? Dn = runFunc(Cn.loginInfo, In.content) : In.valueType === ValueTypeEnum.CURRENT ? (Dn = Cn[In.value], console.log(Dn)) : In.valueType === ValueTypeEnum.QUERY && (Dn = getQueryString(In.value));
    In.key && (nr === "array" ? Bn.push({ key: In.key, value: Dn }) : Bn[In.key] = Dn);
  }), Bn;
}, getQueryString = (_n) => {
  const nr = new RegExp("(^|&)" + _n + "=([^&]*)(&|$)", "i");
  return ((window.location.href.split("?")[1] || "").match(nr) || [])[2];
}, setTitle = (_n) => {
  _n && (document.title = _n);
}, getLoginType = () => {
  let _n = getLocalStorage("loginType");
  if (_n)
    try {
      _n = gBase64.decode(_n), _n = JSONParse(_n);
    } catch {
      console.log("解析登录类型失败"), _n = {};
    }
  return _n || {};
}, methodMap = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror"
  ],
  // New WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  // Old WebKit
  [
    "webkitRequestFullScreen",
    "webkitCancelFullScreen",
    "webkitCurrentFullScreenElement",
    "webkitCancelFullScreen",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror"
  ],
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError"
  ]
], nativeAPI = (() => {
  if (typeof document > "u")
    return !1;
  const _n = methodMap[0], nr = {};
  for (const Cn of methodMap)
    if ((Cn == null ? void 0 : Cn[1]) in document) {
      for (const [In, Dn] of Cn.entries())
        nr[_n[In]] = Dn;
      return nr;
    }
  return !1;
})(), eventNameMap = {
  change: nativeAPI.fullscreenchange,
  error: nativeAPI.fullscreenerror
};
let screenfull = {
  // eslint-disable-next-line default-param-last
  request(_n = document.documentElement, nr) {
    return new Promise((Cn, Bn) => {
      const In = () => {
        screenfull.off("change", In), Cn();
      };
      screenfull.on("change", In);
      const Dn = _n[nativeAPI.requestFullscreen](nr);
      Dn instanceof Promise && Dn.then(In).catch(Bn);
    });
  },
  exit() {
    return new Promise((_n, nr) => {
      if (!screenfull.isFullscreen) {
        _n();
        return;
      }
      const Cn = () => {
        screenfull.off("change", Cn), _n();
      };
      screenfull.on("change", Cn);
      const Bn = document[nativeAPI.exitFullscreen]();
      Bn instanceof Promise && Bn.then(Cn).catch(nr);
    });
  },
  toggle(_n, nr) {
    return screenfull.isFullscreen ? screenfull.exit() : screenfull.request(_n, nr);
  },
  onchange(_n) {
    screenfull.on("change", _n);
  },
  onerror(_n) {
    screenfull.on("error", _n);
  },
  on(_n, nr) {
    const Cn = eventNameMap[_n];
    Cn && document.addEventListener(Cn, nr, !1);
  },
  off(_n, nr) {
    const Cn = eventNameMap[_n];
    Cn && document.removeEventListener(Cn, nr, !1);
  },
  raw: nativeAPI
};
Object.defineProperties(screenfull, {
  isFullscreen: {
    get: () => !!document[nativeAPI.fullscreenElement]
  },
  element: {
    enumerable: !0,
    get: () => document[nativeAPI.fullscreenElement] ?? void 0
  },
  isEnabled: {
    enumerable: !0,
    // Coerce to boolean in case of old WebKit.
    get: () => !!document[nativeAPI.fullscreenEnabled]
  }
});
nativeAPI || (screenfull = { isEnabled: !1 });
function getRolesList(_n) {
  return get$1(`/dms/role/list/1/${_n}`);
}
function screenPerms(_n, nr, Cn) {
  return get$1("/dms/perms/screen/perms/user/" + _n + "/" + nr, {}, { Authorization: Cn });
}
const chartEditStore = useChartEditStore(), getSessionStorageInfo = async () => {
  const nr = document.location.hash.split("/"), Cn = nr && nr[nr.length - 1], Bn = getSessionStorage(
    StorageEnum.DMS_CHART_STORAGE_LIST
  );
  if (Bn) {
    for (let In = 0; In < Bn.length; In++)
      if (Cn.toString() === Bn[In].id) {
        let { editCanvasConfig: Dn, requestGlobalConfig: Ln, componentList: $n, globalEvent: Nn } = Bn[In];
        return Dn.hasPerms = !0, chartEditStore.editCanvasConfig = Dn, chartEditStore.requestGlobalConfig = Ln, chartEditStore.globalEvent = Nn, chartEditStore.componentList = $n, Bn[In];
      }
  }
}, getPublishScreenInfo = async () => {
  const nr = document.location.hash.split("/"), Cn = nr && nr[nr.length - 1];
  return getHistoryInfo(Cn).then(dealData);
};
let responseData = null;
const dealData = async (_n) => {
  if (_n && (responseData = _n), !responseData)
    return !1;
  const { code: nr, data: Cn } = responseData;
  if (nr === 200 && Cn && Cn.content) {
    const Bn = JSONParse(Cn.content);
    if (isPreview()) {
      Bn.editCanvasConfig.hasPerms = !0;
      let In = "", Dn = 0, Ln = getLocalStorage("loginInfo" + Bn.editCanvasConfig.loginPageId);
      if (Ln)
        try {
          Ln = JSON.parse(Ln), In = Ln.data.token, Dn = Ln.data.projectId;
        } catch {
          console.log("失败");
        }
      if (Bn.editCanvasConfig.previewScaleType === "auto") {
        let $n = { width: 1, height: 1 };
        $n.width = window.innerWidth / Bn.editCanvasConfig.width, $n.height = window.innerHeight / Bn.editCanvasConfig.height;
        const Nn = (Fn) => {
          if (Fn.originAttr || (Fn.originAttr = {
            scale: $n,
            attr: cloneDeep(Fn.attr),
            option: cloneDeep(Fn.option)
          }), Fn.attr.w = Fn.attr.w * $n.width, Fn.attr.h = Fn.attr.h * $n.height, Fn.attr.x = Fn.attr.x * $n.width, Fn.attr.y = Fn.attr.y * $n.height, Fn.option) {
            ["OneUnifyMenu", "ThemeMenu", "ItemMenu", "DatasetMenu"].includes(Fn.key) && Fn.option.style.menuWidth && (Fn.option.style.menuWidth = Fn.option.style.menuWidth * $n.width), Fn.option.collapseStyle && Fn.option.collapseStyle.width && (Fn.option.collapseStyle.width = Fn.option.collapseStyle.width * $n.width), Fn.option.collapseStyle && Fn.option.collapseStyle.height && (Fn.option.collapseStyle.height = Fn.option.collapseStyle.height * $n.width);
            const Pn = $n.width > 1.25 ? 1.25 : $n.width;
            Fn.option.style && Fn.option.style.fontSize && (Fn.option.style.fontSize = Fn.option.style.fontSize * Pn), Fn.option.style && Fn.option.style.subFontSize && (Fn.option.style.subFontSize = Fn.option.style.subFontSize * Pn), Fn.option.style && Fn.option.style.timeSize && (Fn.option.style.timeSize = Fn.originAttr.option.style.timeSize * $n.width), Fn.option.style && Fn.option.style.timeLineHeight && (Fn.option.style.timeLineHeight = Fn.originAttr.option.style.timeLineHeight * $n.height), Fn.option.style && Fn.option.style.width && (Fn.option.style.width = Fn.option.style.width * $n.width), ["CustomTable"].indexOf(Fn.key) === -1 && Fn.option.hoverStyle && Fn.option.hoverStyle.fontSize && (Fn.option.hoverStyle.fontSize = Fn.option.hoverStyle.fontSize * Pn), Fn.option.hoverStyle && Fn.option.hoverStyle.width && (Fn.option.hoverStyle.width = Fn.option.hoverStyle.width * $n.width), Fn.option.activeStyle && Fn.option.activeStyle.fontSize && (Fn.option.activeStyle.fontSize = Fn.option.activeStyle.fontSize * Pn), Fn.option.activeStyle && Fn.option.activeStyle.width && (Fn.option.activeStyle.width = Fn.option.activeStyle.width * $n.width), Fn.option.fontSize && (Fn.option.fontSize = Fn.option.fontSize * Pn), Fn.option.timeSize && (Fn.option.timeSize = Fn.option.timeSize * Pn);
          }
        }, Rn = (Fn) => {
          Fn.map((Pn) => {
            Nn(Pn), Pn.groupList && Rn(Pn.groupList), Pn.componentList && Rn(Pn.componentList);
          });
        };
        Rn(Bn.componentList);
      }
      In && screenPerms(Dn, Bn.editCanvasConfig.id, In).then(async ($n) => {
        if ($n && $n.code === 200 && $n.data) {
          const Nn = $n.data.component.map((Fn) => Fn.widgetId);
          let Rn = [];
          $n.data.thirdPerms && (Rn = $n.data.thirdPerms.map((Fn) => Fn.widgetId)), Nn.length > 0 && Bn.componentList && (await Bn.componentList.map((Fn) => {
            if (Fn.setAuth) {
              if (Nn.indexOf(Fn.id) === -1 && (Fn.hasGrant = !1), Fn.option) {
                if (Fn.option.buttons) {
                  const Pn = [];
                  Rn.forEach((Un) => {
                    Un.indexOf(Fn.id + "_button_") > -1 && Pn.push(Un.split("_button_")[1]);
                  }), Fn.option.btnGrantIds = Pn;
                }
                if (Fn.option.menu_menu || Fn.option.menu || ["Menu", "Menu2", "Menu3"].includes(Fn.key)) {
                  const Pn = [];
                  Rn.forEach((Un) => {
                    Un.indexOf(Fn.id + "_menu_") > -1 && Pn.push(Un.split("_menu_")[1]);
                  }), Fn.option.menuGrantIds = Pn;
                }
              }
              (Fn.groupList || Fn.componentList) && (Fn.groupList || Fn.componentList).map((Un) => {
                if (Un.setAuth && (Nn.indexOf(Un.id) === -1 && (Un.hasGrant = !1), Un.option)) {
                  if (Un.option.buttons) {
                    const Hn = [];
                    Rn.forEach((zn) => {
                      zn.indexOf(Un.id + "_button_") > -1 && Hn.push(zn.split("_button_")[1]);
                    }), Un.option.btnGrantIds = Hn;
                  }
                  if (Un.option.menu_menu || Un.option.menu || ["Menu", "Menu2", "Menu3"].includes(Un.key)) {
                    const Hn = [];
                    Rn.forEach((zn) => {
                      zn.indexOf(Un.id + "_menu_") > -1 && Hn.push(zn.split("_menu_")[1]);
                    }), Un.option.menuGrantIds = Hn;
                  }
                }
              });
            }
          }), chartEditStore.componentList = Bn.componentList);
        }
      }).catch(($n) => {
        console.error($n);
      });
    }
    chartEditStore.editCanvasConfig = Bn.editCanvasConfig, chartEditStore.requestGlobalConfig = Bn.requestGlobalConfig, chartEditStore.globalEvent = Bn.globalEvent, chartEditStore.componentList = Bn.componentList;
  }
  return chartEditStore;
}, getScreenDataInfo = async (_n) => {
  const nr = document.location.hash, Cn = nr.split("/");
  let Bn = Cn && Cn[Cn.length - 1];
  const In = nr.replace("#", "").split("?")[0];
  if (_n) {
    const Dn = localStorage.getItem("RouterMatching");
    let Ln = [];
    Dn && (Ln = JSON.parse(Dn)), Ln.forEach(($n) => {
      ($n.path === In || "/" + $n.path === In) && (Bn = $n.id);
    });
  }
  return getScreenInfo(Bn).then(dealData);
};
var mathSin = Math.sin, mathCos = Math.cos, PI$4 = Math.PI, PI2$1 = Math.PI * 2, degree = 180 / PI$4, SVGPathRebuilder = function() {
  function _n() {
  }
  return _n.prototype.reset = function(nr) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, nr || 4);
  }, _n.prototype.moveTo = function(nr, Cn) {
    this._add("M", nr, Cn);
  }, _n.prototype.lineTo = function(nr, Cn) {
    this._add("L", nr, Cn);
  }, _n.prototype.bezierCurveTo = function(nr, Cn, Bn, In, Dn, Ln) {
    this._add("C", nr, Cn, Bn, In, Dn, Ln);
  }, _n.prototype.quadraticCurveTo = function(nr, Cn, Bn, In) {
    this._add("Q", nr, Cn, Bn, In);
  }, _n.prototype.arc = function(nr, Cn, Bn, In, Dn, Ln) {
    this.ellipse(nr, Cn, Bn, Bn, 0, In, Dn, Ln);
  }, _n.prototype.ellipse = function(nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
    var Rn = $n - Ln, Fn = !Nn, Pn = Math.abs(Rn), Un = isAroundZero(Pn - PI2$1) || (Fn ? Rn >= PI2$1 : -Rn >= PI2$1), Hn = Rn > 0 ? Rn % PI2$1 : Rn % PI2$1 + PI2$1, zn = !1;
    Un ? zn = !0 : isAroundZero(Pn) ? zn = !1 : zn = Hn >= PI$4 == !!Fn;
    var Gn = nr + Bn * mathCos(Ln), Yn = Cn + In * mathSin(Ln);
    this._start && this._add("M", Gn, Yn);
    var Wn = Math.round(Dn * degree);
    if (Un) {
      var Xn = 1 / this._p, ea = (Fn ? 1 : -1) * (PI2$1 - Xn);
      this._add("A", Bn, In, Wn, 1, +Fn, nr + Bn * mathCos(Ln + ea), Cn + In * mathSin(Ln + ea)), Xn > 0.01 && this._add("A", Bn, In, Wn, 0, +Fn, Gn, Yn);
    } else {
      var ta = nr + Bn * mathCos($n), na = Cn + In * mathSin($n);
      this._add("A", Bn, In, Wn, +zn, +Fn, ta, na);
    }
  }, _n.prototype.rect = function(nr, Cn, Bn, In) {
    this._add("M", nr, Cn), this._add("l", Bn, 0), this._add("l", 0, In), this._add("l", -Bn, 0), this._add("Z");
  }, _n.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, _n.prototype._add = function(nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn) {
    for (var Fn = [], Pn = this._p, Un = 1; Un < arguments.length; Un++) {
      var Hn = arguments[Un];
      if (isNaN(Hn)) {
        this._invalid = !0;
        return;
      }
      Fn.push(Math.round(Hn * Pn) / Pn);
    }
    this._d.push(nr + Fn.join(" ")), this._start = nr === "Z";
  }, _n.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, _n.prototype.getStr = function() {
    return this._str;
  }, _n;
}();
const SVGPathRebuilder$1 = SVGPathRebuilder;
var NONE = "none", mathRound = Math.round;
function pathHasFill(_n) {
  var nr = _n.fill;
  return nr != null && nr !== NONE;
}
function pathHasStroke(_n) {
  var nr = _n.stroke;
  return nr != null && nr !== NONE;
}
var strokeProps = ["lineCap", "miterLimit", "lineJoin"], svgStrokeProps = map$1(strokeProps, function(_n) {
  return "stroke-" + _n.toLowerCase();
});
function mapStyleToAttrs(_n, nr, Cn, Bn) {
  var In = nr.opacity == null ? 1 : nr.opacity;
  if (Cn instanceof ZRImage$1) {
    _n("opacity", In);
    return;
  }
  if (pathHasFill(nr)) {
    var Dn = normalizeColor(nr.fill);
    _n("fill", Dn.color);
    var Ln = nr.fillOpacity != null ? nr.fillOpacity * Dn.opacity * In : Dn.opacity * In;
    (Bn || Ln < 1) && _n("fill-opacity", Ln);
  } else
    _n("fill", NONE);
  if (pathHasStroke(nr)) {
    var $n = normalizeColor(nr.stroke);
    _n("stroke", $n.color);
    var Nn = nr.strokeNoScale ? Cn.getLineScale() : 1, Rn = Nn ? (nr.lineWidth || 0) / Nn : 0, Fn = nr.strokeOpacity != null ? nr.strokeOpacity * $n.opacity * In : $n.opacity * In, Pn = nr.strokeFirst;
    if ((Bn || Rn !== 1) && _n("stroke-width", Rn), (Bn || Pn) && _n("paint-order", Pn ? "stroke" : "fill"), (Bn || Fn < 1) && _n("stroke-opacity", Fn), nr.lineDash) {
      var Un = getLineDash(Cn), Hn = Un[0], zn = Un[1];
      Hn && (zn = mathRound(zn || 0), _n("stroke-dasharray", Hn.join(",")), (zn || Bn) && _n("stroke-dashoffset", zn));
    } else
      Bn && _n("stroke-dasharray", NONE);
    for (var Gn = 0; Gn < strokeProps.length; Gn++) {
      var Yn = strokeProps[Gn];
      if (Bn || nr[Yn] !== DEFAULT_PATH_STYLE[Yn]) {
        var Wn = nr[Yn] || DEFAULT_PATH_STYLE[Yn];
        Wn && _n(svgStrokeProps[Gn], Wn);
      }
    }
  } else
    Bn && _n("stroke", NONE);
}
var SVGNS = "http://www.w3.org/2000/svg", XLINKNS = "http://www.w3.org/1999/xlink", XMLNS = "http://www.w3.org/2000/xmlns/", XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace", META_DATA_PREFIX = "ecmeta_";
function createElement(_n) {
  return document.createElementNS(SVGNS, _n);
}
function createVNode(_n, nr, Cn, Bn, In) {
  return {
    tag: _n,
    attrs: Cn || {},
    children: Bn,
    text: In,
    key: nr
  };
}
function createElementOpen(_n, nr) {
  var Cn = [];
  if (nr)
    for (var Bn in nr) {
      var In = nr[Bn], Dn = Bn;
      In !== !1 && (In !== !0 && In != null && (Dn += '="' + In + '"'), Cn.push(Dn));
    }
  return "<" + _n + " " + Cn.join(" ") + ">";
}
function createElementClose(_n) {
  return "</" + _n + ">";
}
function vNodeToString(_n, nr) {
  nr = nr || {};
  var Cn = nr.newline ? `
` : "";
  function Bn(In) {
    var Dn = In.children, Ln = In.tag, $n = In.attrs, Nn = In.text;
    return createElementOpen(Ln, $n) + (Ln !== "style" ? encodeHTML(Nn) : Nn || "") + (Dn ? "" + Cn + map$1(Dn, function(Rn) {
      return Bn(Rn);
    }).join(Cn) + Cn : "") + createElementClose(Ln);
  }
  return Bn(_n);
}
function getCssString(_n, nr, Cn) {
  Cn = Cn || {};
  var Bn = Cn.newline ? `
` : "", In = " {" + Bn, Dn = Bn + "}", Ln = map$1(keys(_n), function(Nn) {
    return Nn + In + map$1(keys(_n[Nn]), function(Rn) {
      return Rn + ":" + _n[Nn][Rn] + ";";
    }).join(Bn) + Dn;
  }).join(Bn), $n = map$1(keys(nr), function(Nn) {
    return "@keyframes " + Nn + In + map$1(keys(nr[Nn]), function(Rn) {
      return Rn + In + map$1(keys(nr[Nn][Rn]), function(Fn) {
        var Pn = nr[Nn][Rn][Fn];
        return Fn === "d" && (Pn = 'path("' + Pn + '")'), Fn + ":" + Pn + ";";
      }).join(Bn) + Dn;
    }).join(Bn) + Dn;
  }).join(Bn);
  return !Ln && !$n ? "" : ["<![CDATA[", Ln, $n, "]]>"].join(Bn);
}
function createBrushScope(_n) {
  return {
    zrId: _n,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function createSVGVNode(_n, nr, Cn, Bn) {
  return createVNode("svg", "root", {
    width: _n,
    height: nr,
    xmlns: SVGNS,
    "xmlns:xlink": XLINKNS,
    version: "1.1",
    baseProfile: "full",
    viewBox: Bn ? "0 0 " + _n + " " + nr : !1
  }, Cn);
}
var cssClassIdx = 0;
function getClassId() {
  return cssClassIdx++;
}
var EASING_MAP = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, transformOriginKey = "transform-origin";
function buildPathString(_n, nr, Cn) {
  var Bn = extend({}, _n.shape);
  extend(Bn, nr), _n.buildPath(Cn, Bn);
  var In = new SVGPathRebuilder$1();
  return In.reset(getPathPrecision(_n)), Cn.rebuildPath(In, 1), In.generateStr(), In.getStr();
}
function setTransformOrigin(_n, nr) {
  var Cn = nr.originX, Bn = nr.originY;
  (Cn || Bn) && (_n[transformOriginKey] = Cn + "px " + Bn + "px");
}
var ANIMATE_STYLE_MAP = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function addAnimation(_n, nr) {
  var Cn = nr.zrId + "-ani-" + nr.cssAnimIdx++;
  return nr.cssAnims[Cn] = _n, Cn;
}
function createCompoundPathCSSAnimation(_n, nr, Cn) {
  var Bn = _n.shape.paths, In = {}, Dn, Ln;
  if (each$f(Bn, function(Nn) {
    var Rn = createBrushScope(Cn.zrId);
    Rn.animation = !0, createCSSAnimation(Nn, {}, Rn, !0);
    var Fn = Rn.cssAnims, Pn = Rn.cssNodes, Un = keys(Fn), Hn = Un.length;
    if (Hn) {
      Ln = Un[Hn - 1];
      var zn = Fn[Ln];
      for (var Gn in zn) {
        var Yn = zn[Gn];
        In[Gn] = In[Gn] || { d: "" }, In[Gn].d += Yn.d || "";
      }
      for (var Wn in Pn) {
        var Xn = Pn[Wn].animation;
        Xn.indexOf(Ln) >= 0 && (Dn = Xn);
      }
    }
  }), !!Dn) {
    nr.d = !1;
    var $n = addAnimation(In, Cn);
    return Dn.replace(Ln, $n);
  }
}
function getEasingFunc(_n) {
  return isString$1(_n) ? EASING_MAP[_n] ? "cubic-bezier(" + EASING_MAP[_n] + ")" : createCubicEasingFunc(_n) ? _n : "" : "";
}
function createCSSAnimation(_n, nr, Cn, Bn) {
  var In = _n.animators, Dn = In.length, Ln = [];
  if (_n instanceof CompoundPath$1) {
    var $n = createCompoundPathCSSAnimation(_n, nr, Cn);
    if ($n)
      Ln.push($n);
    else if (!Dn)
      return;
  } else if (!Dn)
    return;
  for (var Nn = {}, Rn = 0; Rn < Dn; Rn++) {
    var Fn = In[Rn], Pn = [Fn.getMaxTime() / 1e3 + "s"], Un = getEasingFunc(Fn.getClip().easing), Hn = Fn.getDelay();
    Un ? Pn.push(Un) : Pn.push("linear"), Hn && Pn.push(Hn / 1e3 + "s"), Fn.getLoop() && Pn.push("infinite");
    var zn = Pn.join(" ");
    Nn[zn] = Nn[zn] || [zn, []], Nn[zn][1].push(Fn);
  }
  function Gn(Xn) {
    var ea = Xn[1], ta = ea.length, na = {}, ra = {}, aa = {}, ia = "animation-timing-function";
    function Aa(Sa, Ea, Ia) {
      for (var Ba = Sa.getTracks(), Ma = Sa.getMaxTime(), La = 0; La < Ba.length; La++) {
        var Da = Ba[La];
        if (Da.needsAnimate()) {
          var Na = Da.keyframes, $a = Da.propName;
          if (Ia && ($a = Ia($a)), $a)
            for (var Oa = 0; Oa < Na.length; Oa++) {
              var Pa = Na[Oa], ka = Math.round(Pa.time / Ma * 100) + "%", Ua = getEasingFunc(Pa.easing), Fa = Pa.rawValue;
              (isString$1(Fa) || isNumber(Fa)) && (Ea[ka] = Ea[ka] || {}, Ea[ka][$a] = Pa.rawValue, Ua && (Ea[ka][ia] = Ua));
            }
        }
      }
    }
    for (var sa = 0; sa < ta; sa++) {
      var oa = ea[sa], la = oa.targetName;
      la ? la === "shape" && Aa(oa, ra) : !Bn && Aa(oa, na);
    }
    for (var ua in na) {
      var ca = {};
      copyTransform(ca, _n), extend(ca, na[ua]);
      var fa = getSRTTransformString(ca), ha = na[ua][ia];
      aa[ua] = fa ? {
        transform: fa
      } : {}, setTransformOrigin(aa[ua], ca), ha && (aa[ua][ia] = ha);
    }
    var pa, ya = !0;
    for (var ua in ra) {
      aa[ua] = aa[ua] || {};
      var da = !pa, ha = ra[ua][ia];
      da && (pa = new PathProxy$1());
      var Ca = pa.len();
      pa.reset(), aa[ua].d = buildPathString(_n, ra[ua], pa);
      var ma = pa.len();
      if (!da && Ca !== ma) {
        ya = !1;
        break;
      }
      ha && (aa[ua][ia] = ha);
    }
    if (!ya)
      for (var ua in aa)
        delete aa[ua].d;
    if (!Bn)
      for (var sa = 0; sa < ta; sa++) {
        var oa = ea[sa], la = oa.targetName;
        la === "style" && Aa(oa, aa, function(Ba) {
          return ANIMATE_STYLE_MAP[Ba];
        });
      }
    for (var va = keys(aa), ga = !0, xa, sa = 1; sa < va.length; sa++) {
      var wa = va[sa - 1], ba = va[sa];
      if (aa[wa][transformOriginKey] !== aa[ba][transformOriginKey]) {
        ga = !1;
        break;
      }
      xa = aa[wa][transformOriginKey];
    }
    if (ga && xa) {
      for (var ua in aa)
        aa[ua][transformOriginKey] && delete aa[ua][transformOriginKey];
      nr[transformOriginKey] = xa;
    }
    if (filter(va, function(Sa) {
      return keys(aa[Sa]).length > 0;
    }).length) {
      var Ta = addAnimation(aa, Cn);
      return Ta + " " + Xn[0] + " both";
    }
  }
  for (var Yn in Nn) {
    var $n = Gn(Nn[Yn]);
    $n && Ln.push($n);
  }
  if (Ln.length) {
    var Wn = Cn.zrId + "-cls-" + getClassId();
    Cn.cssNodes["." + Wn] = {
      animation: Ln.join(",")
    }, nr.class = Wn;
  }
}
function createCSSEmphasis(_n, nr, Cn) {
  if (!_n.ignore)
    if (_n.isSilent()) {
      var Bn = {
        "pointer-events": "none"
      };
      setClassAttribute(Bn, nr, Cn, !0);
    } else {
      var In = _n.states.emphasis && _n.states.emphasis.style ? _n.states.emphasis.style : {}, Dn = In.fill;
      if (!Dn) {
        var Ln = _n.style && _n.style.fill, $n = _n.states.select && _n.states.select.style && _n.states.select.style.fill, Nn = _n.currentStates.indexOf("select") >= 0 && $n || Ln;
        Nn && (Dn = liftColor(Nn));
      }
      var Rn = In.lineWidth;
      if (Rn) {
        var Fn = !In.strokeNoScale && _n.transform ? _n.transform[0] : 1;
        Rn = Rn / Fn;
      }
      var Bn = {
        cursor: "pointer"
      };
      Dn && (Bn.fill = Dn), In.stroke && (Bn.stroke = In.stroke), Rn && (Bn["stroke-width"] = Rn), setClassAttribute(Bn, nr, Cn, !0);
    }
}
function setClassAttribute(_n, nr, Cn, Bn) {
  var In = JSON.stringify(_n), Dn = Cn.cssStyleCache[In];
  Dn || (Dn = Cn.zrId + "-cls-" + getClassId(), Cn.cssStyleCache[In] = Dn, Cn.cssNodes["." + Dn + (Bn ? ":hover" : "")] = _n), nr.class = nr.class ? nr.class + " " + Dn : Dn;
}
var round$1 = Math.round;
function isImageLike(_n) {
  return _n && isString$1(_n.src);
}
function isCanvasLike(_n) {
  return _n && isFunction$1(_n.toDataURL);
}
function setStyleAttrs(_n, nr, Cn, Bn) {
  mapStyleToAttrs(function(In, Dn) {
    var Ln = In === "fill" || In === "stroke";
    Ln && isGradient(Dn) ? setGradient(nr, _n, In, Bn) : Ln && isPattern(Dn) ? setPattern(Cn, _n, In, Bn) : _n[In] = Dn, Ln && Bn.ssr && Dn === "none" && (_n["pointer-events"] = "visible");
  }, nr, Cn, !1), setShadow(Cn, _n, Bn);
}
function setMetaData(_n, nr) {
  var Cn = getElementSSRData(nr);
  Cn && (Cn.each(function(Bn, In) {
    Bn != null && (_n[(META_DATA_PREFIX + In).toLowerCase()] = Bn + "");
  }), nr.isSilent() && (_n[META_DATA_PREFIX + "silent"] = "true"));
}
function noRotateScale(_n) {
  return isAroundZero(_n[0] - 1) && isAroundZero(_n[1]) && isAroundZero(_n[2]) && isAroundZero(_n[3] - 1);
}
function noTranslate(_n) {
  return isAroundZero(_n[4]) && isAroundZero(_n[5]);
}
function setTransform(_n, nr, Cn) {
  if (nr && !(noTranslate(nr) && noRotateScale(nr))) {
    var Bn = Cn ? 10 : 1e4;
    _n.transform = noRotateScale(nr) ? "translate(" + round$1(nr[4] * Bn) / Bn + " " + round$1(nr[5] * Bn) / Bn + ")" : getMatrixStr(nr);
  }
}
function convertPolyShape(_n, nr, Cn) {
  for (var Bn = _n.points, In = [], Dn = 0; Dn < Bn.length; Dn++)
    In.push(round$1(Bn[Dn][0] * Cn) / Cn), In.push(round$1(Bn[Dn][1] * Cn) / Cn);
  nr.points = In.join(" ");
}
function validatePolyShape(_n) {
  return !_n.smooth;
}
function createAttrsConvert(_n) {
  var nr = map$1(_n, function(Cn) {
    return typeof Cn == "string" ? [Cn, Cn] : Cn;
  });
  return function(Cn, Bn, In) {
    for (var Dn = 0; Dn < nr.length; Dn++) {
      var Ln = nr[Dn], $n = Cn[Ln[0]];
      $n != null && (Bn[Ln[1]] = round$1($n * In) / In);
    }
  };
}
var builtinShapesDef = {
  circle: [createAttrsConvert(["cx", "cy", "r"])],
  polyline: [convertPolyShape, validatePolyShape],
  polygon: [convertPolyShape, validatePolyShape]
};
function hasShapeAnimation(_n) {
  for (var nr = _n.animators, Cn = 0; Cn < nr.length; Cn++)
    if (nr[Cn].targetName === "shape")
      return !0;
  return !1;
}
function brushSVGPath(_n, nr) {
  var Cn = _n.style, Bn = _n.shape, In = builtinShapesDef[_n.type], Dn = {}, Ln = nr.animation, $n = "path", Nn = _n.style.strokePercent, Rn = nr.compress && getPathPrecision(_n) || 4;
  if (In && !nr.willUpdate && !(In[1] && !In[1](Bn)) && !(Ln && hasShapeAnimation(_n)) && !(Nn < 1)) {
    $n = _n.type;
    var Fn = Math.pow(10, Rn);
    In[0](Bn, Dn, Fn);
  } else {
    var Pn = !_n.path || _n.shapeChanged();
    _n.path || _n.createPathProxy();
    var Un = _n.path;
    Pn && (Un.beginPath(), _n.buildPath(Un, _n.shape), _n.pathUpdated());
    var Hn = Un.getVersion(), zn = _n, Gn = zn.__svgPathBuilder;
    (zn.__svgPathVersion !== Hn || !Gn || Nn !== zn.__svgPathStrokePercent) && (Gn || (Gn = zn.__svgPathBuilder = new SVGPathRebuilder$1()), Gn.reset(Rn), Un.rebuildPath(Gn, Nn), Gn.generateStr(), zn.__svgPathVersion = Hn, zn.__svgPathStrokePercent = Nn), Dn.d = Gn.getStr();
  }
  return setTransform(Dn, _n.transform), setStyleAttrs(Dn, Cn, _n, nr), setMetaData(Dn, _n), nr.animation && createCSSAnimation(_n, Dn, nr), nr.emphasis && createCSSEmphasis(_n, Dn, nr), createVNode($n, _n.id + "", Dn);
}
function brushSVGImage(_n, nr) {
  var Cn = _n.style, Bn = Cn.image;
  if (Bn && !isString$1(Bn) && (isImageLike(Bn) ? Bn = Bn.src : isCanvasLike(Bn) && (Bn = Bn.toDataURL())), !!Bn) {
    var In = Cn.x || 0, Dn = Cn.y || 0, Ln = Cn.width, $n = Cn.height, Nn = {
      href: Bn,
      width: Ln,
      height: $n
    };
    return In && (Nn.x = In), Dn && (Nn.y = Dn), setTransform(Nn, _n.transform), setStyleAttrs(Nn, Cn, _n, nr), setMetaData(Nn, _n), nr.animation && createCSSAnimation(_n, Nn, nr), createVNode("image", _n.id + "", Nn);
  }
}
function brushSVGTSpan(_n, nr) {
  var Cn = _n.style, Bn = Cn.text;
  if (Bn != null && (Bn += ""), !(!Bn || isNaN(Cn.x) || isNaN(Cn.y))) {
    var In = Cn.font || DEFAULT_FONT, Dn = Cn.x || 0, Ln = adjustTextY$1(Cn.y || 0, getLineHeight(In), Cn.textBaseline), $n = TEXT_ALIGN_TO_ANCHOR[Cn.textAlign] || Cn.textAlign, Nn = {
      "dominant-baseline": "central",
      "text-anchor": $n
    };
    if (hasSeparateFont(Cn)) {
      var Rn = "", Fn = Cn.fontStyle, Pn = parseFontSize(Cn.fontSize);
      if (!parseFloat(Pn))
        return;
      var Un = Cn.fontFamily || DEFAULT_FONT_FAMILY, Hn = Cn.fontWeight;
      Rn += "font-size:" + Pn + ";font-family:" + Un + ";", Fn && Fn !== "normal" && (Rn += "font-style:" + Fn + ";"), Hn && Hn !== "normal" && (Rn += "font-weight:" + Hn + ";"), Nn.style = Rn;
    } else
      Nn.style = "font: " + In;
    return Bn.match(/\s/) && (Nn["xml:space"] = "preserve"), Dn && (Nn.x = Dn), Ln && (Nn.y = Ln), setTransform(Nn, _n.transform), setStyleAttrs(Nn, Cn, _n, nr), setMetaData(Nn, _n), nr.animation && createCSSAnimation(_n, Nn, nr), createVNode("text", _n.id + "", Nn, void 0, Bn);
  }
}
function brush(_n, nr) {
  if (_n instanceof Path$1)
    return brushSVGPath(_n, nr);
  if (_n instanceof ZRImage$1)
    return brushSVGImage(_n, nr);
  if (_n instanceof TSpan$1)
    return brushSVGTSpan(_n, nr);
}
function setShadow(_n, nr, Cn) {
  var Bn = _n.style;
  if (hasShadow(Bn)) {
    var In = getShadowKey(_n), Dn = Cn.shadowCache, Ln = Dn[In];
    if (!Ln) {
      var $n = _n.getGlobalScale(), Nn = $n[0], Rn = $n[1];
      if (!Nn || !Rn)
        return;
      var Fn = Bn.shadowOffsetX || 0, Pn = Bn.shadowOffsetY || 0, Un = Bn.shadowBlur, Hn = normalizeColor(Bn.shadowColor), zn = Hn.opacity, Gn = Hn.color, Yn = Un / 2 / Nn, Wn = Un / 2 / Rn, Xn = Yn + " " + Wn;
      Ln = Cn.zrId + "-s" + Cn.shadowIdx++, Cn.defs[Ln] = createVNode("filter", Ln, {
        id: Ln,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        createVNode("feDropShadow", "", {
          dx: Fn / Nn,
          dy: Pn / Rn,
          stdDeviation: Xn,
          "flood-color": Gn,
          "flood-opacity": zn
        })
      ]), Dn[In] = Ln;
    }
    nr.filter = getIdURL(Ln);
  }
}
function setGradient(_n, nr, Cn, Bn) {
  var In = _n[Cn], Dn, Ln = {
    gradientUnits: In.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (isLinearGradient$1(In))
    Dn = "linearGradient", Ln.x1 = In.x, Ln.y1 = In.y, Ln.x2 = In.x2, Ln.y2 = In.y2;
  else if (isRadialGradient$1(In))
    Dn = "radialGradient", Ln.cx = retrieve2(In.x, 0.5), Ln.cy = retrieve2(In.y, 0.5), Ln.r = retrieve2(In.r, 0.5);
  else {
    process.env.NODE_ENV !== "production" && logError("Illegal gradient type.");
    return;
  }
  for (var $n = In.colorStops, Nn = [], Rn = 0, Fn = $n.length; Rn < Fn; ++Rn) {
    var Pn = round4($n[Rn].offset) * 100 + "%", Un = $n[Rn].color, Hn = normalizeColor(Un), zn = Hn.color, Gn = Hn.opacity, Yn = {
      offset: Pn
    };
    Yn["stop-color"] = zn, Gn < 1 && (Yn["stop-opacity"] = Gn), Nn.push(createVNode("stop", Rn + "", Yn));
  }
  var Wn = createVNode(Dn, "", Ln, Nn), Xn = vNodeToString(Wn), ea = Bn.gradientCache, ta = ea[Xn];
  ta || (ta = Bn.zrId + "-g" + Bn.gradientIdx++, ea[Xn] = ta, Ln.id = ta, Bn.defs[ta] = createVNode(Dn, ta, Ln, Nn)), nr[Cn] = getIdURL(ta);
}
function setPattern(_n, nr, Cn, Bn) {
  var In = _n.style[Cn], Dn = _n.getBoundingRect(), Ln = {}, $n = In.repeat, Nn = $n === "no-repeat", Rn = $n === "repeat-x", Fn = $n === "repeat-y", Pn;
  if (isImagePattern(In)) {
    var Un = In.imageWidth, Hn = In.imageHeight, zn = void 0, Gn = In.image;
    if (isString$1(Gn) ? zn = Gn : isImageLike(Gn) ? zn = Gn.src : isCanvasLike(Gn) && (zn = Gn.toDataURL()), typeof Image > "u") {
      var Yn = "Image width/height must been given explictly in svg-ssr renderer.";
      assert(Un, Yn), assert(Hn, Yn);
    } else if (Un == null || Hn == null) {
      var Wn = function(sa, oa) {
        if (sa) {
          var la = sa.elm, ua = Un || oa.width, ca = Hn || oa.height;
          sa.tag === "pattern" && (Rn ? (ca = 1, ua /= Dn.width) : Fn && (ua = 1, ca /= Dn.height)), sa.attrs.width = ua, sa.attrs.height = ca, la && (la.setAttribute("width", ua), la.setAttribute("height", ca));
        }
      }, Xn = createOrUpdateImage(zn, null, _n, function(sa) {
        Nn || Wn(ra, sa), Wn(Pn, sa);
      });
      Xn && Xn.width && Xn.height && (Un = Un || Xn.width, Hn = Hn || Xn.height);
    }
    Pn = createVNode("image", "img", {
      href: zn,
      width: Un,
      height: Hn
    }), Ln.width = Un, Ln.height = Hn;
  } else
    In.svgElement && (Pn = clone$4(In.svgElement), Ln.width = In.svgWidth, Ln.height = In.svgHeight);
  if (Pn) {
    var ea, ta;
    Nn ? ea = ta = 1 : Rn ? (ta = 1, ea = Ln.width / Dn.width) : Fn ? (ea = 1, ta = Ln.height / Dn.height) : Ln.patternUnits = "userSpaceOnUse", ea != null && !isNaN(ea) && (Ln.width = ea), ta != null && !isNaN(ta) && (Ln.height = ta);
    var na = getSRTTransformString(In);
    na && (Ln.patternTransform = na);
    var ra = createVNode("pattern", "", Ln, [Pn]), aa = vNodeToString(ra), ia = Bn.patternCache, Aa = ia[aa];
    Aa || (Aa = Bn.zrId + "-p" + Bn.patternIdx++, ia[aa] = Aa, Ln.id = Aa, ra = Bn.defs[Aa] = createVNode("pattern", Aa, Ln, [Pn])), nr[Cn] = getIdURL(Aa);
  }
}
function setClipPath(_n, nr, Cn) {
  var Bn = Cn.clipPathCache, In = Cn.defs, Dn = Bn[_n.id];
  if (!Dn) {
    Dn = Cn.zrId + "-c" + Cn.clipPathIdx++;
    var Ln = {
      id: Dn
    };
    Bn[_n.id] = Dn, In[Dn] = createVNode("clipPath", Dn, Ln, [brushSVGPath(_n, Cn)]);
  }
  nr["clip-path"] = getIdURL(Dn);
}
function createTextNode(_n) {
  return document.createTextNode(_n);
}
function insertBefore(_n, nr, Cn) {
  _n.insertBefore(nr, Cn);
}
function removeChild(_n, nr) {
  _n.removeChild(nr);
}
function appendChild(_n, nr) {
  _n.appendChild(nr);
}
function parentNode(_n) {
  return _n.parentNode;
}
function nextSibling(_n) {
  return _n.nextSibling;
}
function setTextContent(_n, nr) {
  _n.textContent = nr;
}
var colonChar = 58, xChar = 120, emptyNode = createVNode("", "");
function isUndef(_n) {
  return _n === void 0;
}
function isDef(_n) {
  return _n !== void 0;
}
function createKeyToOldIdx(_n, nr, Cn) {
  for (var Bn = {}, In = nr; In <= Cn; ++In) {
    var Dn = _n[In].key;
    Dn !== void 0 && (process.env.NODE_ENV !== "production" && Bn[Dn] != null && console.error("Duplicate key " + Dn), Bn[Dn] = In);
  }
  return Bn;
}
function sameVnode(_n, nr) {
  var Cn = _n.key === nr.key, Bn = _n.tag === nr.tag;
  return Bn && Cn;
}
function createElm(_n) {
  var nr, Cn = _n.children, Bn = _n.tag;
  if (isDef(Bn)) {
    var In = _n.elm = createElement(Bn);
    if (updateAttrs(emptyNode, _n), isArray$4(Cn))
      for (nr = 0; nr < Cn.length; ++nr) {
        var Dn = Cn[nr];
        Dn != null && appendChild(In, createElm(Dn));
      }
    else
      isDef(_n.text) && !isObject$6(_n.text) && appendChild(In, createTextNode(_n.text));
  } else
    _n.elm = createTextNode(_n.text);
  return _n.elm;
}
function addVnodes(_n, nr, Cn, Bn, In) {
  for (; Bn <= In; ++Bn) {
    var Dn = Cn[Bn];
    Dn != null && insertBefore(_n, createElm(Dn), nr);
  }
}
function removeVnodes(_n, nr, Cn, Bn) {
  for (; Cn <= Bn; ++Cn) {
    var In = nr[Cn];
    if (In != null)
      if (isDef(In.tag)) {
        var Dn = parentNode(In.elm);
        removeChild(Dn, In.elm);
      } else
        removeChild(_n, In.elm);
  }
}
function updateAttrs(_n, nr) {
  var Cn, Bn = nr.elm, In = _n && _n.attrs || {}, Dn = nr.attrs || {};
  if (In !== Dn) {
    for (Cn in Dn) {
      var Ln = Dn[Cn], $n = In[Cn];
      $n !== Ln && (Ln === !0 ? Bn.setAttribute(Cn, "") : Ln === !1 ? Bn.removeAttribute(Cn) : Cn === "style" ? Bn.style.cssText = Ln : Cn.charCodeAt(0) !== xChar ? Bn.setAttribute(Cn, Ln) : Cn === "xmlns:xlink" || Cn === "xmlns" ? Bn.setAttributeNS(XMLNS, Cn, Ln) : Cn.charCodeAt(3) === colonChar ? Bn.setAttributeNS(XML_NAMESPACE, Cn, Ln) : Cn.charCodeAt(5) === colonChar ? Bn.setAttributeNS(XLINKNS, Cn, Ln) : Bn.setAttribute(Cn, Ln));
    }
    for (Cn in In)
      Cn in Dn || Bn.removeAttribute(Cn);
  }
}
function updateChildren(_n, nr, Cn) {
  for (var Bn = 0, In = 0, Dn = nr.length - 1, Ln = nr[0], $n = nr[Dn], Nn = Cn.length - 1, Rn = Cn[0], Fn = Cn[Nn], Pn, Un, Hn, zn; Bn <= Dn && In <= Nn; )
    Ln == null ? Ln = nr[++Bn] : $n == null ? $n = nr[--Dn] : Rn == null ? Rn = Cn[++In] : Fn == null ? Fn = Cn[--Nn] : sameVnode(Ln, Rn) ? (patchVnode(Ln, Rn), Ln = nr[++Bn], Rn = Cn[++In]) : sameVnode($n, Fn) ? (patchVnode($n, Fn), $n = nr[--Dn], Fn = Cn[--Nn]) : sameVnode(Ln, Fn) ? (patchVnode(Ln, Fn), insertBefore(_n, Ln.elm, nextSibling($n.elm)), Ln = nr[++Bn], Fn = Cn[--Nn]) : sameVnode($n, Rn) ? (patchVnode($n, Rn), insertBefore(_n, $n.elm, Ln.elm), $n = nr[--Dn], Rn = Cn[++In]) : (isUndef(Pn) && (Pn = createKeyToOldIdx(nr, Bn, Dn)), Un = Pn[Rn.key], isUndef(Un) ? insertBefore(_n, createElm(Rn), Ln.elm) : (Hn = nr[Un], Hn.tag !== Rn.tag ? insertBefore(_n, createElm(Rn), Ln.elm) : (patchVnode(Hn, Rn), nr[Un] = void 0, insertBefore(_n, Hn.elm, Ln.elm))), Rn = Cn[++In]);
  (Bn <= Dn || In <= Nn) && (Bn > Dn ? (zn = Cn[Nn + 1] == null ? null : Cn[Nn + 1].elm, addVnodes(_n, zn, Cn, In, Nn)) : removeVnodes(_n, nr, Bn, Dn));
}
function patchVnode(_n, nr) {
  var Cn = nr.elm = _n.elm, Bn = _n.children, In = nr.children;
  _n !== nr && (updateAttrs(_n, nr), isUndef(nr.text) ? isDef(Bn) && isDef(In) ? Bn !== In && updateChildren(Cn, Bn, In) : isDef(In) ? (isDef(_n.text) && setTextContent(Cn, ""), addVnodes(Cn, null, In, 0, In.length - 1)) : isDef(Bn) ? removeVnodes(Cn, Bn, 0, Bn.length - 1) : isDef(_n.text) && setTextContent(Cn, "") : _n.text !== nr.text && (isDef(Bn) && removeVnodes(Cn, Bn, 0, Bn.length - 1), setTextContent(Cn, nr.text)));
}
function patch(_n, nr) {
  if (sameVnode(_n, nr))
    patchVnode(_n, nr);
  else {
    var Cn = _n.elm, Bn = parentNode(Cn);
    createElm(nr), Bn !== null && (insertBefore(Bn, nr.elm, nextSibling(Cn)), removeVnodes(Bn, [_n], 0, 0));
  }
  return nr;
}
var svgId = 0, SVGPainter = function() {
  function _n(nr, Cn, Bn) {
    if (this.type = "svg", this.refreshHover = createMethodNotSupport("refreshHover"), this.configLayer = createMethodNotSupport("configLayer"), this.storage = Cn, this._opts = Bn = extend({}, Bn), this.root = nr, this._id = "zr" + svgId++, this._oldVNode = createSVGVNode(Bn.width, Bn.height), nr && !Bn.ssr) {
      var In = this._viewport = document.createElement("div");
      In.style.cssText = "position:relative;overflow:hidden";
      var Dn = this._svgDom = this._oldVNode.elm = createElement("svg");
      updateAttrs(null, this._oldVNode), In.appendChild(Dn), nr.appendChild(In);
    }
    this.resize(Bn.width, Bn.height);
  }
  return _n.prototype.getType = function() {
    return this.type;
  }, _n.prototype.getViewportRoot = function() {
    return this._viewport;
  }, _n.prototype.getViewportRootOffset = function() {
    var nr = this.getViewportRoot();
    if (nr)
      return {
        offsetLeft: nr.offsetLeft || 0,
        offsetTop: nr.offsetTop || 0
      };
  }, _n.prototype.getSvgDom = function() {
    return this._svgDom;
  }, _n.prototype.refresh = function() {
    if (this.root) {
      var nr = this.renderToVNode({
        willUpdate: !0
      });
      nr.attrs.style = "position:absolute;left:0;top:0;user-select:none", patch(this._oldVNode, nr), this._oldVNode = nr;
    }
  }, _n.prototype.renderOneToVNode = function(nr) {
    return brush(nr, createBrushScope(this._id));
  }, _n.prototype.renderToVNode = function(nr) {
    nr = nr || {};
    var Cn = this.storage.getDisplayList(!0), Bn = this._width, In = this._height, Dn = createBrushScope(this._id);
    Dn.animation = nr.animation, Dn.willUpdate = nr.willUpdate, Dn.compress = nr.compress, Dn.emphasis = nr.emphasis, Dn.ssr = this._opts.ssr;
    var Ln = [], $n = this._bgVNode = createBackgroundVNode(Bn, In, this._backgroundColor, Dn);
    $n && Ln.push($n);
    var Nn = nr.compress ? null : this._mainVNode = createVNode("g", "main", {}, []);
    this._paintList(Cn, Dn, Nn ? Nn.children : Ln), Nn && Ln.push(Nn);
    var Rn = map$1(keys(Dn.defs), function(Un) {
      return Dn.defs[Un];
    });
    if (Rn.length && Ln.push(createVNode("defs", "defs", {}, Rn)), nr.animation) {
      var Fn = getCssString(Dn.cssNodes, Dn.cssAnims, { newline: !0 });
      if (Fn) {
        var Pn = createVNode("style", "stl", {}, [], Fn);
        Ln.push(Pn);
      }
    }
    return createSVGVNode(Bn, In, Ln, nr.useViewBox);
  }, _n.prototype.renderToString = function(nr) {
    return nr = nr || {}, vNodeToString(this.renderToVNode({
      animation: retrieve2(nr.cssAnimation, !0),
      emphasis: retrieve2(nr.cssEmphasis, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: retrieve2(nr.useViewBox, !0)
    }), { newline: !0 });
  }, _n.prototype.setBackgroundColor = function(nr) {
    this._backgroundColor = nr;
  }, _n.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, _n.prototype._paintList = function(nr, Cn, Bn) {
    for (var In = nr.length, Dn = [], Ln = 0, $n, Nn, Rn = 0, Fn = 0; Fn < In; Fn++) {
      var Pn = nr[Fn];
      if (!Pn.invisible) {
        var Un = Pn.__clipPaths, Hn = Un && Un.length || 0, zn = Nn && Nn.length || 0, Gn = void 0;
        for (Gn = Math.max(Hn - 1, zn - 1); Gn >= 0 && !(Un && Nn && Un[Gn] === Nn[Gn]); Gn--)
          ;
        for (var Yn = zn - 1; Yn > Gn; Yn--)
          Ln--, $n = Dn[Ln - 1];
        for (var Wn = Gn + 1; Wn < Hn; Wn++) {
          var Xn = {};
          setClipPath(Un[Wn], Xn, Cn);
          var ea = createVNode("g", "clip-g-" + Rn++, Xn, []);
          ($n ? $n.children : Bn).push(ea), Dn[Ln++] = ea, $n = ea;
        }
        Nn = Un;
        var ta = brush(Pn, Cn);
        ta && ($n ? $n.children : Bn).push(ta);
      }
    }
  }, _n.prototype.resize = function(nr, Cn) {
    var Bn = this._opts, In = this.root, Dn = this._viewport;
    if (nr != null && (Bn.width = nr), Cn != null && (Bn.height = Cn), In && Dn && (Dn.style.display = "none", nr = getSize$1(In, 0, Bn), Cn = getSize$1(In, 1, Bn), Dn.style.display = ""), this._width !== nr || this._height !== Cn) {
      if (this._width = nr, this._height = Cn, Dn) {
        var Ln = Dn.style;
        Ln.width = nr + "px", Ln.height = Cn + "px";
      }
      if (isPattern(this._backgroundColor))
        this.refresh();
      else {
        var $n = this._svgDom;
        $n && ($n.setAttribute("width", nr), $n.setAttribute("height", Cn));
        var Nn = this._bgVNode && this._bgVNode.elm;
        Nn && (Nn.setAttribute("width", nr), Nn.setAttribute("height", Cn));
      }
    }
  }, _n.prototype.getWidth = function() {
    return this._width;
  }, _n.prototype.getHeight = function() {
    return this._height;
  }, _n.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, _n.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, _n.prototype.toDataURL = function(nr) {
    var Cn = this.renderToString(), Bn = "data:image/svg+xml;";
    return nr ? (Cn = encodeBase64(Cn), Cn && Bn + "base64," + Cn) : Bn + "charset=UTF-8," + encodeURIComponent(Cn);
  }, _n;
}();
function createMethodNotSupport(_n) {
  return function() {
    process.env.NODE_ENV !== "production" && logError('In SVG mode painter not support method "' + _n + '"');
  };
}
function createBackgroundVNode(_n, nr, Cn, Bn) {
  var In;
  if (Cn && Cn !== "none")
    if (In = createVNode("rect", "bg", {
      width: _n,
      height: nr,
      x: "0",
      y: "0"
    }), isGradient(Cn))
      setGradient({ fill: Cn }, In.attrs, "fill", Bn);
    else if (isPattern(Cn))
      setPattern({
        style: {
          fill: Cn
        },
        dirty: noop$1,
        getBoundingRect: function() {
          return { width: _n, height: nr };
        }
      }, In.attrs, "fill", Bn);
    else {
      var Dn = normalizeColor(Cn), Ln = Dn.color, $n = Dn.opacity;
      In.attrs.fill = Ln, $n < 1 && (In.attrs["fill-opacity"] = $n);
    }
  return In;
}
const SVGPainter$1 = SVGPainter;
function install$S(_n) {
  _n.registerPainter("svg", SVGPainter$1);
}
function createDom(_n, nr, Cn) {
  var Bn = platformApi.createCanvas(), In = nr.getWidth(), Dn = nr.getHeight(), Ln = Bn.style;
  return Ln && (Ln.position = "absolute", Ln.left = "0", Ln.top = "0", Ln.width = In + "px", Ln.height = Dn + "px", Bn.setAttribute("data-zr-dom-id", _n)), Bn.width = In * Cn, Bn.height = Dn * Cn, Bn;
}
var Layer = function(_n) {
  __extends$2(nr, _n);
  function nr(Cn, Bn, In) {
    var Dn = _n.call(this) || this;
    Dn.motionBlur = !1, Dn.lastFrameAlpha = 0.7, Dn.dpr = 1, Dn.virtual = !1, Dn.config = {}, Dn.incremental = !1, Dn.zlevel = 0, Dn.maxRepaintRectCount = 5, Dn.__dirty = !0, Dn.__firstTimePaint = !0, Dn.__used = !1, Dn.__drawIndex = 0, Dn.__startIndex = 0, Dn.__endIndex = 0, Dn.__prevStartIndex = null, Dn.__prevEndIndex = null;
    var Ln;
    In = In || devicePixelRatio, typeof Cn == "string" ? Ln = createDom(Cn, Bn, In) : isObject$6(Cn) && (Ln = Cn, Cn = Ln.id), Dn.id = Cn, Dn.dom = Ln;
    var $n = Ln.style;
    return $n && (disableUserSelect(Ln), Ln.onselectstart = function() {
      return !1;
    }, $n.padding = "0", $n.margin = "0", $n.borderWidth = "0"), Dn.painter = Bn, Dn.dpr = In, Dn;
  }
  return nr.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, nr.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, nr.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, nr.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, nr.prototype.createBackBuffer = function() {
    var Cn = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, Cn), this.ctxBack = this.domBack.getContext("2d"), Cn !== 1 && this.ctxBack.scale(Cn, Cn);
  }, nr.prototype.createRepaintRects = function(Cn, Bn, In, Dn) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var Ln = [], $n = this.maxRepaintRectCount, Nn = !1, Rn = new BoundingRect$1(0, 0, 0, 0);
    function Fn(Xn) {
      if (!(!Xn.isFinite() || Xn.isZero()))
        if (Ln.length === 0) {
          var ea = new BoundingRect$1(0, 0, 0, 0);
          ea.copy(Xn), Ln.push(ea);
        } else {
          for (var ta = !1, na = 1 / 0, ra = 0, aa = 0; aa < Ln.length; ++aa) {
            var ia = Ln[aa];
            if (ia.intersect(Xn)) {
              var Aa = new BoundingRect$1(0, 0, 0, 0);
              Aa.copy(ia), Aa.union(Xn), Ln[aa] = Aa, ta = !0;
              break;
            } else if (Nn) {
              Rn.copy(Xn), Rn.union(ia);
              var sa = Xn.width * Xn.height, oa = ia.width * ia.height, la = Rn.width * Rn.height, ua = la - sa - oa;
              ua < na && (na = ua, ra = aa);
            }
          }
          if (Nn && (Ln[ra].union(Xn), ta = !0), !ta) {
            var ea = new BoundingRect$1(0, 0, 0, 0);
            ea.copy(Xn), Ln.push(ea);
          }
          Nn || (Nn = Ln.length >= $n);
        }
    }
    for (var Pn = this.__startIndex; Pn < this.__endIndex; ++Pn) {
      var Un = Cn[Pn];
      if (Un) {
        var Hn = Un.shouldBePainted(In, Dn, !0, !0), zn = Un.__isRendered && (Un.__dirty & REDRAW_BIT || !Hn) ? Un.getPrevPaintRect() : null;
        zn && Fn(zn);
        var Gn = Hn && (Un.__dirty & REDRAW_BIT || !Un.__isRendered) ? Un.getPaintRect() : null;
        Gn && Fn(Gn);
      }
    }
    for (var Pn = this.__prevStartIndex; Pn < this.__prevEndIndex; ++Pn) {
      var Un = Bn[Pn], Hn = Un && Un.shouldBePainted(In, Dn, !0, !0);
      if (Un && (!Hn || !Un.__zr) && Un.__isRendered) {
        var zn = Un.getPrevPaintRect();
        zn && Fn(zn);
      }
    }
    var Yn;
    do {
      Yn = !1;
      for (var Pn = 0; Pn < Ln.length; ) {
        if (Ln[Pn].isZero()) {
          Ln.splice(Pn, 1);
          continue;
        }
        for (var Wn = Pn + 1; Wn < Ln.length; )
          Ln[Pn].intersect(Ln[Wn]) ? (Yn = !0, Ln[Pn].union(Ln[Wn]), Ln.splice(Wn, 1)) : Wn++;
        Pn++;
      }
    } while (Yn);
    return this._paintRects = Ln, Ln;
  }, nr.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, nr.prototype.resize = function(Cn, Bn) {
    var In = this.dpr, Dn = this.dom, Ln = Dn.style, $n = this.domBack;
    Ln && (Ln.width = Cn + "px", Ln.height = Bn + "px"), Dn.width = Cn * In, Dn.height = Bn * In, $n && ($n.width = Cn * In, $n.height = Bn * In, In !== 1 && this.ctxBack.scale(In, In));
  }, nr.prototype.clear = function(Cn, Bn, In) {
    var Dn = this.dom, Ln = this.ctx, $n = Dn.width, Nn = Dn.height;
    Bn = Bn || this.clearColor;
    var Rn = this.motionBlur && !Cn, Fn = this.lastFrameAlpha, Pn = this.dpr, Un = this;
    Rn && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(Dn, 0, 0, $n / Pn, Nn / Pn));
    var Hn = this.domBack;
    function zn(Gn, Yn, Wn, Xn) {
      if (Ln.clearRect(Gn, Yn, Wn, Xn), Bn && Bn !== "transparent") {
        var ea = void 0;
        if (isGradientObject(Bn)) {
          var ta = Bn.global || Bn.__width === Wn && Bn.__height === Xn;
          ea = ta && Bn.__canvasGradient || getCanvasGradient(Ln, Bn, {
            x: 0,
            y: 0,
            width: Wn,
            height: Xn
          }), Bn.__canvasGradient = ea, Bn.__width = Wn, Bn.__height = Xn;
        } else
          isImagePatternObject(Bn) && (Bn.scaleX = Bn.scaleX || Pn, Bn.scaleY = Bn.scaleY || Pn, ea = createCanvasPattern(Ln, Bn, {
            dirty: function() {
              Un.setUnpainted(), Un.painter.refresh();
            }
          }));
        Ln.save(), Ln.fillStyle = ea || Bn, Ln.fillRect(Gn, Yn, Wn, Xn), Ln.restore();
      }
      Rn && (Ln.save(), Ln.globalAlpha = Fn, Ln.drawImage(Hn, Gn, Yn, Wn, Xn), Ln.restore());
    }
    !In || Rn ? zn(0, 0, $n, Nn) : In.length && each$f(In, function(Gn) {
      zn(Gn.x * Pn, Gn.y * Pn, Gn.width * Pn, Gn.height * Pn);
    });
  }, nr;
}(Eventful$1);
const Layer$1 = Layer;
var HOVER_LAYER_ZLEVEL = 1e5, CANVAS_ZLEVEL = 314159, EL_AFTER_INCREMENTAL_INC = 0.01, INCREMENTAL_INC = 1e-3;
function isLayerValid(_n) {
  return _n ? _n.__builtin__ ? !0 : !(typeof _n.resize != "function" || typeof _n.refresh != "function") : !1;
}
function createRoot(_n, nr) {
  var Cn = document.createElement("div");
  return Cn.style.cssText = [
    "position:relative",
    "width:" + _n + "px",
    "height:" + nr + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", Cn;
}
var CanvasPainter = function() {
  function _n(nr, Cn, Bn, In) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var Dn = !nr.nodeName || nr.nodeName.toUpperCase() === "CANVAS";
    this._opts = Bn = extend({}, Bn || {}), this.dpr = Bn.devicePixelRatio || devicePixelRatio, this._singleCanvas = Dn, this.root = nr;
    var Ln = nr.style;
    Ln && (disableUserSelect(nr), nr.innerHTML = ""), this.storage = Cn;
    var $n = this._zlevelList;
    this._prevDisplayList = [];
    var Nn = this._layers;
    if (Dn) {
      var Fn = nr, Pn = Fn.width, Un = Fn.height;
      Bn.width != null && (Pn = Bn.width), Bn.height != null && (Un = Bn.height), this.dpr = Bn.devicePixelRatio || 1, Fn.width = Pn * this.dpr, Fn.height = Un * this.dpr, this._width = Pn, this._height = Un;
      var Hn = new Layer$1(Fn, this, this.dpr);
      Hn.__builtin__ = !0, Hn.initContext(), Nn[CANVAS_ZLEVEL] = Hn, Hn.zlevel = CANVAS_ZLEVEL, $n.push(CANVAS_ZLEVEL), this._domRoot = nr;
    } else {
      this._width = getSize$1(nr, 0, Bn), this._height = getSize$1(nr, 1, Bn);
      var Rn = this._domRoot = createRoot(this._width, this._height);
      nr.appendChild(Rn);
    }
  }
  return _n.prototype.getType = function() {
    return "canvas";
  }, _n.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, _n.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, _n.prototype.getViewportRootOffset = function() {
    var nr = this.getViewportRoot();
    if (nr)
      return {
        offsetLeft: nr.offsetLeft || 0,
        offsetTop: nr.offsetTop || 0
      };
  }, _n.prototype.refresh = function(nr) {
    var Cn = this.storage.getDisplayList(!0), Bn = this._prevDisplayList, In = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(Cn, Bn, nr, this._redrawId);
    for (var Dn = 0; Dn < In.length; Dn++) {
      var Ln = In[Dn], $n = this._layers[Ln];
      if (!$n.__builtin__ && $n.refresh) {
        var Nn = Dn === 0 ? this._backgroundColor : null;
        $n.refresh(Nn);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = Cn.slice()), this;
  }, _n.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, _n.prototype._paintHoverList = function(nr) {
    var Cn = nr.length, Bn = this._hoverlayer;
    if (Bn && Bn.clear(), !!Cn) {
      for (var In = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, Dn, Ln = 0; Ln < Cn; Ln++) {
        var $n = nr[Ln];
        $n.__inHover && (Bn || (Bn = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL)), Dn || (Dn = Bn.ctx, Dn.save()), brush$1(Dn, $n, In, Ln === Cn - 1));
      }
      Dn && Dn.restore();
    }
  }, _n.prototype.getHoverLayer = function() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  }, _n.prototype.paintOne = function(nr, Cn) {
    brushSingle(nr, Cn);
  }, _n.prototype._paintList = function(nr, Cn, Bn, In) {
    if (this._redrawId === In) {
      Bn = Bn || !1, this._updateLayerStatus(nr);
      var Dn = this._doPaintList(nr, Cn, Bn), Ln = Dn.finished, $n = Dn.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), $n && this._paintHoverList(nr), Ln)
        this.eachLayer(function(Rn) {
          Rn.afterBrush && Rn.afterBrush();
        });
      else {
        var Nn = this;
        requestAnimationFrame$2(function() {
          Nn._paintList(nr, Cn, Bn, In);
        });
      }
    }
  }, _n.prototype._compositeManually = function() {
    var nr = this.getLayer(CANVAS_ZLEVEL).ctx, Cn = this._domRoot.width, Bn = this._domRoot.height;
    nr.clearRect(0, 0, Cn, Bn), this.eachBuiltinLayer(function(In) {
      In.virtual && nr.drawImage(In.dom, 0, 0, Cn, Bn);
    });
  }, _n.prototype._doPaintList = function(nr, Cn, Bn) {
    for (var In = this, Dn = [], Ln = this._opts.useDirtyRect, $n = 0; $n < this._zlevelList.length; $n++) {
      var Nn = this._zlevelList[$n], Rn = this._layers[Nn];
      Rn.__builtin__ && Rn !== this._hoverlayer && (Rn.__dirty || Bn) && Dn.push(Rn);
    }
    for (var Fn = !0, Pn = !1, Un = function(Gn) {
      var Yn = Dn[Gn], Wn = Yn.ctx, Xn = Ln && Yn.createRepaintRects(nr, Cn, Hn._width, Hn._height), ea = Bn ? Yn.__startIndex : Yn.__drawIndex, ta = !Bn && Yn.incremental && Date.now, na = ta && Date.now(), ra = Yn.zlevel === Hn._zlevelList[0] ? Hn._backgroundColor : null;
      if (Yn.__startIndex === Yn.__endIndex)
        Yn.clear(!1, ra, Xn);
      else if (ea === Yn.__startIndex) {
        var aa = nr[ea];
        (!aa.incremental || !aa.notClear || Bn) && Yn.clear(!1, ra, Xn);
      }
      ea === -1 && (console.error("For some unknown reason. drawIndex is -1"), ea = Yn.__startIndex);
      var ia, Aa = function(ua) {
        var ca = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: In._width,
          viewHeight: In._height
        };
        for (ia = ea; ia < Yn.__endIndex; ia++) {
          var fa = nr[ia];
          if (fa.__inHover && (Pn = !0), In._doPaintEl(fa, Yn, Ln, ua, ca, ia === Yn.__endIndex - 1), ta) {
            var ha = Date.now() - na;
            if (ha > 15)
              break;
          }
        }
        ca.prevElClipPaths && Wn.restore();
      };
      if (Xn)
        if (Xn.length === 0)
          ia = Yn.__endIndex;
        else
          for (var sa = Hn.dpr, oa = 0; oa < Xn.length; ++oa) {
            var la = Xn[oa];
            Wn.save(), Wn.beginPath(), Wn.rect(la.x * sa, la.y * sa, la.width * sa, la.height * sa), Wn.clip(), Aa(la), Wn.restore();
          }
      else
        Wn.save(), Aa(), Wn.restore();
      Yn.__drawIndex = ia, Yn.__drawIndex < Yn.__endIndex && (Fn = !1);
    }, Hn = this, zn = 0; zn < Dn.length; zn++)
      Un(zn);
    return env$1.wxa && each$f(this._layers, function(Gn) {
      Gn && Gn.ctx && Gn.ctx.draw && Gn.ctx.draw();
    }), {
      finished: Fn,
      needsRefreshHover: Pn
    };
  }, _n.prototype._doPaintEl = function(nr, Cn, Bn, In, Dn, Ln) {
    var $n = Cn.ctx;
    if (Bn) {
      var Nn = nr.getPaintRect();
      (!In || Nn && Nn.intersect(In)) && (brush$1($n, nr, Dn, Ln), nr.setPrevPaintRect(Nn));
    } else
      brush$1($n, nr, Dn, Ln);
  }, _n.prototype.getLayer = function(nr, Cn) {
    this._singleCanvas && !this._needsManuallyCompositing && (nr = CANVAS_ZLEVEL);
    var Bn = this._layers[nr];
    return Bn || (Bn = new Layer$1("zr_" + nr, this, this.dpr), Bn.zlevel = nr, Bn.__builtin__ = !0, this._layerConfig[nr] ? merge$1(Bn, this._layerConfig[nr], !0) : this._layerConfig[nr - EL_AFTER_INCREMENTAL_INC] && merge$1(Bn, this._layerConfig[nr - EL_AFTER_INCREMENTAL_INC], !0), Cn && (Bn.virtual = Cn), this.insertLayer(nr, Bn), Bn.initContext()), Bn;
  }, _n.prototype.insertLayer = function(nr, Cn) {
    var Bn = this._layers, In = this._zlevelList, Dn = In.length, Ln = this._domRoot, $n = null, Nn = -1;
    if (Bn[nr]) {
      process.env.NODE_ENV !== "production" && logError("ZLevel " + nr + " has been used already");
      return;
    }
    if (!isLayerValid(Cn)) {
      process.env.NODE_ENV !== "production" && logError("Layer of zlevel " + nr + " is not valid");
      return;
    }
    if (Dn > 0 && nr > In[0]) {
      for (Nn = 0; Nn < Dn - 1 && !(In[Nn] < nr && In[Nn + 1] > nr); Nn++)
        ;
      $n = Bn[In[Nn]];
    }
    if (In.splice(Nn + 1, 0, nr), Bn[nr] = Cn, !Cn.virtual)
      if ($n) {
        var Rn = $n.dom;
        Rn.nextSibling ? Ln.insertBefore(Cn.dom, Rn.nextSibling) : Ln.appendChild(Cn.dom);
      } else
        Ln.firstChild ? Ln.insertBefore(Cn.dom, Ln.firstChild) : Ln.appendChild(Cn.dom);
    Cn.painter || (Cn.painter = this);
  }, _n.prototype.eachLayer = function(nr, Cn) {
    for (var Bn = this._zlevelList, In = 0; In < Bn.length; In++) {
      var Dn = Bn[In];
      nr.call(Cn, this._layers[Dn], Dn);
    }
  }, _n.prototype.eachBuiltinLayer = function(nr, Cn) {
    for (var Bn = this._zlevelList, In = 0; In < Bn.length; In++) {
      var Dn = Bn[In], Ln = this._layers[Dn];
      Ln.__builtin__ && nr.call(Cn, Ln, Dn);
    }
  }, _n.prototype.eachOtherLayer = function(nr, Cn) {
    for (var Bn = this._zlevelList, In = 0; In < Bn.length; In++) {
      var Dn = Bn[In], Ln = this._layers[Dn];
      Ln.__builtin__ || nr.call(Cn, Ln, Dn);
    }
  }, _n.prototype.getLayers = function() {
    return this._layers;
  }, _n.prototype._updateLayerStatus = function(nr) {
    this.eachBuiltinLayer(function(Pn, Un) {
      Pn.__dirty = Pn.__used = !1;
    });
    function Cn(Pn) {
      Dn && (Dn.__endIndex !== Pn && (Dn.__dirty = !0), Dn.__endIndex = Pn);
    }
    if (this._singleCanvas)
      for (var Bn = 1; Bn < nr.length; Bn++) {
        var In = nr[Bn];
        if (In.zlevel !== nr[Bn - 1].zlevel || In.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var Dn = null, Ln = 0, $n, Nn;
    for (Nn = 0; Nn < nr.length; Nn++) {
      var In = nr[Nn], Rn = In.zlevel, Fn = void 0;
      $n !== Rn && ($n = Rn, Ln = 0), In.incremental ? (Fn = this.getLayer(Rn + INCREMENTAL_INC, this._needsManuallyCompositing), Fn.incremental = !0, Ln = 1) : Fn = this.getLayer(Rn + (Ln > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing), Fn.__builtin__ || logError("ZLevel " + Rn + " has been used by unkown layer " + Fn.id), Fn !== Dn && (Fn.__used = !0, Fn.__startIndex !== Nn && (Fn.__dirty = !0), Fn.__startIndex = Nn, Fn.incremental ? Fn.__drawIndex = -1 : Fn.__drawIndex = Nn, Cn(Nn), Dn = Fn), In.__dirty & REDRAW_BIT && !In.__inHover && (Fn.__dirty = !0, Fn.incremental && Fn.__drawIndex < 0 && (Fn.__drawIndex = Nn));
    }
    Cn(Nn), this.eachBuiltinLayer(function(Pn, Un) {
      !Pn.__used && Pn.getElementCount() > 0 && (Pn.__dirty = !0, Pn.__startIndex = Pn.__endIndex = Pn.__drawIndex = 0), Pn.__dirty && Pn.__drawIndex < 0 && (Pn.__drawIndex = Pn.__startIndex);
    });
  }, _n.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, _n.prototype._clearLayer = function(nr) {
    nr.clear();
  }, _n.prototype.setBackgroundColor = function(nr) {
    this._backgroundColor = nr, each$f(this._layers, function(Cn) {
      Cn.setUnpainted();
    });
  }, _n.prototype.configLayer = function(nr, Cn) {
    if (Cn) {
      var Bn = this._layerConfig;
      Bn[nr] ? merge$1(Bn[nr], Cn, !0) : Bn[nr] = Cn;
      for (var In = 0; In < this._zlevelList.length; In++) {
        var Dn = this._zlevelList[In];
        if (Dn === nr || Dn === nr + EL_AFTER_INCREMENTAL_INC) {
          var Ln = this._layers[Dn];
          merge$1(Ln, Bn[nr], !0);
        }
      }
    }
  }, _n.prototype.delLayer = function(nr) {
    var Cn = this._layers, Bn = this._zlevelList, In = Cn[nr];
    In && (In.dom.parentNode.removeChild(In.dom), delete Cn[nr], Bn.splice(indexOf(Bn, nr), 1));
  }, _n.prototype.resize = function(nr, Cn) {
    if (this._domRoot.style) {
      var Bn = this._domRoot;
      Bn.style.display = "none";
      var In = this._opts, Dn = this.root;
      if (nr != null && (In.width = nr), Cn != null && (In.height = Cn), nr = getSize$1(Dn, 0, In), Cn = getSize$1(Dn, 1, In), Bn.style.display = "", this._width !== nr || Cn !== this._height) {
        Bn.style.width = nr + "px", Bn.style.height = Cn + "px";
        for (var Ln in this._layers)
          this._layers.hasOwnProperty(Ln) && this._layers[Ln].resize(nr, Cn);
        this.refresh(!0);
      }
      this._width = nr, this._height = Cn;
    } else {
      if (nr == null || Cn == null)
        return;
      this._width = nr, this._height = Cn, this.getLayer(CANVAS_ZLEVEL).resize(nr, Cn);
    }
    return this;
  }, _n.prototype.clearLayer = function(nr) {
    var Cn = this._layers[nr];
    Cn && Cn.clear();
  }, _n.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, _n.prototype.getRenderedCanvas = function(nr) {
    if (nr = nr || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[CANVAS_ZLEVEL].dom;
    var Cn = new Layer$1("image", this, nr.pixelRatio || this.dpr);
    Cn.initContext(), Cn.clear(!1, nr.backgroundColor || this._backgroundColor);
    var Bn = Cn.ctx;
    if (nr.pixelRatio <= this.dpr) {
      this.refresh();
      var In = Cn.dom.width, Dn = Cn.dom.height;
      this.eachLayer(function(Pn) {
        Pn.__builtin__ ? Bn.drawImage(Pn.dom, 0, 0, In, Dn) : Pn.renderToCanvas && (Bn.save(), Pn.renderToCanvas(Bn), Bn.restore());
      });
    } else
      for (var Ln = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, $n = this.storage.getDisplayList(!0), Nn = 0, Rn = $n.length; Nn < Rn; Nn++) {
        var Fn = $n[Nn];
        brush$1(Bn, Fn, Ln, Nn === Rn - 1);
      }
    return Cn.dom;
  }, _n.prototype.getWidth = function() {
    return this._width;
  }, _n.prototype.getHeight = function() {
    return this._height;
  }, _n;
}();
const CanvasPainter$1 = CanvasPainter;
function install$R(_n) {
  _n.registerPainter("canvas", CanvasPainter$1);
}
var LineSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.hasSymbolVisual = !0, Cn;
    }
    return nr.prototype.getInitialData = function(Cn) {
      if (process.env.NODE_ENV !== "production") {
        var Bn = Cn.coordinateSystem;
        if (Bn !== "polar" && Bn !== "cartesian2d")
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0
      });
    }, nr.prototype.getLegendIcon = function(Cn) {
      var Bn = new Group$4(), In = createSymbol$1("line", 0, Cn.itemHeight / 2, Cn.itemWidth, 0, Cn.lineStyle.stroke, !1);
      Bn.add(In), In.setStyle(Cn.lineStyle);
      var Dn = this.getData().getVisual("symbol"), Ln = this.getData().getVisual("symbolRotate"), $n = Dn === "none" ? "circle" : Dn, Nn = Cn.itemHeight * 0.8, Rn = createSymbol$1($n, (Cn.itemWidth - Nn) / 2, (Cn.itemHeight - Nn) / 2, Nn, Nn, Cn.itemStyle.fill);
      Bn.add(Rn), Rn.setStyle(Cn.itemStyle);
      var Fn = Cn.iconRotate === "inherit" ? Ln : Cn.iconRotate || 0;
      return Rn.rotation = Fn * Math.PI / 180, Rn.setOrigin([Cn.itemWidth / 2, Cn.itemHeight / 2]), $n.indexOf("empty") > -1 && (Rn.style.stroke = Rn.style.fill, Rn.style.fill = "#fff", Rn.style.lineWidth = 2), Bn;
    }, nr.type = "series.line", nr.dependencies = ["grid", "polar"], nr.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, nr;
  }(SeriesModel$1)
);
const LineSeries = LineSeriesModel;
function getDefaultLabel(_n, nr) {
  var Cn = _n.mapDimensionsAll("defaultedLabel"), Bn = Cn.length;
  if (Bn === 1) {
    var In = retrieveRawValue(_n, nr, Cn[0]);
    return In != null ? In + "" : null;
  } else if (Bn) {
    for (var Dn = [], Ln = 0; Ln < Cn.length; Ln++)
      Dn.push(retrieveRawValue(_n, nr, Cn[Ln]));
    return Dn.join(" ");
  }
}
function getDefaultInterpolatedLabel(_n, nr) {
  var Cn = _n.mapDimensionsAll("defaultedLabel");
  if (!isArray$4(nr))
    return nr + "";
  for (var Bn = [], In = 0; In < Cn.length; In++) {
    var Dn = _n.getDimensionIndex(Cn[In]);
    Dn >= 0 && Bn.push(nr[Dn]);
  }
  return Bn.join(" ");
}
var Symbol$1 = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In, Dn) {
      var Ln = _n.call(this) || this;
      return Ln.updateData(Cn, Bn, In, Dn), Ln;
    }
    return nr.prototype._createSymbol = function(Cn, Bn, In, Dn, Ln) {
      this.removeAll();
      var $n = createSymbol$1(Cn, -1, -1, 2, 2, null, Ln);
      $n.attr({
        z2: 100,
        culling: !0,
        scaleX: Dn[0] / 2,
        scaleY: Dn[1] / 2
      }), $n.drift = driftSymbol, this._symbolType = Cn, this.add($n);
    }, nr.prototype.stopSymbolAnimation = function(Cn) {
      this.childAt(0).stopAnimation(null, Cn);
    }, nr.prototype.getSymbolType = function() {
      return this._symbolType;
    }, nr.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, nr.prototype.highlight = function() {
      enterEmphasis(this.childAt(0));
    }, nr.prototype.downplay = function() {
      leaveEmphasis(this.childAt(0));
    }, nr.prototype.setZ = function(Cn, Bn) {
      var In = this.childAt(0);
      In.zlevel = Cn, In.z = Bn;
    }, nr.prototype.setDraggable = function(Cn, Bn) {
      var In = this.childAt(0);
      In.draggable = Cn, In.cursor = !Bn && Cn ? "move" : In.cursor;
    }, nr.prototype.updateData = function(Cn, Bn, In, Dn) {
      this.silent = !1;
      var Ln = Cn.getItemVisual(Bn, "symbol") || "circle", $n = Cn.hostModel, Nn = nr.getSymbolSize(Cn, Bn), Rn = Ln !== this._symbolType, Fn = Dn && Dn.disableAnimation;
      if (Rn) {
        var Pn = Cn.getItemVisual(Bn, "symbolKeepAspect");
        this._createSymbol(Ln, Cn, Bn, Nn, Pn);
      } else {
        var Un = this.childAt(0);
        Un.silent = !1;
        var Hn = {
          scaleX: Nn[0] / 2,
          scaleY: Nn[1] / 2
        };
        Fn ? Un.attr(Hn) : updateProps$1(Un, Hn, $n, Bn), saveOldStyle(Un);
      }
      if (this._updateCommon(Cn, Bn, Nn, In, Dn), Rn) {
        var Un = this.childAt(0);
        if (!Fn) {
          var Hn = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: Un.style.opacity
            }
          };
          Un.scaleX = Un.scaleY = 0, Un.style.opacity = 0, initProps(Un, Hn, $n, Bn);
        }
      }
      Fn && this.childAt(0).stopAnimation("leave");
    }, nr.prototype._updateCommon = function(Cn, Bn, In, Dn, Ln) {
      var $n = this.childAt(0), Nn = Cn.hostModel, Rn, Fn, Pn, Un, Hn, zn, Gn, Yn, Wn;
      if (Dn && (Rn = Dn.emphasisItemStyle, Fn = Dn.blurItemStyle, Pn = Dn.selectItemStyle, Un = Dn.focus, Hn = Dn.blurScope, Gn = Dn.labelStatesModels, Yn = Dn.hoverScale, Wn = Dn.cursorStyle, zn = Dn.emphasisDisabled), !Dn || Cn.hasItemOption) {
        var Xn = Dn && Dn.itemModel ? Dn.itemModel : Cn.getItemModel(Bn), ea = Xn.getModel("emphasis");
        Rn = ea.getModel("itemStyle").getItemStyle(), Pn = Xn.getModel(["select", "itemStyle"]).getItemStyle(), Fn = Xn.getModel(["blur", "itemStyle"]).getItemStyle(), Un = ea.get("focus"), Hn = ea.get("blurScope"), zn = ea.get("disabled"), Gn = getLabelStatesModels(Xn), Yn = ea.getShallow("scale"), Wn = Xn.getShallow("cursor");
      }
      var ta = Cn.getItemVisual(Bn, "symbolRotate");
      $n.attr("rotation", (ta || 0) * Math.PI / 180 || 0);
      var na = normalizeSymbolOffset(Cn.getItemVisual(Bn, "symbolOffset"), In);
      na && ($n.x = na[0], $n.y = na[1]), Wn && $n.attr("cursor", Wn);
      var ra = Cn.getItemVisual(Bn, "style"), aa = ra.fill;
      if ($n instanceof ZRImage$1) {
        var ia = $n.style;
        $n.useStyle(extend({
          // TODO other properties like x, y ?
          image: ia.image,
          x: ia.x,
          y: ia.y,
          width: ia.width,
          height: ia.height
        }, ra));
      } else
        $n.__isEmptyBrush ? $n.useStyle(extend({}, ra)) : $n.useStyle(ra), $n.style.decal = null, $n.setColor(aa, Ln && Ln.symbolInnerColor), $n.style.strokeNoScale = !0;
      var Aa = Cn.getItemVisual(Bn, "liftZ"), sa = this._z2;
      Aa != null ? sa == null && (this._z2 = $n.z2, $n.z2 += Aa) : sa != null && ($n.z2 = sa, this._z2 = null);
      var oa = Ln && Ln.useNameLabel;
      setLabelStyle($n, Gn, {
        labelFetcher: Nn,
        labelDataIndex: Bn,
        defaultText: la,
        inheritColor: aa,
        defaultOpacity: ra.opacity
      });
      function la(fa) {
        return oa ? Cn.getName(fa) : getDefaultLabel(Cn, fa);
      }
      this._sizeX = In[0] / 2, this._sizeY = In[1] / 2;
      var ua = $n.ensureState("emphasis");
      ua.style = Rn, $n.ensureState("select").style = Pn, $n.ensureState("blur").style = Fn;
      var ca = Yn == null || Yn === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(Yn) && Yn > 0 ? +Yn : 1;
      ua.scaleX = this._sizeX * ca, ua.scaleY = this._sizeY * ca, this.setSymbolScale(1), toggleHoverEmphasis(this, Un, Hn, zn);
    }, nr.prototype.setSymbolScale = function(Cn) {
      this.scaleX = this.scaleY = Cn;
    }, nr.prototype.fadeOut = function(Cn, Bn, In) {
      var Dn = this.childAt(0), Ln = getECData(this).dataIndex, $n = In && In.animation;
      if (this.silent = Dn.silent = !0, In && In.fadeLabel) {
        var Nn = Dn.getTextContent();
        Nn && removeElement(Nn, {
          style: {
            opacity: 0
          }
        }, Bn, {
          dataIndex: Ln,
          removeOpt: $n,
          cb: function() {
            Dn.removeTextContent();
          }
        });
      } else
        Dn.removeTextContent();
      removeElement(Dn, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, Bn, {
        dataIndex: Ln,
        cb: Cn,
        removeOpt: $n
      });
    }, nr.getSymbolSize = function(Cn, Bn) {
      return normalizeSymbolSize(Cn.getItemVisual(Bn, "symbolSize"));
    }, nr;
  }(Group$4)
);
function driftSymbol(_n, nr) {
  this.parent.drift(_n, nr);
}
const SymbolClz = Symbol$1;
function symbolNeedsDraw$1(_n, nr, Cn, Bn) {
  return nr && !isNaN(nr[0]) && !isNaN(nr[1]) && !(Bn.isIgnore && Bn.isIgnore(Cn)) && !(Bn.clipShape && !Bn.clipShape.contain(nr[0], nr[1])) && _n.getItemVisual(Cn, "symbol") !== "none";
}
function normalizeUpdateOpt(_n) {
  return _n != null && !isObject$6(_n) && (_n = {
    isIgnore: _n
  }), _n || {};
}
function makeSeriesScope$2(_n) {
  var nr = _n.hostModel, Cn = nr.getModel("emphasis");
  return {
    emphasisItemStyle: Cn.getModel("itemStyle").getItemStyle(),
    blurItemStyle: nr.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: nr.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: Cn.get("focus"),
    blurScope: Cn.get("blurScope"),
    emphasisDisabled: Cn.get("disabled"),
    hoverScale: Cn.get("scale"),
    labelStatesModels: getLabelStatesModels(nr),
    cursorStyle: nr.get("cursor")
  };
}
var SymbolDraw = (
  /** @class */
  function() {
    function _n(nr) {
      this.group = new Group$4(), this._SymbolCtor = nr || SymbolClz;
    }
    return _n.prototype.updateData = function(nr, Cn) {
      this._progressiveEls = null, Cn = normalizeUpdateOpt(Cn);
      var Bn = this.group, In = nr.hostModel, Dn = this._data, Ln = this._SymbolCtor, $n = Cn.disableAnimation, Nn = makeSeriesScope$2(nr), Rn = {
        disableAnimation: $n
      }, Fn = Cn.getSymbolPoint || function(Pn) {
        return nr.getItemLayout(Pn);
      };
      Dn || Bn.removeAll(), nr.diff(Dn).add(function(Pn) {
        var Un = Fn(Pn);
        if (symbolNeedsDraw$1(nr, Un, Pn, Cn)) {
          var Hn = new Ln(nr, Pn, Nn, Rn);
          Hn.setPosition(Un), nr.setItemGraphicEl(Pn, Hn), Bn.add(Hn);
        }
      }).update(function(Pn, Un) {
        var Hn = Dn.getItemGraphicEl(Un), zn = Fn(Pn);
        if (!symbolNeedsDraw$1(nr, zn, Pn, Cn)) {
          Bn.remove(Hn);
          return;
        }
        var Gn = nr.getItemVisual(Pn, "symbol") || "circle", Yn = Hn && Hn.getSymbolType && Hn.getSymbolType();
        if (!Hn || Yn && Yn !== Gn)
          Bn.remove(Hn), Hn = new Ln(nr, Pn, Nn, Rn), Hn.setPosition(zn);
        else {
          Hn.updateData(nr, Pn, Nn, Rn);
          var Wn = {
            x: zn[0],
            y: zn[1]
          };
          $n ? Hn.attr(Wn) : updateProps$1(Hn, Wn, In);
        }
        Bn.add(Hn), nr.setItemGraphicEl(Pn, Hn);
      }).remove(function(Pn) {
        var Un = Dn.getItemGraphicEl(Pn);
        Un && Un.fadeOut(function() {
          Bn.remove(Un);
        }, In);
      }).execute(), this._getSymbolPoint = Fn, this._data = nr;
    }, _n.prototype.updateLayout = function() {
      var nr = this, Cn = this._data;
      Cn && Cn.eachItemGraphicEl(function(Bn, In) {
        var Dn = nr._getSymbolPoint(In);
        Bn.setPosition(Dn), Bn.markRedraw();
      });
    }, _n.prototype.incrementalPrepareUpdate = function(nr) {
      this._seriesScope = makeSeriesScope$2(nr), this._data = null, this.group.removeAll();
    }, _n.prototype.incrementalUpdate = function(nr, Cn, Bn) {
      this._progressiveEls = [], Bn = normalizeUpdateOpt(Bn);
      function In(Nn) {
        Nn.isGroup || (Nn.incremental = !0, Nn.ensureState("emphasis").hoverLayer = !0);
      }
      for (var Dn = nr.start; Dn < nr.end; Dn++) {
        var Ln = Cn.getItemLayout(Dn);
        if (symbolNeedsDraw$1(Cn, Ln, Dn, Bn)) {
          var $n = new this._SymbolCtor(Cn, Dn, this._seriesScope);
          $n.traverse(In), $n.setPosition(Ln), this.group.add($n), Cn.setItemGraphicEl(Dn, $n), this._progressiveEls.push($n);
        }
      }
    }, _n.prototype.eachRendered = function(nr) {
      traverseElements(this._progressiveEls || this.group, nr);
    }, _n.prototype.remove = function(nr) {
      var Cn = this.group, Bn = this._data;
      Bn && nr ? Bn.eachItemGraphicEl(function(In) {
        In.fadeOut(function() {
          Cn.remove(In);
        }, Bn.hostModel);
      }) : Cn.removeAll();
    }, _n;
  }()
);
const SymbolDraw$1 = SymbolDraw;
function prepareDataCoordInfo(_n, nr, Cn) {
  var Bn = _n.getBaseAxis(), In = _n.getOtherAxis(Bn), Dn = getValueStart(In, Cn), Ln = Bn.dim, $n = In.dim, Nn = nr.mapDimension($n), Rn = nr.mapDimension(Ln), Fn = $n === "x" || $n === "radius" ? 1 : 0, Pn = map$1(_n.dimensions, function(zn) {
    return nr.mapDimension(zn);
  }), Un = !1, Hn = nr.getCalculationInfo("stackResultDimension");
  return isDimensionStacked(
    nr,
    Pn[0]
    /* , dims[1] */
  ) && (Un = !0, Pn[0] = Hn), isDimensionStacked(
    nr,
    Pn[1]
    /* , dims[0] */
  ) && (Un = !0, Pn[1] = Hn), {
    dataDimsForPoint: Pn,
    valueStart: Dn,
    valueAxisDim: $n,
    baseAxisDim: Ln,
    stacked: !!Un,
    valueDim: Nn,
    baseDim: Rn,
    baseDataOffset: Fn,
    stackedOverDimension: nr.getCalculationInfo("stackedOverDimension")
  };
}
function getValueStart(_n, nr) {
  var Cn = 0, Bn = _n.scale.getExtent();
  return nr === "start" ? Cn = Bn[0] : nr === "end" ? Cn = Bn[1] : isNumber(nr) && !isNaN(nr) ? Cn = nr : Bn[0] > 0 ? Cn = Bn[0] : Bn[1] < 0 && (Cn = Bn[1]), Cn;
}
function getStackedOnPoint(_n, nr, Cn, Bn) {
  var In = NaN;
  _n.stacked && (In = Cn.get(Cn.getCalculationInfo("stackedOverDimension"), Bn)), isNaN(In) && (In = _n.valueStart);
  var Dn = _n.baseDataOffset, Ln = [];
  return Ln[Dn] = Cn.get(_n.baseDim, Bn), Ln[1 - Dn] = In, nr.dataToPoint(Ln);
}
function diffData(_n, nr) {
  var Cn = [];
  return nr.diff(_n).add(function(Bn) {
    Cn.push({
      cmd: "+",
      idx: Bn
    });
  }).update(function(Bn, In) {
    Cn.push({
      cmd: "=",
      idx: In,
      idx1: Bn
    });
  }).remove(function(Bn) {
    Cn.push({
      cmd: "-",
      idx: Bn
    });
  }).execute(), Cn;
}
function lineAnimationDiff(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  for (var Nn = diffData(_n, nr), Rn = [], Fn = [], Pn = [], Un = [], Hn = [], zn = [], Gn = [], Yn = prepareDataCoordInfo(In, nr, Ln), Wn = _n.getLayout("points") || [], Xn = nr.getLayout("points") || [], ea = 0; ea < Nn.length; ea++) {
    var ta = Nn[ea], na = !0, ra = void 0, aa = void 0;
    switch (ta.cmd) {
      case "=":
        ra = ta.idx * 2, aa = ta.idx1 * 2;
        var ia = Wn[ra], Aa = Wn[ra + 1], sa = Xn[aa], oa = Xn[aa + 1];
        (isNaN(ia) || isNaN(Aa)) && (ia = sa, Aa = oa), Rn.push(ia, Aa), Fn.push(sa, oa), Pn.push(Cn[ra], Cn[ra + 1]), Un.push(Bn[aa], Bn[aa + 1]), Gn.push(nr.getRawIndex(ta.idx1));
        break;
      case "+":
        var la = ta.idx, ua = Yn.dataDimsForPoint, ca = In.dataToPoint([nr.get(ua[0], la), nr.get(ua[1], la)]);
        aa = la * 2, Rn.push(ca[0], ca[1]), Fn.push(Xn[aa], Xn[aa + 1]);
        var fa = getStackedOnPoint(Yn, In, nr, la);
        Pn.push(fa[0], fa[1]), Un.push(Bn[aa], Bn[aa + 1]), Gn.push(nr.getRawIndex(la));
        break;
      case "-":
        na = !1;
    }
    na && (Hn.push(ta), zn.push(zn.length));
  }
  zn.sort(function(wa, ba) {
    return Gn[wa] - Gn[ba];
  });
  for (var ha = Rn.length, pa = createFloat32Array(ha), ya = createFloat32Array(ha), da = createFloat32Array(ha), Ca = createFloat32Array(ha), ma = [], ea = 0; ea < zn.length; ea++) {
    var va = zn[ea], ga = ea * 2, xa = va * 2;
    pa[ga] = Rn[xa], pa[ga + 1] = Rn[xa + 1], ya[ga] = Fn[xa], ya[ga + 1] = Fn[xa + 1], da[ga] = Pn[xa], da[ga + 1] = Pn[xa + 1], Ca[ga] = Un[xa], Ca[ga + 1] = Un[xa + 1], ma[ea] = Hn[va];
  }
  return {
    current: pa,
    next: ya,
    stackedOnCurrent: da,
    stackedOnNext: Ca,
    status: ma
  };
}
var mathMin$5 = Math.min, mathMax$5 = Math.max;
function isPointNull$1(_n, nr) {
  return isNaN(_n) || isNaN(nr);
}
function drawSegment(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
  for (var Rn, Fn, Pn, Un, Hn, zn, Gn = Cn, Yn = 0; Yn < Bn; Yn++) {
    var Wn = nr[Gn * 2], Xn = nr[Gn * 2 + 1];
    if (Gn >= In || Gn < 0)
      break;
    if (isPointNull$1(Wn, Xn)) {
      if (Nn) {
        Gn += Dn;
        continue;
      }
      break;
    }
    if (Gn === Cn)
      _n[Dn > 0 ? "moveTo" : "lineTo"](Wn, Xn), Pn = Wn, Un = Xn;
    else {
      var ea = Wn - Rn, ta = Xn - Fn;
      if (ea * ea + ta * ta < 0.5) {
        Gn += Dn;
        continue;
      }
      if (Ln > 0) {
        for (var na = Gn + Dn, ra = nr[na * 2], aa = nr[na * 2 + 1]; ra === Wn && aa === Xn && Yn < Bn; )
          Yn++, na += Dn, Gn += Dn, ra = nr[na * 2], aa = nr[na * 2 + 1], Wn = nr[Gn * 2], Xn = nr[Gn * 2 + 1], ea = Wn - Rn, ta = Xn - Fn;
        var ia = Yn + 1;
        if (Nn)
          for (; isPointNull$1(ra, aa) && ia < Bn; )
            ia++, na += Dn, ra = nr[na * 2], aa = nr[na * 2 + 1];
        var Aa = 0.5, sa = 0, oa = 0, la = void 0, ua = void 0;
        if (ia >= Bn || isPointNull$1(ra, aa))
          Hn = Wn, zn = Xn;
        else {
          sa = ra - Rn, oa = aa - Fn;
          var ca = Wn - Rn, fa = ra - Wn, ha = Xn - Fn, pa = aa - Xn, ya = void 0, da = void 0;
          if ($n === "x") {
            ya = Math.abs(ca), da = Math.abs(fa);
            var Ca = sa > 0 ? 1 : -1;
            Hn = Wn - Ca * ya * Ln, zn = Xn, la = Wn + Ca * da * Ln, ua = Xn;
          } else if ($n === "y") {
            ya = Math.abs(ha), da = Math.abs(pa);
            var ma = oa > 0 ? 1 : -1;
            Hn = Wn, zn = Xn - ma * ya * Ln, la = Wn, ua = Xn + ma * da * Ln;
          } else
            ya = Math.sqrt(ca * ca + ha * ha), da = Math.sqrt(fa * fa + pa * pa), Aa = da / (da + ya), Hn = Wn - sa * Ln * (1 - Aa), zn = Xn - oa * Ln * (1 - Aa), la = Wn + sa * Ln * Aa, ua = Xn + oa * Ln * Aa, la = mathMin$5(la, mathMax$5(ra, Wn)), ua = mathMin$5(ua, mathMax$5(aa, Xn)), la = mathMax$5(la, mathMin$5(ra, Wn)), ua = mathMax$5(ua, mathMin$5(aa, Xn)), sa = la - Wn, oa = ua - Xn, Hn = Wn - sa * ya / da, zn = Xn - oa * ya / da, Hn = mathMin$5(Hn, mathMax$5(Rn, Wn)), zn = mathMin$5(zn, mathMax$5(Fn, Xn)), Hn = mathMax$5(Hn, mathMin$5(Rn, Wn)), zn = mathMax$5(zn, mathMin$5(Fn, Xn)), sa = Wn - Hn, oa = Xn - zn, la = Wn + sa * da / ya, ua = Xn + oa * da / ya;
        }
        _n.bezierCurveTo(Pn, Un, Hn, zn, Wn, Xn), Pn = la, Un = ua;
      } else
        _n.lineTo(Wn, Xn);
    }
    Rn = Wn, Fn = Xn, Gn += Dn;
  }
  return Yn;
}
var ECPolylineShape = (
  /** @class */
  function() {
    function _n() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return _n;
  }()
), ECPolyline = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "ec-polyline", Bn;
    }
    return nr.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, nr.prototype.getDefaultShape = function() {
      return new ECPolylineShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Bn.points, Dn = 0, Ln = In.length / 2;
      if (Bn.connectNulls) {
        for (; Ln > 0 && isPointNull$1(In[Ln * 2 - 2], In[Ln * 2 - 1]); Ln--)
          ;
        for (; Dn < Ln && isPointNull$1(In[Dn * 2], In[Dn * 2 + 1]); Dn++)
          ;
      }
      for (; Dn < Ln; )
        Dn += drawSegment(Cn, In, Dn, Ln, Ln, 1, Bn.smooth, Bn.smoothMonotone, Bn.connectNulls) + 1;
    }, nr.prototype.getPointOn = function(Cn, Bn) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var In = this.path, Dn = In.data, Ln = PathProxy$1.CMD, $n, Nn, Rn = Bn === "x", Fn = [], Pn = 0; Pn < Dn.length; ) {
        var Un = Dn[Pn++], Hn = void 0, zn = void 0, Gn = void 0, Yn = void 0, Wn = void 0, Xn = void 0, ea = void 0;
        switch (Un) {
          case Ln.M:
            $n = Dn[Pn++], Nn = Dn[Pn++];
            break;
          case Ln.L:
            if (Hn = Dn[Pn++], zn = Dn[Pn++], ea = Rn ? (Cn - $n) / (Hn - $n) : (Cn - Nn) / (zn - Nn), ea <= 1 && ea >= 0) {
              var ta = Rn ? (zn - Nn) * ea + Nn : (Hn - $n) * ea + $n;
              return Rn ? [Cn, ta] : [ta, Cn];
            }
            $n = Hn, Nn = zn;
            break;
          case Ln.C:
            Hn = Dn[Pn++], zn = Dn[Pn++], Gn = Dn[Pn++], Yn = Dn[Pn++], Wn = Dn[Pn++], Xn = Dn[Pn++];
            var na = Rn ? cubicRootAt($n, Hn, Gn, Wn, Cn, Fn) : cubicRootAt(Nn, zn, Yn, Xn, Cn, Fn);
            if (na > 0)
              for (var ra = 0; ra < na; ra++) {
                var aa = Fn[ra];
                if (aa <= 1 && aa >= 0) {
                  var ta = Rn ? cubicAt(Nn, zn, Yn, Xn, aa) : cubicAt($n, Hn, Gn, Wn, aa);
                  return Rn ? [Cn, ta] : [ta, Cn];
                }
              }
            $n = Wn, Nn = Xn;
            break;
        }
      }
    }, nr;
  }(Path$1)
), ECPolygonShape = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr;
  }(ECPolylineShape)
), ECPolygon = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "ec-polygon", Bn;
    }
    return nr.prototype.getDefaultShape = function() {
      return new ECPolygonShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Bn.points, Dn = Bn.stackedOnPoints, Ln = 0, $n = In.length / 2, Nn = Bn.smoothMonotone;
      if (Bn.connectNulls) {
        for (; $n > 0 && isPointNull$1(In[$n * 2 - 2], In[$n * 2 - 1]); $n--)
          ;
        for (; Ln < $n && isPointNull$1(In[Ln * 2], In[Ln * 2 + 1]); Ln++)
          ;
      }
      for (; Ln < $n; ) {
        var Rn = drawSegment(Cn, In, Ln, $n, $n, 1, Bn.smooth, Nn, Bn.connectNulls);
        drawSegment(Cn, Dn, Ln + Rn - 1, Rn, $n, -1, Bn.stackedOnSmooth, Nn, Bn.connectNulls), Ln += Rn + 1, Cn.closePath();
      }
    }, nr;
  }(Path$1)
);
function createGridClipPath(_n, nr, Cn, Bn, In) {
  var Dn = _n.getArea(), Ln = Dn.x, $n = Dn.y, Nn = Dn.width, Rn = Dn.height, Fn = Cn.get(["lineStyle", "width"]) || 0;
  Ln -= Fn / 2, $n -= Fn / 2, Nn += Fn, Rn += Fn, Nn = Math.ceil(Nn), Ln !== Math.floor(Ln) && (Ln = Math.floor(Ln), Nn++);
  var Pn = new Rect$3({
    shape: {
      x: Ln,
      y: $n,
      width: Nn,
      height: Rn
    }
  });
  if (nr) {
    var Un = _n.getBaseAxis(), Hn = Un.isHorizontal(), zn = Un.inverse;
    Hn ? (zn && (Pn.shape.x += Nn), Pn.shape.width = 0) : (zn || (Pn.shape.y += Rn), Pn.shape.height = 0);
    var Gn = isFunction$1(In) ? function(Yn) {
      In(Yn, Pn);
    } : null;
    initProps(Pn, {
      shape: {
        width: Nn,
        height: Rn,
        x: Ln,
        y: $n
      }
    }, Cn, null, Bn, Gn);
  }
  return Pn;
}
function createPolarClipPath(_n, nr, Cn) {
  var Bn = _n.getArea(), In = round$4(Bn.r0, 1), Dn = round$4(Bn.r, 1), Ln = new Sector$1({
    shape: {
      cx: round$4(_n.cx, 1),
      cy: round$4(_n.cy, 1),
      r0: In,
      r: Dn,
      startAngle: Bn.startAngle,
      endAngle: Bn.endAngle,
      clockwise: Bn.clockwise
    }
  });
  if (nr) {
    var $n = _n.getBaseAxis().dim === "angle";
    $n ? Ln.shape.endAngle = Bn.startAngle : Ln.shape.r = In, initProps(Ln, {
      shape: {
        endAngle: Bn.endAngle,
        r: Dn
      }
    }, Cn);
  }
  return Ln;
}
function createClipPath(_n, nr, Cn, Bn, In) {
  if (_n) {
    if (_n.type === "polar")
      return createPolarClipPath(_n, nr, Cn);
    if (_n.type === "cartesian2d")
      return createGridClipPath(_n, nr, Cn, Bn, In);
  } else
    return null;
  return null;
}
function isCoordinateSystemType(_n, nr) {
  return _n.type === nr;
}
function isPointsSame(_n, nr) {
  if (_n.length === nr.length) {
    for (var Cn = 0; Cn < _n.length; Cn++)
      if (_n[Cn] !== nr[Cn])
        return;
    return !0;
  }
}
function bboxFromPoints(_n) {
  for (var nr = 1 / 0, Cn = 1 / 0, Bn = -1 / 0, In = -1 / 0, Dn = 0; Dn < _n.length; ) {
    var Ln = _n[Dn++], $n = _n[Dn++];
    isNaN(Ln) || (nr = Math.min(Ln, nr), Bn = Math.max(Ln, Bn)), isNaN($n) || (Cn = Math.min($n, Cn), In = Math.max($n, In));
  }
  return [[nr, Cn], [Bn, In]];
}
function getBoundingDiff(_n, nr) {
  var Cn = bboxFromPoints(_n), Bn = Cn[0], In = Cn[1], Dn = bboxFromPoints(nr), Ln = Dn[0], $n = Dn[1];
  return Math.max(Math.abs(Bn[0] - Ln[0]), Math.abs(Bn[1] - Ln[1]), Math.abs(In[0] - $n[0]), Math.abs(In[1] - $n[1]));
}
function getSmooth(_n) {
  return isNumber(_n) ? _n : _n ? 0.5 : 0;
}
function getStackedOnPoints(_n, nr, Cn) {
  if (!Cn.valueDim)
    return [];
  for (var Bn = nr.count(), In = createFloat32Array(Bn * 2), Dn = 0; Dn < Bn; Dn++) {
    var Ln = getStackedOnPoint(Cn, _n, nr, Dn);
    In[Dn * 2] = Ln[0], In[Dn * 2 + 1] = Ln[1];
  }
  return In;
}
function turnPointsIntoStep(_n, nr, Cn, Bn, In) {
  var Dn = Cn.getBaseAxis(), Ln = Dn.dim === "x" || Dn.dim === "radius" ? 0 : 1, $n = [], Nn = 0, Rn = [], Fn = [], Pn = [], Un = [];
  if (In) {
    for (Nn = 0; Nn < _n.length; Nn += 2) {
      var Hn = nr || _n;
      !isNaN(Hn[Nn]) && !isNaN(Hn[Nn + 1]) && Un.push(_n[Nn], _n[Nn + 1]);
    }
    _n = Un;
  }
  for (Nn = 0; Nn < _n.length - 2; Nn += 2)
    switch (Pn[0] = _n[Nn + 2], Pn[1] = _n[Nn + 3], Fn[0] = _n[Nn], Fn[1] = _n[Nn + 1], $n.push(Fn[0], Fn[1]), Bn) {
      case "end":
        Rn[Ln] = Pn[Ln], Rn[1 - Ln] = Fn[1 - Ln], $n.push(Rn[0], Rn[1]);
        break;
      case "middle":
        var zn = (Fn[Ln] + Pn[Ln]) / 2, Gn = [];
        Rn[Ln] = Gn[Ln] = zn, Rn[1 - Ln] = Fn[1 - Ln], Gn[1 - Ln] = Pn[1 - Ln], $n.push(Rn[0], Rn[1]), $n.push(Gn[0], Gn[1]);
        break;
      default:
        Rn[Ln] = Fn[Ln], Rn[1 - Ln] = Pn[1 - Ln], $n.push(Rn[0], Rn[1]);
    }
  return $n.push(_n[Nn++], _n[Nn++]), $n;
}
function clipColorStops(_n, nr) {
  var Cn = [], Bn = _n.length, In, Dn;
  function Ln(Fn, Pn, Un) {
    var Hn = Fn.coord, zn = (Un - Hn) / (Pn.coord - Hn), Gn = lerp$1(zn, [Fn.color, Pn.color]);
    return {
      coord: Un,
      color: Gn
    };
  }
  for (var $n = 0; $n < Bn; $n++) {
    var Nn = _n[$n], Rn = Nn.coord;
    if (Rn < 0)
      In = Nn;
    else if (Rn > nr) {
      Dn ? Cn.push(Ln(Dn, Nn, nr)) : In && Cn.push(Ln(In, Nn, 0), Ln(In, Nn, nr));
      break;
    } else
      In && (Cn.push(Ln(In, Nn, 0)), In = null), Cn.push(Nn), Dn = Nn;
  }
  return Cn;
}
function getVisualGradient(_n, nr, Cn) {
  var Bn = _n.getVisual("visualMeta");
  if (!(!Bn || !Bn.length || !_n.count())) {
    if (nr.type !== "cartesian2d") {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
      return;
    }
    for (var In, Dn, Ln = Bn.length - 1; Ln >= 0; Ln--) {
      var $n = _n.getDimensionInfo(Bn[Ln].dimension);
      if (In = $n && $n.coordDim, In === "x" || In === "y") {
        Dn = Bn[Ln];
        break;
      }
    }
    if (!Dn) {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
      return;
    }
    var Nn = nr.getAxis(In), Rn = map$1(Dn.stops, function(ea) {
      return {
        coord: Nn.toGlobalCoord(Nn.dataToCoord(ea.value)),
        color: ea.color
      };
    }), Fn = Rn.length, Pn = Dn.outerColors.slice();
    Fn && Rn[0].coord > Rn[Fn - 1].coord && (Rn.reverse(), Pn.reverse());
    var Un = clipColorStops(Rn, In === "x" ? Cn.getWidth() : Cn.getHeight()), Hn = Un.length;
    if (!Hn && Fn)
      return Rn[0].coord < 0 ? Pn[1] ? Pn[1] : Rn[Fn - 1].color : Pn[0] ? Pn[0] : Rn[0].color;
    var zn = 10, Gn = Un[0].coord - zn, Yn = Un[Hn - 1].coord + zn, Wn = Yn - Gn;
    if (Wn < 1e-3)
      return "transparent";
    each$f(Un, function(ea) {
      ea.offset = (ea.coord - Gn) / Wn;
    }), Un.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: Hn ? Un[Hn - 1].offset : 0.5,
      color: Pn[1] || "transparent"
    }), Un.unshift({
      offset: Hn ? Un[0].offset : 0.5,
      color: Pn[0] || "transparent"
    });
    var Xn = new LinearGradient$1(0, 0, 0, 0, Un, !0);
    return Xn[In] = Gn, Xn[In + "2"] = Yn, Xn;
  }
}
function getIsIgnoreFunc(_n, nr, Cn) {
  var Bn = _n.get("showAllSymbol"), In = Bn === "auto";
  if (!(Bn && !In)) {
    var Dn = Cn.getAxesByScale("ordinal")[0];
    if (Dn && !(In && canShowAllSymbolForCategory(Dn, nr))) {
      var Ln = nr.mapDimension(Dn.dim), $n = {};
      return each$f(Dn.getViewLabels(), function(Nn) {
        var Rn = Dn.scale.getRawOrdinalNumber(Nn.tickValue);
        $n[Rn] = 1;
      }), function(Nn) {
        return !$n.hasOwnProperty(nr.get(Ln, Nn));
      };
    }
  }
}
function canShowAllSymbolForCategory(_n, nr) {
  var Cn = _n.getExtent(), Bn = Math.abs(Cn[1] - Cn[0]) / _n.scale.count();
  isNaN(Bn) && (Bn = 0);
  for (var In = nr.count(), Dn = Math.max(1, Math.round(In / 5)), Ln = 0; Ln < In; Ln += Dn)
    if (SymbolClz.getSymbolSize(
      nr,
      Ln
      // Only for cartesian, where `isHorizontal` exists.
    )[_n.isHorizontal() ? 1 : 0] * 1.5 > Bn)
      return !1;
  return !0;
}
function isPointNull(_n, nr) {
  return isNaN(_n) || isNaN(nr);
}
function getLastIndexNotNull(_n) {
  for (var nr = _n.length / 2; nr > 0 && isPointNull(_n[nr * 2 - 2], _n[nr * 2 - 1]); nr--)
    ;
  return nr - 1;
}
function getPointAtIndex(_n, nr) {
  return [_n[nr * 2], _n[nr * 2 + 1]];
}
function getIndexRange(_n, nr, Cn) {
  for (var Bn = _n.length / 2, In = Cn === "x" ? 0 : 1, Dn, Ln, $n = 0, Nn = -1, Rn = 0; Rn < Bn; Rn++)
    if (Ln = _n[Rn * 2 + In], !(isNaN(Ln) || isNaN(_n[Rn * 2 + 1 - In]))) {
      if (Rn === 0) {
        Dn = Ln;
        continue;
      }
      if (Dn <= nr && Ln >= nr || Dn >= nr && Ln <= nr) {
        Nn = Rn;
        break;
      }
      $n = Rn, Dn = Ln;
    }
  return {
    range: [$n, Nn],
    t: (nr - Dn) / (Ln - Dn)
  };
}
function anyStateShowEndLabel(_n) {
  if (_n.get(["endLabel", "show"]))
    return !0;
  for (var nr = 0; nr < SPECIAL_STATES.length; nr++)
    if (_n.get([SPECIAL_STATES[nr], "endLabel", "show"]))
      return !0;
  return !1;
}
function createLineClipPath(_n, nr, Cn, Bn) {
  if (isCoordinateSystemType(nr, "cartesian2d")) {
    var In = Bn.getModel("endLabel"), Dn = In.get("valueAnimation"), Ln = Bn.getData(), $n = {
      lastFrameIndex: 0
    }, Nn = anyStateShowEndLabel(Bn) ? function(Hn, zn) {
      _n._endLabelOnDuring(Hn, zn, Ln, $n, Dn, In, nr);
    } : null, Rn = nr.getBaseAxis().isHorizontal(), Fn = createGridClipPath(nr, Cn, Bn, function() {
      var Hn = _n._endLabel;
      Hn && Cn && $n.originalX != null && Hn.attr({
        x: $n.originalX,
        y: $n.originalY
      });
    }, Nn);
    if (!Bn.get("clip", !0)) {
      var Pn = Fn.shape, Un = Math.max(Pn.width, Pn.height);
      Rn ? (Pn.y -= Un, Pn.height += Un * 2) : (Pn.x -= Un, Pn.width += Un * 2);
    }
    return Nn && Nn(1, Fn), Fn;
  } else
    return process.env.NODE_ENV !== "production" && Bn.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), createPolarClipPath(nr, Cn, Bn);
}
function getEndLabelStateSpecified(_n, nr) {
  var Cn = nr.getBaseAxis(), Bn = Cn.isHorizontal(), In = Cn.inverse, Dn = Bn ? In ? "right" : "left" : "center", Ln = Bn ? "middle" : In ? "top" : "bottom";
  return {
    normal: {
      align: _n.get("align") || Dn,
      verticalAlign: _n.get("verticalAlign") || Ln
    }
  };
}
var LineView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.init = function() {
      var Cn = new Group$4(), Bn = new SymbolDraw$1();
      this.group.add(Bn.group), this._symbolDraw = Bn, this._lineGroup = Cn, this._changePolyState = bind$1(this._changePolyState, this);
    }, nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Cn.coordinateSystem, Ln = this.group, $n = Cn.getData(), Nn = Cn.getModel("lineStyle"), Rn = Cn.getModel("areaStyle"), Fn = $n.getLayout("points") || [], Pn = Dn.type === "polar", Un = this._coordSys, Hn = this._symbolDraw, zn = this._polyline, Gn = this._polygon, Yn = this._lineGroup, Wn = !Bn.ssr && Cn.get("animation"), Xn = !Rn.isEmpty(), ea = Rn.get("origin"), ta = prepareDataCoordInfo(Dn, $n, ea), na = Xn && getStackedOnPoints(Dn, $n, ta), ra = Cn.get("showSymbol"), aa = Cn.get("connectNulls"), ia = ra && !Pn && getIsIgnoreFunc(Cn, $n, Dn), Aa = this._data;
      Aa && Aa.eachItemGraphicEl(function(wa, ba) {
        wa.__temp && (Ln.remove(wa), Aa.setItemGraphicEl(ba, null));
      }), ra || Hn.remove(), Ln.add(Yn);
      var sa = Pn ? !1 : Cn.get("step"), oa;
      Dn && Dn.getArea && Cn.get("clip", !0) && (oa = Dn.getArea(), oa.width != null ? (oa.x -= 0.1, oa.y -= 0.1, oa.width += 0.2, oa.height += 0.2) : oa.r0 && (oa.r0 -= 0.5, oa.r += 0.5)), this._clipShapeForSymbol = oa;
      var la = getVisualGradient($n, Dn, In) || $n.getVisual("style")[$n.getVisual("drawType")];
      if (!(zn && Un.type === Dn.type && sa === this._step))
        ra && Hn.updateData($n, {
          isIgnore: ia,
          clipShape: oa,
          disableAnimation: !0,
          getSymbolPoint: function(wa) {
            return [Fn[wa * 2], Fn[wa * 2 + 1]];
          }
        }), Wn && this._initSymbolLabelAnimation($n, Dn, oa), sa && (na && (na = turnPointsIntoStep(na, Fn, Dn, sa, aa)), Fn = turnPointsIntoStep(Fn, null, Dn, sa, aa)), zn = this._newPolyline(Fn), Xn ? Gn = this._newPolygon(Fn, na) : Gn && (Yn.remove(Gn), Gn = this._polygon = null), Pn || this._initOrUpdateEndLabel(Cn, Dn, convertToColorString(la)), Yn.setClipPath(createLineClipPath(this, Dn, !0, Cn));
      else {
        Xn && !Gn ? Gn = this._newPolygon(Fn, na) : Gn && !Xn && (Yn.remove(Gn), Gn = this._polygon = null), Pn || this._initOrUpdateEndLabel(Cn, Dn, convertToColorString(la));
        var ua = Yn.getClipPath();
        if (ua) {
          var ca = createLineClipPath(this, Dn, !1, Cn);
          initProps(ua, {
            shape: ca.shape
          }, Cn);
        } else
          Yn.setClipPath(createLineClipPath(this, Dn, !0, Cn));
        ra && Hn.updateData($n, {
          isIgnore: ia,
          clipShape: oa,
          disableAnimation: !0,
          getSymbolPoint: function(wa) {
            return [Fn[wa * 2], Fn[wa * 2 + 1]];
          }
        }), (!isPointsSame(this._stackedOnPoints, na) || !isPointsSame(this._points, Fn)) && (Wn ? this._doUpdateAnimation($n, na, Dn, In, sa, ea, aa) : (sa && (na && (na = turnPointsIntoStep(na, Fn, Dn, sa, aa)), Fn = turnPointsIntoStep(Fn, null, Dn, sa, aa)), zn.setShape({
          points: Fn
        }), Gn && Gn.setShape({
          points: Fn,
          stackedOnPoints: na
        })));
      }
      var fa = Cn.getModel("emphasis"), ha = fa.get("focus"), pa = fa.get("blurScope"), ya = fa.get("disabled");
      if (zn.useStyle(defaults(
        // Use color in lineStyle first
        Nn.getLineStyle(),
        {
          fill: "none",
          stroke: la,
          lineJoin: "bevel"
        }
      )), setStatesStylesFromModel(zn, Cn, "lineStyle"), zn.style.lineWidth > 0 && Cn.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var da = zn.getState("emphasis").style;
        da.lineWidth = +zn.style.lineWidth + 1;
      }
      getECData(zn).seriesIndex = Cn.seriesIndex, toggleHoverEmphasis(zn, ha, pa, ya);
      var Ca = getSmooth(Cn.get("smooth")), ma = Cn.get("smoothMonotone");
      if (zn.setShape({
        smooth: Ca,
        smoothMonotone: ma,
        connectNulls: aa
      }), Gn) {
        var va = $n.getCalculationInfo("stackedOnSeries"), ga = 0;
        Gn.useStyle(defaults(Rn.getAreaStyle(), {
          fill: la,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: $n.getVisual("style").decal
        })), va && (ga = getSmooth(va.get("smooth"))), Gn.setShape({
          smooth: Ca,
          stackedOnSmooth: ga,
          smoothMonotone: ma,
          connectNulls: aa
        }), setStatesStylesFromModel(Gn, Cn, "areaStyle"), getECData(Gn).seriesIndex = Cn.seriesIndex, toggleHoverEmphasis(Gn, ha, pa, ya);
      }
      var xa = this._changePolyState;
      $n.eachItemGraphicEl(function(wa) {
        wa && (wa.onHoverStateChange = xa);
      }), this._polyline.onHoverStateChange = xa, this._data = $n, this._coordSys = Dn, this._stackedOnPoints = na, this._points = Fn, this._step = sa, this._valueOrigin = ea, Cn.get("triggerLineEvent") && (this.packEventData(Cn, zn), Gn && this.packEventData(Cn, Gn));
    }, nr.prototype.packEventData = function(Cn, Bn) {
      getECData(Bn).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: Cn.componentIndex,
        seriesIndex: Cn.seriesIndex,
        seriesName: Cn.name,
        seriesType: "line"
      };
    }, nr.prototype.highlight = function(Cn, Bn, In, Dn) {
      var Ln = Cn.getData(), $n = queryDataIndex(Ln, Dn);
      if (this._changePolyState("emphasis"), !($n instanceof Array) && $n != null && $n >= 0) {
        var Nn = Ln.getLayout("points"), Rn = Ln.getItemGraphicEl($n);
        if (!Rn) {
          var Fn = Nn[$n * 2], Pn = Nn[$n * 2 + 1];
          if (isNaN(Fn) || isNaN(Pn) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(Fn, Pn))
            return;
          var Un = Cn.get("zlevel") || 0, Hn = Cn.get("z") || 0;
          Rn = new SymbolClz(Ln, $n), Rn.x = Fn, Rn.y = Pn, Rn.setZ(Un, Hn);
          var zn = Rn.getSymbolPath().getTextContent();
          zn && (zn.zlevel = Un, zn.z = Hn, zn.z2 = this._polyline.z2 + 1), Rn.__temp = !0, Ln.setItemGraphicEl($n, Rn), Rn.stopSymbolAnimation(!0), this.group.add(Rn);
        }
        Rn.highlight();
      } else
        ChartView$1.prototype.highlight.call(this, Cn, Bn, In, Dn);
    }, nr.prototype.downplay = function(Cn, Bn, In, Dn) {
      var Ln = Cn.getData(), $n = queryDataIndex(Ln, Dn);
      if (this._changePolyState("normal"), $n != null && $n >= 0) {
        var Nn = Ln.getItemGraphicEl($n);
        Nn && (Nn.__temp ? (Ln.setItemGraphicEl($n, null), this.group.remove(Nn)) : Nn.downplay());
      } else
        ChartView$1.prototype.downplay.call(this, Cn, Bn, In, Dn);
    }, nr.prototype._changePolyState = function(Cn) {
      var Bn = this._polygon;
      setStatesFlag(this._polyline, Cn), Bn && setStatesFlag(Bn, Cn);
    }, nr.prototype._newPolyline = function(Cn) {
      var Bn = this._polyline;
      return Bn && this._lineGroup.remove(Bn), Bn = new ECPolyline({
        shape: {
          points: Cn
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(Bn), this._polyline = Bn, Bn;
    }, nr.prototype._newPolygon = function(Cn, Bn) {
      var In = this._polygon;
      return In && this._lineGroup.remove(In), In = new ECPolygon({
        shape: {
          points: Cn,
          stackedOnPoints: Bn
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(In), this._polygon = In, In;
    }, nr.prototype._initSymbolLabelAnimation = function(Cn, Bn, In) {
      var Dn, Ln, $n = Bn.getBaseAxis(), Nn = $n.inverse;
      Bn.type === "cartesian2d" ? (Dn = $n.isHorizontal(), Ln = !1) : Bn.type === "polar" && (Dn = $n.dim === "angle", Ln = !0);
      var Rn = Cn.hostModel, Fn = Rn.get("animationDuration");
      isFunction$1(Fn) && (Fn = Fn(null));
      var Pn = Rn.get("animationDelay") || 0, Un = isFunction$1(Pn) ? Pn(null) : Pn;
      Cn.eachItemGraphicEl(function(Hn, zn) {
        var Gn = Hn;
        if (Gn) {
          var Yn = [Hn.x, Hn.y], Wn = void 0, Xn = void 0, ea = void 0;
          if (In)
            if (Ln) {
              var ta = In, na = Bn.pointToCoord(Yn);
              Dn ? (Wn = ta.startAngle, Xn = ta.endAngle, ea = -na[1] / 180 * Math.PI) : (Wn = ta.r0, Xn = ta.r, ea = na[0]);
            } else {
              var ra = In;
              Dn ? (Wn = ra.x, Xn = ra.x + ra.width, ea = Hn.x) : (Wn = ra.y + ra.height, Xn = ra.y, ea = Hn.y);
            }
          var aa = Xn === Wn ? 0 : (ea - Wn) / (Xn - Wn);
          Nn && (aa = 1 - aa);
          var ia = isFunction$1(Pn) ? Pn(zn) : Fn * aa + Un, Aa = Gn.getSymbolPath(), sa = Aa.getTextContent();
          Gn.attr({
            scaleX: 0,
            scaleY: 0
          }), Gn.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: ia
          }), sa && sa.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: ia
          }), Aa.disableLabelAnimation = !0;
        }
      });
    }, nr.prototype._initOrUpdateEndLabel = function(Cn, Bn, In) {
      var Dn = Cn.getModel("endLabel");
      if (anyStateShowEndLabel(Cn)) {
        var Ln = Cn.getData(), $n = this._polyline, Nn = Ln.getLayout("points");
        if (!Nn) {
          $n.removeTextContent(), this._endLabel = null;
          return;
        }
        var Rn = this._endLabel;
        Rn || (Rn = this._endLabel = new ZRText$1({
          z2: 200
          // should be higher than item symbol
        }), Rn.ignoreClip = !0, $n.setTextContent(this._endLabel), $n.disableLabelAnimation = !0);
        var Fn = getLastIndexNotNull(Nn);
        Fn >= 0 && (setLabelStyle($n, getLabelStatesModels(Cn, "endLabel"), {
          inheritColor: In,
          labelFetcher: Cn,
          labelDataIndex: Fn,
          defaultText: function(Pn, Un, Hn) {
            return Hn != null ? getDefaultInterpolatedLabel(Ln, Hn) : getDefaultLabel(Ln, Pn);
          },
          enableTextSetter: !0
        }, getEndLabelStateSpecified(Dn, Bn)), $n.textConfig.position = null);
      } else
        this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, nr.prototype._endLabelOnDuring = function(Cn, Bn, In, Dn, Ln, $n, Nn) {
      var Rn = this._endLabel, Fn = this._polyline;
      if (Rn) {
        Cn < 1 && Dn.originalX == null && (Dn.originalX = Rn.x, Dn.originalY = Rn.y);
        var Pn = In.getLayout("points"), Un = In.hostModel, Hn = Un.get("connectNulls"), zn = $n.get("precision"), Gn = $n.get("distance") || 0, Yn = Nn.getBaseAxis(), Wn = Yn.isHorizontal(), Xn = Yn.inverse, ea = Bn.shape, ta = Xn ? Wn ? ea.x : ea.y + ea.height : Wn ? ea.x + ea.width : ea.y, na = (Wn ? Gn : 0) * (Xn ? -1 : 1), ra = (Wn ? 0 : -Gn) * (Xn ? -1 : 1), aa = Wn ? "x" : "y", ia = getIndexRange(Pn, ta, aa), Aa = ia.range, sa = Aa[1] - Aa[0], oa = void 0;
        if (sa >= 1) {
          if (sa > 1 && !Hn) {
            var la = getPointAtIndex(Pn, Aa[0]);
            Rn.attr({
              x: la[0] + na,
              y: la[1] + ra
            }), Ln && (oa = Un.getRawValue(Aa[0]));
          } else {
            var la = Fn.getPointOn(ta, aa);
            la && Rn.attr({
              x: la[0] + na,
              y: la[1] + ra
            });
            var ua = Un.getRawValue(Aa[0]), ca = Un.getRawValue(Aa[1]);
            Ln && (oa = interpolateRawValues(In, zn, ua, ca, ia.t));
          }
          Dn.lastFrameIndex = Aa[0];
        } else {
          var fa = Cn === 1 || Dn.lastFrameIndex > 0 ? Aa[0] : 0, la = getPointAtIndex(Pn, fa);
          Ln && (oa = Un.getRawValue(fa)), Rn.attr({
            x: la[0] + na,
            y: la[1] + ra
          });
        }
        if (Ln) {
          var ha = labelInner(Rn);
          typeof ha.setLabelText == "function" && ha.setLabelText(oa);
        }
      }
    }, nr.prototype._doUpdateAnimation = function(Cn, Bn, In, Dn, Ln, $n, Nn) {
      var Rn = this._polyline, Fn = this._polygon, Pn = Cn.hostModel, Un = lineAnimationDiff(this._data, Cn, this._stackedOnPoints, Bn, this._coordSys, In, this._valueOrigin), Hn = Un.current, zn = Un.stackedOnCurrent, Gn = Un.next, Yn = Un.stackedOnNext;
      if (Ln && (zn = turnPointsIntoStep(Un.stackedOnCurrent, Un.current, In, Ln, Nn), Hn = turnPointsIntoStep(Un.current, null, In, Ln, Nn), Yn = turnPointsIntoStep(Un.stackedOnNext, Un.next, In, Ln, Nn), Gn = turnPointsIntoStep(Un.next, null, In, Ln, Nn)), getBoundingDiff(Hn, Gn) > 3e3 || Fn && getBoundingDiff(zn, Yn) > 3e3) {
        Rn.stopAnimation(), Rn.setShape({
          points: Gn
        }), Fn && (Fn.stopAnimation(), Fn.setShape({
          points: Gn,
          stackedOnPoints: Yn
        }));
        return;
      }
      Rn.shape.__points = Un.current, Rn.shape.points = Hn;
      var Wn = {
        shape: {
          points: Gn
        }
      };
      Un.current !== Hn && (Wn.shape.__points = Un.next), Rn.stopAnimation(), updateProps$1(Rn, Wn, Pn), Fn && (Fn.setShape({
        // Reuse the points with polyline.
        points: Hn,
        stackedOnPoints: zn
      }), Fn.stopAnimation(), updateProps$1(Fn, {
        shape: {
          stackedOnPoints: Yn
        }
      }, Pn), Rn.shape.points !== Fn.shape.points && (Fn.shape.points = Rn.shape.points));
      for (var Xn = [], ea = Un.status, ta = 0; ta < ea.length; ta++) {
        var na = ea[ta].cmd;
        if (na === "=") {
          var ra = Cn.getItemGraphicEl(ea[ta].idx1);
          ra && Xn.push({
            el: ra,
            ptIdx: ta
            // Index of points
          });
        }
      }
      Rn.animators && Rn.animators.length && Rn.animators[0].during(function() {
        Fn && Fn.dirtyShape();
        for (var aa = Rn.shape.__points, ia = 0; ia < Xn.length; ia++) {
          var Aa = Xn[ia].el, sa = Xn[ia].ptIdx * 2;
          Aa.x = aa[sa], Aa.y = aa[sa + 1], Aa.markRedraw();
        }
      });
    }, nr.prototype.remove = function(Cn) {
      var Bn = this.group, In = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), In && In.eachItemGraphicEl(function(Dn, Ln) {
        Dn.__temp && (Bn.remove(Dn), In.setItemGraphicEl(Ln, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, nr.type = "line", nr;
  }(ChartView$1)
);
const LineView$1 = LineView;
function pointsLayout(_n, nr) {
  return {
    seriesType: _n,
    plan: createRenderPlanner(),
    reset: function(Cn) {
      var Bn = Cn.getData(), In = Cn.coordinateSystem, Dn = Cn.pipelineContext, Ln = nr || Dn.large;
      if (In) {
        var $n = map$1(In.dimensions, function(Hn) {
          return Bn.mapDimension(Hn);
        }).slice(0, 2), Nn = $n.length, Rn = Bn.getCalculationInfo("stackResultDimension");
        isDimensionStacked(Bn, $n[0]) && ($n[0] = Rn), isDimensionStacked(Bn, $n[1]) && ($n[1] = Rn);
        var Fn = Bn.getStore(), Pn = Bn.getDimensionIndex($n[0]), Un = Bn.getDimensionIndex($n[1]);
        return Nn && {
          progress: function(Hn, zn) {
            for (var Gn = Hn.end - Hn.start, Yn = Ln && createFloat32Array(Gn * Nn), Wn = [], Xn = [], ea = Hn.start, ta = 0; ea < Hn.end; ea++) {
              var na = void 0;
              if (Nn === 1) {
                var ra = Fn.get(Pn, ea);
                na = In.dataToPoint(ra, null, Xn);
              } else
                Wn[0] = Fn.get(Pn, ea), Wn[1] = Fn.get(Un, ea), na = In.dataToPoint(Wn, null, Xn);
              Ln ? (Yn[ta++] = na[0], Yn[ta++] = na[1]) : zn.setItemLayout(ea, na.slice());
            }
            Ln && zn.setLayout("points", Yn);
          }
        };
      }
    }
  };
}
var samplers = {
  average: function(_n) {
    for (var nr = 0, Cn = 0, Bn = 0; Bn < _n.length; Bn++)
      isNaN(_n[Bn]) || (nr += _n[Bn], Cn++);
    return Cn === 0 ? NaN : nr / Cn;
  },
  sum: function(_n) {
    for (var nr = 0, Cn = 0; Cn < _n.length; Cn++)
      nr += _n[Cn] || 0;
    return nr;
  },
  max: function(_n) {
    for (var nr = -1 / 0, Cn = 0; Cn < _n.length; Cn++)
      _n[Cn] > nr && (nr = _n[Cn]);
    return isFinite(nr) ? nr : NaN;
  },
  min: function(_n) {
    for (var nr = 1 / 0, Cn = 0; Cn < _n.length; Cn++)
      _n[Cn] < nr && (nr = _n[Cn]);
    return isFinite(nr) ? nr : NaN;
  },
  // TODO
  // Median
  nearest: function(_n) {
    return _n[0];
  }
}, indexSampler = function(_n) {
  return Math.round(_n.length / 2);
};
function dataSample(_n) {
  return {
    seriesType: _n,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(nr, Cn, Bn) {
      var In = nr.getData(), Dn = nr.get("sampling"), Ln = nr.coordinateSystem, $n = In.count();
      if ($n > 10 && Ln.type === "cartesian2d" && Dn) {
        var Nn = Ln.getBaseAxis(), Rn = Ln.getOtherAxis(Nn), Fn = Nn.getExtent(), Pn = Bn.getDevicePixelRatio(), Un = Math.abs(Fn[1] - Fn[0]) * (Pn || 1), Hn = Math.round($n / Un);
        if (isFinite(Hn) && Hn > 1) {
          Dn === "lttb" ? nr.setData(In.lttbDownSample(In.mapDimension(Rn.dim), 1 / Hn)) : Dn === "minmax" && nr.setData(In.minmaxDownSample(In.mapDimension(Rn.dim), 1 / Hn));
          var zn = void 0;
          isString$1(Dn) ? zn = samplers[Dn] : isFunction$1(Dn) && (zn = Dn), zn && nr.setData(In.downSample(In.mapDimension(Rn.dim), 1 / Hn, zn, indexSampler));
        }
      }
    }
  };
}
function install$Q(_n) {
  _n.registerChartView(LineView$1), _n.registerSeriesModel(LineSeries), _n.registerLayout(pointsLayout("line", !0)), _n.registerVisual({
    seriesType: "line",
    reset: function(nr) {
      var Cn = nr.getData(), Bn = nr.getModel("lineStyle").getLineStyle();
      Bn && !Bn.stroke && (Bn.stroke = Cn.getVisual("style").fill), Cn.setVisual("legendLineStyle", Bn);
    }
  }), _n.registerProcessor(_n.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}
var BaseBarSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.getInitialData = function(Cn, Bn) {
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0
      });
    }, nr.prototype.getMarkerPosition = function(Cn, Bn, In) {
      var Dn = this.coordinateSystem;
      if (Dn && Dn.clampData) {
        var Ln = Dn.clampData(Cn), $n = Dn.dataToPoint(Ln);
        if (In)
          each$f(Dn.getAxes(), function(Un, Hn) {
            if (Un.type === "category" && Bn != null) {
              var zn = Un.getTicksCoords(), Gn = Un.getTickModel().get("alignWithLabel"), Yn = Ln[Hn], Wn = Bn[Hn] === "x1" || Bn[Hn] === "y1";
              if (Wn && !Gn && (Yn += 1), zn.length < 2)
                return;
              if (zn.length === 2) {
                $n[Hn] = Un.toGlobalCoord(Un.getExtent()[Wn ? 1 : 0]);
                return;
              }
              for (var Xn = void 0, ea = void 0, ta = 1, na = 0; na < zn.length; na++) {
                var ra = zn[na].coord, aa = na === zn.length - 1 ? zn[na - 1].tickValue + ta : zn[na].tickValue;
                if (aa === Yn) {
                  ea = ra;
                  break;
                } else if (aa < Yn)
                  Xn = ra;
                else if (Xn != null && aa > Yn) {
                  ea = (ra + Xn) / 2;
                  break;
                }
                na === 1 && (ta = aa - zn[0].tickValue);
              }
              ea == null && (Xn ? Xn && (ea = zn[zn.length - 1].coord) : ea = zn[0].coord), $n[Hn] = Un.toGlobalCoord(ea);
            }
          });
        else {
          var Nn = this.getData(), Rn = Nn.getLayout("offset"), Fn = Nn.getLayout("size"), Pn = Dn.getBaseAxis().isHorizontal() ? 0 : 1;
          $n[Pn] += Rn + Fn / 2;
        }
        return $n;
      }
      return [NaN, NaN];
    }, nr.type = "series.__base_bar__", nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, nr;
  }(SeriesModel$1)
);
SeriesModel$1.registerClass(BaseBarSeriesModel);
const BaseBarSeriesModel$1 = BaseBarSeriesModel;
var BarSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.getInitialData = function() {
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, nr.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, nr.prototype.getProgressiveThreshold = function() {
      var Cn = this.get("progressiveThreshold"), Bn = this.get("largeThreshold");
      return Bn > Cn && (Cn = Bn), Cn;
    }, nr.prototype.brushSelector = function(Cn, Bn, In) {
      return In.rect(Bn.getItemLayout(Cn));
    }, nr.type = "series.bar", nr.dependencies = ["grid", "polar"], nr.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: !1
    }), nr;
  }(BaseBarSeriesModel$1)
);
const BarSeries = BarSeriesModel;
var SausageShape = (
  /** @class */
  function() {
    function _n() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return _n;
  }()
), SausagePath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "sausage", Bn;
    }
    return nr.prototype.getDefaultShape = function() {
      return new SausageShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Bn.cx, Dn = Bn.cy, Ln = Math.max(Bn.r0 || 0, 0), $n = Math.max(Bn.r, 0), Nn = ($n - Ln) * 0.5, Rn = Ln + Nn, Fn = Bn.startAngle, Pn = Bn.endAngle, Un = Bn.clockwise, Hn = Math.PI * 2, zn = Un ? Pn - Fn < Hn : Fn - Pn < Hn;
      zn || (Fn = Pn - (Un ? Hn : -Hn));
      var Gn = Math.cos(Fn), Yn = Math.sin(Fn), Wn = Math.cos(Pn), Xn = Math.sin(Pn);
      zn ? (Cn.moveTo(Gn * Ln + In, Yn * Ln + Dn), Cn.arc(Gn * Rn + In, Yn * Rn + Dn, Nn, -Math.PI + Fn, Fn, !Un)) : Cn.moveTo(Gn * $n + In, Yn * $n + Dn), Cn.arc(In, Dn, $n, Fn, Pn, !Un), Cn.arc(Wn * Rn + In, Xn * Rn + Dn, Nn, Pn - Math.PI * 2, Pn - Math.PI, !Un), Ln !== 0 && Cn.arc(In, Dn, Ln, Pn, Fn, Un);
    }, nr;
  }(Path$1)
);
const Sausage = SausagePath;
function createSectorCalculateTextPosition(_n, nr) {
  nr = nr || {};
  var Cn = nr.isRoundCap;
  return function(Bn, In, Dn) {
    var Ln = In.position;
    if (!Ln || Ln instanceof Array)
      return calculateTextPosition(Bn, In, Dn);
    var $n = _n(Ln), Nn = In.distance != null ? In.distance : 5, Rn = this.shape, Fn = Rn.cx, Pn = Rn.cy, Un = Rn.r, Hn = Rn.r0, zn = (Un + Hn) / 2, Gn = Rn.startAngle, Yn = Rn.endAngle, Wn = (Gn + Yn) / 2, Xn = Cn ? Math.abs(Un - Hn) / 2 : 0, ea = Math.cos, ta = Math.sin, na = Fn + Un * ea(Gn), ra = Pn + Un * ta(Gn), aa = "left", ia = "top";
    switch ($n) {
      case "startArc":
        na = Fn + (Hn - Nn) * ea(Wn), ra = Pn + (Hn - Nn) * ta(Wn), aa = "center", ia = "top";
        break;
      case "insideStartArc":
        na = Fn + (Hn + Nn) * ea(Wn), ra = Pn + (Hn + Nn) * ta(Wn), aa = "center", ia = "bottom";
        break;
      case "startAngle":
        na = Fn + zn * ea(Gn) + adjustAngleDistanceX(Gn, Nn + Xn, !1), ra = Pn + zn * ta(Gn) + adjustAngleDistanceY(Gn, Nn + Xn, !1), aa = "right", ia = "middle";
        break;
      case "insideStartAngle":
        na = Fn + zn * ea(Gn) + adjustAngleDistanceX(Gn, -Nn + Xn, !1), ra = Pn + zn * ta(Gn) + adjustAngleDistanceY(Gn, -Nn + Xn, !1), aa = "left", ia = "middle";
        break;
      case "middle":
        na = Fn + zn * ea(Wn), ra = Pn + zn * ta(Wn), aa = "center", ia = "middle";
        break;
      case "endArc":
        na = Fn + (Un + Nn) * ea(Wn), ra = Pn + (Un + Nn) * ta(Wn), aa = "center", ia = "bottom";
        break;
      case "insideEndArc":
        na = Fn + (Un - Nn) * ea(Wn), ra = Pn + (Un - Nn) * ta(Wn), aa = "center", ia = "top";
        break;
      case "endAngle":
        na = Fn + zn * ea(Yn) + adjustAngleDistanceX(Yn, Nn + Xn, !0), ra = Pn + zn * ta(Yn) + adjustAngleDistanceY(Yn, Nn + Xn, !0), aa = "left", ia = "middle";
        break;
      case "insideEndAngle":
        na = Fn + zn * ea(Yn) + adjustAngleDistanceX(Yn, -Nn + Xn, !0), ra = Pn + zn * ta(Yn) + adjustAngleDistanceY(Yn, -Nn + Xn, !0), aa = "right", ia = "middle";
        break;
      default:
        return calculateTextPosition(Bn, In, Dn);
    }
    return Bn = Bn || {}, Bn.x = na, Bn.y = ra, Bn.align = aa, Bn.verticalAlign = ia, Bn;
  };
}
function setSectorTextRotation(_n, nr, Cn, Bn) {
  if (isNumber(Bn)) {
    _n.setTextConfig({
      rotation: Bn
    });
    return;
  } else if (isArray$4(nr)) {
    _n.setTextConfig({
      rotation: 0
    });
    return;
  }
  var In = _n.shape, Dn = In.clockwise ? In.startAngle : In.endAngle, Ln = In.clockwise ? In.endAngle : In.startAngle, $n = (Dn + Ln) / 2, Nn, Rn = Cn(nr);
  switch (Rn) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      Nn = $n;
      break;
    case "startAngle":
    case "insideStartAngle":
      Nn = Dn;
      break;
    case "endAngle":
    case "insideEndAngle":
      Nn = Ln;
      break;
    default:
      _n.setTextConfig({
        rotation: 0
      });
      return;
  }
  var Fn = Math.PI * 1.5 - Nn;
  Rn === "middle" && Fn > Math.PI / 2 && Fn < Math.PI * 1.5 && (Fn -= Math.PI), _n.setTextConfig({
    rotation: Fn
  });
}
function adjustAngleDistanceX(_n, nr, Cn) {
  return nr * Math.sin(_n) * (Cn ? -1 : 1);
}
function adjustAngleDistanceY(_n, nr, Cn) {
  return nr * Math.cos(_n) * (Cn ? 1 : -1);
}
function getSectorCornerRadius(_n, nr, Cn) {
  var Bn = _n.get("borderRadius");
  if (Bn == null)
    return Cn ? {
      cornerRadius: 0
    } : null;
  isArray$4(Bn) || (Bn = [Bn, Bn, Bn, Bn]);
  var In = Math.abs(nr.r || 0 - nr.r0 || 0);
  return {
    cornerRadius: map$1(Bn, function(Dn) {
      return parsePercent$1(Dn, In);
    })
  };
}
var mathMax$4 = Math.max, mathMin$4 = Math.min;
function getClipArea(_n, nr) {
  var Cn = _n.getArea && _n.getArea();
  if (isCoordinateSystemType(_n, "cartesian2d")) {
    var Bn = _n.getBaseAxis();
    if (Bn.type !== "category" || !Bn.onBand) {
      var In = nr.getLayout("bandWidth");
      Bn.isHorizontal() ? (Cn.x -= In, Cn.width += In * 2) : (Cn.y -= In, Cn.height += In * 2);
    }
  }
  return Cn;
}
var BarView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n.call(this) || this;
      return Cn.type = nr.type, Cn._isFirstFrame = !0, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      this._model = Cn, this._removeOnRenderedListener(In), this._updateDrawMode(Cn);
      var Ln = Cn.get("coordinateSystem");
      Ln === "cartesian2d" || Ln === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(Cn, Bn, In) : this._renderNormal(Cn, Bn, In, Dn)) : process.env.NODE_ENV !== "production" && warn("Only cartesian2d and polar supported for bar.");
    }, nr.prototype.incrementalPrepareRender = function(Cn) {
      this._clear(), this._updateDrawMode(Cn), this._updateLargeClip(Cn);
    }, nr.prototype.incrementalRender = function(Cn, Bn) {
      this._progressiveEls = [], this._incrementalRenderLarge(Cn, Bn);
    }, nr.prototype.eachRendered = function(Cn) {
      traverseElements(this._progressiveEls || this.group, Cn);
    }, nr.prototype._updateDrawMode = function(Cn) {
      var Bn = Cn.pipelineContext.large;
      (this._isLargeDraw == null || Bn !== this._isLargeDraw) && (this._isLargeDraw = Bn, this._clear());
    }, nr.prototype._renderNormal = function(Cn, Bn, In, Dn) {
      var Ln = this.group, $n = Cn.getData(), Nn = this._data, Rn = Cn.coordinateSystem, Fn = Rn.getBaseAxis(), Pn;
      Rn.type === "cartesian2d" ? Pn = Fn.isHorizontal() : Rn.type === "polar" && (Pn = Fn.dim === "angle");
      var Un = Cn.isAnimationEnabled() ? Cn : null, Hn = shouldRealtimeSort(Cn, Rn);
      Hn && this._enableRealtimeSort(Hn, $n, In);
      var zn = Cn.get("clip", !0) || Hn, Gn = getClipArea(Rn, $n);
      Ln.removeClipPath();
      var Yn = Cn.get("roundCap", !0), Wn = Cn.get("showBackground", !0), Xn = Cn.getModel("backgroundStyle"), ea = Xn.get("borderRadius") || 0, ta = [], na = this._backgroundEls, ra = Dn && Dn.isInitSort, aa = Dn && Dn.type === "changeAxisOrder";
      function ia(oa) {
        var la = getLayout[Rn.type]($n, oa), ua = createBackgroundEl(Rn, Pn, la);
        return ua.useStyle(Xn.getItemStyle()), Rn.type === "cartesian2d" ? ua.setShape("r", ea) : ua.setShape("cornerRadius", ea), ta[oa] = ua, ua;
      }
      $n.diff(Nn).add(function(oa) {
        var la = $n.getItemModel(oa), ua = getLayout[Rn.type]($n, oa, la);
        if (Wn && ia(oa), !(!$n.hasValue(oa) || !isValidLayout[Rn.type](ua))) {
          var ca = !1;
          zn && (ca = clip[Rn.type](Gn, ua));
          var fa = elementCreator[Rn.type](Cn, $n, oa, ua, Pn, Un, Fn.model, !1, Yn);
          Hn && (fa.forceLabelAnimation = !0), updateStyle(fa, $n, oa, la, ua, Cn, Pn, Rn.type === "polar"), ra ? fa.attr({
            shape: ua
          }) : Hn ? updateRealtimeAnimation(Hn, Un, fa, ua, oa, Pn, !1, !1) : initProps(fa, {
            shape: ua
          }, Cn, oa), $n.setItemGraphicEl(oa, fa), Ln.add(fa), fa.ignore = ca;
        }
      }).update(function(oa, la) {
        var ua = $n.getItemModel(oa), ca = getLayout[Rn.type]($n, oa, ua);
        if (Wn) {
          var fa = void 0;
          na.length === 0 ? fa = ia(la) : (fa = na[la], fa.useStyle(Xn.getItemStyle()), Rn.type === "cartesian2d" ? fa.setShape("r", ea) : fa.setShape("cornerRadius", ea), ta[oa] = fa);
          var ha = getLayout[Rn.type]($n, oa), pa = createBackgroundShape(Pn, ha, Rn);
          updateProps$1(fa, {
            shape: pa
          }, Un, oa);
        }
        var ya = Nn.getItemGraphicEl(la);
        if (!$n.hasValue(oa) || !isValidLayout[Rn.type](ca)) {
          Ln.remove(ya);
          return;
        }
        var da = !1;
        if (zn && (da = clip[Rn.type](Gn, ca), da && Ln.remove(ya)), ya ? saveOldStyle(ya) : ya = elementCreator[Rn.type](Cn, $n, oa, ca, Pn, Un, Fn.model, !!ya, Yn), Hn && (ya.forceLabelAnimation = !0), aa) {
          var Ca = ya.getTextContent();
          if (Ca) {
            var ma = labelInner(Ca);
            ma.prevValue != null && (ma.prevValue = ma.value);
          }
        } else
          updateStyle(ya, $n, oa, ua, ca, Cn, Pn, Rn.type === "polar");
        ra ? ya.attr({
          shape: ca
        }) : Hn ? updateRealtimeAnimation(Hn, Un, ya, ca, oa, Pn, !0, aa) : updateProps$1(ya, {
          shape: ca
        }, Cn, oa, null), $n.setItemGraphicEl(oa, ya), ya.ignore = da, Ln.add(ya);
      }).remove(function(oa) {
        var la = Nn.getItemGraphicEl(oa);
        la && removeElementWithFadeOut(la, Cn, oa);
      }).execute();
      var Aa = this._backgroundGroup || (this._backgroundGroup = new Group$4());
      Aa.removeAll();
      for (var sa = 0; sa < ta.length; ++sa)
        Aa.add(ta[sa]);
      Ln.add(Aa), this._backgroundEls = ta, this._data = $n;
    }, nr.prototype._renderLarge = function(Cn, Bn, In) {
      this._clear(), createLarge$1(Cn, this.group), this._updateLargeClip(Cn);
    }, nr.prototype._incrementalRenderLarge = function(Cn, Bn) {
      this._removeBackground(), createLarge$1(Bn, this.group, this._progressiveEls, !0);
    }, nr.prototype._updateLargeClip = function(Cn) {
      var Bn = Cn.get("clip", !0) && createClipPath(Cn.coordinateSystem, !1, Cn), In = this.group;
      Bn ? In.setClipPath(Bn) : In.removeClipPath();
    }, nr.prototype._enableRealtimeSort = function(Cn, Bn, In) {
      var Dn = this;
      if (Bn.count()) {
        var Ln = Cn.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(Bn, Cn, In), this._isFirstFrame = !1;
        else {
          var $n = function(Nn) {
            var Rn = Bn.getItemGraphicEl(Nn), Fn = Rn && Rn.shape;
            return Fn && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(Ln.isHorizontal() ? Fn.height : Fn.width) || 0;
          };
          this._onRendered = function() {
            Dn._updateSortWithinSameData(Bn, $n, Ln, In);
          }, In.getZr().on("rendered", this._onRendered);
        }
      }
    }, nr.prototype._dataSort = function(Cn, Bn, In) {
      var Dn = [];
      return Cn.each(Cn.mapDimension(Bn.dim), function(Ln, $n) {
        var Nn = In($n);
        Nn = Nn ?? NaN, Dn.push({
          dataIndex: $n,
          mappedValue: Nn,
          ordinalNumber: Ln
        });
      }), Dn.sort(function(Ln, $n) {
        return $n.mappedValue - Ln.mappedValue;
      }), {
        ordinalNumbers: map$1(Dn, function(Ln) {
          return Ln.ordinalNumber;
        })
      };
    }, nr.prototype._isOrderChangedWithinSameData = function(Cn, Bn, In) {
      for (var Dn = In.scale, Ln = Cn.mapDimension(In.dim), $n = Number.MAX_VALUE, Nn = 0, Rn = Dn.getOrdinalMeta().categories.length; Nn < Rn; ++Nn) {
        var Fn = Cn.rawIndexOf(Ln, Dn.getRawOrdinalNumber(Nn)), Pn = Fn < 0 ? Number.MIN_VALUE : Bn(Cn.indexOfRawIndex(Fn));
        if (Pn > $n)
          return !0;
        $n = Pn;
      }
      return !1;
    }, nr.prototype._isOrderDifferentInView = function(Cn, Bn) {
      for (var In = Bn.scale, Dn = In.getExtent(), Ln = Math.max(0, Dn[0]), $n = Math.min(Dn[1], In.getOrdinalMeta().categories.length - 1); Ln <= $n; ++Ln)
        if (Cn.ordinalNumbers[Ln] !== In.getRawOrdinalNumber(Ln))
          return !0;
    }, nr.prototype._updateSortWithinSameData = function(Cn, Bn, In, Dn) {
      if (this._isOrderChangedWithinSameData(Cn, Bn, In)) {
        var Ln = this._dataSort(Cn, In, Bn);
        this._isOrderDifferentInView(Ln, In) && (this._removeOnRenderedListener(Dn), Dn.dispatchAction({
          type: "changeAxisOrder",
          componentType: In.dim + "Axis",
          axisId: In.index,
          sortInfo: Ln
        }));
      }
    }, nr.prototype._dispatchInitSort = function(Cn, Bn, In) {
      var Dn = Bn.baseAxis, Ln = this._dataSort(Cn, Dn, function($n) {
        return Cn.get(Cn.mapDimension(Bn.otherAxis.dim), $n);
      });
      In.dispatchAction({
        type: "changeAxisOrder",
        componentType: Dn.dim + "Axis",
        isInitSort: !0,
        axisId: Dn.index,
        sortInfo: Ln
      });
    }, nr.prototype.remove = function(Cn, Bn) {
      this._clear(this._model), this._removeOnRenderedListener(Bn);
    }, nr.prototype.dispose = function(Cn, Bn) {
      this._removeOnRenderedListener(Bn);
    }, nr.prototype._removeOnRenderedListener = function(Cn) {
      this._onRendered && (Cn.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, nr.prototype._clear = function(Cn) {
      var Bn = this.group, In = this._data;
      Cn && Cn.isAnimationEnabled() && In && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], In.eachItemGraphicEl(function(Dn) {
        removeElementWithFadeOut(Dn, Cn, getECData(Dn).dataIndex);
      })) : Bn.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, nr.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, nr.type = "bar", nr;
  }(ChartView$1)
), clip = {
  cartesian2d: function(_n, nr) {
    var Cn = nr.width < 0 ? -1 : 1, Bn = nr.height < 0 ? -1 : 1;
    Cn < 0 && (nr.x += nr.width, nr.width = -nr.width), Bn < 0 && (nr.y += nr.height, nr.height = -nr.height);
    var In = _n.x + _n.width, Dn = _n.y + _n.height, Ln = mathMax$4(nr.x, _n.x), $n = mathMin$4(nr.x + nr.width, In), Nn = mathMax$4(nr.y, _n.y), Rn = mathMin$4(nr.y + nr.height, Dn), Fn = $n < Ln, Pn = Rn < Nn;
    return nr.x = Fn && Ln > In ? $n : Ln, nr.y = Pn && Nn > Dn ? Rn : Nn, nr.width = Fn ? 0 : $n - Ln, nr.height = Pn ? 0 : Rn - Nn, Cn < 0 && (nr.x += nr.width, nr.width = -nr.width), Bn < 0 && (nr.y += nr.height, nr.height = -nr.height), Fn || Pn;
  },
  polar: function(_n, nr) {
    var Cn = nr.r0 <= nr.r ? 1 : -1;
    if (Cn < 0) {
      var Bn = nr.r;
      nr.r = nr.r0, nr.r0 = Bn;
    }
    var In = mathMin$4(nr.r, _n.r), Dn = mathMax$4(nr.r0, _n.r0);
    nr.r = In, nr.r0 = Dn;
    var Ln = In - Dn < 0;
    if (Cn < 0) {
      var Bn = nr.r;
      nr.r = nr.r0, nr.r0 = Bn;
    }
    return Ln;
  }
}, elementCreator = {
  cartesian2d: function(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
    var Rn = new Rect$3({
      shape: extend({}, Bn),
      z2: 1
    });
    if (Rn.__dataIndex = Cn, Rn.name = "item", Dn) {
      var Fn = Rn.shape, Pn = In ? "height" : "width";
      Fn[Pn] = 0;
    }
    return Rn;
  },
  polar: function(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
    var Rn = !In && Nn ? Sausage : Sector$1, Fn = new Rn({
      shape: Bn,
      z2: 1
    });
    Fn.name = "item";
    var Pn = createPolarPositionMapping(In);
    if (Fn.calculateTextPosition = createSectorCalculateTextPosition(Pn, {
      isRoundCap: Rn === Sausage
    }), Dn) {
      var Un = Fn.shape, Hn = In ? "r" : "endAngle", zn = {};
      Un[Hn] = In ? Bn.r0 : Bn.startAngle, zn[Hn] = Bn[Hn], ($n ? updateProps$1 : initProps)(Fn, {
        shape: zn
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, Dn);
    }
    return Fn;
  }
};
function shouldRealtimeSort(_n, nr) {
  var Cn = _n.get("realtimeSort", !0), Bn = nr.getBaseAxis();
  if (process.env.NODE_ENV !== "production" && Cn && (Bn.type !== "category" && warn("`realtimeSort` will not work because this bar series is not based on a category axis."), nr.type !== "cartesian2d" && warn("`realtimeSort` will not work because this bar series is not on cartesian2d.")), Cn && Bn.type === "category" && nr.type === "cartesian2d")
    return {
      baseAxis: Bn,
      otherAxis: nr.getOtherAxis(Bn)
    };
}
function updateRealtimeAnimation(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  var Nn, Rn;
  Dn ? (Rn = {
    x: Bn.x,
    width: Bn.width
  }, Nn = {
    y: Bn.y,
    height: Bn.height
  }) : (Rn = {
    y: Bn.y,
    height: Bn.height
  }, Nn = {
    x: Bn.x,
    width: Bn.width
  }), $n || (Ln ? updateProps$1 : initProps)(Cn, {
    shape: Nn
  }, nr, In, null);
  var Fn = nr ? _n.baseAxis.model : null;
  (Ln ? updateProps$1 : initProps)(Cn, {
    shape: Rn
  }, Fn, In);
}
function checkPropertiesNotValid(_n, nr) {
  for (var Cn = 0; Cn < nr.length; Cn++)
    if (!isFinite(_n[nr[Cn]]))
      return !0;
  return !1;
}
var rectPropties = ["x", "y", "width", "height"], polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"], isValidLayout = {
  cartesian2d: function(_n) {
    return !checkPropertiesNotValid(_n, rectPropties);
  },
  polar: function(_n) {
    return !checkPropertiesNotValid(_n, polarPropties);
  }
}, getLayout = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(_n, nr, Cn) {
    var Bn = _n.getItemLayout(nr), In = Cn ? getLineWidth(Cn, Bn) : 0, Dn = Bn.width > 0 ? 1 : -1, Ln = Bn.height > 0 ? 1 : -1;
    return {
      x: Bn.x + Dn * In / 2,
      y: Bn.y + Ln * In / 2,
      width: Bn.width - Dn * In,
      height: Bn.height - Ln * In
    };
  },
  polar: function(_n, nr, Cn) {
    var Bn = _n.getItemLayout(nr);
    return {
      cx: Bn.cx,
      cy: Bn.cy,
      r0: Bn.r0,
      r: Bn.r,
      startAngle: Bn.startAngle,
      endAngle: Bn.endAngle,
      clockwise: Bn.clockwise
    };
  }
};
function isZeroOnPolar(_n) {
  return _n.startAngle != null && _n.endAngle != null && _n.startAngle === _n.endAngle;
}
function createPolarPositionMapping(_n) {
  return function(nr) {
    var Cn = nr ? "Arc" : "Angle";
    return function(Bn) {
      switch (Bn) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return Bn + Cn;
        default:
          return Bn;
      }
    };
  }(_n);
}
function updateStyle(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  var Nn = nr.getItemVisual(Cn, "style");
  if ($n) {
    if (!Dn.get("roundCap")) {
      var Fn = _n.shape, Pn = getSectorCornerRadius(Bn.getModel("itemStyle"), Fn, !0);
      extend(Fn, Pn), _n.setShape(Fn);
    }
  } else {
    var Rn = Bn.get(["itemStyle", "borderRadius"]) || 0;
    _n.setShape("r", Rn);
  }
  _n.useStyle(Nn);
  var Un = Bn.getShallow("cursor");
  Un && _n.attr("cursor", Un);
  var Hn = $n ? Ln ? In.r >= In.r0 ? "endArc" : "startArc" : In.endAngle >= In.startAngle ? "endAngle" : "startAngle" : Ln ? In.height >= 0 ? "bottom" : "top" : In.width >= 0 ? "right" : "left", zn = getLabelStatesModels(Bn);
  setLabelStyle(_n, zn, {
    labelFetcher: Dn,
    labelDataIndex: Cn,
    defaultText: getDefaultLabel(Dn.getData(), Cn),
    inheritColor: Nn.fill,
    defaultOpacity: Nn.opacity,
    defaultOutsidePosition: Hn
  });
  var Gn = _n.getTextContent();
  if ($n && Gn) {
    var Yn = Bn.get(["label", "position"]);
    _n.textConfig.inside = Yn === "middle" ? !0 : null, setSectorTextRotation(_n, Yn === "outside" ? Hn : Yn, createPolarPositionMapping(Ln), Bn.get(["label", "rotate"]));
  }
  setLabelValueAnimation(Gn, zn, Dn.getRawValue(Cn), function(Xn) {
    return getDefaultInterpolatedLabel(nr, Xn);
  });
  var Wn = Bn.getModel(["emphasis"]);
  toggleHoverEmphasis(_n, Wn.get("focus"), Wn.get("blurScope"), Wn.get("disabled")), setStatesStylesFromModel(_n, Bn), isZeroOnPolar(In) && (_n.style.fill = "none", _n.style.stroke = "none", each$f(_n.states, function(Xn) {
    Xn.style && (Xn.style.fill = Xn.style.stroke = "none");
  }));
}
function getLineWidth(_n, nr) {
  var Cn = _n.get(["itemStyle", "borderColor"]);
  if (!Cn || Cn === "none")
    return 0;
  var Bn = _n.get(["itemStyle", "borderWidth"]) || 0, In = isNaN(nr.width) ? Number.MAX_VALUE : Math.abs(nr.width), Dn = isNaN(nr.height) ? Number.MAX_VALUE : Math.abs(nr.height);
  return Math.min(Bn, In, Dn);
}
var LagePathShape = (
  /** @class */
  function() {
    function _n() {
    }
    return _n;
  }()
), LargePath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "largeBar", Bn;
    }
    return nr.prototype.getDefaultShape = function() {
      return new LagePathShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      for (var In = Bn.points, Dn = this.baseDimIdx, Ln = 1 - this.baseDimIdx, $n = [], Nn = [], Rn = this.barWidth, Fn = 0; Fn < In.length; Fn += 3)
        Nn[Dn] = Rn, Nn[Ln] = In[Fn + 2], $n[Dn] = In[Fn + Dn], $n[Ln] = In[Fn + Ln], Cn.rect($n[0], $n[1], Nn[0], Nn[1]);
    }, nr;
  }(Path$1)
);
function createLarge$1(_n, nr, Cn, Bn) {
  var In = _n.getData(), Dn = In.getLayout("valueAxisHorizontal") ? 1 : 0, Ln = In.getLayout("largeDataIndices"), $n = In.getLayout("size"), Nn = _n.getModel("backgroundStyle"), Rn = In.getLayout("largeBackgroundPoints");
  if (Rn) {
    var Fn = new LargePath({
      shape: {
        points: Rn
      },
      incremental: !!Bn,
      silent: !0,
      z2: 0
    });
    Fn.baseDimIdx = Dn, Fn.largeDataIndices = Ln, Fn.barWidth = $n, Fn.useStyle(Nn.getItemStyle()), nr.add(Fn), Cn && Cn.push(Fn);
  }
  var Pn = new LargePath({
    shape: {
      points: In.getLayout("largePoints")
    },
    incremental: !!Bn,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  Pn.baseDimIdx = Dn, Pn.largeDataIndices = Ln, Pn.barWidth = $n, nr.add(Pn), Pn.useStyle(In.getVisual("style")), Pn.style.stroke = null, getECData(Pn).seriesIndex = _n.seriesIndex, _n.get("silent") || (Pn.on("mousedown", largePathUpdateDataIndex), Pn.on("mousemove", largePathUpdateDataIndex)), Cn && Cn.push(Pn);
}
var largePathUpdateDataIndex = throttle(function(_n) {
  var nr = this, Cn = largePathFindDataIndex(nr, _n.offsetX, _n.offsetY);
  getECData(nr).dataIndex = Cn >= 0 ? Cn : null;
}, 30, !1);
function largePathFindDataIndex(_n, nr, Cn) {
  for (var Bn = _n.baseDimIdx, In = 1 - Bn, Dn = _n.shape.points, Ln = _n.largeDataIndices, $n = [], Nn = [], Rn = _n.barWidth, Fn = 0, Pn = Dn.length / 3; Fn < Pn; Fn++) {
    var Un = Fn * 3;
    if (Nn[Bn] = Rn, Nn[In] = Dn[Un + 2], $n[Bn] = Dn[Un + Bn], $n[In] = Dn[Un + In], Nn[In] < 0 && ($n[In] += Nn[In], Nn[In] = -Nn[In]), nr >= $n[0] && nr <= $n[0] + Nn[0] && Cn >= $n[1] && Cn <= $n[1] + Nn[1])
      return Ln[Fn];
  }
  return -1;
}
function createBackgroundShape(_n, nr, Cn) {
  if (isCoordinateSystemType(Cn, "cartesian2d")) {
    var Bn = nr, In = Cn.getArea();
    return {
      x: _n ? Bn.x : In.x,
      y: _n ? In.y : Bn.y,
      width: _n ? Bn.width : In.width,
      height: _n ? In.height : Bn.height
    };
  } else {
    var In = Cn.getArea(), Dn = nr;
    return {
      cx: In.cx,
      cy: In.cy,
      r0: _n ? In.r0 : Dn.r0,
      r: _n ? In.r : Dn.r,
      startAngle: _n ? Dn.startAngle : 0,
      endAngle: _n ? Dn.endAngle : Math.PI * 2
    };
  }
}
function createBackgroundEl(_n, nr, Cn) {
  var Bn = _n.type === "polar" ? Sector$1 : Rect$3;
  return new Bn({
    shape: createBackgroundShape(nr, Cn, _n),
    silent: !0,
    z2: 0
  });
}
const BarView$1 = BarView;
function install$P(_n) {
  _n.registerChartView(BarView$1), _n.registerSeriesModel(BarSeries), _n.registerLayout(_n.PRIORITY.VISUAL.LAYOUT, curry$1(layout$3, "bar")), _n.registerLayout(_n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar")), _n.registerProcessor(_n.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar")), _n.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(nr, Cn) {
    var Bn = nr.componentType || "series";
    Cn.eachComponent({
      mainType: Bn,
      query: nr
    }, function(In) {
      nr.sortInfo && In.axis.setCategorySortInfo(nr.sortInfo);
    });
  });
}
var PI2 = Math.PI * 2, RADIAN$2 = Math.PI / 180;
function getViewRect$5(_n, nr) {
  return getLayoutRect$1(_n.getBoxLayoutParams(), {
    width: nr.getWidth(),
    height: nr.getHeight()
  });
}
function getBasicPieLayout(_n, nr) {
  var Cn = getViewRect$5(_n, nr), Bn = _n.get("center"), In = _n.get("radius");
  isArray$4(In) || (In = [0, In]);
  var Dn = parsePercent(Cn.width, nr.getWidth()), Ln = parsePercent(Cn.height, nr.getHeight()), $n = Math.min(Dn, Ln), Nn = parsePercent(In[0], $n / 2), Rn = parsePercent(In[1], $n / 2), Fn, Pn, Un = _n.coordinateSystem;
  if (Un) {
    var Hn = Un.dataToPoint(Bn);
    Fn = Hn[0] || 0, Pn = Hn[1] || 0;
  } else
    isArray$4(Bn) || (Bn = [Bn, Bn]), Fn = parsePercent(Bn[0], Dn) + Cn.x, Pn = parsePercent(Bn[1], Ln) + Cn.y;
  return {
    cx: Fn,
    cy: Pn,
    r0: Nn,
    r: Rn
  };
}
function pieLayout(_n, nr, Cn) {
  nr.eachSeriesByType(_n, function(Bn) {
    var In = Bn.getData(), Dn = In.mapDimension("value"), Ln = getViewRect$5(Bn, Cn), $n = getBasicPieLayout(Bn, Cn), Nn = $n.cx, Rn = $n.cy, Fn = $n.r, Pn = $n.r0, Un = -Bn.get("startAngle") * RADIAN$2, Hn = Bn.get("endAngle"), zn = Bn.get("padAngle") * RADIAN$2;
    Hn = Hn === "auto" ? Un - PI2 : -Hn * RADIAN$2;
    var Gn = Bn.get("minAngle") * RADIAN$2, Yn = Gn + zn, Wn = 0;
    In.each(Dn, function(pa) {
      !isNaN(pa) && Wn++;
    });
    var Xn = In.getSum(Dn), ea = Math.PI / (Xn || Wn) * 2, ta = Bn.get("clockwise"), na = Bn.get("roseType"), ra = Bn.get("stillShowZeroSum"), aa = In.getDataExtent(Dn);
    aa[0] = 0;
    var ia = ta ? 1 : -1, Aa = [Un, Hn], sa = ia * zn / 2;
    normalizeArcAngles(Aa, !ta), Un = Aa[0], Hn = Aa[1];
    var oa = getSeriesLayoutData(Bn);
    oa.startAngle = Un, oa.endAngle = Hn, oa.clockwise = ta;
    var la = Math.abs(Hn - Un), ua = la, ca = 0, fa = Un;
    if (In.setLayout({
      viewRect: Ln,
      r: Fn
    }), In.each(Dn, function(pa, ya) {
      var da;
      if (isNaN(pa)) {
        In.setItemLayout(ya, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: ta,
          cx: Nn,
          cy: Rn,
          r0: Pn,
          r: na ? NaN : Fn
        });
        return;
      }
      na !== "area" ? da = Xn === 0 && ra ? ea : pa * ea : da = la / Wn, da < Yn ? (da = Yn, ua -= Yn) : ca += pa;
      var Ca = fa + ia * da, ma = 0, va = 0;
      zn > da ? (ma = fa + ia * da / 2, va = ma) : (ma = fa + sa, va = Ca - sa), In.setItemLayout(ya, {
        angle: da,
        startAngle: ma,
        endAngle: va,
        clockwise: ta,
        cx: Nn,
        cy: Rn,
        r0: Pn,
        r: na ? linearMap$2(pa, aa, [Pn, Fn]) : Fn
      }), fa = Ca;
    }), ua < PI2 && Wn)
      if (ua <= 1e-3) {
        var ha = la / Wn;
        In.each(Dn, function(pa, ya) {
          if (!isNaN(pa)) {
            var da = In.getItemLayout(ya);
            da.angle = ha;
            var Ca = 0, ma = 0;
            ha < zn ? (Ca = Un + ia * (ya + 1 / 2) * ha, ma = Ca) : (Ca = Un + ia * ya * ha + sa, ma = Un + ia * (ya + 1) * ha - sa), da.startAngle = Ca, da.endAngle = ma;
          }
        });
      } else
        ea = ua / ca, fa = Un, In.each(Dn, function(pa, ya) {
          if (!isNaN(pa)) {
            var da = In.getItemLayout(ya), Ca = da.angle === Yn ? Yn : pa * ea, ma = 0, va = 0;
            Ca < zn ? (ma = fa + ia * Ca / 2, va = ma) : (ma = fa + sa, va = fa + ia * Ca - sa), da.startAngle = ma, da.endAngle = va, fa += ia * Ca;
          }
        });
  });
}
var getSeriesLayoutData = makeInner();
function dataFilter$1(_n) {
  return {
    seriesType: _n,
    reset: function(nr, Cn) {
      var Bn = Cn.findComponents({
        mainType: "legend"
      });
      if (!(!Bn || !Bn.length)) {
        var In = nr.getData();
        In.filterSelf(function(Dn) {
          for (var Ln = In.getName(Dn), $n = 0; $n < Bn.length; $n++)
            if (!Bn[$n].isSelected(Ln))
              return !1;
          return !0;
        });
      }
    }
  };
}
var RADIAN$1 = Math.PI / 180;
function adjustSingleSide(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn) {
  if (_n.length < 2)
    return;
  function Fn(Gn) {
    for (var Yn = Gn.rB, Wn = Yn * Yn, Xn = 0; Xn < Gn.list.length; Xn++) {
      var ea = Gn.list[Xn], ta = Math.abs(ea.label.y - Cn), na = Bn + ea.len, ra = na * na, aa = Math.sqrt(Math.abs((1 - ta * ta / Wn) * ra)), ia = nr + (aa + ea.len2) * In, Aa = ia - ea.label.x, sa = ea.targetTextWidth - Aa * In;
      constrainTextWidth(ea, sa, !0), ea.label.x = ia;
    }
  }
  function Pn(Gn) {
    for (var Yn = {
      list: [],
      maxY: 0
    }, Wn = {
      list: [],
      maxY: 0
    }, Xn = 0; Xn < Gn.length; Xn++)
      if (Gn[Xn].labelAlignTo === "none") {
        var ea = Gn[Xn], ta = ea.label.y > Cn ? Wn : Yn, na = Math.abs(ea.label.y - Cn);
        if (na >= ta.maxY) {
          var ra = ea.label.x - nr - ea.len2 * In, aa = Bn + ea.len, ia = Math.abs(ra) < aa ? Math.sqrt(na * na / (1 - ra * ra / aa / aa)) : aa;
          ta.rB = ia, ta.maxY = na;
        }
        ta.list.push(ea);
      }
    Fn(Yn), Fn(Wn);
  }
  for (var Un = _n.length, Hn = 0; Hn < Un; Hn++)
    if (_n[Hn].position === "outer" && _n[Hn].labelAlignTo === "labelLine") {
      var zn = _n[Hn].label.x - Rn;
      _n[Hn].linePoints[1][0] += zn, _n[Hn].label.x = Rn;
    }
  shiftLayoutOnY(_n, Nn, Nn + Ln) && Pn(_n);
}
function avoidOverlap(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  for (var Nn = [], Rn = [], Fn = Number.MAX_VALUE, Pn = -Number.MAX_VALUE, Un = 0; Un < _n.length; Un++) {
    var Hn = _n[Un].label;
    isPositionCenter(_n[Un]) || (Hn.x < nr ? (Fn = Math.min(Fn, Hn.x), Nn.push(_n[Un])) : (Pn = Math.max(Pn, Hn.x), Rn.push(_n[Un])));
  }
  for (var Un = 0; Un < _n.length; Un++) {
    var zn = _n[Un];
    if (!isPositionCenter(zn) && zn.linePoints) {
      if (zn.labelStyleWidth != null)
        continue;
      var Hn = zn.label, Gn = zn.linePoints, Yn = void 0;
      zn.labelAlignTo === "edge" ? Hn.x < nr ? Yn = Gn[2][0] - zn.labelDistance - Ln - zn.edgeDistance : Yn = Ln + In - zn.edgeDistance - Gn[2][0] - zn.labelDistance : zn.labelAlignTo === "labelLine" ? Hn.x < nr ? Yn = Fn - Ln - zn.bleedMargin : Yn = Ln + In - Pn - zn.bleedMargin : Hn.x < nr ? Yn = Hn.x - Ln - zn.bleedMargin : Yn = Ln + In - Hn.x - zn.bleedMargin, zn.targetTextWidth = Yn, constrainTextWidth(zn, Yn);
    }
  }
  adjustSingleSide(Rn, nr, Cn, Bn, 1, In, Dn, Ln, $n, Pn), adjustSingleSide(Nn, nr, Cn, Bn, -1, In, Dn, Ln, $n, Fn);
  for (var Un = 0; Un < _n.length; Un++) {
    var zn = _n[Un];
    if (!isPositionCenter(zn) && zn.linePoints) {
      var Hn = zn.label, Gn = zn.linePoints, Wn = zn.labelAlignTo === "edge", Xn = Hn.style.padding, ea = Xn ? Xn[1] + Xn[3] : 0, ta = Hn.style.backgroundColor ? 0 : ea, na = zn.rect.width + ta, ra = Gn[1][0] - Gn[2][0];
      Wn ? Hn.x < nr ? Gn[2][0] = Ln + zn.edgeDistance + na + zn.labelDistance : Gn[2][0] = Ln + In - zn.edgeDistance - na - zn.labelDistance : (Hn.x < nr ? Gn[2][0] = Hn.x + zn.labelDistance : Gn[2][0] = Hn.x - zn.labelDistance, Gn[1][0] = Gn[2][0] + ra), Gn[1][1] = Gn[2][1] = Hn.y;
    }
  }
}
function constrainTextWidth(_n, nr, Cn) {
  if (Cn === void 0 && (Cn = !1), _n.labelStyleWidth == null) {
    var Bn = _n.label, In = Bn.style, Dn = _n.rect, Ln = In.backgroundColor, $n = In.padding, Nn = $n ? $n[1] + $n[3] : 0, Rn = In.overflow, Fn = Dn.width + (Ln ? 0 : Nn);
    if (nr < Fn || Cn) {
      var Pn = Dn.height;
      if (Rn && Rn.match("break")) {
        Bn.setStyle("backgroundColor", null), Bn.setStyle("width", nr - Nn);
        var Un = Bn.getBoundingRect();
        Bn.setStyle("width", Math.ceil(Un.width)), Bn.setStyle("backgroundColor", Ln);
      } else {
        var Hn = nr - Nn, zn = nr < Fn ? Hn : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          Cn ? Hn > _n.unconstrainedWidth ? null : Hn : null
        );
        Bn.setStyle("width", zn);
      }
      var Gn = Bn.getBoundingRect();
      Dn.width = Gn.width;
      var Yn = (Bn.style.margin || 0) + 2.1;
      Dn.height = Gn.height + Yn, Dn.y -= (Dn.height - Pn) / 2;
    }
  }
}
function isPositionCenter(_n) {
  return _n.position === "center";
}
function pieLabelLayout(_n) {
  var nr = _n.getData(), Cn = [], Bn, In, Dn = !1, Ln = (_n.get("minShowLabelAngle") || 0) * RADIAN$1, $n = nr.getLayout("viewRect"), Nn = nr.getLayout("r"), Rn = $n.width, Fn = $n.x, Pn = $n.y, Un = $n.height;
  function Hn(ra) {
    ra.ignore = !0;
  }
  function zn(ra) {
    if (!ra.ignore)
      return !0;
    for (var aa in ra.states)
      if (ra.states[aa].ignore === !1)
        return !0;
    return !1;
  }
  nr.each(function(ra) {
    var aa = nr.getItemGraphicEl(ra), ia = aa.shape, Aa = aa.getTextContent(), sa = aa.getTextGuideLine(), oa = nr.getItemModel(ra), la = oa.getModel("label"), ua = la.get("position") || oa.get(["emphasis", "label", "position"]), ca = la.get("distanceToLabelLine"), fa = la.get("alignTo"), ha = parsePercent(la.get("edgeDistance"), Rn), pa = la.get("bleedMargin"), ya = oa.getModel("labelLine"), da = ya.get("length");
    da = parsePercent(da, Rn);
    var Ca = ya.get("length2");
    if (Ca = parsePercent(Ca, Rn), Math.abs(ia.endAngle - ia.startAngle) < Ln) {
      each$f(Aa.states, Hn), Aa.ignore = !0, sa && (each$f(sa.states, Hn), sa.ignore = !0);
      return;
    }
    if (zn(Aa)) {
      var ma = (ia.startAngle + ia.endAngle) / 2, va = Math.cos(ma), ga = Math.sin(ma), xa, wa, ba, Ta;
      Bn = ia.cx, In = ia.cy;
      var Sa = ua === "inside" || ua === "inner";
      if (ua === "center")
        xa = ia.cx, wa = ia.cy, Ta = "center";
      else {
        var Ea = (Sa ? (ia.r + ia.r0) / 2 * va : ia.r * va) + Bn, Ia = (Sa ? (ia.r + ia.r0) / 2 * ga : ia.r * ga) + In;
        if (xa = Ea + va * 3, wa = Ia + ga * 3, !Sa) {
          var Ba = Ea + va * (da + Nn - ia.r), Ma = Ia + ga * (da + Nn - ia.r), La = Ba + (va < 0 ? -1 : 1) * Ca, Da = Ma;
          fa === "edge" ? xa = va < 0 ? Fn + ha : Fn + Rn - ha : xa = La + (va < 0 ? -ca : ca), wa = Da, ba = [[Ea, Ia], [Ba, Ma], [La, Da]];
        }
        Ta = Sa ? "center" : fa === "edge" ? va > 0 ? "right" : "left" : va > 0 ? "left" : "right";
      }
      var Na = Math.PI, $a = 0, Oa = la.get("rotate");
      if (isNumber(Oa))
        $a = Oa * (Na / 180);
      else if (ua === "center")
        $a = 0;
      else if (Oa === "radial" || Oa === !0) {
        var Pa = va < 0 ? -ma + Na : -ma;
        $a = Pa;
      } else if (Oa === "tangential" && ua !== "outside" && ua !== "outer") {
        var ka = Math.atan2(va, ga);
        ka < 0 && (ka = Na * 2 + ka);
        var Ua = ga > 0;
        Ua && (ka = Na + ka), $a = ka - Na;
      }
      if (Dn = !!$a, Aa.x = xa, Aa.y = wa, Aa.rotation = $a, Aa.setStyle({
        verticalAlign: "middle"
      }), Sa) {
        Aa.setStyle({
          align: Ta
        });
        var Qa = Aa.states.select;
        Qa && (Qa.x += Aa.x, Qa.y += Aa.y);
      } else {
        var Fa = Aa.getBoundingRect().clone();
        Fa.applyTransform(Aa.getComputedTransform());
        var Ha = (Aa.style.margin || 0) + 2.1;
        Fa.y -= Ha / 2, Fa.height += Ha, Cn.push({
          label: Aa,
          labelLine: sa,
          position: ua,
          len: da,
          len2: Ca,
          minTurnAngle: ya.get("minTurnAngle"),
          maxSurfaceAngle: ya.get("maxSurfaceAngle"),
          surfaceNormal: new Point$1(va, ga),
          linePoints: ba,
          textAlign: Ta,
          labelDistance: ca,
          labelAlignTo: fa,
          edgeDistance: ha,
          bleedMargin: pa,
          rect: Fa,
          unconstrainedWidth: Fa.width,
          labelStyleWidth: Aa.style.width
        });
      }
      aa.setTextConfig({
        inside: Sa
      });
    }
  }), !Dn && _n.get("avoidLabelOverlap") && avoidOverlap(Cn, Bn, In, Nn, Rn, Un, Fn, Pn);
  for (var Gn = 0; Gn < Cn.length; Gn++) {
    var Yn = Cn[Gn], Wn = Yn.label, Xn = Yn.labelLine, ea = isNaN(Wn.x) || isNaN(Wn.y);
    if (Wn) {
      Wn.setStyle({
        align: Yn.textAlign
      }), ea && (each$f(Wn.states, Hn), Wn.ignore = !0);
      var ta = Wn.states.select;
      ta && (ta.x += Wn.x, ta.y += Wn.y);
    }
    if (Xn) {
      var na = Yn.linePoints;
      ea || !na ? (each$f(Xn.states, Hn), Xn.ignore = !0) : (limitTurnAngle(na, Yn.minTurnAngle), limitSurfaceAngle(na, Yn.surfaceNormal, Yn.maxSurfaceAngle), Xn.setShape({
        points: na
      }), Wn.__hostTarget.textGuideLineConfig = {
        anchor: new Point$1(na[0][0], na[0][1])
      });
    }
  }
}
var PiePiece = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In) {
      var Dn = _n.call(this) || this;
      Dn.z2 = 2;
      var Ln = new ZRText$1();
      return Dn.setTextContent(Ln), Dn.updateData(Cn, Bn, In, !0), Dn;
    }
    return nr.prototype.updateData = function(Cn, Bn, In, Dn) {
      var Ln = this, $n = Cn.hostModel, Nn = Cn.getItemModel(Bn), Rn = Nn.getModel("emphasis"), Fn = Cn.getItemLayout(Bn), Pn = extend(getSectorCornerRadius(Nn.getModel("itemStyle"), Fn, !0), Fn);
      if (isNaN(Pn.startAngle)) {
        Ln.setShape(Pn);
        return;
      }
      if (Dn) {
        Ln.setShape(Pn);
        var Un = $n.getShallow("animationType");
        $n.ecModel.ssr ? (initProps(Ln, {
          scaleX: 0,
          scaleY: 0
        }, $n, {
          dataIndex: Bn,
          isFrom: !0
        }), Ln.originX = Pn.cx, Ln.originY = Pn.cy) : Un === "scale" ? (Ln.shape.r = Fn.r0, initProps(Ln, {
          shape: {
            r: Fn.r
          }
        }, $n, Bn)) : In != null ? (Ln.setShape({
          startAngle: In,
          endAngle: In
        }), initProps(Ln, {
          shape: {
            startAngle: Fn.startAngle,
            endAngle: Fn.endAngle
          }
        }, $n, Bn)) : (Ln.shape.endAngle = Fn.startAngle, updateProps$1(Ln, {
          shape: {
            endAngle: Fn.endAngle
          }
        }, $n, Bn));
      } else
        saveOldStyle(Ln), updateProps$1(Ln, {
          shape: Pn
        }, $n, Bn);
      Ln.useStyle(Cn.getItemVisual(Bn, "style")), setStatesStylesFromModel(Ln, Nn);
      var Hn = (Fn.startAngle + Fn.endAngle) / 2, zn = $n.get("selectedOffset"), Gn = Math.cos(Hn) * zn, Yn = Math.sin(Hn) * zn, Wn = Nn.getShallow("cursor");
      Wn && Ln.attr("cursor", Wn), this._updateLabel($n, Cn, Bn), Ln.ensureState("emphasis").shape = extend({
        r: Fn.r + (Rn.get("scale") && Rn.get("scaleSize") || 0)
      }, getSectorCornerRadius(Rn.getModel("itemStyle"), Fn)), extend(Ln.ensureState("select"), {
        x: Gn,
        y: Yn,
        shape: getSectorCornerRadius(Nn.getModel(["select", "itemStyle"]), Fn)
      }), extend(Ln.ensureState("blur"), {
        shape: getSectorCornerRadius(Nn.getModel(["blur", "itemStyle"]), Fn)
      });
      var Xn = Ln.getTextGuideLine(), ea = Ln.getTextContent();
      Xn && extend(Xn.ensureState("select"), {
        x: Gn,
        y: Yn
      }), extend(ea.ensureState("select"), {
        x: Gn,
        y: Yn
      }), toggleHoverEmphasis(this, Rn.get("focus"), Rn.get("blurScope"), Rn.get("disabled"));
    }, nr.prototype._updateLabel = function(Cn, Bn, In) {
      var Dn = this, Ln = Bn.getItemModel(In), $n = Ln.getModel("labelLine"), Nn = Bn.getItemVisual(In, "style"), Rn = Nn && Nn.fill, Fn = Nn && Nn.opacity;
      setLabelStyle(Dn, getLabelStatesModels(Ln), {
        labelFetcher: Bn.hostModel,
        labelDataIndex: In,
        inheritColor: Rn,
        defaultOpacity: Fn,
        defaultText: Cn.getFormattedLabel(In, "normal") || Bn.getName(In)
      });
      var Pn = Dn.getTextContent();
      Dn.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), Pn.attr({
        z2: 10
      });
      var Un = Cn.get(["label", "position"]);
      if (Un !== "outside" && Un !== "outer")
        Dn.removeTextGuideLine();
      else {
        var Hn = this.getTextGuideLine();
        Hn || (Hn = new Polyline$3(), this.setTextGuideLine(Hn)), setLabelLineStyle(this, getLabelLineStatesModels(Ln), {
          stroke: Rn,
          opacity: retrieve3($n.get(["lineStyle", "opacity"]), Fn, 1)
        });
      }
    }, nr;
  }(Sector$1)
), PieView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.ignoreLabelLineUpdate = !0, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      var Ln = Cn.getData(), $n = this._data, Nn = this.group, Rn;
      if (!$n && Ln.count() > 0) {
        for (var Fn = Ln.getItemLayout(0), Pn = 1; isNaN(Fn && Fn.startAngle) && Pn < Ln.count(); ++Pn)
          Fn = Ln.getItemLayout(Pn);
        Fn && (Rn = Fn.startAngle);
      }
      if (this._emptyCircleSector && Nn.remove(this._emptyCircleSector), Ln.count() === 0 && Cn.get("showEmptyCircle")) {
        var Un = getSeriesLayoutData(Cn), Hn = new Sector$1({
          shape: extend(getBasicPieLayout(Cn, In), Un)
        });
        Hn.useStyle(Cn.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = Hn, Nn.add(Hn);
      }
      Ln.diff($n).add(function(zn) {
        var Gn = new PiePiece(Ln, zn, Rn);
        Ln.setItemGraphicEl(zn, Gn), Nn.add(Gn);
      }).update(function(zn, Gn) {
        var Yn = $n.getItemGraphicEl(Gn);
        Yn.updateData(Ln, zn, Rn), Yn.off("click"), Nn.add(Yn), Ln.setItemGraphicEl(zn, Yn);
      }).remove(function(zn) {
        var Gn = $n.getItemGraphicEl(zn);
        removeElementWithFadeOut(Gn, Cn, zn);
      }).execute(), pieLabelLayout(Cn), Cn.get("animationTypeUpdate") !== "expansion" && (this._data = Ln);
    }, nr.prototype.dispose = function() {
    }, nr.prototype.containPoint = function(Cn, Bn) {
      var In = Bn.getData(), Dn = In.getItemLayout(0);
      if (Dn) {
        var Ln = Cn[0] - Dn.cx, $n = Cn[1] - Dn.cy, Nn = Math.sqrt(Ln * Ln + $n * $n);
        return Nn <= Dn.r && Nn >= Dn.r0;
      }
    }, nr.type = "pie", nr;
  }(ChartView$1)
);
const PieView$1 = PieView;
function createSeriesDataSimply(_n, nr, Cn) {
  nr = isArray$4(nr) && {
    coordDimensions: nr
  } || extend({
    encodeDefine: _n.getEncode()
  }, nr);
  var Bn = _n.getSource(), In = prepareSeriesDataSchema(Bn, nr).dimensions, Dn = new SeriesData$1(In, _n);
  return Dn.initData(Bn, Cn), Dn;
}
var LegendVisualProvider = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this._getDataWithEncodedVisual = nr, this._getRawData = Cn;
    }
    return _n.prototype.getAllNames = function() {
      var nr = this._getRawData();
      return nr.mapArray(nr.getName);
    }, _n.prototype.containName = function(nr) {
      var Cn = this._getRawData();
      return Cn.indexOfName(nr) >= 0;
    }, _n.prototype.indexOfName = function(nr) {
      var Cn = this._getDataWithEncodedVisual();
      return Cn.indexOfName(nr);
    }, _n.prototype.getItemVisual = function(nr, Cn) {
      var Bn = this._getDataWithEncodedVisual();
      return Bn.getItemVisual(nr, Cn);
    }, _n;
  }()
);
const LegendVisualProvider$1 = LegendVisualProvider;
var innerData = makeInner(), PieSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.init = function(Cn) {
      _n.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this)), this._defaultLabelLine(Cn);
    }, nr.prototype.mergeOption = function() {
      _n.prototype.mergeOption.apply(this, arguments);
    }, nr.prototype.getInitialData = function() {
      return createSeriesDataSimply(this, {
        coordDimensions: ["value"],
        encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
      });
    }, nr.prototype.getDataParams = function(Cn) {
      var Bn = this.getData(), In = innerData(Bn), Dn = In.seats;
      if (!Dn) {
        var Ln = [];
        Bn.each(Bn.mapDimension("value"), function(Nn) {
          Ln.push(Nn);
        }), Dn = In.seats = getPercentSeats(Ln, Bn.hostModel.get("percentPrecision"));
      }
      var $n = _n.prototype.getDataParams.call(this, Cn);
      return $n.percent = Dn[Cn] || 0, $n.$vars.push("percent"), $n;
    }, nr.prototype._defaultLabelLine = function(Cn) {
      defaultEmphasis(Cn, "labelLine", ["show"]);
      var Bn = Cn.labelLine, In = Cn.emphasis.labelLine;
      Bn.show = Bn.show && Cn.label.show, In.show = In.show && Cn.emphasis.label.show;
    }, nr.type = "series.pie", nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      // 最小角度改为0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 选中时扇区偏移量
      selectedOffset: 10,
      // 选择模式，默认关闭，可选single，multiple
      // selectedMode: false,
      // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter: 标签文本格式器，同 tooltip.formatter，不支持异步回调
        // 默认使用全局文本样式，详见 textStyle
        // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 引导线两段中的第一段长度
        length: 15,
        // 引导线两段中的第二段长度
        length2: 15,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: 各异,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, nr;
  }(SeriesModel$1)
);
const PieSeriesModel$1 = PieSeriesModel;
function negativeDataFilter(_n) {
  return {
    seriesType: _n,
    reset: function(nr, Cn) {
      var Bn = nr.getData();
      Bn.filterSelf(function(In) {
        var Dn = Bn.mapDimension("value"), Ln = Bn.get(Dn, In);
        return !(isNumber(Ln) && !isNaN(Ln) && Ln < 0);
      });
    }
  };
}
function install$O(_n) {
  _n.registerChartView(PieView$1), _n.registerSeriesModel(PieSeriesModel$1), createLegacyDataSelectAction("pie", _n.registerAction), _n.registerLayout(curry$1(pieLayout, "pie")), _n.registerProcessor(dataFilter$1("pie")), _n.registerProcessor(negativeDataFilter("pie"));
}
var ScatterSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.hasSymbolVisual = !0, Cn;
    }
    return nr.prototype.getInitialData = function(Cn, Bn) {
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0
      });
    }, nr.prototype.getProgressive = function() {
      var Cn = this.option.progressive;
      return Cn ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, nr.prototype.getProgressiveThreshold = function() {
      var Cn = this.option.progressiveThreshold;
      return Cn ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, nr.prototype.brushSelector = function(Cn, Bn, In) {
      return In.point(Bn.getItemLayout(Cn));
    }, nr.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, nr.type = "series.scatter", nr.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], nr.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 图形旋转控制
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 各异
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, nr;
  }(SeriesModel$1)
);
const ScatterSeriesModel$1 = ScatterSeriesModel;
var BOOST_SIZE_THRESHOLD = 4, LargeSymbolPathShape = (
  /** @class */
  function() {
    function _n() {
    }
    return _n;
  }()
), LargeSymbolPath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn._off = 0, Bn.hoverDataIdx = -1, Bn;
    }
    return nr.prototype.getDefaultShape = function() {
      return new LargeSymbolPathShape();
    }, nr.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Bn.points, Dn = Bn.size, Ln = this.symbolProxy, $n = Ln.shape, Nn = Cn.getContext ? Cn.getContext() : Cn, Rn = Nn && Dn[0] < BOOST_SIZE_THRESHOLD, Fn = this.softClipShape, Pn;
      if (Rn) {
        this._ctx = Nn;
        return;
      }
      for (this._ctx = null, Pn = this._off; Pn < In.length; ) {
        var Un = In[Pn++], Hn = In[Pn++];
        isNaN(Un) || isNaN(Hn) || Fn && !Fn.contain(Un, Hn) || ($n.x = Un - Dn[0] / 2, $n.y = Hn - Dn[1] / 2, $n.width = Dn[0], $n.height = Dn[1], Ln.buildPath(Cn, $n, !0));
      }
      this.incremental && (this._off = Pn, this.notClear = !0);
    }, nr.prototype.afterBrush = function() {
      var Cn = this.shape, Bn = Cn.points, In = Cn.size, Dn = this._ctx, Ln = this.softClipShape, $n;
      if (Dn) {
        for ($n = this._off; $n < Bn.length; ) {
          var Nn = Bn[$n++], Rn = Bn[$n++];
          isNaN(Nn) || isNaN(Rn) || Ln && !Ln.contain(Nn, Rn) || Dn.fillRect(Nn - In[0] / 2, Rn - In[1] / 2, In[0], In[1]);
        }
        this.incremental && (this._off = $n, this.notClear = !0);
      }
    }, nr.prototype.findDataIndex = function(Cn, Bn) {
      for (var In = this.shape, Dn = In.points, Ln = In.size, $n = Math.max(Ln[0], 4), Nn = Math.max(Ln[1], 4), Rn = Dn.length / 2 - 1; Rn >= 0; Rn--) {
        var Fn = Rn * 2, Pn = Dn[Fn] - $n / 2, Un = Dn[Fn + 1] - Nn / 2;
        if (Cn >= Pn && Bn >= Un && Cn <= Pn + $n && Bn <= Un + Nn)
          return Rn;
      }
      return -1;
    }, nr.prototype.contain = function(Cn, Bn) {
      var In = this.transformCoordToLocal(Cn, Bn), Dn = this.getBoundingRect();
      if (Cn = In[0], Bn = In[1], Dn.contain(Cn, Bn)) {
        var Ln = this.hoverDataIdx = this.findDataIndex(Cn, Bn);
        return Ln >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, nr.prototype.getBoundingRect = function() {
      var Cn = this._rect;
      if (!Cn) {
        for (var Bn = this.shape, In = Bn.points, Dn = Bn.size, Ln = Dn[0], $n = Dn[1], Nn = 1 / 0, Rn = 1 / 0, Fn = -1 / 0, Pn = -1 / 0, Un = 0; Un < In.length; ) {
          var Hn = In[Un++], zn = In[Un++];
          Nn = Math.min(Hn, Nn), Fn = Math.max(Hn, Fn), Rn = Math.min(zn, Rn), Pn = Math.max(zn, Pn);
        }
        Cn = this._rect = new BoundingRect$1(Nn - Ln / 2, Rn - $n / 2, Fn - Nn + Ln, Pn - Rn + $n);
      }
      return Cn;
    }, nr;
  }(Path$1)
), LargeSymbolDraw = (
  /** @class */
  function() {
    function _n() {
      this.group = new Group$4();
    }
    return _n.prototype.updateData = function(nr, Cn) {
      this._clear();
      var Bn = this._create();
      Bn.setShape({
        points: nr.getLayout("points")
      }), this._setCommon(Bn, nr, Cn);
    }, _n.prototype.updateLayout = function(nr) {
      var Cn = nr.getLayout("points");
      this.group.eachChild(function(Bn) {
        if (Bn.startIndex != null) {
          var In = (Bn.endIndex - Bn.startIndex) * 2, Dn = Bn.startIndex * 4 * 2;
          Cn = new Float32Array(Cn.buffer, Dn, In);
        }
        Bn.setShape("points", Cn), Bn.reset();
      });
    }, _n.prototype.incrementalPrepareUpdate = function(nr) {
      this._clear();
    }, _n.prototype.incrementalUpdate = function(nr, Cn, Bn) {
      var In = this._newAdded[0], Dn = Cn.getLayout("points"), Ln = In && In.shape.points;
      if (Ln && Ln.length < 2e4) {
        var $n = Ln.length, Nn = new Float32Array($n + Dn.length);
        Nn.set(Ln), Nn.set(Dn, $n), In.endIndex = nr.end, In.setShape({
          points: Nn
        });
      } else {
        this._newAdded = [];
        var Rn = this._create();
        Rn.startIndex = nr.start, Rn.endIndex = nr.end, Rn.incremental = !0, Rn.setShape({
          points: Dn
        }), this._setCommon(Rn, Cn, Bn);
      }
    }, _n.prototype.eachRendered = function(nr) {
      this._newAdded[0] && nr(this._newAdded[0]);
    }, _n.prototype._create = function() {
      var nr = new LargeSymbolPath({
        cursor: "default"
      });
      return nr.ignoreCoarsePointer = !0, this.group.add(nr), this._newAdded.push(nr), nr;
    }, _n.prototype._setCommon = function(nr, Cn, Bn) {
      var In = Cn.hostModel;
      Bn = Bn || {};
      var Dn = Cn.getVisual("symbolSize");
      nr.setShape("size", Dn instanceof Array ? Dn : [Dn, Dn]), nr.softClipShape = Bn.clipShape || null, nr.symbolProxy = createSymbol$1(Cn.getVisual("symbol"), 0, 0, 0, 0), nr.setColor = nr.symbolProxy.setColor;
      var Ln = nr.shape.size[0] < BOOST_SIZE_THRESHOLD;
      nr.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        In.getModel("itemStyle").getItemStyle(Ln ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var $n = Cn.getVisual("style"), Nn = $n && $n.fill;
      Nn && nr.setColor(Nn);
      var Rn = getECData(nr);
      Rn.seriesIndex = In.seriesIndex, nr.on("mousemove", function(Fn) {
        Rn.dataIndex = null;
        var Pn = nr.hoverDataIdx;
        Pn >= 0 && (Rn.dataIndex = Pn + (nr.startIndex || 0));
      });
    }, _n.prototype.remove = function() {
      this._clear();
    }, _n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, _n;
  }()
);
const LargeSymbolDraw$1 = LargeSymbolDraw;
var ScatterView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = this._updateSymbolDraw(Dn, Cn);
      Ln.updateData(Dn, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(Cn)
      }), this._finished = !0;
    }, nr.prototype.incrementalPrepareRender = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = this._updateSymbolDraw(Dn, Cn);
      Ln.incrementalPrepareUpdate(Dn), this._finished = !1;
    }, nr.prototype.incrementalRender = function(Cn, Bn, In) {
      this._symbolDraw.incrementalUpdate(Cn, Bn.getData(), {
        clipShape: this._getClipShape(Bn)
      }), this._finished = Cn.end === Bn.getData().count();
    }, nr.prototype.updateTransform = function(Cn, Bn, In) {
      var Dn = Cn.getData();
      if (this.group.dirty(), !this._finished || Dn.count() > 1e4)
        return {
          update: !0
        };
      var Ln = pointsLayout("").reset(Cn, Bn, In);
      Ln.progress && Ln.progress({
        start: 0,
        end: Dn.count(),
        count: Dn.count()
      }, Dn), this._symbolDraw.updateLayout(Dn);
    }, nr.prototype.eachRendered = function(Cn) {
      this._symbolDraw && this._symbolDraw.eachRendered(Cn);
    }, nr.prototype._getClipShape = function(Cn) {
      if (Cn.get("clip", !0)) {
        var Bn = Cn.coordinateSystem;
        return Bn && Bn.getArea && Bn.getArea(0.1);
      }
    }, nr.prototype._updateSymbolDraw = function(Cn, Bn) {
      var In = this._symbolDraw, Dn = Bn.pipelineContext, Ln = Dn.large;
      return (!In || Ln !== this._isLargeDraw) && (In && In.remove(), In = this._symbolDraw = Ln ? new LargeSymbolDraw$1() : new SymbolDraw$1(), this._isLargeDraw = Ln, this.group.removeAll()), this.group.add(In.group), In;
    }, nr.prototype.remove = function(Cn, Bn) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, nr.prototype.dispose = function() {
    }, nr.type = "scatter", nr;
  }(ChartView$1)
);
const ScatterView$1 = ScatterView;
var GridModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.type = "grid", nr.dependencies = ["xAxis", "yAxis"], nr.layoutMode = "box", nr.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      // If grid size contain label
      containLabel: !1,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, nr;
  }(ComponentModel$1)
);
const GridModel$1 = GridModel;
var CartesianAxisModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
    }, nr.type = "cartesian2dAxis", nr;
  }(ComponentModel$1)
);
mixin(CartesianAxisModel, AxisModelCommonMixin);
var defaultOption$1 = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: !0,
    showMinLine: !0,
    showMaxLine: !0,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
}, categoryAxis = merge$1({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, defaultOption$1), valueAxis = merge$1({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, defaultOption$1), timeAxis = merge$1({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, valueAxis), logAxis = defaults({
  logBase: 10
}, valueAxis);
const axisDefault = {
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
};
var AXIS_TYPES = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function axisModelCreator(_n, nr, Cn, Bn) {
  each$f(AXIS_TYPES, function(In, Dn) {
    var Ln = merge$1(merge$1({}, axisDefault[Dn], !0), Bn, !0), $n = (
      /** @class */
      function(Nn) {
        __extends$2(Rn, Nn);
        function Rn() {
          var Fn = Nn !== null && Nn.apply(this, arguments) || this;
          return Fn.type = nr + "Axis." + Dn, Fn;
        }
        return Rn.prototype.mergeDefaultAndTheme = function(Fn, Pn) {
          var Un = fetchLayoutMode(this), Hn = Un ? getLayoutParams(Fn) : {}, zn = Pn.getTheme();
          merge$1(Fn, zn.get(Dn + "Axis")), merge$1(Fn, this.getDefaultOption()), Fn.type = getAxisType(Fn), Un && mergeLayoutParam(Fn, Hn, Un);
        }, Rn.prototype.optionUpdated = function() {
          var Fn = this.option;
          Fn.type === "category" && (this.__ordinalMeta = OrdinalMeta$1.createByAxisModel(this));
        }, Rn.prototype.getCategories = function(Fn) {
          var Pn = this.option;
          if (Pn.type === "category")
            return Fn ? Pn.data : this.__ordinalMeta.categories;
        }, Rn.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, Rn.type = nr + "Axis." + Dn, Rn.defaultOption = Ln, Rn;
      }(Cn)
    );
    _n.registerComponentModel($n);
  }), _n.registerSubTypeDefaulter(nr + "Axis", getAxisType);
}
function getAxisType(_n) {
  return _n.type || (_n.data ? "category" : "value");
}
var Cartesian = (
  /** @class */
  function() {
    function _n(nr) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = nr || "";
    }
    return _n.prototype.getAxis = function(nr) {
      return this._axes[nr];
    }, _n.prototype.getAxes = function() {
      return map$1(this._dimList, function(nr) {
        return this._axes[nr];
      }, this);
    }, _n.prototype.getAxesByScale = function(nr) {
      return nr = nr.toLowerCase(), filter(this.getAxes(), function(Cn) {
        return Cn.scale.type === nr;
      });
    }, _n.prototype.addAxis = function(nr) {
      var Cn = nr.dim;
      this._axes[Cn] = nr, this._dimList.push(Cn);
    }, _n;
  }()
);
const Cartesian$1 = Cartesian;
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(_n) {
  return _n.type === "interval" || _n.type === "time";
}
var Cartesian2D = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = "cartesian2d", Cn.dimensions = cartesian2DDimensions, Cn;
    }
    return nr.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var Cn = this.getAxis("x").scale, Bn = this.getAxis("y").scale;
      if (!(!canCalculateAffineTransform(Cn) || !canCalculateAffineTransform(Bn))) {
        var In = Cn.getExtent(), Dn = Bn.getExtent(), Ln = this.dataToPoint([In[0], Dn[0]]), $n = this.dataToPoint([In[1], Dn[1]]), Nn = In[1] - In[0], Rn = Dn[1] - Dn[0];
        if (!(!Nn || !Rn)) {
          var Fn = ($n[0] - Ln[0]) / Nn, Pn = ($n[1] - Ln[1]) / Rn, Un = Ln[0] - In[0] * Fn, Hn = Ln[1] - Dn[0] * Pn, zn = this._transform = [Fn, 0, 0, Pn, Un, Hn];
          this._invTransform = invert([], zn);
        }
      }
    }, nr.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, nr.prototype.containPoint = function(Cn) {
      var Bn = this.getAxis("x"), In = this.getAxis("y");
      return Bn.contain(Bn.toLocalCoord(Cn[0])) && In.contain(In.toLocalCoord(Cn[1]));
    }, nr.prototype.containData = function(Cn) {
      return this.getAxis("x").containData(Cn[0]) && this.getAxis("y").containData(Cn[1]);
    }, nr.prototype.containZone = function(Cn, Bn) {
      var In = this.dataToPoint(Cn), Dn = this.dataToPoint(Bn), Ln = this.getArea(), $n = new BoundingRect$1(In[0], In[1], Dn[0] - In[0], Dn[1] - In[1]);
      return Ln.intersect($n);
    }, nr.prototype.dataToPoint = function(Cn, Bn, In) {
      In = In || [];
      var Dn = Cn[0], Ln = Cn[1];
      if (this._transform && Dn != null && isFinite(Dn) && Ln != null && isFinite(Ln))
        return applyTransform$1(In, Cn, this._transform);
      var $n = this.getAxis("x"), Nn = this.getAxis("y");
      return In[0] = $n.toGlobalCoord($n.dataToCoord(Dn, Bn)), In[1] = Nn.toGlobalCoord(Nn.dataToCoord(Ln, Bn)), In;
    }, nr.prototype.clampData = function(Cn, Bn) {
      var In = this.getAxis("x").scale, Dn = this.getAxis("y").scale, Ln = In.getExtent(), $n = Dn.getExtent(), Nn = In.parse(Cn[0]), Rn = Dn.parse(Cn[1]);
      return Bn = Bn || [], Bn[0] = Math.min(Math.max(Math.min(Ln[0], Ln[1]), Nn), Math.max(Ln[0], Ln[1])), Bn[1] = Math.min(Math.max(Math.min($n[0], $n[1]), Rn), Math.max($n[0], $n[1])), Bn;
    }, nr.prototype.pointToData = function(Cn, Bn) {
      var In = [];
      if (this._invTransform)
        return applyTransform$1(In, Cn, this._invTransform);
      var Dn = this.getAxis("x"), Ln = this.getAxis("y");
      return In[0] = Dn.coordToData(Dn.toLocalCoord(Cn[0]), Bn), In[1] = Ln.coordToData(Ln.toLocalCoord(Cn[1]), Bn), In;
    }, nr.prototype.getOtherAxis = function(Cn) {
      return this.getAxis(Cn.dim === "x" ? "y" : "x");
    }, nr.prototype.getArea = function(Cn) {
      Cn = Cn || 0;
      var Bn = this.getAxis("x").getGlobalExtent(), In = this.getAxis("y").getGlobalExtent(), Dn = Math.min(Bn[0], Bn[1]) - Cn, Ln = Math.min(In[0], In[1]) - Cn, $n = Math.max(Bn[0], Bn[1]) - Dn + Cn, Nn = Math.max(In[0], In[1]) - Ln + Cn;
      return new BoundingRect$1(Dn, Ln, $n, Nn);
    }, nr;
  }(Cartesian$1)
), Axis2D = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In, Dn, Ln) {
      var $n = _n.call(this, Cn, Bn, In) || this;
      return $n.index = 0, $n.type = Dn || "value", $n.position = Ln || "bottom", $n;
    }
    return nr.prototype.isHorizontal = function() {
      var Cn = this.position;
      return Cn === "top" || Cn === "bottom";
    }, nr.prototype.getGlobalExtent = function(Cn) {
      var Bn = this.getExtent();
      return Bn[0] = this.toGlobalCoord(Bn[0]), Bn[1] = this.toGlobalCoord(Bn[1]), Cn && Bn[0] > Bn[1] && Bn.reverse(), Bn;
    }, nr.prototype.pointToData = function(Cn, Bn) {
      return this.coordToData(this.toLocalCoord(Cn[this.dim === "x" ? 0 : 1]), Bn);
    }, nr.prototype.setCategorySortInfo = function(Cn) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = Cn, this.scale.setSortInfo(Cn);
    }, nr;
  }(Axis$1)
);
const Axis2D$1 = Axis2D;
function layout$2(_n, nr, Cn) {
  Cn = Cn || {};
  var Bn = _n.coordinateSystem, In = nr.axis, Dn = {}, Ln = In.getAxesOnZeroOf()[0], $n = In.position, Nn = Ln ? "onZero" : $n, Rn = In.dim, Fn = Bn.getRect(), Pn = [Fn.x, Fn.x + Fn.width, Fn.y, Fn.y + Fn.height], Un = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, Hn = nr.get("offset") || 0, zn = Rn === "x" ? [Pn[2] - Hn, Pn[3] + Hn] : [Pn[0] - Hn, Pn[1] + Hn];
  if (Ln) {
    var Gn = Ln.toGlobalCoord(Ln.dataToCoord(0));
    zn[Un.onZero] = Math.max(Math.min(Gn, zn[1]), zn[0]);
  }
  Dn.position = [Rn === "y" ? zn[Un[Nn]] : Pn[0], Rn === "x" ? zn[Un[Nn]] : Pn[3]], Dn.rotation = Math.PI / 2 * (Rn === "x" ? 0 : 1);
  var Yn = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  Dn.labelDirection = Dn.tickDirection = Dn.nameDirection = Yn[$n], Dn.labelOffset = Ln ? zn[Un[$n]] - zn[Un.onZero] : 0, nr.get(["axisTick", "inside"]) && (Dn.tickDirection = -Dn.tickDirection), retrieve(Cn.labelInside, nr.get(["axisLabel", "inside"])) && (Dn.labelDirection = -Dn.labelDirection);
  var Wn = nr.get(["axisLabel", "rotate"]);
  return Dn.labelRotate = Nn === "top" ? -Wn : Wn, Dn.z2 = 1, Dn;
}
function isCartesian2DSeries(_n) {
  return _n.get("coordinateSystem") === "cartesian2d";
}
function findAxisModels(_n) {
  var nr = {
    xAxisModel: null,
    yAxisModel: null
  };
  return each$f(nr, function(Cn, Bn) {
    var In = Bn.replace(/Model$/, ""), Dn = _n.getReferringComponents(In, SINGLE_REFERRING).models[0];
    if (process.env.NODE_ENV !== "production" && !Dn)
      throw new Error(In + ' "' + retrieve3(_n.get(In + "Index"), _n.get(In + "Id"), 0) + '" not found');
    nr[Bn] = Dn;
  }), nr;
}
var mathLog = Math.log;
function alignScaleTicks(_n, nr, Cn) {
  var Bn = IntervalScale$1.prototype, In = Bn.getTicks.call(Cn), Dn = Bn.getTicks.call(Cn, !0), Ln = In.length - 1, $n = Bn.getInterval.call(Cn), Nn = getScaleExtent(_n, nr), Rn = Nn.extent, Fn = Nn.fixMin, Pn = Nn.fixMax;
  if (_n.type === "log") {
    var Un = mathLog(_n.base);
    Rn = [mathLog(Rn[0]) / Un, mathLog(Rn[1]) / Un];
  }
  _n.setExtent(Rn[0], Rn[1]), _n.calcNiceExtent({
    splitNumber: Ln,
    fixMin: Fn,
    fixMax: Pn
  });
  var Hn = Bn.getExtent.call(_n);
  Fn && (Rn[0] = Hn[0]), Pn && (Rn[1] = Hn[1]);
  var zn = Bn.getInterval.call(_n), Gn = Rn[0], Yn = Rn[1];
  if (Fn && Pn)
    zn = (Yn - Gn) / Ln;
  else if (Fn)
    for (Yn = Rn[0] + zn * Ln; Yn < Rn[1] && isFinite(Yn) && isFinite(Rn[1]); )
      zn = increaseInterval(zn), Yn = Rn[0] + zn * Ln;
  else if (Pn)
    for (Gn = Rn[1] - zn * Ln; Gn > Rn[0] && isFinite(Gn) && isFinite(Rn[0]); )
      zn = increaseInterval(zn), Gn = Rn[1] - zn * Ln;
  else {
    var Wn = _n.getTicks().length - 1;
    Wn > Ln && (zn = increaseInterval(zn));
    var Xn = zn * Ln;
    Yn = Math.ceil(Rn[1] / zn) * zn, Gn = round$4(Yn - Xn), Gn < 0 && Rn[0] >= 0 ? (Gn = 0, Yn = round$4(Xn)) : Yn > 0 && Rn[1] <= 0 && (Yn = 0, Gn = -round$4(Xn));
  }
  var ea = (In[0].value - Dn[0].value) / $n, ta = (In[Ln].value - Dn[Ln].value) / $n;
  if (Bn.setExtent.call(_n, Gn + zn * ea, Yn + zn * ta), Bn.setInterval.call(_n, zn), (ea || ta) && Bn.setNiceExtent.call(_n, Gn + zn, Yn - zn), process.env.NODE_ENV !== "production") {
    var na = Bn.getTicks.call(_n);
    na[1] && (!isValueNice(zn) || getPrecisionSafe(na[1].value) > getPrecisionSafe(zn)) && warn(
      // eslint-disable-next-line
      "The ticks may be not readable when set min: " + nr.get("min") + ", max: " + nr.get("max") + " and alignTicks: true"
    );
  }
}
var Grid = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = cartesian2DDimensions, this._initCartesian(nr, Cn, Bn), this.model = nr;
    }
    return _n.prototype.getRect = function() {
      return this._rect;
    }, _n.prototype.update = function(nr, Cn) {
      var Bn = this._axesMap;
      this._updateScale(nr, this.model);
      function In(Ln) {
        var $n, Nn = keys(Ln), Rn = Nn.length;
        if (Rn) {
          for (var Fn = [], Pn = Rn - 1; Pn >= 0; Pn--) {
            var Un = +Nn[Pn], Hn = Ln[Un], zn = Hn.model, Gn = Hn.scale;
            // Only value and log axis without interval support alignTicks.
            isIntervalOrLogScale(Gn) && zn.get("alignTicks") && zn.get("interval") == null ? Fn.push(Hn) : (niceScaleExtent(Gn, zn), isIntervalOrLogScale(Gn) && ($n = Hn));
          }
          Fn.length && ($n || ($n = Fn.pop(), niceScaleExtent($n.scale, $n.model)), each$f(Fn, function(Yn) {
            alignScaleTicks(Yn.scale, Yn.model, $n.scale);
          }));
        }
      }
      In(Bn.x), In(Bn.y);
      var Dn = {};
      each$f(Bn.x, function(Ln) {
        fixAxisOnZero(Bn, "y", Ln, Dn);
      }), each$f(Bn.y, function(Ln) {
        fixAxisOnZero(Bn, "x", Ln, Dn);
      }), this.resize(this.model, Cn);
    }, _n.prototype.resize = function(nr, Cn, Bn) {
      var In = nr.getBoxLayoutParams(), Dn = !Bn && nr.get("containLabel"), Ln = getLayoutRect$1(In, {
        width: Cn.getWidth(),
        height: Cn.getHeight()
      });
      this._rect = Ln;
      var $n = this._axesList;
      Nn(), Dn && (each$f($n, function(Rn) {
        if (!Rn.model.get(["axisLabel", "inside"])) {
          var Fn = estimateLabelUnionRect(Rn);
          if (Fn) {
            var Pn = Rn.isHorizontal() ? "height" : "width", Un = Rn.model.get(["axisLabel", "margin"]);
            Ln[Pn] -= Fn[Pn] + Un, Rn.position === "top" ? Ln.y += Fn.height + Un : Rn.position === "left" && (Ln.x += Fn.width + Un);
          }
        }
      }), Nn()), each$f(this._coordsList, function(Rn) {
        Rn.calcAffineTransform();
      });
      function Nn() {
        each$f($n, function(Rn) {
          var Fn = Rn.isHorizontal(), Pn = Fn ? [0, Ln.width] : [0, Ln.height], Un = Rn.inverse ? 1 : 0;
          Rn.setExtent(Pn[Un], Pn[1 - Un]), updateAxisTransform(Rn, Fn ? Ln.x : Ln.y);
        });
      }
    }, _n.prototype.getAxis = function(nr, Cn) {
      var Bn = this._axesMap[nr];
      if (Bn != null)
        return Bn[Cn || 0];
    }, _n.prototype.getAxes = function() {
      return this._axesList.slice();
    }, _n.prototype.getCartesian = function(nr, Cn) {
      if (nr != null && Cn != null) {
        var Bn = "x" + nr + "y" + Cn;
        return this._coordsMap[Bn];
      }
      isObject$6(nr) && (Cn = nr.yAxisIndex, nr = nr.xAxisIndex);
      for (var In = 0, Dn = this._coordsList; In < Dn.length; In++)
        if (Dn[In].getAxis("x").index === nr || Dn[In].getAxis("y").index === Cn)
          return Dn[In];
    }, _n.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, _n.prototype.convertToPixel = function(nr, Cn, Bn) {
      var In = this._findConvertTarget(Cn);
      return In.cartesian ? In.cartesian.dataToPoint(Bn) : In.axis ? In.axis.toGlobalCoord(In.axis.dataToCoord(Bn)) : null;
    }, _n.prototype.convertFromPixel = function(nr, Cn, Bn) {
      var In = this._findConvertTarget(Cn);
      return In.cartesian ? In.cartesian.pointToData(Bn) : In.axis ? In.axis.coordToData(In.axis.toLocalCoord(Bn)) : null;
    }, _n.prototype._findConvertTarget = function(nr) {
      var Cn = nr.seriesModel, Bn = nr.xAxisModel || Cn && Cn.getReferringComponents("xAxis", SINGLE_REFERRING).models[0], In = nr.yAxisModel || Cn && Cn.getReferringComponents("yAxis", SINGLE_REFERRING).models[0], Dn = nr.gridModel, Ln = this._coordsList, $n, Nn;
      if (Cn)
        $n = Cn.coordinateSystem, indexOf(Ln, $n) < 0 && ($n = null);
      else if (Bn && In)
        $n = this.getCartesian(Bn.componentIndex, In.componentIndex);
      else if (Bn)
        Nn = this.getAxis("x", Bn.componentIndex);
      else if (In)
        Nn = this.getAxis("y", In.componentIndex);
      else if (Dn) {
        var Rn = Dn.coordinateSystem;
        Rn === this && ($n = this._coordsList[0]);
      }
      return {
        cartesian: $n,
        axis: Nn
      };
    }, _n.prototype.containPoint = function(nr) {
      var Cn = this._coordsList[0];
      if (Cn)
        return Cn.containPoint(nr);
    }, _n.prototype._initCartesian = function(nr, Cn, Bn) {
      var In = this, Dn = this, Ln = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, $n = {
        x: {},
        y: {}
      }, Nn = {
        x: 0,
        y: 0
      };
      if (Cn.eachComponent("xAxis", Rn("x"), this), Cn.eachComponent("yAxis", Rn("y"), this), !Nn.x || !Nn.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = $n, each$f($n.x, function(Fn, Pn) {
        each$f($n.y, function(Un, Hn) {
          var zn = "x" + Pn + "y" + Hn, Gn = new Cartesian2D(zn);
          Gn.master = In, Gn.model = nr, In._coordsMap[zn] = Gn, In._coordsList.push(Gn), Gn.addAxis(Fn), Gn.addAxis(Un);
        });
      });
      function Rn(Fn) {
        return function(Pn, Un) {
          if (isAxisUsedInTheGrid(Pn, nr)) {
            var Hn = Pn.get("position");
            Fn === "x" ? Hn !== "top" && Hn !== "bottom" && (Hn = Ln.bottom ? "top" : "bottom") : Hn !== "left" && Hn !== "right" && (Hn = Ln.left ? "right" : "left"), Ln[Hn] = !0;
            var zn = new Axis2D$1(Fn, createScaleByModel$1(Pn), [0, 0], Pn.get("type"), Hn), Gn = zn.type === "category";
            zn.onBand = Gn && Pn.get("boundaryGap"), zn.inverse = Pn.get("inverse"), Pn.axis = zn, zn.model = Pn, zn.grid = Dn, zn.index = Un, Dn._axesList.push(zn), $n[Fn][Un] = zn, Nn[Fn]++;
          }
        };
      }
    }, _n.prototype._updateScale = function(nr, Cn) {
      each$f(this._axesList, function(In) {
        if (In.scale.setExtent(1 / 0, -1 / 0), In.type === "category") {
          var Dn = In.model.get("categorySortInfo");
          In.scale.setSortInfo(Dn);
        }
      }), nr.eachSeries(function(In) {
        if (isCartesian2DSeries(In)) {
          var Dn = findAxisModels(In), Ln = Dn.xAxisModel, $n = Dn.yAxisModel;
          if (!isAxisUsedInTheGrid(Ln, Cn) || !isAxisUsedInTheGrid($n, Cn))
            return;
          var Nn = this.getCartesian(Ln.componentIndex, $n.componentIndex), Rn = In.getData(), Fn = Nn.getAxis("x"), Pn = Nn.getAxis("y");
          Bn(Rn, Fn), Bn(Rn, Pn);
        }
      }, this);
      function Bn(In, Dn) {
        each$f(getDataDimensionsOnAxis(In, Dn.dim), function(Ln) {
          Dn.scale.unionExtentFromData(In, Ln);
        });
      }
    }, _n.prototype.getTooltipAxes = function(nr) {
      var Cn = [], Bn = [];
      return each$f(this.getCartesians(), function(In) {
        var Dn = nr != null && nr !== "auto" ? In.getAxis(nr) : In.getBaseAxis(), Ln = In.getOtherAxis(Dn);
        indexOf(Cn, Dn) < 0 && Cn.push(Dn), indexOf(Bn, Ln) < 0 && Bn.push(Ln);
      }), {
        baseAxes: Cn,
        otherAxes: Bn
      };
    }, _n.create = function(nr, Cn) {
      var Bn = [];
      return nr.eachComponent("grid", function(In, Dn) {
        var Ln = new _n(In, nr, Cn);
        Ln.name = "grid_" + Dn, Ln.resize(In, Cn, !0), In.coordinateSystem = Ln, Bn.push(Ln);
      }), nr.eachSeries(function(In) {
        if (isCartesian2DSeries(In)) {
          var Dn = findAxisModels(In), Ln = Dn.xAxisModel, $n = Dn.yAxisModel, Nn = Ln.getCoordSysModel();
          if (process.env.NODE_ENV !== "production") {
            if (!Nn)
              throw new Error('Grid "' + retrieve3(Ln.get("gridIndex"), Ln.get("gridId"), 0) + '" not found');
            if (Ln.getCoordSysModel() !== $n.getCoordSysModel())
              throw new Error("xAxis and yAxis must use the same grid");
          }
          var Rn = Nn.coordinateSystem;
          In.coordinateSystem = Rn.getCartesian(Ln.componentIndex, $n.componentIndex);
        }
      }), Bn;
    }, _n.dimensions = cartesian2DDimensions, _n;
  }()
);
function isAxisUsedInTheGrid(_n, nr) {
  return _n.getCoordSysModel() === nr;
}
function fixAxisOnZero(_n, nr, Cn, Bn) {
  Cn.getAxesOnZeroOf = function() {
    return Dn ? [Dn] : [];
  };
  var In = _n[nr], Dn, Ln = Cn.model, $n = Ln.get(["axisLine", "onZero"]), Nn = Ln.get(["axisLine", "onZeroAxisIndex"]);
  if (!$n)
    return;
  if (Nn != null)
    canOnZeroToAxis(In[Nn]) && (Dn = In[Nn]);
  else
    for (var Rn in In)
      if (In.hasOwnProperty(Rn) && canOnZeroToAxis(In[Rn]) && !Bn[Fn(In[Rn])]) {
        Dn = In[Rn];
        break;
      }
  Dn && (Bn[Fn(Dn)] = !0);
  function Fn(Pn) {
    return Pn.dim + "_" + Pn.index;
  }
}
function canOnZeroToAxis(_n) {
  return _n && _n.type !== "category" && _n.type !== "time" && ifAxisCrossZero(_n);
}
function updateAxisTransform(_n, nr) {
  var Cn = _n.getExtent(), Bn = Cn[0] + Cn[1];
  _n.toGlobalCoord = _n.dim === "x" ? function(In) {
    return In + nr;
  } : function(In) {
    return Bn - In + nr;
  }, _n.toLocalCoord = _n.dim === "x" ? function(In) {
    return In - nr;
  } : function(In) {
    return Bn - In + nr;
  };
}
const Grid$1 = Grid;
var PI$3 = Math.PI, AxisBuilder = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.group = new Group$4(), this.opt = Cn, this.axisModel = nr, defaults(Cn, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0,
        handleAutoShown: function() {
          return !0;
        }
      });
      var Bn = new Group$4({
        x: Cn.position[0],
        y: Cn.position[1],
        rotation: Cn.rotation
      });
      Bn.updateTransform(), this._transformGroup = Bn;
    }
    return _n.prototype.hasBuilder = function(nr) {
      return !!builders[nr];
    }, _n.prototype.add = function(nr) {
      builders[nr](this.opt, this.axisModel, this.group, this._transformGroup);
    }, _n.prototype.getGroup = function() {
      return this.group;
    }, _n.innerTextLayout = function(nr, Cn, Bn) {
      var In = remRadian(Cn - nr), Dn, Ln;
      return isRadianAroundZero(In) ? (Ln = Bn > 0 ? "top" : "bottom", Dn = "center") : isRadianAroundZero(In - PI$3) ? (Ln = Bn > 0 ? "bottom" : "top", Dn = "center") : (Ln = "middle", In > 0 && In < PI$3 ? Dn = Bn > 0 ? "right" : "left" : Dn = Bn > 0 ? "left" : "right"), {
        rotation: In,
        textAlign: Dn,
        textVerticalAlign: Ln
      };
    }, _n.makeAxisEventDataBase = function(nr) {
      var Cn = {
        componentType: nr.mainType,
        componentIndex: nr.componentIndex
      };
      return Cn[nr.mainType + "Index"] = nr.componentIndex, Cn;
    }, _n.isLabelSilent = function(nr) {
      var Cn = nr.get("tooltip");
      return nr.get("silent") || !(nr.get("triggerEvent") || Cn && Cn.show);
    }, _n;
  }()
), builders = {
  axisLine: function(_n, nr, Cn, Bn) {
    var In = nr.get(["axisLine", "show"]);
    if (In === "auto" && _n.handleAutoShown && (In = _n.handleAutoShown("axisLine")), !!In) {
      var Dn = nr.axis.getExtent(), Ln = Bn.transform, $n = [Dn[0], 0], Nn = [Dn[1], 0], Rn = $n[0] > Nn[0];
      Ln && (applyTransform$1($n, $n, Ln), applyTransform$1(Nn, Nn, Ln));
      var Fn = extend({
        lineCap: "round"
      }, nr.getModel(["axisLine", "lineStyle"]).getLineStyle()), Pn = new Line$3({
        shape: {
          x1: $n[0],
          y1: $n[1],
          x2: Nn[0],
          y2: Nn[1]
        },
        style: Fn,
        strokeContainThreshold: _n.strokeContainThreshold || 5,
        silent: !0,
        z2: 1
      });
      subPixelOptimizeLine(Pn.shape, Pn.style.lineWidth), Pn.anid = "line", Cn.add(Pn);
      var Un = nr.get(["axisLine", "symbol"]);
      if (Un != null) {
        var Hn = nr.get(["axisLine", "symbolSize"]);
        isString$1(Un) && (Un = [Un, Un]), (isString$1(Hn) || isNumber(Hn)) && (Hn = [Hn, Hn]);
        var zn = normalizeSymbolOffset(nr.get(["axisLine", "symbolOffset"]) || 0, Hn), Gn = Hn[0], Yn = Hn[1];
        each$f([{
          rotate: _n.rotation + Math.PI / 2,
          offset: zn[0],
          r: 0
        }, {
          rotate: _n.rotation - Math.PI / 2,
          offset: zn[1],
          r: Math.sqrt(($n[0] - Nn[0]) * ($n[0] - Nn[0]) + ($n[1] - Nn[1]) * ($n[1] - Nn[1]))
        }], function(Wn, Xn) {
          if (Un[Xn] !== "none" && Un[Xn] != null) {
            var ea = createSymbol$1(Un[Xn], -Gn / 2, -Yn / 2, Gn, Yn, Fn.stroke, !0), ta = Wn.r + Wn.offset, na = Rn ? Nn : $n;
            ea.attr({
              rotation: Wn.rotate,
              x: na[0] + ta * Math.cos(_n.rotation),
              y: na[1] - ta * Math.sin(_n.rotation),
              silent: !0,
              z2: 11
            }), Cn.add(ea);
          }
        });
      }
    }
  },
  axisTickLabel: function(_n, nr, Cn, Bn) {
    var In = buildAxisMajorTicks(Cn, Bn, nr, _n), Dn = buildAxisLabel(Cn, Bn, nr, _n);
    if (fixMinMaxLabelShow(nr, Dn, In), buildAxisMinorTicks(Cn, Bn, nr, _n.tickDirection), nr.get(["axisLabel", "hideOverlap"])) {
      var Ln = prepareLayoutList(map$1(Dn, function($n) {
        return {
          label: $n,
          priority: $n.z2,
          defaultAttr: {
            ignore: $n.ignore
          }
        };
      }));
      hideOverlap(Ln);
    }
  },
  axisName: function(_n, nr, Cn, Bn) {
    var In = retrieve(_n.axisName, nr.get("name"));
    if (In) {
      var Dn = nr.get("nameLocation"), Ln = _n.nameDirection, $n = nr.getModel("nameTextStyle"), Nn = nr.get("nameGap") || 0, Rn = nr.axis.getExtent(), Fn = Rn[0] > Rn[1] ? -1 : 1, Pn = [
        Dn === "start" ? Rn[0] - Fn * Nn : Dn === "end" ? Rn[1] + Fn * Nn : (Rn[0] + Rn[1]) / 2,
        // Reuse labelOffset.
        isNameLocationCenter(Dn) ? _n.labelOffset + Ln * Nn : 0
      ], Un, Hn = nr.get("nameRotate");
      Hn != null && (Hn = Hn * PI$3 / 180);
      var zn;
      isNameLocationCenter(Dn) ? Un = AxisBuilder.innerTextLayout(
        _n.rotation,
        Hn ?? _n.rotation,
        // Adapt to axis.
        Ln
      ) : (Un = endTextLayout(_n.rotation, Dn, Hn || 0, Rn), zn = _n.axisNameAvailableWidth, zn != null && (zn = Math.abs(zn / Math.sin(Un.rotation)), !isFinite(zn) && (zn = null)));
      var Gn = $n.getFont(), Yn = nr.get("nameTruncate", !0) || {}, Wn = Yn.ellipsis, Xn = retrieve(_n.nameTruncateMaxWidth, Yn.maxWidth, zn), ea = new ZRText$1({
        x: Pn[0],
        y: Pn[1],
        rotation: Un.rotation,
        silent: AxisBuilder.isLabelSilent(nr),
        style: createTextStyle$1($n, {
          text: In,
          font: Gn,
          overflow: "truncate",
          width: Xn,
          ellipsis: Wn,
          fill: $n.getTextColor() || nr.get(["axisLine", "lineStyle", "color"]),
          align: $n.get("align") || Un.textAlign,
          verticalAlign: $n.get("verticalAlign") || Un.textVerticalAlign
        }),
        z2: 1
      });
      if (setTooltipConfig({
        el: ea,
        componentModel: nr,
        itemName: In
      }), ea.__fullText = In, ea.anid = "name", nr.get("triggerEvent")) {
        var ta = AxisBuilder.makeAxisEventDataBase(nr);
        ta.targetType = "axisName", ta.name = In, getECData(ea).eventData = ta;
      }
      Bn.add(ea), ea.updateTransform(), Cn.add(ea), ea.decomposeTransform();
    }
  }
};
function endTextLayout(_n, nr, Cn, Bn) {
  var In = remRadian(Cn - _n), Dn, Ln, $n = Bn[0] > Bn[1], Nn = nr === "start" && !$n || nr !== "start" && $n;
  return isRadianAroundZero(In - PI$3 / 2) ? (Ln = Nn ? "bottom" : "top", Dn = "center") : isRadianAroundZero(In - PI$3 * 1.5) ? (Ln = Nn ? "top" : "bottom", Dn = "center") : (Ln = "middle", In < PI$3 * 1.5 && In > PI$3 / 2 ? Dn = Nn ? "left" : "right" : Dn = Nn ? "right" : "left"), {
    rotation: In,
    textAlign: Dn,
    textVerticalAlign: Ln
  };
}
function fixMinMaxLabelShow(_n, nr, Cn) {
  if (!shouldShowAllLabels(_n.axis)) {
    var Bn = _n.get(["axisLabel", "showMinLabel"]), In = _n.get(["axisLabel", "showMaxLabel"]);
    nr = nr || [], Cn = Cn || [];
    var Dn = nr[0], Ln = nr[1], $n = nr[nr.length - 1], Nn = nr[nr.length - 2], Rn = Cn[0], Fn = Cn[1], Pn = Cn[Cn.length - 1], Un = Cn[Cn.length - 2];
    Bn === !1 ? (ignoreEl(Dn), ignoreEl(Rn)) : isTwoLabelOverlapped(Dn, Ln) && (Bn ? (ignoreEl(Ln), ignoreEl(Fn)) : (ignoreEl(Dn), ignoreEl(Rn))), In === !1 ? (ignoreEl($n), ignoreEl(Pn)) : isTwoLabelOverlapped(Nn, $n) && (In ? (ignoreEl(Nn), ignoreEl(Un)) : (ignoreEl($n), ignoreEl(Pn)));
  }
}
function ignoreEl(_n) {
  _n && (_n.ignore = !0);
}
function isTwoLabelOverlapped(_n, nr) {
  var Cn = _n && _n.getBoundingRect().clone(), Bn = nr && nr.getBoundingRect().clone();
  if (!(!Cn || !Bn)) {
    var In = identity$1([]);
    return rotate(In, In, -_n.rotation), Cn.applyTransform(mul([], In, _n.getLocalTransform())), Bn.applyTransform(mul([], In, nr.getLocalTransform())), Cn.intersect(Bn);
  }
}
function isNameLocationCenter(_n) {
  return _n === "middle" || _n === "center";
}
function createTicks(_n, nr, Cn, Bn, In) {
  for (var Dn = [], Ln = [], $n = [], Nn = 0; Nn < _n.length; Nn++) {
    var Rn = _n[Nn].coord;
    Ln[0] = Rn, Ln[1] = 0, $n[0] = Rn, $n[1] = Cn, nr && (applyTransform$1(Ln, Ln, nr), applyTransform$1($n, $n, nr));
    var Fn = new Line$3({
      shape: {
        x1: Ln[0],
        y1: Ln[1],
        x2: $n[0],
        y2: $n[1]
      },
      style: Bn,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    subPixelOptimizeLine(Fn.shape, Fn.style.lineWidth), Fn.anid = In + "_" + _n[Nn].tickValue, Dn.push(Fn);
  }
  return Dn;
}
function buildAxisMajorTicks(_n, nr, Cn, Bn) {
  var In = Cn.axis, Dn = Cn.getModel("axisTick"), Ln = Dn.get("show");
  if (Ln === "auto" && Bn.handleAutoShown && (Ln = Bn.handleAutoShown("axisTick")), !(!Ln || In.scale.isBlank())) {
    for (var $n = Dn.getModel("lineStyle"), Nn = Bn.tickDirection * Dn.get("length"), Rn = In.getTicksCoords(), Fn = createTicks(Rn, nr.transform, Nn, defaults($n.getLineStyle(), {
      stroke: Cn.get(["axisLine", "lineStyle", "color"])
    }), "ticks"), Pn = 0; Pn < Fn.length; Pn++)
      _n.add(Fn[Pn]);
    return Fn;
  }
}
function buildAxisMinorTicks(_n, nr, Cn, Bn) {
  var In = Cn.axis, Dn = Cn.getModel("minorTick");
  if (!(!Dn.get("show") || In.scale.isBlank())) {
    var Ln = In.getMinorTicksCoords();
    if (Ln.length)
      for (var $n = Dn.getModel("lineStyle"), Nn = Bn * Dn.get("length"), Rn = defaults($n.getLineStyle(), defaults(Cn.getModel("axisTick").getLineStyle(), {
        stroke: Cn.get(["axisLine", "lineStyle", "color"])
      })), Fn = 0; Fn < Ln.length; Fn++)
        for (var Pn = createTicks(Ln[Fn], nr.transform, Nn, Rn, "minorticks_" + Fn), Un = 0; Un < Pn.length; Un++)
          _n.add(Pn[Un]);
  }
}
function buildAxisLabel(_n, nr, Cn, Bn) {
  var In = Cn.axis, Dn = retrieve(Bn.axisLabelShow, Cn.get(["axisLabel", "show"]));
  if (!(!Dn || In.scale.isBlank())) {
    var Ln = Cn.getModel("axisLabel"), $n = Ln.get("margin"), Nn = In.getViewLabels(), Rn = (retrieve(Bn.labelRotate, Ln.get("rotate")) || 0) * PI$3 / 180, Fn = AxisBuilder.innerTextLayout(Bn.rotation, Rn, Bn.labelDirection), Pn = Cn.getCategories && Cn.getCategories(!0), Un = [], Hn = AxisBuilder.isLabelSilent(Cn), zn = Cn.get("triggerEvent");
    return each$f(Nn, function(Gn, Yn) {
      var Wn = In.scale.type === "ordinal" ? In.scale.getRawOrdinalNumber(Gn.tickValue) : Gn.tickValue, Xn = Gn.formattedLabel, ea = Gn.rawLabel, ta = Ln;
      if (Pn && Pn[Wn]) {
        var na = Pn[Wn];
        isObject$6(na) && na.textStyle && (ta = new Model$1(na.textStyle, Ln, Cn.ecModel));
      }
      var ra = ta.getTextColor() || Cn.get(["axisLine", "lineStyle", "color"]), aa = In.dataToCoord(Wn), ia = ta.getShallow("align", !0) || Fn.textAlign, Aa = retrieve2(ta.getShallow("alignMinLabel", !0), ia), sa = retrieve2(ta.getShallow("alignMaxLabel", !0), ia), oa = ta.getShallow("verticalAlign", !0) || ta.getShallow("baseline", !0) || Fn.textVerticalAlign, la = retrieve2(ta.getShallow("verticalAlignMinLabel", !0), oa), ua = retrieve2(ta.getShallow("verticalAlignMaxLabel", !0), oa), ca = new ZRText$1({
        x: aa,
        y: Bn.labelOffset + Bn.labelDirection * $n,
        rotation: Fn.rotation,
        silent: Hn,
        z2: 10 + (Gn.level || 0),
        style: createTextStyle$1(ta, {
          text: Xn,
          align: Yn === 0 ? Aa : Yn === Nn.length - 1 ? sa : ia,
          verticalAlign: Yn === 0 ? la : Yn === Nn.length - 1 ? ua : oa,
          fill: isFunction$1(ra) ? ra(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            In.type === "category" ? ea : In.type === "value" ? Wn + "" : Wn,
            Yn
          ) : ra
        })
      });
      if (ca.anid = "label_" + Wn, setTooltipConfig({
        el: ca,
        componentModel: Cn,
        itemName: Xn,
        formatterParamsExtra: {
          isTruncated: function() {
            return ca.isTruncated;
          },
          value: ea,
          tickIndex: Yn
        }
      }), zn) {
        var fa = AxisBuilder.makeAxisEventDataBase(Cn);
        fa.targetType = "axisLabel", fa.value = ea, fa.tickIndex = Yn, In.type === "category" && (fa.dataIndex = Wn), getECData(ca).eventData = fa;
      }
      nr.add(ca), ca.updateTransform(), Un.push(ca), _n.add(ca), ca.decomposeTransform();
    }), Un;
  }
}
const AxisBuilder$1 = AxisBuilder;
function collect(_n, nr) {
  var Cn = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return collectAxesInfo(Cn, _n, nr), Cn.seriesInvolved && collectSeriesInfo(Cn, _n), Cn;
}
function collectAxesInfo(_n, nr, Cn) {
  var Bn = nr.getComponent("tooltip"), In = nr.getComponent("axisPointer"), Dn = In.get("link", !0) || [], Ln = [];
  each$f(Cn.getCoordinateSystems(), function($n) {
    if (!$n.axisPointerEnabled)
      return;
    var Nn = makeKey($n.model), Rn = _n.coordSysAxesInfo[Nn] = {};
    _n.coordSysMap[Nn] = $n;
    var Fn = $n.model, Pn = Fn.getModel("tooltip", Bn);
    if (each$f($n.getAxes(), curry$1(Gn, !1, null)), $n.getTooltipAxes && Bn && Pn.get("show")) {
      var Un = Pn.get("trigger") === "axis", Hn = Pn.get(["axisPointer", "type"]) === "cross", zn = $n.getTooltipAxes(Pn.get(["axisPointer", "axis"]));
      (Un || Hn) && each$f(zn.baseAxes, curry$1(Gn, Hn ? "cross" : !0, Un)), Hn && each$f(zn.otherAxes, curry$1(Gn, "cross", !1));
    }
    function Gn(Yn, Wn, Xn) {
      var ea = Xn.model.getModel("axisPointer", In), ta = ea.get("show");
      if (!(!ta || ta === "auto" && !Yn && !isHandleTrigger(ea))) {
        Wn == null && (Wn = ea.get("triggerTooltip")), ea = Yn ? makeAxisPointerModel(Xn, Pn, In, nr, Yn, Wn) : ea;
        var na = ea.get("snap"), ra = ea.get("triggerEmphasis"), aa = makeKey(Xn.model), ia = Wn || na || Xn.type === "category", Aa = _n.axesInfo[aa] = {
          key: aa,
          axis: Xn,
          coordSys: $n,
          axisPointerModel: ea,
          triggerTooltip: Wn,
          triggerEmphasis: ra,
          involveSeries: ia,
          snap: na,
          useHandle: isHandleTrigger(ea),
          seriesModels: [],
          linkGroup: null
        };
        Rn[aa] = Aa, _n.seriesInvolved = _n.seriesInvolved || ia;
        var sa = getLinkGroupIndex(Dn, Xn);
        if (sa != null) {
          var oa = Ln[sa] || (Ln[sa] = {
            axesInfo: {}
          });
          oa.axesInfo[aa] = Aa, oa.mapper = Dn[sa].mapper, Aa.linkGroup = oa;
        }
      }
    }
  });
}
function makeAxisPointerModel(_n, nr, Cn, Bn, In, Dn) {
  var Ln = nr.getModel("axisPointer"), $n = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], Nn = {};
  each$f($n, function(Un) {
    Nn[Un] = clone$4(Ln.get(Un));
  }), Nn.snap = _n.type !== "category" && !!Dn, Ln.get("type") === "cross" && (Nn.type = "line");
  var Rn = Nn.label || (Nn.label = {});
  if (Rn.show == null && (Rn.show = !1), In === "cross") {
    var Fn = Ln.get(["label", "show"]);
    if (Rn.show = Fn ?? !0, !Dn) {
      var Pn = Nn.lineStyle = Ln.get("crossStyle");
      Pn && defaults(Rn, Pn.textStyle);
    }
  }
  return _n.model.getModel("axisPointer", new Model$1(Nn, Cn, Bn));
}
function collectSeriesInfo(_n, nr) {
  nr.eachSeries(function(Cn) {
    var Bn = Cn.coordinateSystem, In = Cn.get(["tooltip", "trigger"], !0), Dn = Cn.get(["tooltip", "show"], !0);
    !Bn || In === "none" || In === !1 || In === "item" || Dn === !1 || Cn.get(["axisPointer", "show"], !0) === !1 || each$f(_n.coordSysAxesInfo[makeKey(Bn.model)], function(Ln) {
      var $n = Ln.axis;
      Bn.getAxis($n.dim) === $n && (Ln.seriesModels.push(Cn), Ln.seriesDataCount == null && (Ln.seriesDataCount = 0), Ln.seriesDataCount += Cn.getData().count());
    });
  });
}
function getLinkGroupIndex(_n, nr) {
  for (var Cn = nr.model, Bn = nr.dim, In = 0; In < _n.length; In++) {
    var Dn = _n[In] || {};
    if (checkPropInLink(Dn[Bn + "AxisId"], Cn.id) || checkPropInLink(Dn[Bn + "AxisIndex"], Cn.componentIndex) || checkPropInLink(Dn[Bn + "AxisName"], Cn.name))
      return In;
  }
}
function checkPropInLink(_n, nr) {
  return _n === "all" || isArray$4(_n) && indexOf(_n, nr) >= 0 || _n === nr;
}
function fixValue(_n) {
  var nr = getAxisInfo$1(_n);
  if (nr) {
    var Cn = nr.axisPointerModel, Bn = nr.axis.scale, In = Cn.option, Dn = Cn.get("status"), Ln = Cn.get("value");
    Ln != null && (Ln = Bn.parse(Ln));
    var $n = isHandleTrigger(Cn);
    Dn == null && (In.status = $n ? "show" : "hide");
    var Nn = Bn.getExtent().slice();
    Nn[0] > Nn[1] && Nn.reverse(), // Pick a value on axis when initializing.
    (Ln == null || Ln > Nn[1]) && (Ln = Nn[1]), Ln < Nn[0] && (Ln = Nn[0]), In.value = Ln, $n && (In.status = nr.axis.scale.isBlank() ? "hide" : "show");
  }
}
function getAxisInfo$1(_n) {
  var nr = (_n.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return nr && nr.axesInfo[makeKey(_n)];
}
function getAxisPointerModel(_n) {
  var nr = getAxisInfo$1(_n);
  return nr && nr.axisPointerModel;
}
function isHandleTrigger(_n) {
  return !!_n.get(["handle", "show"]);
}
function makeKey(_n) {
  return _n.type + "||" + _n.id;
}
var axisPointerClazz = {}, AxisView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      this.axisPointerClass && fixValue(Cn), _n.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(Cn, In, !0);
    }, nr.prototype.updateAxisPointer = function(Cn, Bn, In, Dn) {
      this._doUpdateAxisPointerClass(Cn, In, !1);
    }, nr.prototype.remove = function(Cn, Bn) {
      var In = this._axisPointer;
      In && In.remove(Bn);
    }, nr.prototype.dispose = function(Cn, Bn) {
      this._disposeAxisPointer(Bn), _n.prototype.dispose.apply(this, arguments);
    }, nr.prototype._doUpdateAxisPointerClass = function(Cn, Bn, In) {
      var Dn = nr.getAxisPointerClass(this.axisPointerClass);
      if (Dn) {
        var Ln = getAxisPointerModel(Cn);
        Ln ? (this._axisPointer || (this._axisPointer = new Dn())).render(Cn, Ln, Bn, In) : this._disposeAxisPointer(Bn);
      }
    }, nr.prototype._disposeAxisPointer = function(Cn) {
      this._axisPointer && this._axisPointer.dispose(Cn), this._axisPointer = null;
    }, nr.registerAxisPointerClass = function(Cn, Bn) {
      if (process.env.NODE_ENV !== "production" && axisPointerClazz[Cn])
        throw new Error("axisPointer " + Cn + " exists");
      axisPointerClazz[Cn] = Bn;
    }, nr.getAxisPointerClass = function(Cn) {
      return Cn && axisPointerClazz[Cn];
    }, nr.type = "axis", nr;
  }(ComponentView$1)
);
const AxisView$1 = AxisView;
var inner$f = makeInner();
function rectCoordAxisBuildSplitArea(_n, nr, Cn, Bn) {
  var In = Cn.axis;
  if (!In.scale.isBlank()) {
    var Dn = Cn.getModel("splitArea"), Ln = Dn.getModel("areaStyle"), $n = Ln.get("color"), Nn = Bn.coordinateSystem.getRect(), Rn = In.getTicksCoords({
      tickModel: Dn,
      clamp: !0
    });
    if (Rn.length) {
      var Fn = $n.length, Pn = inner$f(_n).splitAreaColors, Un = createHashMap(), Hn = 0;
      if (Pn)
        for (var zn = 0; zn < Rn.length; zn++) {
          var Gn = Pn.get(Rn[zn].tickValue);
          if (Gn != null) {
            Hn = (Gn + (Fn - 1) * zn) % Fn;
            break;
          }
        }
      var Yn = In.toGlobalCoord(Rn[0].coord), Wn = Ln.getAreaStyle();
      $n = isArray$4($n) ? $n : [$n];
      for (var zn = 1; zn < Rn.length; zn++) {
        var Xn = In.toGlobalCoord(Rn[zn].coord), ea = void 0, ta = void 0, na = void 0, ra = void 0;
        In.isHorizontal() ? (ea = Yn, ta = Nn.y, na = Xn - ea, ra = Nn.height, Yn = ea + na) : (ea = Nn.x, ta = Yn, na = Nn.width, ra = Xn - ta, Yn = ta + ra);
        var aa = Rn[zn - 1].tickValue;
        aa != null && Un.set(aa, Hn), nr.add(new Rect$3({
          anid: aa != null ? "area_" + aa : null,
          shape: {
            x: ea,
            y: ta,
            width: na,
            height: ra
          },
          style: defaults({
            fill: $n[Hn]
          }, Wn),
          autoBatch: !0,
          silent: !0
        })), Hn = (Hn + 1) % Fn;
      }
      inner$f(_n).splitAreaColors = Un;
    }
  }
}
function rectCoordAxisHandleRemove(_n) {
  inner$f(_n).splitAreaColors = null;
}
var axisBuilderAttrs$3 = ["axisLine", "axisTickLabel", "axisName"], selfBuilderAttrs$2 = ["splitArea", "splitLine", "minorSplitLine"], CartesianAxisView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.axisPointerClass = "CartesianAxisPointer", Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      this.group.removeAll();
      var Ln = this._axisGroup;
      if (this._axisGroup = new Group$4(), this.group.add(this._axisGroup), !!Cn.get("show")) {
        var $n = Cn.getCoordSysModel(), Nn = layout$2($n, Cn), Rn = new AxisBuilder$1(Cn, extend({
          handleAutoShown: function(Pn) {
            for (var Un = $n.coordinateSystem.getCartesians(), Hn = 0; Hn < Un.length; Hn++)
              if (isIntervalOrLogScale(Un[Hn].getOtherAxis(Cn.axis).scale))
                return !0;
            return !1;
          }
        }, Nn));
        each$f(axisBuilderAttrs$3, Rn.add, Rn), this._axisGroup.add(Rn.getGroup()), each$f(selfBuilderAttrs$2, function(Pn) {
          Cn.get([Pn, "show"]) && axisElementBuilders$2[Pn](this, this._axisGroup, Cn, $n);
        }, this);
        var Fn = Dn && Dn.type === "changeAxisOrder" && Dn.isInitSort;
        Fn || groupTransition(Ln, this._axisGroup, Cn), _n.prototype.render.call(this, Cn, Bn, In, Dn);
      }
    }, nr.prototype.remove = function() {
      rectCoordAxisHandleRemove(this);
    }, nr.type = "cartesianAxis", nr;
  }(AxisView$1)
), axisElementBuilders$2 = {
  splitLine: function(_n, nr, Cn, Bn) {
    var In = Cn.axis;
    if (!In.scale.isBlank()) {
      var Dn = Cn.getModel("splitLine"), Ln = Dn.getModel("lineStyle"), $n = Ln.get("color"), Nn = Dn.get("showMinLine") !== !1, Rn = Dn.get("showMaxLine") !== !1;
      $n = isArray$4($n) ? $n : [$n];
      for (var Fn = Bn.coordinateSystem.getRect(), Pn = In.isHorizontal(), Un = 0, Hn = In.getTicksCoords({
        tickModel: Dn
      }), zn = [], Gn = [], Yn = Ln.getLineStyle(), Wn = 0; Wn < Hn.length; Wn++) {
        var Xn = In.toGlobalCoord(Hn[Wn].coord);
        if (!(Wn === 0 && !Nn || Wn === Hn.length - 1 && !Rn)) {
          var ea = Hn[Wn].tickValue;
          Pn ? (zn[0] = Xn, zn[1] = Fn.y, Gn[0] = Xn, Gn[1] = Fn.y + Fn.height) : (zn[0] = Fn.x, zn[1] = Xn, Gn[0] = Fn.x + Fn.width, Gn[1] = Xn);
          var ta = Un++ % $n.length, na = new Line$3({
            anid: ea != null ? "line_" + ea : null,
            autoBatch: !0,
            shape: {
              x1: zn[0],
              y1: zn[1],
              x2: Gn[0],
              y2: Gn[1]
            },
            style: defaults({
              stroke: $n[ta]
            }, Yn),
            silent: !0
          });
          subPixelOptimizeLine(na.shape, Yn.lineWidth), nr.add(na);
        }
      }
    }
  },
  minorSplitLine: function(_n, nr, Cn, Bn) {
    var In = Cn.axis, Dn = Cn.getModel("minorSplitLine"), Ln = Dn.getModel("lineStyle"), $n = Bn.coordinateSystem.getRect(), Nn = In.isHorizontal(), Rn = In.getMinorTicksCoords();
    if (Rn.length)
      for (var Fn = [], Pn = [], Un = Ln.getLineStyle(), Hn = 0; Hn < Rn.length; Hn++)
        for (var zn = 0; zn < Rn[Hn].length; zn++) {
          var Gn = In.toGlobalCoord(Rn[Hn][zn].coord);
          Nn ? (Fn[0] = Gn, Fn[1] = $n.y, Pn[0] = Gn, Pn[1] = $n.y + $n.height) : (Fn[0] = $n.x, Fn[1] = Gn, Pn[0] = $n.x + $n.width, Pn[1] = Gn);
          var Yn = new Line$3({
            anid: "minor_line_" + Rn[Hn][zn].tickValue,
            autoBatch: !0,
            shape: {
              x1: Fn[0],
              y1: Fn[1],
              x2: Pn[0],
              y2: Pn[1]
            },
            style: Un,
            silent: !0
          });
          subPixelOptimizeLine(Yn.shape, Un.lineWidth), nr.add(Yn);
        }
  },
  splitArea: function(_n, nr, Cn, Bn) {
    rectCoordAxisBuildSplitArea(_n, nr, Cn, Bn);
  }
}, CartesianXAxisView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "xAxis", nr;
  }(CartesianAxisView)
), CartesianYAxisView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = CartesianXAxisView.type, Cn;
    }
    return nr.type = "yAxis", nr;
  }(CartesianAxisView)
), GridView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = "grid", Cn;
    }
    return nr.prototype.render = function(Cn, Bn) {
      this.group.removeAll(), Cn.get("show") && this.group.add(new Rect$3({
        shape: Cn.coordinateSystem.getRect(),
        style: defaults({
          fill: Cn.get("backgroundColor")
        }, Cn.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, nr.type = "grid", nr;
  }(ComponentView$1)
), extraOption = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function install$N(_n) {
  _n.registerComponentView(GridView), _n.registerComponentModel(GridModel$1), _n.registerCoordinateSystem("cartesian2d", Grid$1), axisModelCreator(_n, "x", CartesianAxisModel, extraOption), axisModelCreator(_n, "y", CartesianAxisModel, extraOption), _n.registerComponentView(CartesianXAxisView), _n.registerComponentView(CartesianYAxisView), _n.registerPreprocessor(function(nr) {
    nr.xAxis && nr.yAxis && !nr.grid && (nr.grid = {});
  });
}
function install$M(_n) {
  use(install$N), _n.registerSeriesModel(ScatterSeriesModel$1), _n.registerChartView(ScatterView$1), _n.registerLayout(pointsLayout("scatter"));
}
function radarLayout(_n) {
  _n.eachSeriesByType("radar", function(nr) {
    var Cn = nr.getData(), Bn = [], In = nr.coordinateSystem;
    if (In) {
      var Dn = In.getIndicatorAxes();
      each$f(Dn, function(Ln, $n) {
        Cn.each(Cn.mapDimension(Dn[$n].dim), function(Nn, Rn) {
          Bn[Rn] = Bn[Rn] || [];
          var Fn = In.dataToPoint(Nn, $n);
          Bn[Rn][$n] = isValidPoint(Fn) ? Fn : getValueMissingPoint(In);
        });
      }), Cn.each(function(Ln) {
        var $n = find(Bn[Ln], function(Nn) {
          return isValidPoint(Nn);
        }) || getValueMissingPoint(In);
        Bn[Ln].push($n.slice()), Cn.setItemLayout(Ln, Bn[Ln]);
      });
    }
  });
}
function isValidPoint(_n) {
  return !isNaN(_n[0]) && !isNaN(_n[1]);
}
function getValueMissingPoint(_n) {
  return [_n.cx, _n.cy];
}
function radarBackwardCompat(_n) {
  var nr = _n.polar;
  if (nr) {
    isArray$4(nr) || (nr = [nr]);
    var Cn = [];
    each$f(nr, function(Bn, In) {
      Bn.indicator ? (Bn.type && !Bn.shape && (Bn.shape = Bn.type), _n.radar = _n.radar || [], isArray$4(_n.radar) || (_n.radar = [_n.radar]), _n.radar.push(Bn)) : Cn.push(Bn);
    }), _n.polar = Cn;
  }
  each$f(_n.series, function(Bn) {
    Bn && Bn.type === "radar" && Bn.polarIndex && (Bn.radarIndex = Bn.polarIndex);
  });
}
var RadarView$2 = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Cn.coordinateSystem, Ln = this.group, $n = Cn.getData(), Nn = this._data;
      function Rn(Un, Hn) {
        var zn = Un.getItemVisual(Hn, "symbol") || "circle";
        if (zn !== "none") {
          var Gn = normalizeSymbolSize(Un.getItemVisual(Hn, "symbolSize")), Yn = createSymbol$1(zn, -1, -1, 2, 2), Wn = Un.getItemVisual(Hn, "symbolRotate") || 0;
          return Yn.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: Gn[0] / 2,
            scaleY: Gn[1] / 2,
            rotation: Wn * Math.PI / 180 || 0
          }), Yn;
        }
      }
      function Fn(Un, Hn, zn, Gn, Yn, Wn) {
        zn.removeAll();
        for (var Xn = 0; Xn < Hn.length - 1; Xn++) {
          var ea = Rn(Gn, Yn);
          ea && (ea.__dimIdx = Xn, Un[Xn] ? (ea.setPosition(Un[Xn]), graphic$1[Wn ? "initProps" : "updateProps"](ea, {
            x: Hn[Xn][0],
            y: Hn[Xn][1]
          }, Cn, Yn)) : ea.setPosition(Hn[Xn]), zn.add(ea));
        }
      }
      function Pn(Un) {
        return map$1(Un, function(Hn) {
          return [Dn.cx, Dn.cy];
        });
      }
      $n.diff(Nn).add(function(Un) {
        var Hn = $n.getItemLayout(Un);
        if (Hn) {
          var zn = new Polygon$1(), Gn = new Polyline$3(), Yn = {
            shape: {
              points: Hn
            }
          };
          zn.shape.points = Pn(Hn), Gn.shape.points = Pn(Hn), initProps(zn, Yn, Cn, Un), initProps(Gn, Yn, Cn, Un);
          var Wn = new Group$4(), Xn = new Group$4();
          Wn.add(Gn), Wn.add(zn), Wn.add(Xn), Fn(Gn.shape.points, Hn, Xn, $n, Un, !0), $n.setItemGraphicEl(Un, Wn);
        }
      }).update(function(Un, Hn) {
        var zn = Nn.getItemGraphicEl(Hn), Gn = zn.childAt(0), Yn = zn.childAt(1), Wn = zn.childAt(2), Xn = {
          shape: {
            points: $n.getItemLayout(Un)
          }
        };
        Xn.shape.points && (Fn(Gn.shape.points, Xn.shape.points, Wn, $n, Un, !1), saveOldStyle(Yn), saveOldStyle(Gn), updateProps$1(Gn, Xn, Cn), updateProps$1(Yn, Xn, Cn), $n.setItemGraphicEl(Un, zn));
      }).remove(function(Un) {
        Ln.remove(Nn.getItemGraphicEl(Un));
      }).execute(), $n.eachItemGraphicEl(function(Un, Hn) {
        var zn = $n.getItemModel(Hn), Gn = Un.childAt(0), Yn = Un.childAt(1), Wn = Un.childAt(2), Xn = $n.getItemVisual(Hn, "style"), ea = Xn.fill;
        Ln.add(Un), Gn.useStyle(defaults(zn.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: ea
        })), setStatesStylesFromModel(Gn, zn, "lineStyle"), setStatesStylesFromModel(Yn, zn, "areaStyle");
        var ta = zn.getModel("areaStyle"), na = ta.isEmpty() && ta.parentModel.isEmpty();
        Yn.ignore = na, each$f(["emphasis", "select", "blur"], function(ia) {
          var Aa = zn.getModel([ia, "areaStyle"]), sa = Aa.isEmpty() && Aa.parentModel.isEmpty();
          Yn.ensureState(ia).ignore = sa && na;
        }), Yn.useStyle(defaults(ta.getAreaStyle(), {
          fill: ea,
          opacity: 0.7,
          decal: Xn.decal
        }));
        var ra = zn.getModel("emphasis"), aa = ra.getModel("itemStyle").getItemStyle();
        Wn.eachChild(function(ia) {
          if (ia instanceof ZRImage$1) {
            var Aa = ia.style;
            ia.useStyle(extend({
              // TODO other properties like x, y ?
              image: Aa.image,
              x: Aa.x,
              y: Aa.y,
              width: Aa.width,
              height: Aa.height
            }, Xn));
          } else
            ia.useStyle(Xn), ia.setColor(ea), ia.style.strokeNoScale = !0;
          var sa = ia.ensureState("emphasis");
          sa.style = clone$4(aa);
          var oa = $n.getStore().get($n.getDimensionIndex(ia.__dimIdx), Hn);
          (oa == null || isNaN(oa)) && (oa = ""), setLabelStyle(ia, getLabelStatesModels(zn), {
            labelFetcher: $n.hostModel,
            labelDataIndex: Hn,
            labelDimIndex: ia.__dimIdx,
            defaultText: oa,
            inheritColor: ea,
            defaultOpacity: Xn.opacity
          });
        }), toggleHoverEmphasis(Un, ra.get("focus"), ra.get("blurScope"), ra.get("disabled"));
      }), this._data = $n;
    }, nr.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, nr.type = "radar", nr;
  }(ChartView$1)
);
const RadarView$3 = RadarView$2;
var RadarSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.hasSymbolVisual = !0, Cn;
    }
    return nr.prototype.init = function(Cn) {
      _n.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
    }, nr.prototype.getInitialData = function(Cn, Bn) {
      return createSeriesDataSimply(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      var Dn = this.getData(), Ln = this.coordinateSystem, $n = Ln.getIndicatorAxes(), Nn = this.getData().getName(Cn), Rn = Nn === "" ? this.name : Nn, Fn = retrieveVisualColorForTooltipMarker(this, Cn);
      return createTooltipMarkup("section", {
        header: Rn,
        sortBlocks: !0,
        blocks: map$1($n, function(Pn) {
          var Un = Dn.get(Dn.mapDimension(Pn.dim), Cn);
          return createTooltipMarkup("nameValue", {
            markerType: "subItem",
            markerColor: Fn,
            name: Pn.name,
            value: Un,
            sortParam: Un
          });
        })
      });
    }, nr.prototype.getTooltipPosition = function(Cn) {
      if (Cn != null) {
        for (var Bn = this.getData(), In = this.coordinateSystem, Dn = Bn.getValues(map$1(In.dimensions, function(Rn) {
          return Bn.mapDimension(Rn);
        }), Cn), Ln = 0, $n = Dn.length; Ln < $n; Ln++)
          if (!isNaN(Dn[Ln])) {
            var Nn = In.getIndicatorAxes();
            return In.coordToPoint(Nn[Ln].dataToCoord(Dn[Ln]), Ln);
          }
      }
    }, nr.type = "series.radar", nr.dependencies = ["radar"], nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, nr;
  }(SeriesModel$1)
);
const RadarSeriesModel$1 = RadarSeriesModel;
var valueAxisDefault = axisDefault.value;
function defaultsShow(_n, nr) {
  return defaults({
    show: nr
  }, _n);
}
var RadarModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.optionUpdated = function() {
      var Cn = this.get("boundaryGap"), Bn = this.get("splitNumber"), In = this.get("scale"), Dn = this.get("axisLine"), Ln = this.get("axisTick"), $n = this.get("axisLabel"), Nn = this.get("axisName"), Rn = this.get(["axisName", "show"]), Fn = this.get(["axisName", "formatter"]), Pn = this.get("axisNameGap"), Un = this.get("triggerEvent"), Hn = map$1(this.get("indicator") || [], function(zn) {
        zn.max != null && zn.max > 0 && !zn.min ? zn.min = 0 : zn.min != null && zn.min < 0 && !zn.max && (zn.max = 0);
        var Gn = Nn;
        zn.color != null && (Gn = defaults({
          color: zn.color
        }, Nn));
        var Yn = merge$1(clone$4(zn), {
          boundaryGap: Cn,
          splitNumber: Bn,
          scale: In,
          axisLine: Dn,
          axisTick: Ln,
          // axisType: axisType,
          axisLabel: $n,
          // Compatible with 2 and use text
          name: zn.text,
          showName: Rn,
          nameLocation: "end",
          nameGap: Pn,
          // min: 0,
          nameTextStyle: Gn,
          triggerEvent: Un
        }, !1);
        if (isString$1(Fn)) {
          var Wn = Yn.name;
          Yn.name = Fn.replace("{value}", Wn ?? "");
        } else
          isFunction$1(Fn) && (Yn.name = Fn(Yn.name, Yn));
        var Xn = new Model$1(Yn, null, this.ecModel);
        return mixin(Xn, AxisModelCommonMixin.prototype), Xn.mainType = "radar", Xn.componentIndex = this.componentIndex, Xn;
      }, this);
      this._indicatorModels = Hn;
    }, nr.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, nr.type = "radar", nr.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: !0
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: merge$1({
        lineStyle: {
          color: "#bbb"
        }
      }, valueAxisDefault.axisLine),
      axisLabel: defaultsShow(valueAxisDefault.axisLabel, !1),
      axisTick: defaultsShow(valueAxisDefault.axisTick, !1),
      // axisType: 'value',
      splitLine: defaultsShow(valueAxisDefault.splitLine, !0),
      splitArea: defaultsShow(valueAxisDefault.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, nr;
  }(ComponentModel$1)
);
const RadarModel$1 = RadarModel;
var axisBuilderAttrs$2 = ["axisLine", "axisTickLabel", "axisName"], RadarView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = this.group;
      Dn.removeAll(), this._buildAxes(Cn), this._buildSplitLineAndArea(Cn);
    }, nr.prototype._buildAxes = function(Cn) {
      var Bn = Cn.coordinateSystem, In = Bn.getIndicatorAxes(), Dn = map$1(In, function(Ln) {
        var $n = Ln.model.get("showName") ? Ln.name : "", Nn = new AxisBuilder$1(Ln.model, {
          axisName: $n,
          position: [Bn.cx, Bn.cy],
          rotation: Ln.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return Nn;
      });
      each$f(Dn, function(Ln) {
        each$f(axisBuilderAttrs$2, Ln.add, Ln), this.group.add(Ln.getGroup());
      }, this);
    }, nr.prototype._buildSplitLineAndArea = function(Cn) {
      var Bn = Cn.coordinateSystem, In = Bn.getIndicatorAxes();
      if (!In.length)
        return;
      var Dn = Cn.get("shape"), Ln = Cn.getModel("splitLine"), $n = Cn.getModel("splitArea"), Nn = Ln.getModel("lineStyle"), Rn = $n.getModel("areaStyle"), Fn = Ln.get("show"), Pn = $n.get("show"), Un = Nn.get("color"), Hn = Rn.get("color"), zn = isArray$4(Un) ? Un : [Un], Gn = isArray$4(Hn) ? Hn : [Hn], Yn = [], Wn = [];
      function Xn(fa, ha, pa) {
        var ya = pa % ha.length;
        return fa[ya] = fa[ya] || [], ya;
      }
      if (Dn === "circle")
        for (var ea = In[0].getTicksCoords(), ta = Bn.cx, na = Bn.cy, ra = 0; ra < ea.length; ra++) {
          if (Fn) {
            var aa = Xn(Yn, zn, ra);
            Yn[aa].push(new Circle$1({
              shape: {
                cx: ta,
                cy: na,
                r: ea[ra].coord
              }
            }));
          }
          if (Pn && ra < ea.length - 1) {
            var aa = Xn(Wn, Gn, ra);
            Wn[aa].push(new Ring$1({
              shape: {
                cx: ta,
                cy: na,
                r0: ea[ra].coord,
                r: ea[ra + 1].coord
              }
            }));
          }
        }
      else
        for (var ia, Aa = map$1(In, function(fa, ha) {
          var pa = fa.getTicksCoords();
          return ia = ia == null ? pa.length - 1 : Math.min(pa.length - 1, ia), map$1(pa, function(ya) {
            return Bn.coordToPoint(ya.coord, ha);
          });
        }), sa = [], ra = 0; ra <= ia; ra++) {
          for (var oa = [], la = 0; la < In.length; la++)
            oa.push(Aa[la][ra]);
          if (oa[0] ? oa.push(oa[0].slice()) : process.env.NODE_ENV !== "production" && console.error("Can't draw value axis " + ra), Fn) {
            var aa = Xn(Yn, zn, ra);
            Yn[aa].push(new Polyline$3({
              shape: {
                points: oa
              }
            }));
          }
          if (Pn && sa) {
            var aa = Xn(Wn, Gn, ra - 1);
            Wn[aa].push(new Polygon$1({
              shape: {
                points: oa.concat(sa)
              }
            }));
          }
          sa = oa.slice().reverse();
        }
      var ua = Nn.getLineStyle(), ca = Rn.getAreaStyle();
      each$f(Wn, function(fa, ha) {
        this.group.add(mergePath(fa, {
          style: defaults({
            stroke: "none",
            fill: Gn[ha % Gn.length]
          }, ca),
          silent: !0
        }));
      }, this), each$f(Yn, function(fa, ha) {
        this.group.add(mergePath(fa, {
          style: defaults({
            fill: "none",
            stroke: zn[ha % zn.length]
          }, ua),
          silent: !0
        }));
      }, this);
    }, nr.type = "radar", nr;
  }(ComponentView$1)
);
const RadarView$1 = RadarView;
var IndicatorAxis = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In) {
      var Dn = _n.call(this, Cn, Bn, In) || this;
      return Dn.type = "value", Dn.angle = 0, Dn.name = "", Dn;
    }
    return nr;
  }(Axis$1)
);
const IndicatorAxis$1 = IndicatorAxis;
var Radar = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.dimensions = [], this._model = nr, this._indicatorAxes = map$1(nr.getIndicatorModels(), function(In, Dn) {
        var Ln = "indicator_" + Dn, $n = new IndicatorAxis$1(
          Ln,
          new IntervalScale$1()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return $n.name = In.get("name"), $n.model = In, In.axis = $n, this.dimensions.push(Ln), $n;
      }, this), this.resize(nr, Bn);
    }
    return _n.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, _n.prototype.dataToPoint = function(nr, Cn) {
      var Bn = this._indicatorAxes[Cn];
      return this.coordToPoint(Bn.dataToCoord(nr), Cn);
    }, _n.prototype.coordToPoint = function(nr, Cn) {
      var Bn = this._indicatorAxes[Cn], In = Bn.angle, Dn = this.cx + nr * Math.cos(In), Ln = this.cy - nr * Math.sin(In);
      return [Dn, Ln];
    }, _n.prototype.pointToData = function(nr) {
      var Cn = nr[0] - this.cx, Bn = nr[1] - this.cy, In = Math.sqrt(Cn * Cn + Bn * Bn);
      Cn /= In, Bn /= In;
      for (var Dn = Math.atan2(-Bn, Cn), Ln = 1 / 0, $n, Nn = -1, Rn = 0; Rn < this._indicatorAxes.length; Rn++) {
        var Fn = this._indicatorAxes[Rn], Pn = Math.abs(Dn - Fn.angle);
        Pn < Ln && ($n = Fn, Nn = Rn, Ln = Pn);
      }
      return [Nn, +($n && $n.coordToData(In))];
    }, _n.prototype.resize = function(nr, Cn) {
      var Bn = nr.get("center"), In = Cn.getWidth(), Dn = Cn.getHeight(), Ln = Math.min(In, Dn) / 2;
      this.cx = parsePercent(Bn[0], In), this.cy = parsePercent(Bn[1], Dn), this.startAngle = nr.get("startAngle") * Math.PI / 180;
      var $n = nr.get("radius");
      (isString$1($n) || isNumber($n)) && ($n = [0, $n]), this.r0 = parsePercent($n[0], Ln), this.r = parsePercent($n[1], Ln), each$f(this._indicatorAxes, function(Nn, Rn) {
        Nn.setExtent(this.r0, this.r);
        var Fn = this.startAngle + Rn * Math.PI * 2 / this._indicatorAxes.length;
        Fn = Math.atan2(Math.sin(Fn), Math.cos(Fn)), Nn.angle = Fn;
      }, this);
    }, _n.prototype.update = function(nr, Cn) {
      var Bn = this._indicatorAxes, In = this._model;
      each$f(Bn, function($n) {
        $n.scale.setExtent(1 / 0, -1 / 0);
      }), nr.eachSeriesByType("radar", function($n, Nn) {
        if (!($n.get("coordinateSystem") !== "radar" || nr.getComponent("radar", $n.get("radarIndex")) !== In)) {
          var Rn = $n.getData();
          each$f(Bn, function(Fn) {
            Fn.scale.unionExtentFromData(Rn, Rn.mapDimension(Fn.dim));
          });
        }
      }, this);
      var Dn = In.get("splitNumber"), Ln = new IntervalScale$1();
      Ln.setExtent(0, Dn), Ln.setInterval(1), each$f(Bn, function($n, Nn) {
        alignScaleTicks($n.scale, $n.model, Ln);
      });
    }, _n.prototype.convertToPixel = function(nr, Cn, Bn) {
      return console.warn("Not implemented."), null;
    }, _n.prototype.convertFromPixel = function(nr, Cn, Bn) {
      return console.warn("Not implemented."), null;
    }, _n.prototype.containPoint = function(nr) {
      return console.warn("Not implemented."), !1;
    }, _n.create = function(nr, Cn) {
      var Bn = [];
      return nr.eachComponent("radar", function(In) {
        var Dn = new _n(In, nr, Cn);
        Bn.push(Dn), In.coordinateSystem = Dn;
      }), nr.eachSeriesByType("radar", function(In) {
        In.get("coordinateSystem") === "radar" && (In.coordinateSystem = Bn[In.get("radarIndex") || 0]);
      }), Bn;
    }, _n.dimensions = [], _n;
  }()
);
const Radar$1 = Radar;
function install$L(_n) {
  _n.registerCoordinateSystem("radar", Radar$1), _n.registerComponentModel(RadarModel$1), _n.registerComponentView(RadarView$1), _n.registerVisual({
    seriesType: "radar",
    reset: function(nr) {
      var Cn = nr.getData();
      Cn.each(function(Bn) {
        Cn.setItemVisual(Bn, "legendIcon", "roundRect");
      }), Cn.setVisual("legendIcon", "roundRect");
    }
  });
}
function install$K(_n) {
  use(install$L), _n.registerChartView(RadarView$3), _n.registerSeriesModel(RadarSeriesModel$1), _n.registerLayout(radarLayout), _n.registerProcessor(dataFilter$1("radar")), _n.registerPreprocessor(radarBackwardCompat);
}
var ATTR = "\0_ec_interaction_mutex";
function take(_n, nr, Cn) {
  var Bn = getStore(_n);
  Bn[nr] = Cn;
}
function release(_n, nr, Cn) {
  var Bn = getStore(_n), In = Bn[nr];
  In === Cn && (Bn[nr] = null);
}
function isTaken(_n, nr) {
  return !!getStore(_n)[nr];
}
function getStore(_n) {
  return _n[ATTR] || (_n[ATTR] = {});
}
registerAction({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, noop$1);
var RoamController = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this) || this;
      Bn._zr = Cn;
      var In = bind$1(Bn._mousedownHandler, Bn), Dn = bind$1(Bn._mousemoveHandler, Bn), Ln = bind$1(Bn._mouseupHandler, Bn), $n = bind$1(Bn._mousewheelHandler, Bn), Nn = bind$1(Bn._pinchHandler, Bn);
      return Bn.enable = function(Rn, Fn) {
        this.disable(), this._opt = defaults(clone$4(Fn) || {}, {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0
        }), Rn == null && (Rn = !0), (Rn === !0 || Rn === "move" || Rn === "pan") && (Cn.on("mousedown", In), Cn.on("mousemove", Dn), Cn.on("mouseup", Ln)), (Rn === !0 || Rn === "scale" || Rn === "zoom") && (Cn.on("mousewheel", $n), Cn.on("pinch", Nn));
      }, Bn.disable = function() {
        Cn.off("mousedown", In), Cn.off("mousemove", Dn), Cn.off("mouseup", Ln), Cn.off("mousewheel", $n), Cn.off("pinch", Nn);
      }, Bn;
    }
    return nr.prototype.isDragging = function() {
      return this._dragging;
    }, nr.prototype.isPinching = function() {
      return this._pinching;
    }, nr.prototype.setPointerChecker = function(Cn) {
      this.pointerChecker = Cn;
    }, nr.prototype.dispose = function() {
      this.disable();
    }, nr.prototype._mousedownHandler = function(Cn) {
      if (!isMiddleOrRightButtonOnMouseUpDown(Cn)) {
        for (var Bn = Cn.target; Bn; ) {
          if (Bn.draggable)
            return;
          Bn = Bn.__hostTarget || Bn.parent;
        }
        var In = Cn.offsetX, Dn = Cn.offsetY;
        this.pointerChecker && this.pointerChecker(Cn, In, Dn) && (this._x = In, this._y = Dn, this._dragging = !0);
      }
    }, nr.prototype._mousemoveHandler = function(Cn) {
      if (!(!this._dragging || !isAvailableBehavior("moveOnMouseMove", Cn, this._opt) || Cn.gestureEvent === "pinch" || isTaken(this._zr, "globalPan"))) {
        var Bn = Cn.offsetX, In = Cn.offsetY, Dn = this._x, Ln = this._y, $n = Bn - Dn, Nn = In - Ln;
        this._x = Bn, this._y = In, this._opt.preventDefaultMouseMove && stop(Cn.event), trigger$1(this, "pan", "moveOnMouseMove", Cn, {
          dx: $n,
          dy: Nn,
          oldX: Dn,
          oldY: Ln,
          newX: Bn,
          newY: In,
          isAvailableBehavior: null
        });
      }
    }, nr.prototype._mouseupHandler = function(Cn) {
      isMiddleOrRightButtonOnMouseUpDown(Cn) || (this._dragging = !1);
    }, nr.prototype._mousewheelHandler = function(Cn) {
      var Bn = isAvailableBehavior("zoomOnMouseWheel", Cn, this._opt), In = isAvailableBehavior("moveOnMouseWheel", Cn, this._opt), Dn = Cn.wheelDelta, Ln = Math.abs(Dn), $n = Cn.offsetX, Nn = Cn.offsetY;
      if (!(Dn === 0 || !Bn && !In)) {
        if (Bn) {
          var Rn = Ln > 3 ? 1.4 : Ln > 1 ? 1.2 : 1.1, Fn = Dn > 0 ? Rn : 1 / Rn;
          checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", Cn, {
            scale: Fn,
            originX: $n,
            originY: Nn,
            isAvailableBehavior: null
          });
        }
        if (In) {
          var Pn = Math.abs(Dn), Un = (Dn > 0 ? 1 : -1) * (Pn > 3 ? 0.4 : Pn > 1 ? 0.15 : 0.05);
          checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", Cn, {
            scrollDelta: Un,
            originX: $n,
            originY: Nn,
            isAvailableBehavior: null
          });
        }
      }
    }, nr.prototype._pinchHandler = function(Cn) {
      if (!isTaken(this._zr, "globalPan")) {
        var Bn = Cn.pinchScale > 1 ? 1.1 : 1 / 1.1;
        checkPointerAndTrigger(this, "zoom", null, Cn, {
          scale: Bn,
          originX: Cn.pinchX,
          originY: Cn.pinchY,
          isAvailableBehavior: null
        });
      }
    }, nr;
  }(Eventful$1)
);
function checkPointerAndTrigger(_n, nr, Cn, Bn, In) {
  _n.pointerChecker && _n.pointerChecker(Bn, In.originX, In.originY) && (stop(Bn.event), trigger$1(_n, nr, Cn, Bn, In));
}
function trigger$1(_n, nr, Cn, Bn, In) {
  In.isAvailableBehavior = bind$1(isAvailableBehavior, null, Cn, Bn), _n.trigger(nr, In);
}
function isAvailableBehavior(_n, nr, Cn) {
  var Bn = Cn[_n];
  return !_n || Bn && (!isString$1(Bn) || nr.event[Bn + "Key"]);
}
const RoamController$1 = RoamController;
function updateViewOnPan(_n, nr, Cn) {
  var Bn = _n.target;
  Bn.x += nr, Bn.y += Cn, Bn.dirty();
}
function updateViewOnZoom(_n, nr, Cn, Bn) {
  var In = _n.target, Dn = _n.zoomLimit, Ln = _n.zoom = _n.zoom || 1;
  if (Ln *= nr, Dn) {
    var $n = Dn.min || 0, Nn = Dn.max || 1 / 0;
    Ln = Math.max(Math.min(Nn, Ln), $n);
  }
  var Rn = Ln / _n.zoom;
  _n.zoom = Ln, In.x -= (Cn - In.x) * (Rn - 1), In.y -= (Bn - In.y) * (Rn - 1), In.scaleX *= Rn, In.scaleY *= Rn, In.dirty();
}
var IRRELEVANT_EXCLUDES = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function onIrrelevantElement(_n, nr, Cn) {
  var Bn = nr.getComponentByElement(_n.topTarget), In = Bn && Bn.coordinateSystem;
  return Bn && Bn !== Cn && !IRRELEVANT_EXCLUDES.hasOwnProperty(Bn.mainType) && In && In.model !== Cn;
}
function parseXML(_n) {
  if (isString$1(_n)) {
    var nr = new DOMParser();
    _n = nr.parseFromString(_n, "text/xml");
  }
  var Cn = _n;
  for (Cn.nodeType === 9 && (Cn = Cn.firstChild); Cn.nodeName.toLowerCase() !== "svg" || Cn.nodeType !== 1; )
    Cn = Cn.nextSibling;
  return Cn;
}
var nodeParsers, INHERITABLE_STYLE_ATTRIBUTES_MAP = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP), SELF_STYLE_ATTRIBUTES_MAP = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP), SVGParser = function() {
  function _n() {
    this._defs = {}, this._root = null;
  }
  return _n.prototype.parse = function(nr, Cn) {
    Cn = Cn || {};
    var Bn = parseXML(nr);
    if (process.env.NODE_ENV !== "production" && !Bn)
      throw new Error("Illegal svg");
    this._defsUsePending = [];
    var In = new Group$4();
    this._root = In;
    var Dn = [], Ln = Bn.getAttribute("viewBox") || "", $n = parseFloat(Bn.getAttribute("width") || Cn.width), Nn = parseFloat(Bn.getAttribute("height") || Cn.height);
    isNaN($n) && ($n = null), isNaN(Nn) && (Nn = null), parseAttributes(Bn, In, null, !0, !1);
    for (var Rn = Bn.firstChild; Rn; )
      this._parseNode(Rn, In, Dn, null, !1, !1), Rn = Rn.nextSibling;
    applyDefs(this._defs, this._defsUsePending), this._defsUsePending = [];
    var Fn, Pn;
    if (Ln) {
      var Un = splitNumberSequence(Ln);
      Un.length >= 4 && (Fn = {
        x: parseFloat(Un[0] || 0),
        y: parseFloat(Un[1] || 0),
        width: parseFloat(Un[2]),
        height: parseFloat(Un[3])
      });
    }
    if (Fn && $n != null && Nn != null && (Pn = makeViewBoxTransform(Fn, { x: 0, y: 0, width: $n, height: Nn }), !Cn.ignoreViewBox)) {
      var Hn = In;
      In = new Group$4(), In.add(Hn), Hn.scaleX = Hn.scaleY = Pn.scale, Hn.x = Pn.x, Hn.y = Pn.y;
    }
    return !Cn.ignoreRootClip && $n != null && Nn != null && In.setClipPath(new Rect$3({
      shape: { x: 0, y: 0, width: $n, height: Nn }
    })), {
      root: In,
      width: $n,
      height: Nn,
      viewBoxRect: Fn,
      viewBoxTransform: Pn,
      named: Dn
    };
  }, _n.prototype._parseNode = function(nr, Cn, Bn, In, Dn, Ln) {
    var $n = nr.nodeName.toLowerCase(), Nn, Rn = In;
    if ($n === "defs" && (Dn = !0), $n === "text" && (Ln = !0), $n === "defs" || $n === "switch")
      Nn = Cn;
    else {
      if (!Dn) {
        var Fn = nodeParsers[$n];
        if (Fn && hasOwn(nodeParsers, $n)) {
          Nn = Fn.call(this, nr, Cn);
          var Pn = nr.getAttribute("name");
          if (Pn) {
            var Un = {
              name: Pn,
              namedFrom: null,
              svgNodeTagLower: $n,
              el: Nn
            };
            Bn.push(Un), $n === "g" && (Rn = Un);
          } else
            In && Bn.push({
              name: In.name,
              namedFrom: In,
              svgNodeTagLower: $n,
              el: Nn
            });
          Cn.add(Nn);
        }
      }
      var Hn = paintServerParsers[$n];
      if (Hn && hasOwn(paintServerParsers, $n)) {
        var zn = Hn.call(this, nr), Gn = nr.getAttribute("id");
        Gn && (this._defs[Gn] = zn);
      }
    }
    if (Nn && Nn.isGroup)
      for (var Yn = nr.firstChild; Yn; )
        Yn.nodeType === 1 ? this._parseNode(Yn, Nn, Bn, Rn, Dn, Ln) : Yn.nodeType === 3 && Ln && this._parseText(Yn, Nn), Yn = Yn.nextSibling;
  }, _n.prototype._parseText = function(nr, Cn) {
    var Bn = new TSpan$1({
      style: {
        text: nr.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    inheritStyle(Cn, Bn), parseAttributes(nr, Bn, this._defsUsePending, !1, !1), applyTextAlignment(Bn, Cn);
    var In = Bn.style, Dn = In.fontSize;
    Dn && Dn < 9 && (In.fontSize = 9, Bn.scaleX *= Dn / 9, Bn.scaleY *= Dn / 9);
    var Ln = (In.fontSize || In.fontFamily) && [
      In.fontStyle,
      In.fontWeight,
      (In.fontSize || 12) + "px",
      In.fontFamily || "sans-serif"
    ].join(" ");
    In.font = Ln;
    var $n = Bn.getBoundingRect();
    return this._textX += $n.width, Cn.add(Bn), Bn;
  }, _n.internalField = function() {
    nodeParsers = {
      g: function(nr, Cn) {
        var Bn = new Group$4();
        return inheritStyle(Cn, Bn), parseAttributes(nr, Bn, this._defsUsePending, !1, !1), Bn;
      },
      rect: function(nr, Cn) {
        var Bn = new Rect$3();
        return inheritStyle(Cn, Bn), parseAttributes(nr, Bn, this._defsUsePending, !1, !1), Bn.setShape({
          x: parseFloat(nr.getAttribute("x") || "0"),
          y: parseFloat(nr.getAttribute("y") || "0"),
          width: parseFloat(nr.getAttribute("width") || "0"),
          height: parseFloat(nr.getAttribute("height") || "0")
        }), Bn.silent = !0, Bn;
      },
      circle: function(nr, Cn) {
        var Bn = new Circle$1();
        return inheritStyle(Cn, Bn), parseAttributes(nr, Bn, this._defsUsePending, !1, !1), Bn.setShape({
          cx: parseFloat(nr.getAttribute("cx") || "0"),
          cy: parseFloat(nr.getAttribute("cy") || "0"),
          r: parseFloat(nr.getAttribute("r") || "0")
        }), Bn.silent = !0, Bn;
      },
      line: function(nr, Cn) {
        var Bn = new Line$3();
        return inheritStyle(Cn, Bn), parseAttributes(nr, Bn, this._defsUsePending, !1, !1), Bn.setShape({
          x1: parseFloat(nr.getAttribute("x1") || "0"),
          y1: parseFloat(nr.getAttribute("y1") || "0"),
          x2: parseFloat(nr.getAttribute("x2") || "0"),
          y2: parseFloat(nr.getAttribute("y2") || "0")
        }), Bn.silent = !0, Bn;
      },
      ellipse: function(nr, Cn) {
        var Bn = new Ellipse$1();
        return inheritStyle(Cn, Bn), parseAttributes(nr, Bn, this._defsUsePending, !1, !1), Bn.setShape({
          cx: parseFloat(nr.getAttribute("cx") || "0"),
          cy: parseFloat(nr.getAttribute("cy") || "0"),
          rx: parseFloat(nr.getAttribute("rx") || "0"),
          ry: parseFloat(nr.getAttribute("ry") || "0")
        }), Bn.silent = !0, Bn;
      },
      polygon: function(nr, Cn) {
        var Bn = nr.getAttribute("points"), In;
        Bn && (In = parsePoints(Bn));
        var Dn = new Polygon$1({
          shape: {
            points: In || []
          },
          silent: !0
        });
        return inheritStyle(Cn, Dn), parseAttributes(nr, Dn, this._defsUsePending, !1, !1), Dn;
      },
      polyline: function(nr, Cn) {
        var Bn = nr.getAttribute("points"), In;
        Bn && (In = parsePoints(Bn));
        var Dn = new Polyline$3({
          shape: {
            points: In || []
          },
          silent: !0
        });
        return inheritStyle(Cn, Dn), parseAttributes(nr, Dn, this._defsUsePending, !1, !1), Dn;
      },
      image: function(nr, Cn) {
        var Bn = new ZRImage$1();
        return inheritStyle(Cn, Bn), parseAttributes(nr, Bn, this._defsUsePending, !1, !1), Bn.setStyle({
          image: nr.getAttribute("xlink:href") || nr.getAttribute("href"),
          x: +nr.getAttribute("x"),
          y: +nr.getAttribute("y"),
          width: +nr.getAttribute("width"),
          height: +nr.getAttribute("height")
        }), Bn.silent = !0, Bn;
      },
      text: function(nr, Cn) {
        var Bn = nr.getAttribute("x") || "0", In = nr.getAttribute("y") || "0", Dn = nr.getAttribute("dx") || "0", Ln = nr.getAttribute("dy") || "0";
        this._textX = parseFloat(Bn) + parseFloat(Dn), this._textY = parseFloat(In) + parseFloat(Ln);
        var $n = new Group$4();
        return inheritStyle(Cn, $n), parseAttributes(nr, $n, this._defsUsePending, !1, !0), $n;
      },
      tspan: function(nr, Cn) {
        var Bn = nr.getAttribute("x"), In = nr.getAttribute("y");
        Bn != null && (this._textX = parseFloat(Bn)), In != null && (this._textY = parseFloat(In));
        var Dn = nr.getAttribute("dx") || "0", Ln = nr.getAttribute("dy") || "0", $n = new Group$4();
        return inheritStyle(Cn, $n), parseAttributes(nr, $n, this._defsUsePending, !1, !0), this._textX += parseFloat(Dn), this._textY += parseFloat(Ln), $n;
      },
      path: function(nr, Cn) {
        var Bn = nr.getAttribute("d") || "", In = createFromString(Bn);
        return inheritStyle(Cn, In), parseAttributes(nr, In, this._defsUsePending, !1, !1), In.silent = !0, In;
      }
    };
  }(), _n;
}(), paintServerParsers = {
  lineargradient: function(_n) {
    var nr = parseInt(_n.getAttribute("x1") || "0", 10), Cn = parseInt(_n.getAttribute("y1") || "0", 10), Bn = parseInt(_n.getAttribute("x2") || "10", 10), In = parseInt(_n.getAttribute("y2") || "0", 10), Dn = new LinearGradient$1(nr, Cn, Bn, In);
    return parsePaintServerUnit(_n, Dn), parseGradientColorStops(_n, Dn), Dn;
  },
  radialgradient: function(_n) {
    var nr = parseInt(_n.getAttribute("cx") || "0", 10), Cn = parseInt(_n.getAttribute("cy") || "0", 10), Bn = parseInt(_n.getAttribute("r") || "0", 10), In = new RadialGradient$1(nr, Cn, Bn);
    return parsePaintServerUnit(_n, In), parseGradientColorStops(_n, In), In;
  }
};
function parsePaintServerUnit(_n, nr) {
  var Cn = _n.getAttribute("gradientUnits");
  Cn === "userSpaceOnUse" && (nr.global = !0);
}
function parseGradientColorStops(_n, nr) {
  for (var Cn = _n.firstChild; Cn; ) {
    if (Cn.nodeType === 1 && Cn.nodeName.toLocaleLowerCase() === "stop") {
      var Bn = Cn.getAttribute("offset"), In = void 0;
      Bn && Bn.indexOf("%") > 0 ? In = parseInt(Bn, 10) / 100 : Bn ? In = parseFloat(Bn) : In = 0;
      var Dn = {};
      parseInlineStyle(Cn, Dn, Dn);
      var Ln = Dn.stopColor || Cn.getAttribute("stop-color") || "#000000";
      nr.colorStops.push({
        offset: In,
        color: Ln
      });
    }
    Cn = Cn.nextSibling;
  }
}
function inheritStyle(_n, nr) {
  _n && _n.__inheritedStyle && (nr.__inheritedStyle || (nr.__inheritedStyle = {}), defaults(nr.__inheritedStyle, _n.__inheritedStyle));
}
function parsePoints(_n) {
  for (var nr = splitNumberSequence(_n), Cn = [], Bn = 0; Bn < nr.length; Bn += 2) {
    var In = parseFloat(nr[Bn]), Dn = parseFloat(nr[Bn + 1]);
    Cn.push([In, Dn]);
  }
  return Cn;
}
function parseAttributes(_n, nr, Cn, Bn, In) {
  var Dn = nr, Ln = Dn.__inheritedStyle = Dn.__inheritedStyle || {}, $n = {};
  _n.nodeType === 1 && (parseTransformAttribute(_n, nr), parseInlineStyle(_n, Ln, $n), Bn || parseAttributeStyle(_n, Ln, $n)), Dn.style = Dn.style || {}, Ln.fill != null && (Dn.style.fill = getFillStrokeStyle(Dn, "fill", Ln.fill, Cn)), Ln.stroke != null && (Dn.style.stroke = getFillStrokeStyle(Dn, "stroke", Ln.stroke, Cn)), each$f([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(Nn) {
    Ln[Nn] != null && (Dn.style[Nn] = parseFloat(Ln[Nn]));
  }), each$f([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(Nn) {
    Ln[Nn] != null && (Dn.style[Nn] = Ln[Nn]);
  }), In && (Dn.__selfStyle = $n), Ln.lineDash && (Dn.style.lineDash = map$1(splitNumberSequence(Ln.lineDash), function(Nn) {
    return parseFloat(Nn);
  })), (Ln.visibility === "hidden" || Ln.visibility === "collapse") && (Dn.invisible = !0), Ln.display === "none" && (Dn.ignore = !0);
}
function applyTextAlignment(_n, nr) {
  var Cn = nr.__selfStyle;
  if (Cn) {
    var Bn = Cn.textBaseline, In = Bn;
    !Bn || Bn === "auto" || Bn === "baseline" ? In = "alphabetic" : Bn === "before-edge" || Bn === "text-before-edge" ? In = "top" : Bn === "after-edge" || Bn === "text-after-edge" ? In = "bottom" : (Bn === "central" || Bn === "mathematical") && (In = "middle"), _n.style.textBaseline = In;
  }
  var Dn = nr.__inheritedStyle;
  if (Dn) {
    var Ln = Dn.textAlign, $n = Ln;
    Ln && (Ln === "middle" && ($n = "center"), _n.style.textAlign = $n);
  }
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(_n, nr, Cn, Bn) {
  var In = Cn && Cn.match(urlRegex);
  if (In) {
    var Dn = trim$1(In[1]);
    Bn.push([_n, nr, Dn]);
    return;
  }
  return Cn === "none" && (Cn = null), Cn;
}
function applyDefs(_n, nr) {
  for (var Cn = 0; Cn < nr.length; Cn++) {
    var Bn = nr[Cn];
    Bn[0].style[Bn[1]] = _n[Bn[2]];
  }
}
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(_n) {
  return _n.match(numberReg) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(_n, nr) {
  var Cn = _n.getAttribute("transform");
  if (Cn) {
    Cn = Cn.replace(/,/g, " ");
    var Bn = [], In = null;
    Cn.replace(transformRegex, function(Pn, Un, Hn) {
      return Bn.push(Un, Hn), "";
    });
    for (var Dn = Bn.length - 1; Dn > 0; Dn -= 2) {
      var Ln = Bn[Dn], $n = Bn[Dn - 1], Nn = splitNumberSequence(Ln);
      switch (In = In || create$1(), $n) {
        case "translate":
          translate(In, In, [parseFloat(Nn[0]), parseFloat(Nn[1] || "0")]);
          break;
        case "scale":
          scale$1(In, In, [parseFloat(Nn[0]), parseFloat(Nn[1] || Nn[0])]);
          break;
        case "rotate":
          rotate(In, In, -parseFloat(Nn[0]) * DEGREE_TO_ANGLE, [
            parseFloat(Nn[1] || "0"),
            parseFloat(Nn[2] || "0")
          ]);
          break;
        case "skewX":
          var Rn = Math.tan(parseFloat(Nn[0]) * DEGREE_TO_ANGLE);
          mul(In, [1, 0, Rn, 1, 0, 0], In);
          break;
        case "skewY":
          var Fn = Math.tan(parseFloat(Nn[0]) * DEGREE_TO_ANGLE);
          mul(In, [1, Fn, 0, 1, 0, 0], In);
          break;
        case "matrix":
          In[0] = parseFloat(Nn[0]), In[1] = parseFloat(Nn[1]), In[2] = parseFloat(Nn[2]), In[3] = parseFloat(Nn[3]), In[4] = parseFloat(Nn[4]), In[5] = parseFloat(Nn[5]);
          break;
      }
    }
    nr.setLocalTransform(In);
  }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(_n, nr, Cn) {
  var Bn = _n.getAttribute("style");
  if (Bn) {
    styleRegex.lastIndex = 0;
    for (var In; (In = styleRegex.exec(Bn)) != null; ) {
      var Dn = In[1], Ln = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, Dn) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[Dn] : null;
      Ln && (nr[Ln] = In[2]);
      var $n = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, Dn) ? SELF_STYLE_ATTRIBUTES_MAP[Dn] : null;
      $n && (Cn[$n] = In[2]);
    }
  }
}
function parseAttributeStyle(_n, nr, Cn) {
  for (var Bn = 0; Bn < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; Bn++) {
    var In = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[Bn], Dn = _n.getAttribute(In);
    Dn != null && (nr[INHERITABLE_STYLE_ATTRIBUTES_MAP[In]] = Dn);
  }
  for (var Bn = 0; Bn < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; Bn++) {
    var In = SELF_STYLE_ATTRIBUTES_MAP_KEYS[Bn], Dn = _n.getAttribute(In);
    Dn != null && (Cn[SELF_STYLE_ATTRIBUTES_MAP[In]] = Dn);
  }
}
function makeViewBoxTransform(_n, nr) {
  var Cn = nr.width / _n.width, Bn = nr.height / _n.height, In = Math.min(Cn, Bn);
  return {
    scale: In,
    x: -(_n.x + _n.width / 2) * In + (nr.x + nr.width / 2),
    y: -(_n.y + _n.height / 2) * In + (nr.y + nr.height / 2)
  };
}
function parseSVG(_n, nr) {
  var Cn = new SVGParser();
  return Cn.parse(_n, nr);
}
var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), GeoSVGResource = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.type = "geoSVG", this._usedGraphicMap = createHashMap(), this._freedGraphics = [], this._mapName = nr, this._parsedXML = parseXML(Cn);
    }
    return _n.prototype.load = function() {
      var nr = this._firstGraphic;
      if (!nr) {
        nr = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(nr), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var Cn = createRegions(nr.named), Bn = Cn.regions, In = Cn.regionsMap;
        this._regions = Bn, this._regionsMap = In;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, _n.prototype._buildGraphic = function(nr) {
      var Cn, Bn;
      try {
        Cn = nr && parseSVG(nr, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, Bn = Cn.root, assert(Bn != null);
      } catch (Yn) {
        throw new Error(`Invalid svg format
` + Yn.message);
      }
      var In = new Group$4();
      In.add(Bn), In.isGeoSVGGraphicRoot = !0;
      var Dn = Cn.width, Ln = Cn.height, $n = Cn.viewBoxRect, Nn = this._boundingRect;
      if (!Nn) {
        var Rn = void 0, Fn = void 0, Pn = void 0, Un = void 0;
        if (Dn != null ? (Rn = 0, Pn = Dn) : $n && (Rn = $n.x, Pn = $n.width), Ln != null ? (Fn = 0, Un = Ln) : $n && (Fn = $n.y, Un = $n.height), Rn == null || Fn == null) {
          var Hn = Bn.getBoundingRect();
          Rn == null && (Rn = Hn.x, Pn = Hn.width), Fn == null && (Fn = Hn.y, Un = Hn.height);
        }
        Nn = this._boundingRect = new BoundingRect$1(Rn, Fn, Pn, Un);
      }
      if ($n) {
        var zn = makeViewBoxTransform($n, Nn);
        Bn.scaleX = Bn.scaleY = zn.scale, Bn.x = zn.x, Bn.y = zn.y;
      }
      In.setClipPath(new Rect$3({
        shape: Nn.plain()
      }));
      var Gn = [];
      return each$f(Cn.named, function(Yn) {
        REGION_AVAILABLE_SVG_TAG_MAP.get(Yn.svgNodeTagLower) != null && (Gn.push(Yn), setSilent(Yn.el));
      }), {
        root: In,
        boundingRect: Nn,
        named: Gn
      };
    }, _n.prototype.useGraphic = function(nr) {
      var Cn = this._usedGraphicMap, Bn = Cn.get(nr);
      return Bn || (Bn = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), Cn.set(nr, Bn), Bn);
    }, _n.prototype.freeGraphic = function(nr) {
      var Cn = this._usedGraphicMap, Bn = Cn.get(nr);
      Bn && (Cn.removeKey(nr), this._freedGraphics.push(Bn));
    }, _n;
  }()
);
function setSilent(_n) {
  _n.silent = !1, _n.isGroup && _n.traverse(function(nr) {
    nr.silent = !1;
  });
}
function createRegions(_n) {
  var nr = [], Cn = createHashMap();
  return each$f(_n, function(Bn) {
    if (Bn.namedFrom == null) {
      var In = new GeoSVGRegion(Bn.name, Bn.el);
      nr.push(In), Cn.set(Bn.name, In);
    }
  }), {
    regions: nr,
    regionsMap: Cn
  };
}
var geoCoord = [126, 25], nanhaiName = "南海诸岛", points$1 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var i = 0; i < points$1.length; i++)
  for (var k = 0; k < points$1[i].length; k++)
    points$1[i][k][0] /= 10.5, points$1[i][k][1] /= -10.5 / 0.75, points$1[i][k][0] += geoCoord[0], points$1[i][k][1] += geoCoord[1];
function fixNanhai(_n, nr) {
  if (_n === "china") {
    for (var Cn = 0; Cn < nr.length; Cn++)
      if (nr[Cn].name === nanhaiName)
        return;
    nr.push(new GeoJSONRegion(nanhaiName, map$1(points$1, function(Bn) {
      return {
        type: "polygon",
        exterior: Bn
      };
    }), geoCoord));
  }
}
var coordsOffsetMap = {
  南海诸岛: [32, 80],
  // 全国
  广东: [0, -10],
  香港: [10, 5],
  澳门: [-10, 10],
  // '北京': [-10, 0],
  天津: [5, 5]
};
function fixTextCoords(_n, nr) {
  if (_n === "china") {
    var Cn = coordsOffsetMap[nr.name];
    if (Cn) {
      var Bn = nr.getCenter();
      Bn[0] += Cn[0] / 10.5, Bn[1] += -Cn[1] / (10.5 / 0.75), nr.setCenter(Bn);
    }
  }
}
var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function fixDiaoyuIsland(_n, nr) {
  _n === "china" && nr.name === "台湾" && nr.geometries.push({
    type: "polygon",
    exterior: points[0]
  });
}
var DEFAULT_NAME_PROPERTY = "name", GeoJSONResource = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.type = "geoJSON", this._parsedMap = createHashMap(), this._mapName = nr, this._specialAreas = Bn, this._geoJSON = parseInput(Cn);
    }
    return _n.prototype.load = function(nr, Cn) {
      Cn = Cn || DEFAULT_NAME_PROPERTY;
      var Bn = this._parsedMap.get(Cn);
      if (!Bn) {
        var In = this._parseToRegions(Cn);
        Bn = this._parsedMap.set(Cn, {
          regions: In,
          boundingRect: calculateBoundingRect(In)
        });
      }
      var Dn = createHashMap(), Ln = [];
      return each$f(Bn.regions, function($n) {
        var Nn = $n.name;
        nr && hasOwn(nr, Nn) && ($n = $n.cloneShallow(Nn = nr[Nn])), Ln.push($n), Dn.set(Nn, $n);
      }), {
        regions: Ln,
        boundingRect: Bn.boundingRect || new BoundingRect$1(0, 0, 0, 0),
        regionsMap: Dn
      };
    }, _n.prototype._parseToRegions = function(nr) {
      var Cn = this._mapName, Bn = this._geoJSON, In;
      try {
        In = Bn ? parseGeoJSON(Bn, nr) : [];
      } catch (Dn) {
        throw new Error(`Invalid geoJson format
` + Dn.message);
      }
      return fixNanhai(Cn, In), each$f(In, function(Dn) {
        var Ln = Dn.name;
        fixTextCoords(Cn, Dn), fixDiaoyuIsland(Cn, Dn);
        var $n = this._specialAreas && this._specialAreas[Ln];
        $n && Dn.transformTo($n.left, $n.top, $n.width, $n.height);
      }, this), In;
    }, _n.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, _n;
  }()
);
function calculateBoundingRect(_n) {
  for (var nr, Cn = 0; Cn < _n.length; Cn++) {
    var Bn = _n[Cn].getBoundingRect();
    nr = nr || Bn.clone(), nr.union(Bn);
  }
  return nr;
}
function parseInput(_n) {
  return isString$1(_n) ? typeof JSON < "u" && JSON.parse ? JSON.parse(_n) : new Function("return (" + _n + ");")() : _n;
}
var storage = createHashMap();
const geoSourceManager = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(_n, nr, Cn) {
    if (nr.svg) {
      var Bn = new GeoSVGResource(_n, nr.svg);
      storage.set(_n, Bn);
    } else {
      var In = nr.geoJson || nr.geoJSON;
      In && !nr.features ? Cn = nr.specialAreas : In = nr;
      var Bn = new GeoJSONResource(_n, In, Cn);
      storage.set(_n, Bn);
    }
  },
  getGeoResource: function(_n) {
    return storage.get(_n);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(_n) {
    var nr = storage.get(_n);
    return nr && nr.type === "geoJSON" && nr.getMapForUser();
  },
  load: function(_n, nr, Cn) {
    var Bn = storage.get(_n);
    if (!Bn) {
      process.env.NODE_ENV !== "production" && console.error("Map " + _n + " not exists. The GeoJSON of the map must be provided.");
      return;
    }
    return Bn.load(nr, Cn);
  }
};
var OPTION_STYLE_ENABLED_TAGS = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS), STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"])), LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"])), mapLabelRaw = makeInner();
function getFixedItemStyle(_n) {
  var nr = _n.getItemStyle(), Cn = _n.get("areaColor");
  return Cn != null && (nr.fill = Cn), nr;
}
function fixLineStyle(_n) {
  var nr = _n.style;
  nr && (nr.stroke = nr.stroke || nr.fill, nr.fill = null);
}
var MapDraw = (
  /** @class */
  function() {
    function _n(nr) {
      var Cn = new Group$4();
      this.uid = getUID("ec_map_draw"), this._controller = new RoamController$1(nr.getZr()), this._controllerHost = {
        target: Cn
      }, this.group = Cn, Cn.add(this._regionsGroup = new Group$4()), Cn.add(this._svgGroup = new Group$4());
    }
    return _n.prototype.draw = function(nr, Cn, Bn, In, Dn) {
      var Ln = nr.mainType === "geo", $n = nr.getData && nr.getData();
      Ln && Cn.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(Wn) {
        !$n && Wn.getHostGeoModel() === nr && ($n = Wn.getData());
      });
      var Nn = nr.coordinateSystem, Rn = this._regionsGroup, Fn = this.group, Pn = Nn.getTransformInfo(), Un = Pn.raw, Hn = Pn.roam, zn = !Rn.childAt(0) || Dn;
      zn ? (Fn.x = Hn.x, Fn.y = Hn.y, Fn.scaleX = Hn.scaleX, Fn.scaleY = Hn.scaleY, Fn.dirty()) : updateProps$1(Fn, Hn, nr);
      var Gn = $n && $n.getVisual("visualMeta") && $n.getVisual("visualMeta").length > 0, Yn = {
        api: Bn,
        geo: Nn,
        mapOrGeoModel: nr,
        data: $n,
        isVisualEncodedByVisualMap: Gn,
        isGeo: Ln,
        transformInfoRaw: Un
      };
      Nn.resourceType === "geoJSON" ? this._buildGeoJSON(Yn) : Nn.resourceType === "geoSVG" && this._buildSVG(Yn), this._updateController(nr, Cn, Bn), this._updateMapSelectHandler(nr, Rn, Bn, In);
    }, _n.prototype._buildGeoJSON = function(nr) {
      var Cn = this._regionsGroupByName = createHashMap(), Bn = createHashMap(), In = this._regionsGroup, Dn = nr.transformInfoRaw, Ln = nr.mapOrGeoModel, $n = nr.data, Nn = nr.geo.projection, Rn = Nn && Nn.stream;
      function Fn(Hn, zn) {
        return zn && (Hn = zn(Hn)), Hn && [Hn[0] * Dn.scaleX + Dn.x, Hn[1] * Dn.scaleY + Dn.y];
      }
      function Pn(Hn) {
        for (var zn = [], Gn = !Rn && Nn && Nn.project, Yn = 0; Yn < Hn.length; ++Yn) {
          var Wn = Fn(Hn[Yn], Gn);
          Wn && zn.push(Wn);
        }
        return zn;
      }
      function Un(Hn) {
        return {
          shape: {
            points: Pn(Hn)
          }
        };
      }
      In.removeAll(), each$f(nr.geo.regions, function(Hn) {
        var zn = Hn.name, Gn = Cn.get(zn), Yn = Bn.get(zn) || {}, Wn = Yn.dataIdx, Xn = Yn.regionModel;
        if (!Gn) {
          Gn = Cn.set(zn, new Group$4()), In.add(Gn), Wn = $n ? $n.indexOfName(zn) : null, Xn = nr.isGeo ? Ln.getRegionModel(zn) : $n ? $n.getItemModel(Wn) : null;
          var ea = Xn.get("silent", !0);
          ea != null && (Gn.silent = ea), Bn.set(zn, {
            dataIdx: Wn,
            regionModel: Xn
          });
        }
        var ta = [], na = [];
        each$f(Hn.geometries, function(ia) {
          if (ia.type === "polygon") {
            var Aa = [ia.exterior].concat(ia.interiors || []);
            Rn && (Aa = projectPolys(Aa, Rn)), each$f(Aa, function(oa) {
              ta.push(new Polygon$1(Un(oa)));
            });
          } else {
            var sa = ia.points;
            Rn && (sa = projectPolys(sa, Rn, !0)), each$f(sa, function(oa) {
              na.push(new Polyline$3(Un(oa)));
            });
          }
        });
        var ra = Fn(Hn.getCenter(), Nn && Nn.project);
        function aa(ia, Aa) {
          if (ia.length) {
            var sa = new CompoundPath$1({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: ia
              }
            });
            Gn.add(sa), applyOptionStyleForRegion(nr, sa, Wn, Xn), resetLabelForRegion(nr, sa, zn, Xn, Ln, Wn, ra), Aa && (fixLineStyle(sa), each$f(sa.states, fixLineStyle));
          }
        }
        aa(ta), aa(na, !0);
      }), Cn.each(function(Hn, zn) {
        var Gn = Bn.get(zn), Yn = Gn.dataIdx, Wn = Gn.regionModel;
        resetEventTriggerForRegion(nr, Hn, zn, Wn, Ln, Yn), resetTooltipForRegion(nr, Hn, zn, Wn, Ln), resetStateTriggerForRegion(nr, Hn, zn, Wn, Ln);
      }, this);
    }, _n.prototype._buildSVG = function(nr) {
      var Cn = nr.geo.map, Bn = nr.transformInfoRaw;
      this._svgGroup.x = Bn.x, this._svgGroup.y = Bn.y, this._svgGroup.scaleX = Bn.scaleX, this._svgGroup.scaleY = Bn.scaleY, this._svgResourceChanged(Cn) && (this._freeSVG(), this._useSVG(Cn));
      var In = this._svgDispatcherMap = createHashMap(), Dn = !1;
      each$f(this._svgGraphicRecord.named, function(Ln) {
        var $n = Ln.name, Nn = nr.mapOrGeoModel, Rn = nr.data, Fn = Ln.svgNodeTagLower, Pn = Ln.el, Un = Rn ? Rn.indexOfName($n) : null, Hn = Nn.getRegionModel($n);
        OPTION_STYLE_ENABLED_TAG_MAP.get(Fn) != null && Pn instanceof Displayable$1 && applyOptionStyleForRegion(nr, Pn, Un, Hn), Pn instanceof Displayable$1 && (Pn.culling = !0);
        var zn = Hn.get("silent", !0);
        if (zn != null && (Pn.silent = zn), Pn.z2EmphasisLift = 0, !Ln.namedFrom && (LABEL_HOST_MAP.get(Fn) != null && resetLabelForRegion(nr, Pn, $n, Hn, Nn, Un, null), resetEventTriggerForRegion(nr, Pn, $n, Hn, Nn, Un), resetTooltipForRegion(nr, Pn, $n, Hn, Nn), STATE_TRIGGER_TAG_MAP.get(Fn) != null)) {
          var Gn = resetStateTriggerForRegion(nr, Pn, $n, Hn, Nn);
          Gn === "self" && (Dn = !0);
          var Yn = In.get($n) || In.set($n, []);
          Yn.push(Pn);
        }
      }, this), this._enableBlurEntireSVG(Dn, nr);
    }, _n.prototype._enableBlurEntireSVG = function(nr, Cn) {
      if (nr && Cn.isGeo) {
        var Bn = Cn.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), In = Bn.opacity;
        this._svgGraphicRecord.root.traverse(function(Dn) {
          if (!Dn.isGroup) {
            setDefaultStateProxy(Dn);
            var Ln = Dn.ensureState("blur").style || {};
            Ln.opacity == null && In != null && (Ln.opacity = In), Dn.ensureState("emphasis");
          }
        });
      }
    }, _n.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, _n.prototype.findHighDownDispatchers = function(nr, Cn) {
      if (nr == null)
        return [];
      var Bn = Cn.coordinateSystem;
      if (Bn.resourceType === "geoJSON") {
        var In = this._regionsGroupByName;
        if (In) {
          var Dn = In.get(nr);
          return Dn ? [Dn] : [];
        }
      } else if (Bn.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(nr) || [];
    }, _n.prototype._svgResourceChanged = function(nr) {
      return this._svgMapName !== nr;
    }, _n.prototype._useSVG = function(nr) {
      var Cn = geoSourceManager.getGeoResource(nr);
      if (Cn && Cn.type === "geoSVG") {
        var Bn = Cn.useGraphic(this.uid);
        this._svgGroup.add(Bn.root), this._svgGraphicRecord = Bn, this._svgMapName = nr;
      }
    }, _n.prototype._freeSVG = function() {
      var nr = this._svgMapName;
      if (nr != null) {
        var Cn = geoSourceManager.getGeoResource(nr);
        Cn && Cn.type === "geoSVG" && Cn.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, _n.prototype._updateController = function(nr, Cn, Bn) {
      var In = nr.coordinateSystem, Dn = this._controller, Ln = this._controllerHost;
      Ln.zoomLimit = nr.get("scaleLimit"), Ln.zoom = In.getZoom(), Dn.enable(nr.get("roam") || !1);
      var $n = nr.mainType;
      function Nn() {
        var Rn = {
          type: "geoRoam",
          componentType: $n
        };
        return Rn[$n + "Id"] = nr.id, Rn;
      }
      Dn.off("pan").on("pan", function(Rn) {
        this._mouseDownFlag = !1, updateViewOnPan(Ln, Rn.dx, Rn.dy), Bn.dispatchAction(extend(Nn(), {
          dx: Rn.dx,
          dy: Rn.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), Dn.off("zoom").on("zoom", function(Rn) {
        this._mouseDownFlag = !1, updateViewOnZoom(Ln, Rn.scale, Rn.originX, Rn.originY), Bn.dispatchAction(extend(Nn(), {
          totalZoom: Ln.zoom,
          zoom: Rn.scale,
          originX: Rn.originX,
          originY: Rn.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), Dn.setPointerChecker(function(Rn, Fn, Pn) {
        return In.containPoint([Fn, Pn]) && !onIrrelevantElement(Rn, Bn, nr);
      });
    }, _n.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(nr) {
        var Cn = nr.getTextContent();
        Cn && (Cn.ignore = mapLabelRaw(Cn).ignore);
      });
    }, _n.prototype._updateMapSelectHandler = function(nr, Cn, Bn, In) {
      var Dn = this;
      Cn.off("mousedown"), Cn.off("click"), nr.get("selectedMode") && (Cn.on("mousedown", function() {
        Dn._mouseDownFlag = !0;
      }), Cn.on("click", function(Ln) {
        Dn._mouseDownFlag && (Dn._mouseDownFlag = !1);
      }));
    }, _n;
  }()
);
function applyOptionStyleForRegion(_n, nr, Cn, Bn) {
  var In = Bn.getModel("itemStyle"), Dn = Bn.getModel(["emphasis", "itemStyle"]), Ln = Bn.getModel(["blur", "itemStyle"]), $n = Bn.getModel(["select", "itemStyle"]), Nn = getFixedItemStyle(In), Rn = getFixedItemStyle(Dn), Fn = getFixedItemStyle($n), Pn = getFixedItemStyle(Ln), Un = _n.data;
  if (Un) {
    var Hn = Un.getItemVisual(Cn, "style"), zn = Un.getItemVisual(Cn, "decal");
    _n.isVisualEncodedByVisualMap && Hn.fill && (Nn.fill = Hn.fill), zn && (Nn.decal = createOrUpdatePatternFromDecal(zn, _n.api));
  }
  nr.setStyle(Nn), nr.style.strokeNoScale = !0, nr.ensureState("emphasis").style = Rn, nr.ensureState("select").style = Fn, nr.ensureState("blur").style = Pn, setDefaultStateProxy(nr);
}
function resetLabelForRegion(_n, nr, Cn, Bn, In, Dn, Ln) {
  var $n = _n.data, Nn = _n.isGeo, Rn = $n && isNaN($n.get($n.mapDimension("value"), Dn)), Fn = $n && $n.getItemLayout(Dn);
  if (Nn || Rn || Fn && Fn.showLabel) {
    var Pn = Nn ? Cn : Dn, Un = void 0;
    (!$n || Dn >= 0) && (Un = In);
    var Hn = Ln ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    setLabelStyle(nr, getLabelStatesModels(Bn), {
      labelFetcher: Un,
      labelDataIndex: Pn,
      defaultText: Cn
    }, Hn);
    var zn = nr.getTextContent();
    if (zn && (mapLabelRaw(zn).ignore = zn.ignore, nr.textConfig && Ln)) {
      var Gn = nr.getBoundingRect().clone();
      nr.textConfig.layoutRect = Gn, nr.textConfig.position = [(Ln[0] - Gn.x) / Gn.width * 100 + "%", (Ln[1] - Gn.y) / Gn.height * 100 + "%"];
    }
    nr.disableLabelAnimation = !0;
  } else
    nr.removeTextContent(), nr.removeTextConfig(), nr.disableLabelAnimation = null;
}
function resetEventTriggerForRegion(_n, nr, Cn, Bn, In, Dn) {
  _n.data ? _n.data.setItemGraphicEl(Dn, nr) : getECData(nr).eventData = {
    componentType: "geo",
    componentIndex: In.componentIndex,
    geoIndex: In.componentIndex,
    name: Cn,
    region: Bn && Bn.option || {}
  };
}
function resetTooltipForRegion(_n, nr, Cn, Bn, In) {
  _n.data || setTooltipConfig({
    el: nr,
    componentModel: In,
    itemName: Cn,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: Bn.get("tooltip")
  });
}
function resetStateTriggerForRegion(_n, nr, Cn, Bn, In) {
  nr.highDownSilentOnTouch = !!In.get("selectedMode");
  var Dn = Bn.getModel("emphasis"), Ln = Dn.get("focus");
  return toggleHoverEmphasis(nr, Ln, Dn.get("blurScope"), Dn.get("disabled")), _n.isGeo && enableComponentHighDownFeatures(nr, In, Cn), Ln;
}
function projectPolys(_n, nr, Cn) {
  var Bn = [], In;
  function Dn() {
    In = [];
  }
  function Ln() {
    In.length && (Bn.push(In), In = []);
  }
  var $n = nr({
    polygonStart: Dn,
    polygonEnd: Ln,
    lineStart: Dn,
    lineEnd: Ln,
    point: function(Nn, Rn) {
      isFinite(Nn) && isFinite(Rn) && In.push([Nn, Rn]);
    },
    sphere: function() {
    }
  });
  return !Cn && $n.polygonStart(), each$f(_n, function(Nn) {
    $n.lineStart();
    for (var Rn = 0; Rn < Nn.length; Rn++)
      $n.point(Nn[Rn][0], Nn[Rn][1]);
    $n.lineEnd();
  }), !Cn && $n.polygonEnd(), Bn;
}
const MapDraw$1 = MapDraw;
var MapView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      if (!(Dn && Dn.type === "mapToggleSelect" && Dn.from === this.uid)) {
        var Ln = this.group;
        if (Ln.removeAll(), !Cn.getHostGeoModel()) {
          if (this._mapDraw && Dn && Dn.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), Dn && Dn.type === "geoRoam" && Dn.componentType === "series" && Dn.seriesId === Cn.id) {
            var $n = this._mapDraw;
            $n && Ln.add($n.group);
          } else if (Cn.needsDrawMap) {
            var $n = this._mapDraw || new MapDraw$1(In);
            Ln.add($n.group), $n.draw(Cn, Bn, In, this, Dn), this._mapDraw = $n;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          Cn.get("showLegendSymbol") && Bn.getComponent("legend") && this._renderSymbols(Cn, Bn, In);
        }
      }
    }, nr.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, nr.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, nr.prototype._renderSymbols = function(Cn, Bn, In) {
      var Dn = Cn.originalData, Ln = this.group;
      Dn.each(Dn.mapDimension("value"), function($n, Nn) {
        if (!isNaN($n)) {
          var Rn = Dn.getItemLayout(Nn);
          if (!(!Rn || !Rn.point)) {
            var Fn = Rn.point, Pn = Rn.offset, Un = new Circle$1({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: Cn.getData().getVisual("style").fill
              },
              shape: {
                cx: Fn[0] + Pn * 9,
                cy: Fn[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (Pn ? 0 : Z2_EMPHASIS_LIFT + 1)
            });
            if (!Pn) {
              var Hn = Cn.mainSeries.getData(), zn = Dn.getName(Nn), Gn = Hn.indexOfName(zn), Yn = Dn.getItemModel(Nn), Wn = Yn.getModel("label"), Xn = Hn.getItemGraphicEl(Gn);
              setLabelStyle(Un, getLabelStatesModels(Yn), {
                labelFetcher: {
                  getFormattedLabel: function(ea, ta) {
                    return Cn.getFormattedLabel(Gn, ta);
                  }
                },
                defaultText: zn
              }), Un.disableLabelAnimation = !0, Wn.get("position") || Un.setTextConfig({
                position: "bottom"
              }), Xn.onHoverStateChange = function(ea) {
                setStatesFlag(Un, ea);
              };
            }
            Ln.add(Un);
          }
        }
      });
    }, nr.type = "map", nr;
  }(ChartView$1)
);
const MapView$1 = MapView;
var MapSeries = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.needsDrawMap = !1, Cn.seriesGroup = [], Cn.getTooltipPosition = function(Bn) {
        if (Bn != null) {
          var In = this.getData().getName(Bn), Dn = this.coordinateSystem, Ln = Dn.getRegion(In);
          return Ln && Dn.dataToPoint(Ln.getCenter());
        }
      }, Cn;
    }
    return nr.prototype.getInitialData = function(Cn) {
      for (var Bn = createSeriesDataSimply(this, {
        coordDimensions: ["value"],
        encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
      }), In = createHashMap(), Dn = [], Ln = 0, $n = Bn.count(); Ln < $n; Ln++) {
        var Nn = Bn.getName(Ln);
        In.set(Nn, Ln);
      }
      var Rn = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return each$f(Rn.regions, function(Fn) {
        var Pn = Fn.name, Un = In.get(Pn), Hn = Fn.properties && Fn.properties.echartsStyle, zn;
        Un == null ? (zn = {
          name: Pn
        }, Dn.push(zn)) : zn = Bn.getRawDataItem(Un), Hn && merge$1(zn, Hn);
      }), Bn.appendData(Dn), Bn;
    }, nr.prototype.getHostGeoModel = function() {
      var Cn = this.option.geoIndex;
      return Cn != null ? this.ecModel.getComponent("geo", Cn) : null;
    }, nr.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, nr.prototype.getRawValue = function(Cn) {
      var Bn = this.getData();
      return Bn.get(Bn.mapDimension("value"), Cn);
    }, nr.prototype.getRegionModel = function(Cn) {
      var Bn = this.getData();
      return Bn.getItemModel(Bn.indexOfName(Cn));
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      for (var Dn = this.getData(), Ln = this.getRawValue(Cn), $n = Dn.getName(Cn), Nn = this.seriesGroup, Rn = [], Fn = 0; Fn < Nn.length; Fn++) {
        var Pn = Nn[Fn].originalData.indexOfName($n), Un = Dn.mapDimension("value");
        isNaN(Nn[Fn].originalData.get(Un, Pn)) || Rn.push(Nn[Fn].name);
      }
      return createTooltipMarkup("section", {
        header: Rn.join(", "),
        noHeader: !Rn.length,
        blocks: [createTooltipMarkup("nameValue", {
          name: $n,
          value: Ln
        })]
      });
    }, nr.prototype.setZoom = function(Cn) {
      this.option.zoom = Cn;
    }, nr.prototype.setCenter = function(Cn) {
      this.option.center = Cn;
    }, nr.prototype.getLegendIcon = function(Cn) {
      var Bn = Cn.icon || "roundRect", In = createSymbol$1(Bn, 0, 0, Cn.itemWidth, Cn.itemHeight, Cn.itemStyle.fill);
      return In.setStyle(Cn.itemStyle), In.style.stroke = "none", Bn.indexOf("empty") > -1 && (In.style.stroke = In.style.fill, In.style.fill = "#fff", In.style.lineWidth = 2), In;
    }, nr.type = "series.map", nr.dependencies = ["geo"], nr.layoutMode = "box", nr.defaultOption = {
      // 一级层叠
      // zlevel: 0,
      // 二级层叠
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, nr;
  }(SeriesModel$1)
);
const MapSeries$1 = MapSeries;
function dataStatistics(_n, nr) {
  var Cn = {};
  return each$f(_n, function(Bn) {
    Bn.each(Bn.mapDimension("value"), function(In, Dn) {
      var Ln = "ec-" + Bn.getName(Dn);
      Cn[Ln] = Cn[Ln] || [], isNaN(In) || Cn[Ln].push(In);
    });
  }), _n[0].map(_n[0].mapDimension("value"), function(Bn, In) {
    for (var Dn = "ec-" + _n[0].getName(In), Ln = 0, $n = 1 / 0, Nn = -1 / 0, Rn = Cn[Dn].length, Fn = 0; Fn < Rn; Fn++)
      $n = Math.min($n, Cn[Dn][Fn]), Nn = Math.max(Nn, Cn[Dn][Fn]), Ln += Cn[Dn][Fn];
    var Pn;
    return nr === "min" ? Pn = $n : nr === "max" ? Pn = Nn : nr === "average" ? Pn = Ln / Rn : Pn = Ln, Rn === 0 ? NaN : Pn;
  });
}
function mapDataStatistic(_n) {
  var nr = {};
  _n.eachSeriesByType("map", function(Cn) {
    var Bn = Cn.getHostGeoModel(), In = Bn ? "o" + Bn.id : "i" + Cn.getMapType();
    (nr[In] = nr[In] || []).push(Cn);
  }), each$f(nr, function(Cn, Bn) {
    for (var In = dataStatistics(map$1(Cn, function(Ln) {
      return Ln.getData();
    }), Cn[0].get("mapValueCalculation")), Dn = 0; Dn < Cn.length; Dn++)
      Cn[Dn].originalData = Cn[Dn].getData();
    for (var Dn = 0; Dn < Cn.length; Dn++)
      Cn[Dn].seriesGroup = Cn, Cn[Dn].needsDrawMap = Dn === 0 && !Cn[Dn].getHostGeoModel(), Cn[Dn].setData(In.cloneShallow()), Cn[Dn].mainSeries = Cn[0];
  });
}
function mapSymbolLayout(_n) {
  var nr = {};
  _n.eachSeriesByType("map", function(Cn) {
    var Bn = Cn.getMapType();
    if (!(Cn.getHostGeoModel() || nr[Bn])) {
      var In = {};
      each$f(Cn.seriesGroup, function(Ln) {
        var $n = Ln.coordinateSystem, Nn = Ln.originalData;
        Ln.get("showLegendSymbol") && _n.getComponent("legend") && Nn.each(Nn.mapDimension("value"), function(Rn, Fn) {
          var Pn = Nn.getName(Fn), Un = $n.getRegion(Pn);
          if (!(!Un || isNaN(Rn))) {
            var Hn = In[Pn] || 0, zn = $n.dataToPoint(Un.getCenter());
            In[Pn] = Hn + 1, Nn.setItemLayout(Fn, {
              point: zn,
              offset: Hn
            });
          }
        });
      });
      var Dn = Cn.getData();
      Dn.each(function(Ln) {
        var $n = Dn.getName(Ln), Nn = Dn.getItemLayout(Ln) || {};
        Nn.showLabel = !In[$n], Dn.setItemLayout(Ln, Nn);
      }), nr[Bn] = !0;
    }
  });
}
var v2ApplyTransform = applyTransform$1, View = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this) || this;
      return Bn.type = "view", Bn.dimensions = ["x", "y"], Bn._roamTransformable = new Transformable$1(), Bn._rawTransformable = new Transformable$1(), Bn.name = Cn, Bn;
    }
    return nr.prototype.setBoundingRect = function(Cn, Bn, In, Dn) {
      return this._rect = new BoundingRect$1(Cn, Bn, In, Dn), this._rect;
    }, nr.prototype.getBoundingRect = function() {
      return this._rect;
    }, nr.prototype.setViewRect = function(Cn, Bn, In, Dn) {
      this._transformTo(Cn, Bn, In, Dn), this._viewRect = new BoundingRect$1(Cn, Bn, In, Dn);
    }, nr.prototype._transformTo = function(Cn, Bn, In, Dn) {
      var Ln = this.getBoundingRect(), $n = this._rawTransformable;
      $n.transform = Ln.calculateTransform(new BoundingRect$1(Cn, Bn, In, Dn));
      var Nn = $n.parent;
      $n.parent = null, $n.decomposeTransform(), $n.parent = Nn, this._updateTransform();
    }, nr.prototype.setCenter = function(Cn, Bn) {
      Cn && (this._center = [parsePercent(Cn[0], Bn.getWidth()), parsePercent(Cn[1], Bn.getHeight())], this._updateCenterAndZoom());
    }, nr.prototype.setZoom = function(Cn) {
      Cn = Cn || 1;
      var Bn = this.zoomLimit;
      Bn && (Bn.max != null && (Cn = Math.min(Bn.max, Cn)), Bn.min != null && (Cn = Math.max(Bn.min, Cn))), this._zoom = Cn, this._updateCenterAndZoom();
    }, nr.prototype.getDefaultCenter = function() {
      var Cn = this.getBoundingRect(), Bn = Cn.x + Cn.width / 2, In = Cn.y + Cn.height / 2;
      return [Bn, In];
    }, nr.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, nr.prototype.getZoom = function() {
      return this._zoom || 1;
    }, nr.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, nr.prototype._updateCenterAndZoom = function() {
      var Cn = this._rawTransformable.getLocalTransform(), Bn = this._roamTransformable, In = this.getDefaultCenter(), Dn = this.getCenter(), Ln = this.getZoom();
      Dn = applyTransform$1([], Dn, Cn), In = applyTransform$1([], In, Cn), Bn.originX = Dn[0], Bn.originY = Dn[1], Bn.x = In[0] - Dn[0], Bn.y = In[1] - Dn[1], Bn.scaleX = Bn.scaleY = Ln, this._updateTransform();
    }, nr.prototype._updateTransform = function() {
      var Cn = this._roamTransformable, Bn = this._rawTransformable;
      Bn.parent = Cn, Cn.updateTransform(), Bn.updateTransform(), copy(this.transform || (this.transform = []), Bn.transform || create$1()), this._rawTransform = Bn.getLocalTransform(), this.invTransform = this.invTransform || [], invert(this.invTransform, this.transform), this.decomposeTransform();
    }, nr.prototype.getTransformInfo = function() {
      var Cn = this._rawTransformable, Bn = this._roamTransformable, In = new Transformable$1();
      return In.transform = Bn.transform, In.decomposeTransform(), {
        roam: {
          x: In.x,
          y: In.y,
          scaleX: In.scaleX,
          scaleY: In.scaleY
        },
        raw: {
          x: Cn.x,
          y: Cn.y,
          scaleX: Cn.scaleX,
          scaleY: Cn.scaleY
        }
      };
    }, nr.prototype.getViewRect = function() {
      return this._viewRect;
    }, nr.prototype.getViewRectAfterRoam = function() {
      var Cn = this.getBoundingRect().clone();
      return Cn.applyTransform(this.transform), Cn;
    }, nr.prototype.dataToPoint = function(Cn, Bn, In) {
      var Dn = Bn ? this._rawTransform : this.transform;
      return In = In || [], Dn ? v2ApplyTransform(In, Cn, Dn) : copy$1(In, Cn);
    }, nr.prototype.pointToData = function(Cn) {
      var Bn = this.invTransform;
      return Bn ? v2ApplyTransform([], Cn, Bn) : [Cn[0], Cn[1]];
    }, nr.prototype.convertToPixel = function(Cn, Bn, In) {
      var Dn = getCoordSys$4(Bn);
      return Dn === this ? Dn.dataToPoint(In) : null;
    }, nr.prototype.convertFromPixel = function(Cn, Bn, In) {
      var Dn = getCoordSys$4(Bn);
      return Dn === this ? Dn.pointToData(In) : null;
    }, nr.prototype.containPoint = function(Cn) {
      return this.getViewRectAfterRoam().contain(Cn[0], Cn[1]);
    }, nr.dimensions = ["x", "y"], nr;
  }(Transformable$1)
);
function getCoordSys$4(_n) {
  var nr = _n.seriesModel;
  return nr ? nr.coordinateSystem : null;
}
const View$1 = View;
var GEO_DEFAULT_PARAMS = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, geo2DDimensions = ["lng", "lat"], Geo = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In) {
      var Dn = _n.call(this, Cn) || this;
      Dn.dimensions = geo2DDimensions, Dn.type = "geo", Dn._nameCoordMap = createHashMap(), Dn.map = Bn;
      var Ln = In.projection, $n = geoSourceManager.load(Bn, In.nameMap, In.nameProperty), Nn = geoSourceManager.getGeoResource(Bn), Rn = Dn.resourceType = Nn ? Nn.type : null, Fn = Dn.regions = $n.regions, Pn = GEO_DEFAULT_PARAMS[Nn.type];
      Dn._regionsMap = $n.regionsMap, Dn.regions = $n.regions, process.env.NODE_ENV !== "production" && Ln && (Rn === "geoSVG" && (process.env.NODE_ENV !== "production" && warn("Map " + Bn + " with SVG source can't use projection. Only GeoJSON source supports projection."), Ln = null), Ln.project && Ln.unproject || (process.env.NODE_ENV !== "production" && warn("project and unproject must be both provided in the projeciton."), Ln = null)), Dn.projection = Ln;
      var Un;
      if (Ln)
        for (var Hn = 0; Hn < Fn.length; Hn++) {
          var zn = Fn[Hn].getBoundingRect(Ln);
          Un = Un || zn.clone(), Un.union(zn);
        }
      else
        Un = $n.boundingRect;
      return Dn.setBoundingRect(Un.x, Un.y, Un.width, Un.height), Dn.aspectScale = Ln ? 1 : retrieve2(In.aspectScale, Pn.aspectScale), Dn._invertLongitute = Ln ? !1 : Pn.invertLongitute, Dn;
    }
    return nr.prototype._transformTo = function(Cn, Bn, In, Dn) {
      var Ln = this.getBoundingRect(), $n = this._invertLongitute;
      Ln = Ln.clone(), $n && (Ln.y = -Ln.y - Ln.height);
      var Nn = this._rawTransformable;
      Nn.transform = Ln.calculateTransform(new BoundingRect$1(Cn, Bn, In, Dn));
      var Rn = Nn.parent;
      Nn.parent = null, Nn.decomposeTransform(), Nn.parent = Rn, $n && (Nn.scaleY = -Nn.scaleY), this._updateTransform();
    }, nr.prototype.getRegion = function(Cn) {
      return this._regionsMap.get(Cn);
    }, nr.prototype.getRegionByCoord = function(Cn) {
      for (var Bn = this.regions, In = 0; In < Bn.length; In++) {
        var Dn = Bn[In];
        if (Dn.type === "geoJSON" && Dn.contain(Cn))
          return Bn[In];
      }
    }, nr.prototype.addGeoCoord = function(Cn, Bn) {
      this._nameCoordMap.set(Cn, Bn);
    }, nr.prototype.getGeoCoord = function(Cn) {
      var Bn = this._regionsMap.get(Cn);
      return this._nameCoordMap.get(Cn) || Bn && Bn.getCenter();
    }, nr.prototype.dataToPoint = function(Cn, Bn, In) {
      if (isString$1(Cn) && (Cn = this.getGeoCoord(Cn)), Cn) {
        var Dn = this.projection;
        return Dn && (Cn = Dn.project(Cn)), Cn && this.projectedToPoint(Cn, Bn, In);
      }
    }, nr.prototype.pointToData = function(Cn) {
      var Bn = this.projection;
      return Bn && (Cn = Bn.unproject(Cn)), Cn && this.pointToProjected(Cn);
    }, nr.prototype.pointToProjected = function(Cn) {
      return _n.prototype.pointToData.call(this, Cn);
    }, nr.prototype.projectedToPoint = function(Cn, Bn, In) {
      return _n.prototype.dataToPoint.call(this, Cn, Bn, In);
    }, nr.prototype.convertToPixel = function(Cn, Bn, In) {
      var Dn = getCoordSys$3(Bn);
      return Dn === this ? Dn.dataToPoint(In) : null;
    }, nr.prototype.convertFromPixel = function(Cn, Bn, In) {
      var Dn = getCoordSys$3(Bn);
      return Dn === this ? Dn.pointToData(In) : null;
    }, nr;
  }(View$1)
);
mixin(Geo, View$1);
function getCoordSys$3(_n) {
  var nr = _n.geoModel, Cn = _n.seriesModel;
  return nr ? nr.coordinateSystem : Cn ? Cn.coordinateSystem || (Cn.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}
const Geo$1 = Geo;
function resizeGeo(_n, nr) {
  var Cn = _n.get("boundingCoords");
  if (Cn != null) {
    var Bn = Cn[0], In = Cn[1];
    if (!(isFinite(Bn[0]) && isFinite(Bn[1]) && isFinite(In[0]) && isFinite(In[1])))
      process.env.NODE_ENV !== "production" && console.error("Invalid boundingCoords");
    else {
      var Dn = this.projection;
      if (Dn) {
        var Ln = Bn[0], $n = Bn[1], Nn = In[0], Rn = In[1];
        Bn = [1 / 0, 1 / 0], In = [-1 / 0, -1 / 0];
        var Fn = function(ra, aa, ia, Aa) {
          for (var sa = ia - ra, oa = Aa - aa, la = 0; la <= 100; la++) {
            var ua = la / 100, ca = Dn.project([ra + sa * ua, aa + oa * ua]);
            min$2(Bn, Bn, ca), max$3(In, In, ca);
          }
        };
        Fn(Ln, $n, Nn, $n), Fn(Nn, $n, Nn, Rn), Fn(Nn, Rn, Ln, Rn), Fn(Ln, Rn, Nn, $n);
      }
      this.setBoundingRect(Bn[0], Bn[1], In[0] - Bn[0], In[1] - Bn[1]);
    }
  }
  var Pn = this.getBoundingRect(), Un = _n.get("layoutCenter"), Hn = _n.get("layoutSize"), zn = nr.getWidth(), Gn = nr.getHeight(), Yn = Pn.width / Pn.height * this.aspectScale, Wn = !1, Xn, ea;
  Un && Hn && (Xn = [parsePercent(Un[0], zn), parsePercent(Un[1], Gn)], ea = parsePercent(Hn, Math.min(zn, Gn)), !isNaN(Xn[0]) && !isNaN(Xn[1]) && !isNaN(ea) ? Wn = !0 : process.env.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
  var ta;
  if (Wn)
    ta = {}, Yn > 1 ? (ta.width = ea, ta.height = ea / Yn) : (ta.height = ea, ta.width = ea * Yn), ta.y = Xn[1] - ta.height / 2, ta.x = Xn[0] - ta.width / 2;
  else {
    var na = _n.getBoxLayoutParams();
    na.aspect = Yn, ta = getLayoutRect$1(na, {
      width: zn,
      height: Gn
    });
  }
  this.setViewRect(ta.x, ta.y, ta.width, ta.height), this.setCenter(_n.get("center"), nr), this.setZoom(_n.get("zoom"));
}
function setGeoCoords(_n, nr) {
  each$f(nr.get("geoCoord"), function(Cn, Bn) {
    _n.addGeoCoord(Bn, Cn);
  });
}
var GeoCreator = (
  /** @class */
  function() {
    function _n() {
      this.dimensions = geo2DDimensions;
    }
    return _n.prototype.create = function(nr, Cn) {
      var Bn = [];
      function In(Ln) {
        return {
          nameProperty: Ln.get("nameProperty"),
          aspectScale: Ln.get("aspectScale"),
          projection: Ln.get("projection")
        };
      }
      nr.eachComponent("geo", function(Ln, $n) {
        var Nn = Ln.get("map"), Rn = new Geo$1(Nn + $n, Nn, extend({
          nameMap: Ln.get("nameMap")
        }, In(Ln)));
        Rn.zoomLimit = Ln.get("scaleLimit"), Bn.push(Rn), Ln.coordinateSystem = Rn, Rn.model = Ln, Rn.resize = resizeGeo, Rn.resize(Ln, Cn);
      }), nr.eachSeries(function(Ln) {
        var $n = Ln.get("coordinateSystem");
        if ($n === "geo") {
          var Nn = Ln.get("geoIndex") || 0;
          Ln.coordinateSystem = Bn[Nn];
        }
      });
      var Dn = {};
      return nr.eachSeriesByType("map", function(Ln) {
        if (!Ln.getHostGeoModel()) {
          var $n = Ln.getMapType();
          Dn[$n] = Dn[$n] || [], Dn[$n].push(Ln);
        }
      }), each$f(Dn, function(Ln, $n) {
        var Nn = map$1(Ln, function(Fn) {
          return Fn.get("nameMap");
        }), Rn = new Geo$1($n, $n, extend({
          nameMap: mergeAll(Nn)
        }, In(Ln[0])));
        Rn.zoomLimit = retrieve.apply(null, map$1(Ln, function(Fn) {
          return Fn.get("scaleLimit");
        })), Bn.push(Rn), Rn.resize = resizeGeo, Rn.resize(Ln[0], Cn), each$f(Ln, function(Fn) {
          Fn.coordinateSystem = Rn, setGeoCoords(Rn, Fn);
        });
      }), Bn;
    }, _n.prototype.getFilledRegions = function(nr, Cn, Bn, In) {
      for (var Dn = (nr || []).slice(), Ln = createHashMap(), $n = 0; $n < Dn.length; $n++)
        Ln.set(Dn[$n].name, Dn[$n]);
      var Nn = geoSourceManager.load(Cn, Bn, In);
      return each$f(Nn.regions, function(Rn) {
        var Fn = Rn.name, Pn = Ln.get(Fn), Un = Rn.properties && Rn.properties.echartsStyle;
        Pn || (Pn = {
          name: Fn
        }, Dn.push(Pn)), Un && merge$1(Pn, Un);
      }), Dn;
    }, _n;
  }()
), geoCreator = new GeoCreator();
const geoCreator$1 = geoCreator;
var GeoModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      var Dn = geoSourceManager.getGeoResource(Cn.map);
      if (Dn && Dn.type === "geoJSON") {
        var Ln = Cn.itemStyle = Cn.itemStyle || {};
        "color" in Ln || (Ln.color = "#eee");
      }
      this.mergeDefaultAndTheme(Cn, In), defaultEmphasis(Cn, "label", ["show"]);
    }, nr.prototype.optionUpdated = function() {
      var Cn = this, Bn = this.option;
      Bn.regions = geoCreator$1.getFilledRegions(Bn.regions, Bn.map, Bn.nameMap, Bn.nameProperty);
      var In = {};
      this._optionModelMap = reduce(Bn.regions || [], function(Dn, Ln) {
        var $n = Ln.name;
        return $n && (Dn.set($n, new Model$1(Ln, Cn, Cn.ecModel)), Ln.selected && (In[$n] = !0)), Dn;
      }, createHashMap()), Bn.selectedMap || (Bn.selectedMap = In);
    }, nr.prototype.getRegionModel = function(Cn) {
      return this._optionModelMap.get(Cn) || new Model$1(null, this, this.ecModel);
    }, nr.prototype.getFormattedLabel = function(Cn, Bn) {
      var In = this.getRegionModel(Cn), Dn = Bn === "normal" ? In.get(["label", "formatter"]) : In.get(["emphasis", "label", "formatter"]), Ln = {
        name: Cn
      };
      if (isFunction$1(Dn))
        return Ln.status = Bn, Dn(Ln);
      if (isString$1(Dn))
        return Dn.replace("{a}", Cn ?? "");
    }, nr.prototype.setZoom = function(Cn) {
      this.option.zoom = Cn;
    }, nr.prototype.setCenter = function(Cn) {
      this.option.center = Cn;
    }, nr.prototype.select = function(Cn) {
      var Bn = this.option, In = Bn.selectedMode;
      if (In) {
        In !== "multiple" && (Bn.selectedMap = null);
        var Dn = Bn.selectedMap || (Bn.selectedMap = {});
        Dn[Cn] = !0;
      }
    }, nr.prototype.unSelect = function(Cn) {
      var Bn = this.option.selectedMap;
      Bn && (Bn[Cn] = !1);
    }, nr.prototype.toggleSelected = function(Cn) {
      this[this.isSelected(Cn) ? "unSelect" : "select"](Cn);
    }, nr.prototype.isSelected = function(Cn) {
      var Bn = this.option.selectedMap;
      return !!(Bn && Bn[Cn]);
    }, nr.type = "geo", nr.layoutMode = "box", nr.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
        // Default color:
        // + geoJSON: #eee
        // + geoSVG: null (use SVG original `fill`)
        // color: '#eee'
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, nr;
  }(ComponentModel$1)
);
const GeoModel$1 = GeoModel;
function getCenterCoord(_n, nr) {
  return _n.pointToProjected ? _n.pointToProjected(nr) : _n.pointToData(nr);
}
function updateCenterAndZoom(_n, nr, Cn, Bn) {
  var In = _n.getZoom(), Dn = _n.getCenter(), Ln = nr.zoom, $n = _n.projectedToPoint ? _n.projectedToPoint(Dn) : _n.dataToPoint(Dn);
  if (nr.dx != null && nr.dy != null && ($n[0] -= nr.dx, $n[1] -= nr.dy, _n.setCenter(getCenterCoord(_n, $n), Bn)), Ln != null) {
    if (Cn) {
      var Nn = Cn.min || 0, Rn = Cn.max || 1 / 0;
      Ln = Math.max(Math.min(In * Ln, Rn), Nn) / In;
    }
    _n.scaleX *= Ln, _n.scaleY *= Ln;
    var Fn = (nr.originX - _n.x) * (Ln - 1), Pn = (nr.originY - _n.y) * (Ln - 1);
    _n.x -= Fn, _n.y -= Pn, _n.updateTransform(), _n.setCenter(getCenterCoord(_n, $n), Bn), _n.setZoom(Ln * In);
  }
  return {
    center: _n.getCenter(),
    zoom: _n.getZoom()
  };
}
var GeoView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.focusBlurEnabled = !0, Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      this._api = Bn;
    }, nr.prototype.render = function(Cn, Bn, In, Dn) {
      if (this._model = Cn, !Cn.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new MapDraw$1(In));
      var Ln = this._mapDraw;
      Ln.draw(Cn, Bn, In, this, Dn), Ln.group.on("click", this._handleRegionClick, this), Ln.group.silent = Cn.get("silent"), this.group.add(Ln.group), this.updateSelectStatus(Cn, Bn, In);
    }, nr.prototype._handleRegionClick = function(Cn) {
      var Bn;
      findEventDispatcher(Cn.target, function(In) {
        return (Bn = getECData(In).eventData) != null;
      }, !0), Bn && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: Bn.name
      });
    }, nr.prototype.updateSelectStatus = function(Cn, Bn, In) {
      var Dn = this;
      this._mapDraw.group.traverse(function(Ln) {
        var $n = getECData(Ln).eventData;
        if ($n)
          return Dn._model.isSelected($n.name) ? In.enterSelect(Ln) : In.leaveSelect(Ln), !0;
      });
    }, nr.prototype.findHighDownDispatchers = function(Cn) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(Cn, this._model);
    }, nr.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, nr.type = "geo", nr;
  }(ComponentView$1)
);
const GeoView$1 = GeoView;
function registerMap(_n, nr, Cn) {
  geoSourceManager.registerMap(_n, nr, Cn);
}
function install$J(_n) {
  _n.registerCoordinateSystem("geo", geoCreator$1), _n.registerComponentModel(GeoModel$1), _n.registerComponentView(GeoView$1), _n.registerImpl("registerMap", registerMap), _n.registerImpl("getMap", function(Cn) {
    return geoSourceManager.getMapForUser(Cn);
  });
  function nr(Cn, Bn) {
    Bn.update = "geo:updateSelectStatus", _n.registerAction(Bn, function(In, Dn) {
      var Ln = {}, $n = [];
      return Dn.eachComponent({
        mainType: "geo",
        query: In
      }, function(Nn) {
        Nn[Cn](In.name);
        var Rn = Nn.coordinateSystem;
        each$f(Rn.regions, function(Pn) {
          Ln[Pn.name] = Nn.isSelected(Pn.name) || !1;
        });
        var Fn = [];
        each$f(Ln, function(Pn, Un) {
          Ln[Un] && Fn.push(Un);
        }), $n.push({
          geoIndex: Nn.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: Fn
        });
      }), {
        selected: Ln,
        allSelected: $n,
        name: In.name
      };
    });
  }
  nr("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), nr("select", {
    type: "geoSelect",
    event: "geoselected"
  }), nr("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), _n.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(Cn, Bn, In) {
    var Dn = Cn.componentType || "series";
    Bn.eachComponent({
      mainType: Dn,
      query: Cn
    }, function(Ln) {
      var $n = Ln.coordinateSystem;
      if ($n.type === "geo") {
        var Nn = updateCenterAndZoom($n, Cn, Ln.get("scaleLimit"), In);
        Ln.setCenter && Ln.setCenter(Nn.center), Ln.setZoom && Ln.setZoom(Nn.zoom), Dn === "series" && each$f(Ln.seriesGroup, function(Rn) {
          Rn.setCenter(Nn.center), Rn.setZoom(Nn.zoom);
        });
      }
    });
  });
}
function install$I(_n) {
  use(install$J), _n.registerChartView(MapView$1), _n.registerSeriesModel(MapSeries$1), _n.registerLayout(mapSymbolLayout), _n.registerProcessor(_n.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic), createLegacyDataSelectAction("map", _n.registerAction);
}
function init(_n) {
  var nr = _n;
  nr.hierNode = {
    defaultAncestor: null,
    ancestor: nr,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var Cn = [nr], Bn, In; Bn = Cn.pop(); )
    if (In = Bn.children, Bn.isExpand && In.length)
      for (var Dn = In.length, Ln = Dn - 1; Ln >= 0; Ln--) {
        var $n = In[Ln];
        $n.hierNode = {
          defaultAncestor: null,
          ancestor: $n,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: Ln,
          thread: null
        }, Cn.push($n);
      }
}
function firstWalk(_n, nr) {
  var Cn = _n.isExpand ? _n.children : [], Bn = _n.parentNode.children, In = _n.hierNode.i ? Bn[_n.hierNode.i - 1] : null;
  if (Cn.length) {
    executeShifts(_n);
    var Dn = (Cn[0].hierNode.prelim + Cn[Cn.length - 1].hierNode.prelim) / 2;
    In ? (_n.hierNode.prelim = In.hierNode.prelim + nr(_n, In), _n.hierNode.modifier = _n.hierNode.prelim - Dn) : _n.hierNode.prelim = Dn;
  } else
    In && (_n.hierNode.prelim = In.hierNode.prelim + nr(_n, In));
  _n.parentNode.hierNode.defaultAncestor = apportion(_n, In, _n.parentNode.hierNode.defaultAncestor || Bn[0], nr);
}
function secondWalk(_n) {
  var nr = _n.hierNode.prelim + _n.parentNode.hierNode.modifier;
  _n.setLayout({
    x: nr
  }, !0), _n.hierNode.modifier += _n.parentNode.hierNode.modifier;
}
function separation(_n) {
  return arguments.length ? _n : defaultSeparation;
}
function radialCoordinate(_n, nr) {
  return _n -= Math.PI / 2, {
    x: nr * Math.cos(_n),
    y: nr * Math.sin(_n)
  };
}
function getViewRect$4(_n, nr) {
  return getLayoutRect$1(_n.getBoxLayoutParams(), {
    width: nr.getWidth(),
    height: nr.getHeight()
  });
}
function executeShifts(_n) {
  for (var nr = _n.children, Cn = nr.length, Bn = 0, In = 0; --Cn >= 0; ) {
    var Dn = nr[Cn];
    Dn.hierNode.prelim += Bn, Dn.hierNode.modifier += Bn, In += Dn.hierNode.change, Bn += Dn.hierNode.shift + In;
  }
}
function apportion(_n, nr, Cn, Bn) {
  if (nr) {
    for (var In = _n, Dn = _n, Ln = Dn.parentNode.children[0], $n = nr, Nn = In.hierNode.modifier, Rn = Dn.hierNode.modifier, Fn = Ln.hierNode.modifier, Pn = $n.hierNode.modifier; $n = nextRight($n), Dn = nextLeft(Dn), $n && Dn; ) {
      In = nextRight(In), Ln = nextLeft(Ln), In.hierNode.ancestor = _n;
      var Un = $n.hierNode.prelim + Pn - Dn.hierNode.prelim - Rn + Bn($n, Dn);
      Un > 0 && (moveSubtree(nextAncestor($n, _n, Cn), _n, Un), Rn += Un, Nn += Un), Pn += $n.hierNode.modifier, Rn += Dn.hierNode.modifier, Nn += In.hierNode.modifier, Fn += Ln.hierNode.modifier;
    }
    $n && !nextRight(In) && (In.hierNode.thread = $n, In.hierNode.modifier += Pn - Nn), Dn && !nextLeft(Ln) && (Ln.hierNode.thread = Dn, Ln.hierNode.modifier += Rn - Fn, Cn = _n);
  }
  return Cn;
}
function nextRight(_n) {
  var nr = _n.children;
  return nr.length && _n.isExpand ? nr[nr.length - 1] : _n.hierNode.thread;
}
function nextLeft(_n) {
  var nr = _n.children;
  return nr.length && _n.isExpand ? nr[0] : _n.hierNode.thread;
}
function nextAncestor(_n, nr, Cn) {
  return _n.hierNode.ancestor.parentNode === nr.parentNode ? _n.hierNode.ancestor : Cn;
}
function moveSubtree(_n, nr, Cn) {
  var Bn = Cn / (nr.hierNode.i - _n.hierNode.i);
  nr.hierNode.change -= Bn, nr.hierNode.shift += Cn, nr.hierNode.modifier += Cn, nr.hierNode.prelim += Cn, _n.hierNode.change += Bn;
}
function defaultSeparation(_n, nr) {
  return _n.parentNode === nr.parentNode ? 1 : 2;
}
var TreeEdgeShape = (
  /** @class */
  function() {
    function _n() {
      this.parentPoint = [], this.childPoints = [];
    }
    return _n;
  }()
), TreePath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      return _n.call(this, Cn) || this;
    }
    return nr.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, nr.prototype.getDefaultShape = function() {
      return new TreeEdgeShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Bn.childPoints, Dn = In.length, Ln = Bn.parentPoint, $n = In[0], Nn = In[Dn - 1];
      if (Dn === 1) {
        Cn.moveTo(Ln[0], Ln[1]), Cn.lineTo($n[0], $n[1]);
        return;
      }
      var Rn = Bn.orient, Fn = Rn === "TB" || Rn === "BT" ? 0 : 1, Pn = 1 - Fn, Un = parsePercent(Bn.forkPosition, 1), Hn = [];
      Hn[Fn] = Ln[Fn], Hn[Pn] = Ln[Pn] + (Nn[Pn] - Ln[Pn]) * Un, Cn.moveTo(Ln[0], Ln[1]), Cn.lineTo(Hn[0], Hn[1]), Cn.moveTo($n[0], $n[1]), Hn[Fn] = $n[Fn], Cn.lineTo(Hn[0], Hn[1]), Hn[Fn] = Nn[Fn], Cn.lineTo(Hn[0], Hn[1]), Cn.lineTo(Nn[0], Nn[1]);
      for (var zn = 1; zn < Dn - 1; zn++) {
        var Gn = In[zn];
        Cn.moveTo(Gn[0], Gn[1]), Hn[Fn] = Gn[Fn], Cn.lineTo(Hn[0], Hn[1]);
      }
    }, nr;
  }(Path$1)
), TreeView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn._mainGroup = new Group$4(), Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      this._controller = new RoamController$1(Bn.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = Cn.layoutInfo, $n = this._mainGroup, Nn = Cn.get("layout");
      Nn === "radial" ? ($n.x = Ln.x + Ln.width / 2, $n.y = Ln.y + Ln.height / 2) : ($n.x = Ln.x, $n.y = Ln.y), this._updateViewCoordSys(Cn, In), this._updateController(Cn, Bn, In);
      var Rn = this._data;
      Dn.diff(Rn).add(function(Fn) {
        symbolNeedsDraw(Dn, Fn) && updateNode(Dn, Fn, null, $n, Cn);
      }).update(function(Fn, Pn) {
        var Un = Rn.getItemGraphicEl(Pn);
        if (!symbolNeedsDraw(Dn, Fn)) {
          Un && removeNode(Rn, Pn, Un, $n, Cn);
          return;
        }
        updateNode(Dn, Fn, Un, $n, Cn);
      }).remove(function(Fn) {
        var Pn = Rn.getItemGraphicEl(Fn);
        Pn && removeNode(Rn, Fn, Pn, $n, Cn);
      }).execute(), this._nodeScaleRatio = Cn.get("nodeScaleRatio"), this._updateNodeAndLinkScale(Cn), Cn.get("expandAndCollapse") === !0 && Dn.eachItemGraphicEl(function(Fn, Pn) {
        Fn.off("click").on("click", function() {
          In.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: Cn.id,
            dataIndex: Pn
          });
        });
      }), this._data = Dn;
    }, nr.prototype._updateViewCoordSys = function(Cn, Bn) {
      var In = Cn.getData(), Dn = [];
      In.each(function(Pn) {
        var Un = In.getItemLayout(Pn);
        Un && !isNaN(Un.x) && !isNaN(Un.y) && Dn.push([+Un.x, +Un.y]);
      });
      var Ln = [], $n = [];
      fromPoints(Dn, Ln, $n);
      var Nn = this._min, Rn = this._max;
      $n[0] - Ln[0] === 0 && (Ln[0] = Nn ? Nn[0] : Ln[0] - 1, $n[0] = Rn ? Rn[0] : $n[0] + 1), $n[1] - Ln[1] === 0 && (Ln[1] = Nn ? Nn[1] : Ln[1] - 1, $n[1] = Rn ? Rn[1] : $n[1] + 1);
      var Fn = Cn.coordinateSystem = new View$1();
      Fn.zoomLimit = Cn.get("scaleLimit"), Fn.setBoundingRect(Ln[0], Ln[1], $n[0] - Ln[0], $n[1] - Ln[1]), Fn.setCenter(Cn.get("center"), Bn), Fn.setZoom(Cn.get("zoom")), this.group.attr({
        x: Fn.x,
        y: Fn.y,
        scaleX: Fn.scaleX,
        scaleY: Fn.scaleY
      }), this._min = Ln, this._max = $n;
    }, nr.prototype._updateController = function(Cn, Bn, In) {
      var Dn = this, Ln = this._controller, $n = this._controllerHost, Nn = this.group;
      Ln.setPointerChecker(function(Rn, Fn, Pn) {
        var Un = Nn.getBoundingRect();
        return Un.applyTransform(Nn.transform), Un.contain(Fn, Pn) && !onIrrelevantElement(Rn, In, Cn);
      }), Ln.enable(Cn.get("roam")), $n.zoomLimit = Cn.get("scaleLimit"), $n.zoom = Cn.coordinateSystem.getZoom(), Ln.off("pan").off("zoom").on("pan", function(Rn) {
        updateViewOnPan($n, Rn.dx, Rn.dy), In.dispatchAction({
          seriesId: Cn.id,
          type: "treeRoam",
          dx: Rn.dx,
          dy: Rn.dy
        });
      }).on("zoom", function(Rn) {
        updateViewOnZoom($n, Rn.scale, Rn.originX, Rn.originY), In.dispatchAction({
          seriesId: Cn.id,
          type: "treeRoam",
          zoom: Rn.scale,
          originX: Rn.originX,
          originY: Rn.originY
        }), Dn._updateNodeAndLinkScale(Cn), In.updateLabelLayout();
      });
    }, nr.prototype._updateNodeAndLinkScale = function(Cn) {
      var Bn = Cn.getData(), In = this._getNodeGlobalScale(Cn);
      Bn.eachItemGraphicEl(function(Dn, Ln) {
        Dn.setSymbolScale(In);
      });
    }, nr.prototype._getNodeGlobalScale = function(Cn) {
      var Bn = Cn.coordinateSystem;
      if (Bn.type !== "view")
        return 1;
      var In = this._nodeScaleRatio, Dn = Bn.scaleX || 1, Ln = Bn.getZoom(), $n = (Ln - 1) * In + 1;
      return $n / Dn;
    }, nr.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, nr.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, nr.type = "tree", nr;
  }(ChartView$1)
);
function symbolNeedsDraw(_n, nr) {
  var Cn = _n.getItemLayout(nr);
  return Cn && !isNaN(Cn.x) && !isNaN(Cn.y);
}
function updateNode(_n, nr, Cn, Bn, In) {
  var Dn = !Cn, Ln = _n.tree.getNodeByDataIndex(nr), $n = Ln.getModel(), Nn = Ln.getVisual("style").fill, Rn = Ln.isExpand === !1 && Ln.children.length !== 0 ? Nn : "#fff", Fn = _n.tree.root, Pn = Ln.parentNode === Fn ? Ln : Ln.parentNode || Ln, Un = _n.getItemGraphicEl(Pn.dataIndex), Hn = Pn.getLayout(), zn = Un ? {
    x: Un.__oldX,
    y: Un.__oldY,
    rawX: Un.__radialOldRawX,
    rawY: Un.__radialOldRawY
  } : Hn, Gn = Ln.getLayout();
  Dn ? (Cn = new SymbolClz(_n, nr, null, {
    symbolInnerColor: Rn,
    useNameLabel: !0
  }), Cn.x = zn.x, Cn.y = zn.y) : Cn.updateData(_n, nr, null, {
    symbolInnerColor: Rn,
    useNameLabel: !0
  }), Cn.__radialOldRawX = Cn.__radialRawX, Cn.__radialOldRawY = Cn.__radialRawY, Cn.__radialRawX = Gn.rawX, Cn.__radialRawY = Gn.rawY, Bn.add(Cn), _n.setItemGraphicEl(nr, Cn), Cn.__oldX = Cn.x, Cn.__oldY = Cn.y, updateProps$1(Cn, {
    x: Gn.x,
    y: Gn.y
  }, In);
  var Yn = Cn.getSymbolPath();
  if (In.get("layout") === "radial") {
    var Wn = Fn.children[0], Xn = Wn.getLayout(), ea = Wn.children.length, ta = void 0, na = void 0;
    if (Gn.x === Xn.x && Ln.isExpand === !0 && Wn.children.length) {
      var ra = {
        x: (Wn.children[0].getLayout().x + Wn.children[ea - 1].getLayout().x) / 2,
        y: (Wn.children[0].getLayout().y + Wn.children[ea - 1].getLayout().y) / 2
      };
      ta = Math.atan2(ra.y - Xn.y, ra.x - Xn.x), ta < 0 && (ta = Math.PI * 2 + ta), na = ra.x < Xn.x, na && (ta = ta - Math.PI);
    } else
      ta = Math.atan2(Gn.y - Xn.y, Gn.x - Xn.x), ta < 0 && (ta = Math.PI * 2 + ta), Ln.children.length === 0 || Ln.children.length !== 0 && Ln.isExpand === !1 ? (na = Gn.x < Xn.x, na && (ta = ta - Math.PI)) : (na = Gn.x > Xn.x, na || (ta = ta - Math.PI));
    var aa = na ? "left" : "right", ia = $n.getModel("label"), Aa = ia.get("rotate"), sa = Aa * (Math.PI / 180), oa = Yn.getTextContent();
    oa && (Yn.setTextConfig({
      position: ia.get("position") || aa,
      rotation: Aa == null ? -ta : sa,
      origin: "center"
    }), oa.setStyle("verticalAlign", "middle"));
  }
  var la = $n.get(["emphasis", "focus"]), ua = la === "relative" ? concatArray(Ln.getAncestorsIndices(), Ln.getDescendantIndices()) : la === "ancestor" ? Ln.getAncestorsIndices() : la === "descendant" ? Ln.getDescendantIndices() : null;
  ua && (getECData(Cn).focus = ua), drawEdge(In, Ln, Fn, Cn, zn, Hn, Gn, Bn), Cn.__edge && (Cn.onHoverStateChange = function(ca) {
    if (ca !== "blur") {
      var fa = Ln.parentNode && _n.getItemGraphicEl(Ln.parentNode.dataIndex);
      fa && fa.hoverState === HOVER_STATE_BLUR || setStatesFlag(Cn.__edge, ca);
    }
  });
}
function drawEdge(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  var Nn = nr.getModel(), Rn = _n.get("edgeShape"), Fn = _n.get("layout"), Pn = _n.getOrient(), Un = _n.get(["lineStyle", "curveness"]), Hn = _n.get("edgeForkPosition"), zn = Nn.getModel("lineStyle").getLineStyle(), Gn = Bn.__edge;
  if (Rn === "curve")
    nr.parentNode && nr.parentNode !== Cn && (Gn || (Gn = Bn.__edge = new BezierCurve$2({
      shape: getEdgeShape(Fn, Pn, Un, In, In)
    })), updateProps$1(Gn, {
      shape: getEdgeShape(Fn, Pn, Un, Dn, Ln)
    }, _n));
  else if (Rn === "polyline") {
    if (Fn === "orthogonal") {
      if (nr !== Cn && nr.children && nr.children.length !== 0 && nr.isExpand === !0) {
        for (var Yn = nr.children, Wn = [], Xn = 0; Xn < Yn.length; Xn++) {
          var ea = Yn[Xn].getLayout();
          Wn.push([ea.x, ea.y]);
        }
        Gn || (Gn = Bn.__edge = new TreePath({
          shape: {
            parentPoint: [Ln.x, Ln.y],
            childPoints: [[Ln.x, Ln.y]],
            orient: Pn,
            forkPosition: Hn
          }
        })), updateProps$1(Gn, {
          shape: {
            parentPoint: [Ln.x, Ln.y],
            childPoints: Wn
          }
        }, _n);
      }
    } else if (process.env.NODE_ENV !== "production")
      throw new Error("The polyline edgeShape can only be used in orthogonal layout");
  }
  Gn && !(Rn === "polyline" && !nr.isExpand) && (Gn.useStyle(defaults({
    strokeNoScale: !0,
    fill: null
  }, zn)), setStatesStylesFromModel(Gn, Nn, "lineStyle"), setDefaultStateProxy(Gn), $n.add(Gn));
}
function removeNodeEdge(_n, nr, Cn, Bn, In) {
  var Dn = nr.tree.root, Ln = getSourceNode(Dn, _n), $n = Ln.source, Nn = Ln.sourceLayout, Rn = nr.getItemGraphicEl(_n.dataIndex);
  if (Rn) {
    var Fn = nr.getItemGraphicEl($n.dataIndex), Pn = Fn.__edge, Un = Rn.__edge || ($n.isExpand === !1 || $n.children.length === 1 ? Pn : void 0), Hn = Bn.get("edgeShape"), zn = Bn.get("layout"), Gn = Bn.get("orient"), Yn = Bn.get(["lineStyle", "curveness"]);
    Un && (Hn === "curve" ? removeElement(Un, {
      shape: getEdgeShape(zn, Gn, Yn, Nn, Nn),
      style: {
        opacity: 0
      }
    }, Bn, {
      cb: function() {
        Cn.remove(Un);
      },
      removeOpt: In
    }) : Hn === "polyline" && Bn.get("layout") === "orthogonal" && removeElement(Un, {
      shape: {
        parentPoint: [Nn.x, Nn.y],
        childPoints: [[Nn.x, Nn.y]]
      },
      style: {
        opacity: 0
      }
    }, Bn, {
      cb: function() {
        Cn.remove(Un);
      },
      removeOpt: In
    }));
  }
}
function getSourceNode(_n, nr) {
  for (var Cn = nr.parentNode === _n ? nr : nr.parentNode || nr, Bn; Bn = Cn.getLayout(), Bn == null; )
    Cn = Cn.parentNode === _n ? Cn : Cn.parentNode || Cn;
  return {
    source: Cn,
    sourceLayout: Bn
  };
}
function removeNode(_n, nr, Cn, Bn, In) {
  var Dn = _n.tree.getNodeByDataIndex(nr), Ln = _n.tree.root, $n = getSourceNode(Ln, Dn).sourceLayout, Nn = {
    duration: In.get("animationDurationUpdate"),
    easing: In.get("animationEasingUpdate")
  };
  removeElement(Cn, {
    x: $n.x + 1,
    y: $n.y + 1
  }, In, {
    cb: function() {
      Bn.remove(Cn), _n.setItemGraphicEl(nr, null);
    },
    removeOpt: Nn
  }), Cn.fadeOut(null, _n.hostModel, {
    fadeLabel: !0,
    animation: Nn
  }), Dn.children.forEach(function(Rn) {
    removeNodeEdge(Rn, _n, Bn, In, Nn);
  }), removeNodeEdge(Dn, _n, Bn, In, Nn);
}
function getEdgeShape(_n, nr, Cn, Bn, In) {
  var Dn, Ln, $n, Nn, Rn, Fn, Pn, Un;
  if (_n === "radial") {
    Rn = Bn.rawX, Pn = Bn.rawY, Fn = In.rawX, Un = In.rawY;
    var Hn = radialCoordinate(Rn, Pn), zn = radialCoordinate(Rn, Pn + (Un - Pn) * Cn), Gn = radialCoordinate(Fn, Un + (Pn - Un) * Cn), Yn = radialCoordinate(Fn, Un);
    return {
      x1: Hn.x || 0,
      y1: Hn.y || 0,
      x2: Yn.x || 0,
      y2: Yn.y || 0,
      cpx1: zn.x || 0,
      cpy1: zn.y || 0,
      cpx2: Gn.x || 0,
      cpy2: Gn.y || 0
    };
  } else
    Rn = Bn.x, Pn = Bn.y, Fn = In.x, Un = In.y, (nr === "LR" || nr === "RL") && (Dn = Rn + (Fn - Rn) * Cn, Ln = Pn, $n = Fn + (Rn - Fn) * Cn, Nn = Un), (nr === "TB" || nr === "BT") && (Dn = Rn, Ln = Pn + (Un - Pn) * Cn, $n = Fn, Nn = Un + (Pn - Un) * Cn);
  return {
    x1: Rn,
    y1: Pn,
    x2: Fn,
    y2: Un,
    cpx1: Dn,
    cpy1: Ln,
    cpx2: $n,
    cpy2: Nn
  };
}
const TreeView$1 = TreeView;
var inner$e = makeInner();
function linkSeriesData(_n) {
  var nr = _n.mainData, Cn = _n.datas;
  Cn || (Cn = {
    main: nr
  }, _n.datasAttr = {
    main: "data"
  }), _n.datas = _n.mainData = null, linkAll(nr, Cn, _n), each$f(Cn, function(Bn) {
    each$f(nr.TRANSFERABLE_METHODS, function(In) {
      Bn.wrapMethod(In, curry$1(transferInjection, _n));
    });
  }), nr.wrapMethod("cloneShallow", curry$1(cloneShallowInjection, _n)), each$f(nr.CHANGABLE_METHODS, function(Bn) {
    nr.wrapMethod(Bn, curry$1(changeInjection, _n));
  }), assert(Cn[nr.dataType] === nr);
}
function transferInjection(_n, nr) {
  if (isMainData(this)) {
    var Cn = extend({}, inner$e(this).datas);
    Cn[this.dataType] = nr, linkAll(nr, Cn, _n);
  } else
    linkSingle(nr, this.dataType, inner$e(this).mainData, _n);
  return nr;
}
function changeInjection(_n, nr) {
  return _n.struct && _n.struct.update(), nr;
}
function cloneShallowInjection(_n, nr) {
  return each$f(inner$e(nr).datas, function(Cn, Bn) {
    Cn !== nr && linkSingle(Cn.cloneShallow(), Bn, nr, _n);
  }), nr;
}
function getLinkedData(_n) {
  var nr = inner$e(this).mainData;
  return _n == null || nr == null ? nr : inner$e(nr).datas[_n];
}
function getLinkedDataAll() {
  var _n = inner$e(this).mainData;
  return _n == null ? [{
    data: _n
  }] : map$1(keys(inner$e(_n).datas), function(nr) {
    return {
      type: nr,
      data: inner$e(_n).datas[nr]
    };
  });
}
function isMainData(_n) {
  return inner$e(_n).mainData === _n;
}
function linkAll(_n, nr, Cn) {
  inner$e(_n).datas = {}, each$f(nr, function(Bn, In) {
    linkSingle(Bn, In, _n, Cn);
  });
}
function linkSingle(_n, nr, Cn, Bn) {
  inner$e(Cn).datas[nr] = _n, inner$e(_n).mainData = Cn, _n.dataType = nr, Bn.struct && (_n[Bn.structAttr] = Bn.struct, Bn.struct[Bn.datasAttr[nr]] = _n), _n.getLinkedData = getLinkedData, _n.getLinkedDataAll = getLinkedDataAll;
}
var TreeNode = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = nr || "", this.hostTree = Cn;
    }
    return _n.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, _n.prototype.eachNode = function(nr, Cn, Bn) {
      isFunction$1(nr) && (Bn = Cn, Cn = nr, nr = null), nr = nr || {}, isString$1(nr) && (nr = {
        order: nr
      });
      var In = nr.order || "preorder", Dn = this[nr.attr || "children"], Ln;
      In === "preorder" && (Ln = Cn.call(Bn, this));
      for (var $n = 0; !Ln && $n < Dn.length; $n++)
        Dn[$n].eachNode(nr, Cn, Bn);
      In === "postorder" && Cn.call(Bn, this);
    }, _n.prototype.updateDepthAndHeight = function(nr) {
      var Cn = 0;
      this.depth = nr;
      for (var Bn = 0; Bn < this.children.length; Bn++) {
        var In = this.children[Bn];
        In.updateDepthAndHeight(nr + 1), In.height > Cn && (Cn = In.height);
      }
      this.height = Cn + 1;
    }, _n.prototype.getNodeById = function(nr) {
      if (this.getId() === nr)
        return this;
      for (var Cn = 0, Bn = this.children, In = Bn.length; Cn < In; Cn++) {
        var Dn = Bn[Cn].getNodeById(nr);
        if (Dn)
          return Dn;
      }
    }, _n.prototype.contains = function(nr) {
      if (nr === this)
        return !0;
      for (var Cn = 0, Bn = this.children, In = Bn.length; Cn < In; Cn++) {
        var Dn = Bn[Cn].contains(nr);
        if (Dn)
          return Dn;
      }
    }, _n.prototype.getAncestors = function(nr) {
      for (var Cn = [], Bn = nr ? this : this.parentNode; Bn; )
        Cn.push(Bn), Bn = Bn.parentNode;
      return Cn.reverse(), Cn;
    }, _n.prototype.getAncestorsIndices = function() {
      for (var nr = [], Cn = this; Cn; )
        nr.push(Cn.dataIndex), Cn = Cn.parentNode;
      return nr.reverse(), nr;
    }, _n.prototype.getDescendantIndices = function() {
      var nr = [];
      return this.eachNode(function(Cn) {
        nr.push(Cn.dataIndex);
      }), nr;
    }, _n.prototype.getValue = function(nr) {
      var Cn = this.hostTree.data;
      return Cn.getStore().get(Cn.getDimensionIndex(nr || "value"), this.dataIndex);
    }, _n.prototype.setLayout = function(nr, Cn) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, nr, Cn);
    }, _n.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, _n.prototype.getModel = function(nr) {
      if (!(this.dataIndex < 0)) {
        var Cn = this.hostTree, Bn = Cn.data.getItemModel(this.dataIndex);
        return Bn.getModel(nr);
      }
    }, _n.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, _n.prototype.setVisual = function(nr, Cn) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, nr, Cn);
    }, _n.prototype.getVisual = function(nr) {
      return this.hostTree.data.getItemVisual(this.dataIndex, nr);
    }, _n.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, _n.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, _n.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var nr = this.parentNode.children, Cn = 0; Cn < nr.length; ++Cn)
          if (nr[Cn] === this)
            return Cn;
        return -1;
      }
      return -1;
    }, _n.prototype.isAncestorOf = function(nr) {
      for (var Cn = nr.parentNode; Cn; ) {
        if (Cn === this)
          return !0;
        Cn = Cn.parentNode;
      }
      return !1;
    }, _n.prototype.isDescendantOf = function(nr) {
      return nr !== this && nr.isAncestorOf(this);
    }, _n;
  }()
), Tree = (
  /** @class */
  function() {
    function _n(nr) {
      this.type = "tree", this._nodes = [], this.hostModel = nr;
    }
    return _n.prototype.eachNode = function(nr, Cn, Bn) {
      this.root.eachNode(nr, Cn, Bn);
    }, _n.prototype.getNodeByDataIndex = function(nr) {
      var Cn = this.data.getRawIndex(nr);
      return this._nodes[Cn];
    }, _n.prototype.getNodeById = function(nr) {
      return this.root.getNodeById(nr);
    }, _n.prototype.update = function() {
      for (var nr = this.data, Cn = this._nodes, Bn = 0, In = Cn.length; Bn < In; Bn++)
        Cn[Bn].dataIndex = -1;
      for (var Bn = 0, In = nr.count(); Bn < In; Bn++)
        Cn[nr.getRawIndex(Bn)].dataIndex = Bn;
    }, _n.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, _n.createTree = function(nr, Cn, Bn) {
      var In = new _n(Cn), Dn = [], Ln = 1;
      $n(nr);
      function $n(Fn, Pn) {
        var Un = Fn.value;
        Ln = Math.max(Ln, isArray$4(Un) ? Un.length : 1), Dn.push(Fn);
        var Hn = new TreeNode(convertOptionIdName(Fn.name, ""), In);
        Pn ? addChild(Hn, Pn) : In.root = Hn, In._nodes.push(Hn);
        var zn = Fn.children;
        if (zn)
          for (var Gn = 0; Gn < zn.length; Gn++)
            $n(zn[Gn], Hn);
      }
      In.root.updateDepthAndHeight(0);
      var Nn = prepareSeriesDataSchema(Dn, {
        coordDimensions: ["value"],
        dimensionsCount: Ln
      }).dimensions, Rn = new SeriesData$1(Nn, Cn);
      return Rn.initData(Dn), Bn && Bn(Rn), linkSeriesData({
        mainData: Rn,
        struct: In,
        structAttr: "tree"
      }), In.update(), In;
    }, _n;
  }()
);
function addChild(_n, nr) {
  var Cn = nr.children;
  _n.parentNode !== nr && (Cn.push(_n), _n.parentNode = nr);
}
const Tree$1 = Tree;
function retrieveTargetInfo(_n, nr, Cn) {
  if (_n && indexOf(nr, _n.type) >= 0) {
    var Bn = Cn.getData().tree.root, In = _n.targetNode;
    if (isString$1(In) && (In = Bn.getNodeById(In)), In && Bn.contains(In))
      return {
        node: In
      };
    var Dn = _n.targetNodeId;
    if (Dn != null && (In = Bn.getNodeById(Dn)))
      return {
        node: In
      };
  }
}
function getPathToRoot(_n) {
  for (var nr = []; _n; )
    _n = _n.parentNode, _n && nr.push(_n);
  return nr.reverse();
}
function aboveViewRoot(_n, nr) {
  var Cn = getPathToRoot(_n);
  return indexOf(Cn, nr) >= 0;
}
function wrapTreePathInfo(_n, nr) {
  for (var Cn = []; _n; ) {
    var Bn = _n.dataIndex;
    Cn.push({
      name: _n.name,
      dataIndex: Bn,
      value: nr.getRawValue(Bn)
    }), _n = _n.parentNode;
  }
  return Cn.reverse(), Cn;
}
var TreeSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.hasSymbolVisual = !0, Cn.ignoreStyleOnData = !0, Cn;
    }
    return nr.prototype.getInitialData = function(Cn) {
      var Bn = {
        name: Cn.name,
        children: Cn.data
      }, In = Cn.leaves || {}, Dn = new Model$1(In, this, this.ecModel), Ln = Tree$1.createTree(Bn, this, $n);
      function $n(Pn) {
        Pn.wrapMethod("getItemModel", function(Un, Hn) {
          var zn = Ln.getNodeByDataIndex(Hn);
          return zn && zn.children.length && zn.isExpand || (Un.parentModel = Dn), Un;
        });
      }
      var Nn = 0;
      Ln.eachNode("preorder", function(Pn) {
        Pn.depth > Nn && (Nn = Pn.depth);
      });
      var Rn = Cn.expandAndCollapse, Fn = Rn && Cn.initialTreeDepth >= 0 ? Cn.initialTreeDepth : Nn;
      return Ln.root.eachNode("preorder", function(Pn) {
        var Un = Pn.hostTree.data.getRawDataItem(Pn.dataIndex);
        Pn.isExpand = Un && Un.collapsed != null ? !Un.collapsed : Pn.depth <= Fn;
      }), Ln.data;
    }, nr.prototype.getOrient = function() {
      var Cn = this.get("orient");
      return Cn === "horizontal" ? Cn = "LR" : Cn === "vertical" && (Cn = "TB"), Cn;
    }, nr.prototype.setZoom = function(Cn) {
      this.option.zoom = Cn;
    }, nr.prototype.setCenter = function(Cn) {
      this.option.center = Cn;
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      for (var Dn = this.getData().tree, Ln = Dn.root.children[0], $n = Dn.getNodeByDataIndex(Cn), Nn = $n.getValue(), Rn = $n.name; $n && $n !== Ln; )
        Rn = $n.parentNode.name + "." + Rn, $n = $n.parentNode;
      return createTooltipMarkup("nameValue", {
        name: Rn,
        value: Nn,
        noValue: isNaN(Nn) || Nn == null
      });
    }, nr.prototype.getDataParams = function(Cn) {
      var Bn = _n.prototype.getDataParams.apply(this, arguments), In = this.getData().tree.getNodeByDataIndex(Cn);
      return Bn.treeAncestors = wrapTreePathInfo(In, this), Bn.collapsed = !In.isExpand, Bn;
    }, nr.type = "series.tree", nr.layoutMode = "box", nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, nr;
  }(SeriesModel$1)
);
const TreeSeriesModel$1 = TreeSeriesModel;
function eachAfter(_n, nr, Cn) {
  for (var Bn = [_n], In = [], Dn; Dn = Bn.pop(); )
    if (In.push(Dn), Dn.isExpand) {
      var Ln = Dn.children;
      if (Ln.length)
        for (var $n = 0; $n < Ln.length; $n++)
          Bn.push(Ln[$n]);
    }
  for (; Dn = In.pop(); )
    nr(Dn, Cn);
}
function eachBefore(_n, nr) {
  for (var Cn = [_n], Bn; Bn = Cn.pop(); )
    if (nr(Bn), Bn.isExpand) {
      var In = Bn.children;
      if (In.length)
        for (var Dn = In.length - 1; Dn >= 0; Dn--)
          Cn.push(In[Dn]);
    }
}
function treeLayout(_n, nr) {
  _n.eachSeriesByType("tree", function(Cn) {
    commonLayout(Cn, nr);
  });
}
function commonLayout(_n, nr) {
  var Cn = getViewRect$4(_n, nr);
  _n.layoutInfo = Cn;
  var Bn = _n.get("layout"), In = 0, Dn = 0, Ln = null;
  Bn === "radial" ? (In = 2 * Math.PI, Dn = Math.min(Cn.height, Cn.width) / 2, Ln = separation(function(ea, ta) {
    return (ea.parentNode === ta.parentNode ? 1 : 2) / ea.depth;
  })) : (In = Cn.width, Dn = Cn.height, Ln = separation());
  var $n = _n.getData().tree.root, Nn = $n.children[0];
  if (Nn) {
    init($n), eachAfter(Nn, firstWalk, Ln), $n.hierNode.modifier = -Nn.hierNode.prelim, eachBefore(Nn, secondWalk);
    var Rn = Nn, Fn = Nn, Pn = Nn;
    eachBefore(Nn, function(ea) {
      var ta = ea.getLayout().x;
      ta < Rn.getLayout().x && (Rn = ea), ta > Fn.getLayout().x && (Fn = ea), ea.depth > Pn.depth && (Pn = ea);
    });
    var Un = Rn === Fn ? 1 : Ln(Rn, Fn) / 2, Hn = Un - Rn.getLayout().x, zn = 0, Gn = 0, Yn = 0, Wn = 0;
    if (Bn === "radial")
      zn = In / (Fn.getLayout().x + Un + Hn), Gn = Dn / (Pn.depth - 1 || 1), eachBefore(Nn, function(ea) {
        Yn = (ea.getLayout().x + Hn) * zn, Wn = (ea.depth - 1) * Gn;
        var ta = radialCoordinate(Yn, Wn);
        ea.setLayout({
          x: ta.x,
          y: ta.y,
          rawX: Yn,
          rawY: Wn
        }, !0);
      });
    else {
      var Xn = _n.getOrient();
      Xn === "RL" || Xn === "LR" ? (Gn = Dn / (Fn.getLayout().x + Un + Hn), zn = In / (Pn.depth - 1 || 1), eachBefore(Nn, function(ea) {
        Wn = (ea.getLayout().x + Hn) * Gn, Yn = Xn === "LR" ? (ea.depth - 1) * zn : In - (ea.depth - 1) * zn, ea.setLayout({
          x: Yn,
          y: Wn
        }, !0);
      })) : (Xn === "TB" || Xn === "BT") && (zn = In / (Fn.getLayout().x + Un + Hn), Gn = Dn / (Pn.depth - 1 || 1), eachBefore(Nn, function(ea) {
        Yn = (ea.getLayout().x + Hn) * zn, Wn = Xn === "TB" ? (ea.depth - 1) * Gn : Dn - (ea.depth - 1) * Gn, ea.setLayout({
          x: Yn,
          y: Wn
        }, !0);
      }));
    }
  }
}
function treeVisual(_n) {
  _n.eachSeriesByType("tree", function(nr) {
    var Cn = nr.getData(), Bn = Cn.tree;
    Bn.eachNode(function(In) {
      var Dn = In.getModel(), Ln = Dn.getModel("itemStyle").getItemStyle(), $n = Cn.ensureUniqueItemVisual(In.dataIndex, "style");
      extend($n, Ln);
    });
  });
}
function installTreeAction(_n) {
  _n.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(nr, Cn) {
    Cn.eachComponent({
      mainType: "series",
      subType: "tree",
      query: nr
    }, function(Bn) {
      var In = nr.dataIndex, Dn = Bn.getData().tree, Ln = Dn.getNodeByDataIndex(In);
      Ln.isExpand = !Ln.isExpand;
    });
  }), _n.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(nr, Cn, Bn) {
    Cn.eachComponent({
      mainType: "series",
      subType: "tree",
      query: nr
    }, function(In) {
      var Dn = In.coordinateSystem, Ln = updateCenterAndZoom(Dn, nr, void 0, Bn);
      In.setCenter && In.setCenter(Ln.center), In.setZoom && In.setZoom(Ln.zoom);
    });
  });
}
function install$H(_n) {
  _n.registerChartView(TreeView$1), _n.registerSeriesModel(TreeSeriesModel$1), _n.registerLayout(treeLayout), _n.registerVisual(treeVisual), installTreeAction(_n);
}
var actionTypes = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function installTreemapAction(_n) {
  for (var nr = 0; nr < actionTypes.length; nr++)
    _n.registerAction({
      type: actionTypes[nr],
      update: "updateView"
    }, noop$1);
  _n.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(Cn, Bn) {
    Bn.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: Cn
    }, In);
    function In(Dn, Ln) {
      var $n = ["treemapZoomToNode", "treemapRootToNode"], Nn = retrieveTargetInfo(Cn, $n, Dn);
      if (Nn) {
        var Rn = Dn.getViewRoot();
        Rn && (Cn.direction = aboveViewRoot(Rn, Nn.node) ? "rollUp" : "drillDown"), Dn.resetViewRoot(Nn.node);
      }
    }
  });
}
function enableAriaDecalForTree(_n) {
  var nr = _n.getData(), Cn = nr.tree, Bn = {};
  Cn.eachNode(function(In) {
    for (var Dn = In; Dn && Dn.depth > 1; )
      Dn = Dn.parentNode;
    var Ln = getDecalFromPalette(_n.ecModel, Dn.name || Dn.dataIndex + "", Bn);
    In.setVisual("decal", Ln);
  });
}
var TreemapSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.preventUsingHoverLayer = !0, Cn;
    }
    return nr.prototype.getInitialData = function(Cn, Bn) {
      var In = {
        name: Cn.name,
        children: Cn.data
      };
      completeTreeValue$1(In);
      var Dn = Cn.levels || [], Ln = this.designatedVisualItemStyle = {}, $n = new Model$1({
        itemStyle: Ln
      }, this, Bn);
      Dn = Cn.levels = setDefault(Dn, Bn);
      var Nn = map$1(Dn || [], function(Pn) {
        return new Model$1(Pn, $n, Bn);
      }, this), Rn = Tree$1.createTree(In, this, Fn);
      function Fn(Pn) {
        Pn.wrapMethod("getItemModel", function(Un, Hn) {
          var zn = Rn.getNodeByDataIndex(Hn), Gn = zn ? Nn[zn.depth] : null;
          return Un.parentModel = Gn || $n, Un;
        });
      }
      return Rn.data;
    }, nr.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      var Dn = this.getData(), Ln = this.getRawValue(Cn), $n = Dn.getName(Cn);
      return createTooltipMarkup("nameValue", {
        name: $n,
        value: Ln
      });
    }, nr.prototype.getDataParams = function(Cn) {
      var Bn = _n.prototype.getDataParams.apply(this, arguments), In = this.getData().tree.getNodeByDataIndex(Cn);
      return Bn.treeAncestors = wrapTreePathInfo(In, this), Bn.treePathInfo = Bn.treeAncestors, Bn;
    }, nr.prototype.setLayoutInfo = function(Cn) {
      this.layoutInfo = this.layoutInfo || {}, extend(this.layoutInfo, Cn);
    }, nr.prototype.mapIdToIndex = function(Cn) {
      var Bn = this._idIndexMap;
      Bn || (Bn = this._idIndexMap = createHashMap(), this._idIndexMapCount = 0);
      var In = Bn.get(Cn);
      return In == null && Bn.set(Cn, In = this._idIndexMapCount++), In;
    }, nr.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, nr.prototype.resetViewRoot = function(Cn) {
      Cn ? this._viewRoot = Cn : Cn = this._viewRoot;
      var Bn = this.getRawData().tree.root;
      (!Cn || Cn !== Bn && !Bn.contains(Cn)) && (this._viewRoot = Bn);
    }, nr.prototype.enableAriaDecal = function() {
      enableAriaDecalForTree(this);
    }, nr.type = "series.treemap", nr.layoutMode = "box", nr.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "▶",
      // to align specialized icon. ▷▶❒❐▼✚
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: !0,
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        top: "bottom",
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
            // '#5793f3',
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: "#fff",
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, nr;
  }(SeriesModel$1)
);
function completeTreeValue$1(_n) {
  var nr = 0;
  each$f(_n.children, function(Bn) {
    completeTreeValue$1(Bn);
    var In = Bn.value;
    isArray$4(In) && (In = In[0]), nr += In;
  });
  var Cn = _n.value;
  isArray$4(Cn) && (Cn = Cn[0]), (Cn == null || isNaN(Cn)) && (Cn = nr), Cn < 0 && (Cn = 0), isArray$4(_n.value) ? _n.value[0] = Cn : _n.value = Cn;
}
function setDefault(_n, nr) {
  var Cn = normalizeToArray(nr.get("color")), Bn = normalizeToArray(nr.get(["aria", "decal", "decals"]));
  if (Cn) {
    _n = _n || [];
    var In, Dn;
    each$f(_n, function($n) {
      var Nn = new Model$1($n), Rn = Nn.get("color"), Fn = Nn.get("decal");
      (Nn.get(["itemStyle", "color"]) || Rn && Rn !== "none") && (In = !0), (Nn.get(["itemStyle", "decal"]) || Fn && Fn !== "none") && (Dn = !0);
    });
    var Ln = _n[0] || (_n[0] = {});
    return In || (Ln.color = Cn.slice()), !Dn && Bn && (Ln.decal = Bn.slice()), _n;
  }
}
const TreemapSeriesModel$1 = TreemapSeriesModel;
var TEXT_PADDING = 8, ITEM_GAP = 8, ARRAY_LENGTH = 5, Breadcrumb = (
  /** @class */
  function() {
    function _n(nr) {
      this.group = new Group$4(), nr.add(this.group);
    }
    return _n.prototype.render = function(nr, Cn, Bn, In) {
      var Dn = nr.getModel("breadcrumb"), Ln = this.group;
      if (Ln.removeAll(), !(!Dn.get("show") || !Bn)) {
        var $n = Dn.getModel("itemStyle"), Nn = Dn.getModel("emphasis"), Rn = $n.getModel("textStyle"), Fn = Nn.getModel(["itemStyle", "textStyle"]), Pn = {
          pos: {
            left: Dn.get("left"),
            right: Dn.get("right"),
            top: Dn.get("top"),
            bottom: Dn.get("bottom")
          },
          box: {
            width: Cn.getWidth(),
            height: Cn.getHeight()
          },
          emptyItemWidth: Dn.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(Bn, Pn, Rn), this._renderContent(nr, Pn, $n, Nn, Rn, Fn, In), positionElement(Ln, Pn.pos, Pn.box);
      }
    }, _n.prototype._prepare = function(nr, Cn, Bn) {
      for (var In = nr; In; In = In.parentNode) {
        var Dn = convertOptionIdName(In.getModel().get("name"), ""), Ln = Bn.getTextRect(Dn), $n = Math.max(Ln.width + TEXT_PADDING * 2, Cn.emptyItemWidth);
        Cn.totalWidth += $n + ITEM_GAP, Cn.renderList.push({
          node: In,
          text: Dn,
          width: $n
        });
      }
    }, _n.prototype._renderContent = function(nr, Cn, Bn, In, Dn, Ln, $n) {
      for (var Nn = 0, Rn = Cn.emptyItemWidth, Fn = nr.get(["breadcrumb", "height"]), Pn = getAvailableSize(Cn.pos, Cn.box), Un = Cn.totalWidth, Hn = Cn.renderList, zn = In.getModel("itemStyle").getItemStyle(), Gn = Hn.length - 1; Gn >= 0; Gn--) {
        var Yn = Hn[Gn], Wn = Yn.node, Xn = Yn.width, ea = Yn.text;
        Un > Pn.width && (Un -= Xn - Rn, Xn = Rn, ea = null);
        var ta = new Polygon$1({
          shape: {
            points: makeItemPoints(Nn, 0, Xn, Fn, Gn === Hn.length - 1, Gn === 0)
          },
          style: defaults(Bn.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new ZRText$1({
            style: createTextStyle$1(Dn, {
              text: ea
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: Z2_EMPHASIS_LIFT * 1e4,
          onclick: curry$1($n, Wn)
        });
        ta.disableLabelAnimation = !0, ta.getTextContent().ensureState("emphasis").style = createTextStyle$1(Ln, {
          text: ea
        }), ta.ensureState("emphasis").style = zn, toggleHoverEmphasis(ta, In.get("focus"), In.get("blurScope"), In.get("disabled")), this.group.add(ta), packEventData(ta, nr, Wn), Nn += Xn + ITEM_GAP;
      }
    }, _n.prototype.remove = function() {
      this.group.removeAll();
    }, _n;
  }()
);
function makeItemPoints(_n, nr, Cn, Bn, In, Dn) {
  var Ln = [[In ? _n : _n - ARRAY_LENGTH, nr], [_n + Cn, nr], [_n + Cn, nr + Bn], [In ? _n : _n - ARRAY_LENGTH, nr + Bn]];
  return !Dn && Ln.splice(2, 0, [_n + Cn + ARRAY_LENGTH, nr + Bn / 2]), !In && Ln.push([_n, nr + Bn / 2]), Ln;
}
function packEventData(_n, nr, Cn) {
  getECData(_n).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: nr.componentIndex,
    seriesIndex: nr.seriesIndex,
    seriesName: nr.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: Cn && Cn.dataIndex,
      name: Cn && Cn.name
    },
    treePathInfo: Cn && wrapTreePathInfo(Cn, nr)
  };
}
const Breadcrumb$1 = Breadcrumb;
var AnimationWrap = (
  /** @class */
  function() {
    function _n() {
      this._storage = [], this._elExistsMap = {};
    }
    return _n.prototype.add = function(nr, Cn, Bn, In, Dn) {
      return this._elExistsMap[nr.id] ? !1 : (this._elExistsMap[nr.id] = !0, this._storage.push({
        el: nr,
        target: Cn,
        duration: Bn,
        delay: In,
        easing: Dn
      }), !0);
    }, _n.prototype.finished = function(nr) {
      return this._finishedCallback = nr, this;
    }, _n.prototype.start = function() {
      for (var nr = this, Cn = this._storage.length, Bn = function() {
        Cn--, Cn <= 0 && (nr._storage.length = 0, nr._elExistsMap = {}, nr._finishedCallback && nr._finishedCallback());
      }, In = 0, Dn = this._storage.length; In < Dn; In++) {
        var Ln = this._storage[In];
        Ln.el.animateTo(Ln.target, {
          duration: Ln.duration,
          delay: Ln.delay,
          easing: Ln.easing,
          setToFinal: !0,
          done: Bn,
          aborted: Bn
        });
      }
      return this;
    }, _n;
  }()
);
function createWrap() {
  return new AnimationWrap();
}
var Group$2 = Group$4, Rect$1 = Rect$3, DRAG_THRESHOLD = 3, PATH_LABEL_NOAMAL = "label", PATH_UPPERLABEL_NORMAL = "upperLabel", Z2_BASE = Z2_EMPHASIS_LIFT * 10, Z2_BG = Z2_EMPHASIS_LIFT * 2, Z2_CONTENT = Z2_EMPHASIS_LIFT * 3, getStateItemStyle = makeStyleMapper([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), getItemStyleNormal = function(_n) {
  var nr = getStateItemStyle(_n);
  return nr.stroke = nr.fill = nr.lineWidth = null, nr;
}, inner$d = makeInner(), TreemapView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn._state = "ready", Cn._storage = createStorage(), Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      var Ln = Bn.findComponents({
        mainType: "series",
        subType: "treemap",
        query: Dn
      });
      if (!(indexOf(Ln, Cn) < 0)) {
        this.seriesModel = Cn, this.api = In, this.ecModel = Bn;
        var $n = ["treemapZoomToNode", "treemapRootToNode"], Nn = retrieveTargetInfo(Dn, $n, Cn), Rn = Dn && Dn.type, Fn = Cn.layoutInfo, Pn = !this._oldTree, Un = this._storage, Hn = Rn === "treemapRootToNode" && Nn && Un ? {
          rootNodeGroup: Un.nodeGroup[Nn.node.getRawIndex()],
          direction: Dn.direction
        } : null, zn = this._giveContainerGroup(Fn), Gn = Cn.get("animation"), Yn = this._doRender(zn, Cn, Hn);
        Gn && !Pn && (!Rn || Rn === "treemapZoomToNode" || Rn === "treemapRootToNode") ? this._doAnimation(zn, Yn, Cn, Hn) : Yn.renderFinally(), this._resetController(In), this._renderBreadcrumb(Cn, In, Nn);
      }
    }, nr.prototype._giveContainerGroup = function(Cn) {
      var Bn = this._containerGroup;
      return Bn || (Bn = this._containerGroup = new Group$2(), this._initEvents(Bn), this.group.add(Bn)), Bn.x = Cn.x, Bn.y = Cn.y, Bn;
    }, nr.prototype._doRender = function(Cn, Bn, In) {
      var Dn = Bn.getData().tree, Ln = this._oldTree, $n = createStorage(), Nn = createStorage(), Rn = this._storage, Fn = [];
      function Pn(Xn, ea, ta, na) {
        return renderNode(Bn, Nn, Rn, In, $n, Fn, Xn, ea, ta, na);
      }
      Gn(Dn.root ? [Dn.root] : [], Ln && Ln.root ? [Ln.root] : [], Cn, Dn === Ln || !Ln, 0);
      var Un = Yn(Rn);
      if (this._oldTree = Dn, this._storage = Nn, this._controllerHost) {
        var Hn = this.seriesModel.layoutInfo, zn = Dn.root.getLayout();
        zn.width === Hn.width && zn.height === Hn.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: $n,
        willDeleteEls: Un,
        renderFinally: Wn
      };
      function Gn(Xn, ea, ta, na, ra) {
        na ? (ea = Xn, each$f(Xn, function(Aa, sa) {
          !Aa.isRemoved() && ia(sa, sa);
        })) : new DataDiffer$1(ea, Xn, aa, aa).add(ia).update(ia).remove(curry$1(ia, null)).execute();
        function aa(Aa) {
          return Aa.getId();
        }
        function ia(Aa, sa) {
          var oa = Aa != null ? Xn[Aa] : null, la = sa != null ? ea[sa] : null, ua = Pn(oa, la, ta, ra);
          ua && Gn(oa && oa.viewChildren || [], la && la.viewChildren || [], ua, na, ra + 1);
        }
      }
      function Yn(Xn) {
        var ea = createStorage();
        return Xn && each$f(Xn, function(ta, na) {
          var ra = ea[na];
          each$f(ta, function(aa) {
            aa && (ra.push(aa), inner$d(aa).willDelete = !0);
          });
        }), ea;
      }
      function Wn() {
        each$f(Un, function(Xn) {
          each$f(Xn, function(ea) {
            ea.parent && ea.parent.remove(ea);
          });
        }), each$f(Fn, function(Xn) {
          Xn.invisible = !0, Xn.dirty();
        });
      }
    }, nr.prototype._doAnimation = function(Cn, Bn, In, Dn) {
      var Ln = In.get("animationDurationUpdate"), $n = In.get("animationEasing"), Nn = (isFunction$1(Ln) ? 0 : Ln) || 0, Rn = (isFunction$1($n) ? null : $n) || "cubicOut", Fn = createWrap();
      each$f(Bn.willDeleteEls, function(Pn, Un) {
        each$f(Pn, function(Hn, zn) {
          if (!Hn.invisible) {
            var Gn = Hn.parent, Yn, Wn = inner$d(Gn);
            if (Dn && Dn.direction === "drillDown")
              Yn = Gn === Dn.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: Wn.nodeWidth,
                  height: Wn.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var Xn = 0, ea = 0;
              Wn.willDelete || (Xn = Wn.nodeWidth / 2, ea = Wn.nodeHeight / 2), Yn = Un === "nodeGroup" ? {
                x: Xn,
                y: ea,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: Xn,
                  y: ea,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            Yn && Fn.add(Hn, Yn, Nn, 0, Rn);
          }
        });
      }), each$f(this._storage, function(Pn, Un) {
        each$f(Pn, function(Hn, zn) {
          var Gn = Bn.lastsForAnimation[Un][zn], Yn = {};
          Gn && (Hn instanceof Group$4 ? Gn.oldX != null && (Yn.x = Hn.x, Yn.y = Hn.y, Hn.x = Gn.oldX, Hn.y = Gn.oldY) : (Gn.oldShape && (Yn.shape = extend({}, Hn.shape), Hn.setShape(Gn.oldShape)), Gn.fadein ? (Hn.setStyle("opacity", 0), Yn.style = {
            opacity: 1
          }) : Hn.style.opacity !== 1 && (Yn.style = {
            opacity: 1
          })), Fn.add(Hn, Yn, Nn, 0, Rn));
        });
      }, this), this._state = "animating", Fn.finished(bind$1(function() {
        this._state = "ready", Bn.renderFinally();
      }, this)).start();
    }, nr.prototype._resetController = function(Cn) {
      var Bn = this._controller, In = this._controllerHost;
      In || (this._controllerHost = {
        target: this.group
      }, In = this._controllerHost), Bn || (Bn = this._controller = new RoamController$1(Cn.getZr()), Bn.enable(this.seriesModel.get("roam")), In.zoomLimit = this.seriesModel.get("scaleLimit"), In.zoom = this.seriesModel.get("zoom"), Bn.on("pan", bind$1(this._onPan, this)), Bn.on("zoom", bind$1(this._onZoom, this)));
      var Dn = new BoundingRect$1(0, 0, Cn.getWidth(), Cn.getHeight());
      Bn.setPointerChecker(function(Ln, $n, Nn) {
        return Dn.contain($n, Nn);
      });
    }, nr.prototype._clearController = function() {
      var Cn = this._controller;
      this._controllerHost = null, Cn && (Cn.dispose(), Cn = null);
    }, nr.prototype._onPan = function(Cn) {
      if (this._state !== "animating" && (Math.abs(Cn.dx) > DRAG_THRESHOLD || Math.abs(Cn.dy) > DRAG_THRESHOLD)) {
        var Bn = this.seriesModel.getData().tree.root;
        if (!Bn)
          return;
        var In = Bn.getLayout();
        if (!In)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: In.x + Cn.dx,
            y: In.y + Cn.dy,
            width: In.width,
            height: In.height
          }
        });
      }
    }, nr.prototype._onZoom = function(Cn) {
      var Bn = Cn.originX, In = Cn.originY, Dn = Cn.scale;
      if (this._state !== "animating") {
        var Ln = this.seriesModel.getData().tree.root;
        if (!Ln)
          return;
        var $n = Ln.getLayout();
        if (!$n)
          return;
        var Nn = new BoundingRect$1($n.x, $n.y, $n.width, $n.height), Rn = null, Fn = this._controllerHost;
        Rn = Fn.zoomLimit;
        var Pn = Fn.zoom = Fn.zoom || 1;
        if (Pn *= Dn, Rn) {
          var Un = Rn.min || 0, Hn = Rn.max || 1 / 0;
          Pn = Math.max(Math.min(Hn, Pn), Un);
        }
        var zn = Pn / Fn.zoom;
        Fn.zoom = Pn;
        var Gn = this.seriesModel.layoutInfo;
        Bn -= Gn.x, In -= Gn.y;
        var Yn = create$1();
        translate(Yn, Yn, [-Bn, -In]), scale$1(Yn, Yn, [zn, zn]), translate(Yn, Yn, [Bn, In]), Nn.applyTransform(Yn), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: Nn.x,
            y: Nn.y,
            width: Nn.width,
            height: Nn.height
          }
        });
      }
    }, nr.prototype._initEvents = function(Cn) {
      var Bn = this;
      Cn.on("click", function(In) {
        if (Bn._state === "ready") {
          var Dn = Bn.seriesModel.get("nodeClick", !0);
          if (Dn) {
            var Ln = Bn.findTarget(In.offsetX, In.offsetY);
            if (Ln) {
              var $n = Ln.node;
              if ($n.getLayout().isLeafRoot)
                Bn._rootToNode(Ln);
              else if (Dn === "zoomToNode")
                Bn._zoomToNode(Ln);
              else if (Dn === "link") {
                var Nn = $n.hostTree.data.getItemModel($n.dataIndex), Rn = Nn.get("link", !0), Fn = Nn.get("target", !0) || "blank";
                Rn && windowOpen(Rn, Fn);
              }
            }
          }
        }
      }, this);
    }, nr.prototype._renderBreadcrumb = function(Cn, Bn, In) {
      var Dn = this;
      In || (In = Cn.get("leafDepth", !0) != null ? {
        node: Cn.getViewRoot()
      } : this.findTarget(Bn.getWidth() / 2, Bn.getHeight() / 2), In || (In = {
        node: Cn.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new Breadcrumb$1(this.group))).render(Cn, Bn, In.node, function(Ln) {
        Dn._state !== "animating" && (aboveViewRoot(Cn.getViewRoot(), Ln) ? Dn._rootToNode({
          node: Ln
        }) : Dn._zoomToNode({
          node: Ln
        }));
      });
    }, nr.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = createStorage(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, nr.prototype.dispose = function() {
      this._clearController();
    }, nr.prototype._zoomToNode = function(Cn) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: Cn.node
      });
    }, nr.prototype._rootToNode = function(Cn) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: Cn.node
      });
    }, nr.prototype.findTarget = function(Cn, Bn) {
      var In, Dn = this.seriesModel.getViewRoot();
      return Dn.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(Ln) {
        var $n = this._storage.background[Ln.getRawIndex()];
        if ($n) {
          var Nn = $n.transformCoordToLocal(Cn, Bn), Rn = $n.shape;
          if (Rn.x <= Nn[0] && Nn[0] <= Rn.x + Rn.width && Rn.y <= Nn[1] && Nn[1] <= Rn.y + Rn.height)
            In = {
              node: Ln,
              offsetX: Nn[0],
              offsetY: Nn[1]
            };
          else
            return !1;
        }
      }, this), In;
    }, nr.type = "treemap", nr;
  }(ChartView$1)
);
function createStorage() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function renderNode(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn) {
  if (!Ln)
    return;
  var Fn = Ln.getLayout(), Pn = _n.getData(), Un = Ln.getModel();
  if (Pn.setItemGraphicEl(Ln.dataIndex, null), !Fn || !Fn.isInView)
    return;
  var Hn = Fn.width, zn = Fn.height, Gn = Fn.borderWidth, Yn = Fn.invisible, Wn = Ln.getRawIndex(), Xn = $n && $n.getRawIndex(), ea = Ln.viewChildren, ta = Fn.upperHeight, na = ea && ea.length, ra = Un.getModel("itemStyle"), aa = Un.getModel(["emphasis", "itemStyle"]), ia = Un.getModel(["blur", "itemStyle"]), Aa = Un.getModel(["select", "itemStyle"]), sa = ra.get("borderRadius") || 0, oa = wa("nodeGroup", Group$2);
  if (!oa)
    return;
  if (Nn.add(oa), oa.x = Fn.x || 0, oa.y = Fn.y || 0, oa.markRedraw(), inner$d(oa).nodeWidth = Hn, inner$d(oa).nodeHeight = zn, Fn.isAboveViewRoot)
    return oa;
  var la = wa("background", Rect$1, Rn, Z2_BG);
  la && Ca(oa, la, na && Fn.upperLabelHeight);
  var ua = Un.getModel("emphasis"), ca = ua.get("focus"), fa = ua.get("blurScope"), ha = ua.get("disabled"), pa = ca === "ancestor" ? Ln.getAncestorsIndices() : ca === "descendant" ? Ln.getDescendantIndices() : ca;
  if (na)
    isHighDownDispatcher(oa) && setAsHighDownDispatcher(oa, !1), la && (setAsHighDownDispatcher(la, !ha), Pn.setItemGraphicEl(Ln.dataIndex, la), enableHoverFocus(la, pa, fa));
  else {
    var ya = wa("content", Rect$1, Rn, Z2_CONTENT);
    ya && ma(oa, ya), la.disableMorphing = !0, la && isHighDownDispatcher(la) && setAsHighDownDispatcher(la, !1), setAsHighDownDispatcher(oa, !ha), Pn.setItemGraphicEl(Ln.dataIndex, oa);
    var da = Un.getShallow("cursor");
    da && ya.attr("cursor", da), enableHoverFocus(oa, pa, fa);
  }
  return oa;
  function Ca(Sa, Ea, Ia) {
    var Ba = getECData(Ea);
    if (Ba.dataIndex = Ln.dataIndex, Ba.seriesIndex = _n.seriesIndex, Ea.setShape({
      x: 0,
      y: 0,
      width: Hn,
      height: zn,
      r: sa
    }), Yn)
      va(Ea);
    else {
      Ea.invisible = !1;
      var Ma = Ln.getVisual("style"), La = Ma.stroke, Da = getItemStyleNormal(ra);
      Da.fill = La;
      var Na = getStateItemStyle(aa);
      Na.fill = aa.get("borderColor");
      var $a = getStateItemStyle(ia);
      $a.fill = ia.get("borderColor");
      var Oa = getStateItemStyle(Aa);
      if (Oa.fill = Aa.get("borderColor"), Ia) {
        var Pa = Hn - 2 * Gn;
        ga(
          // PENDING: convert ZRColor to ColorString for text.
          Ea,
          La,
          Ma.opacity,
          {
            x: Gn,
            y: 0,
            width: Pa,
            height: ta
          }
        );
      } else
        Ea.removeTextContent();
      Ea.setStyle(Da), Ea.ensureState("emphasis").style = Na, Ea.ensureState("blur").style = $a, Ea.ensureState("select").style = Oa, setDefaultStateProxy(Ea);
    }
    Sa.add(Ea);
  }
  function ma(Sa, Ea) {
    var Ia = getECData(Ea);
    Ia.dataIndex = Ln.dataIndex, Ia.seriesIndex = _n.seriesIndex;
    var Ba = Math.max(Hn - 2 * Gn, 0), Ma = Math.max(zn - 2 * Gn, 0);
    if (Ea.culling = !0, Ea.setShape({
      x: Gn,
      y: Gn,
      width: Ba,
      height: Ma,
      r: sa
    }), Yn)
      va(Ea);
    else {
      Ea.invisible = !1;
      var La = Ln.getVisual("style"), Da = La.fill, Na = getItemStyleNormal(ra);
      Na.fill = Da, Na.decal = La.decal;
      var $a = getStateItemStyle(aa), Oa = getStateItemStyle(ia), Pa = getStateItemStyle(Aa);
      ga(Ea, Da, La.opacity, null), Ea.setStyle(Na), Ea.ensureState("emphasis").style = $a, Ea.ensureState("blur").style = Oa, Ea.ensureState("select").style = Pa, setDefaultStateProxy(Ea);
    }
    Sa.add(Ea);
  }
  function va(Sa) {
    !Sa.invisible && Dn.push(Sa);
  }
  function ga(Sa, Ea, Ia, Ba) {
    var Ma = Un.getModel(Ba ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), La = convertOptionIdName(Un.get("name"), null), Da = Ma.getShallow("show");
    setLabelStyle(Sa, getLabelStatesModels(Un, Ba ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
      defaultText: Da ? La : null,
      inheritColor: Ea,
      defaultOpacity: Ia,
      labelFetcher: _n,
      labelDataIndex: Ln.dataIndex
    });
    var Na = Sa.getTextContent();
    if (Na) {
      var $a = Na.style, Oa = normalizeCssArray$1($a.padding || 0);
      Ba && (Sa.setTextConfig({
        layoutRect: Ba
      }), Na.disableLabelLayout = !0), Na.beforeUpdate = function() {
        var ka = Math.max((Ba ? Ba.width : Sa.shape.width) - Oa[1] - Oa[3], 0), Ua = Math.max((Ba ? Ba.height : Sa.shape.height) - Oa[0] - Oa[2], 0);
        ($a.width !== ka || $a.height !== Ua) && Na.setStyle({
          width: ka,
          height: Ua
        });
      }, $a.truncateMinChar = 2, $a.lineOverflow = "truncate", xa($a, Ba, Fn);
      var Pa = Na.getState("emphasis");
      xa(Pa ? Pa.style : null, Ba, Fn);
    }
  }
  function xa(Sa, Ea, Ia) {
    var Ba = Sa ? Sa.text : null;
    if (!Ea && Ia.isLeafRoot && Ba != null) {
      var Ma = _n.get("drillDownIcon", !0);
      Sa.text = Ma ? Ma + " " + Ba : Ba;
    }
  }
  function wa(Sa, Ea, Ia, Ba) {
    var Ma = Xn != null && Cn[Sa][Xn], La = In[Sa];
    return Ma ? (Cn[Sa][Xn] = null, ba(La, Ma)) : Yn || (Ma = new Ea(), Ma instanceof Displayable$1 && (Ma.z2 = calculateZ2(Ia, Ba)), Ta(La, Ma)), nr[Sa][Wn] = Ma;
  }
  function ba(Sa, Ea) {
    var Ia = Sa[Wn] = {};
    Ea instanceof Group$2 ? (Ia.oldX = Ea.x, Ia.oldY = Ea.y) : Ia.oldShape = extend({}, Ea.shape);
  }
  function Ta(Sa, Ea) {
    var Ia = Sa[Wn] = {}, Ba = Ln.parentNode, Ma = Ea instanceof Group$4;
    if (Ba && (!Bn || Bn.direction === "drillDown")) {
      var La = 0, Da = 0, Na = In.background[Ba.getRawIndex()];
      !Bn && Na && Na.oldShape && (La = Na.oldShape.width, Da = Na.oldShape.height), Ma ? (Ia.oldX = 0, Ia.oldY = Da) : Ia.oldShape = {
        x: La,
        y: Da,
        width: 0,
        height: 0
      };
    }
    Ia.fadein = !Ma;
  }
}
function calculateZ2(_n, nr) {
  return _n * Z2_BASE + nr;
}
const TreemapView$1 = TreemapView;
var each$c = each$f, isObject = isObject$6, CATEGORY_DEFAULT_VISUAL_INDEX = -1, VisualMapping = (
  /** @class */
  function() {
    function _n(nr) {
      var Cn = nr.mappingMethod, Bn = nr.type, In = this.option = clone$4(nr);
      this.type = Bn, this.mappingMethod = Cn, this._normalizeData = normalizers[Cn];
      var Dn = _n.visualHandlers[Bn];
      this.applyVisual = Dn.applyVisual, this.getColorMapper = Dn.getColorMapper, this._normalizedToVisual = Dn._normalizedToVisual[Cn], Cn === "piecewise" ? (normalizeVisualRange(In), preprocessForPiecewise(In)) : Cn === "category" ? In.categories ? preprocessForSpecifiedCategory(In) : normalizeVisualRange(In, !0) : (assert(Cn !== "linear" || In.dataExtent), normalizeVisualRange(In));
    }
    return _n.prototype.mapValueToVisual = function(nr) {
      var Cn = this._normalizeData(nr);
      return this._normalizedToVisual(Cn, nr);
    }, _n.prototype.getNormalizer = function() {
      return bind$1(this._normalizeData, this);
    }, _n.listVisualTypes = function() {
      return keys(_n.visualHandlers);
    }, _n.isValidType = function(nr) {
      return _n.visualHandlers.hasOwnProperty(nr);
    }, _n.eachVisual = function(nr, Cn, Bn) {
      isObject$6(nr) ? each$f(nr, Cn, Bn) : Cn.call(Bn, nr);
    }, _n.mapVisual = function(nr, Cn, Bn) {
      var In, Dn = isArray$4(nr) ? [] : isObject$6(nr) ? {} : (In = !0, null);
      return _n.eachVisual(nr, function(Ln, $n) {
        var Nn = Cn.call(Bn, Ln, $n);
        In ? Dn = Nn : Dn[$n] = Nn;
      }), Dn;
    }, _n.retrieveVisuals = function(nr) {
      var Cn = {}, Bn;
      return nr && each$c(_n.visualHandlers, function(In, Dn) {
        nr.hasOwnProperty(Dn) && (Cn[Dn] = nr[Dn], Bn = !0);
      }), Bn ? Cn : null;
    }, _n.prepareVisualTypes = function(nr) {
      if (isArray$4(nr))
        nr = nr.slice();
      else if (isObject(nr)) {
        var Cn = [];
        each$c(nr, function(Bn, In) {
          Cn.push(In);
        }), nr = Cn;
      } else
        return [];
      return nr.sort(function(Bn, In) {
        return In === "color" && Bn !== "color" && Bn.indexOf("color") === 0 ? 1 : -1;
      }), nr;
    }, _n.dependsOn = function(nr, Cn) {
      return Cn === "color" ? !!(nr && nr.indexOf(Cn) === 0) : nr === Cn;
    }, _n.findPieceIndex = function(nr, Cn, Bn) {
      for (var In, Dn = 1 / 0, Ln = 0, $n = Cn.length; Ln < $n; Ln++) {
        var Nn = Cn[Ln].value;
        if (Nn != null) {
          if (Nn === nr || isString$1(Nn) && Nn === nr + "")
            return Ln;
          Bn && Un(Nn, Ln);
        }
      }
      for (var Ln = 0, $n = Cn.length; Ln < $n; Ln++) {
        var Rn = Cn[Ln], Fn = Rn.interval, Pn = Rn.close;
        if (Fn) {
          if (Fn[0] === -1 / 0) {
            if (littleThan(Pn[1], nr, Fn[1]))
              return Ln;
          } else if (Fn[1] === 1 / 0) {
            if (littleThan(Pn[0], Fn[0], nr))
              return Ln;
          } else if (littleThan(Pn[0], Fn[0], nr) && littleThan(Pn[1], nr, Fn[1]))
            return Ln;
          Bn && Un(Fn[0], Ln), Bn && Un(Fn[1], Ln);
        }
      }
      if (Bn)
        return nr === 1 / 0 ? Cn.length - 1 : nr === -1 / 0 ? 0 : In;
      function Un(Hn, zn) {
        var Gn = Math.abs(Hn - nr);
        Gn < Dn && (Dn = Gn, In = zn);
      }
    }, _n.visualHandlers = {
      color: {
        applyVisual: makeApplyVisual("color"),
        getColorMapper: function() {
          var nr = this.option;
          return bind$1(nr.mappingMethod === "category" ? function(Cn, Bn) {
            return !Bn && (Cn = this._normalizeData(Cn)), doMapCategory.call(this, Cn);
          } : function(Cn, Bn, In) {
            var Dn = !!In;
            return !Bn && (Cn = this._normalizeData(Cn)), In = fastLerp(Cn, nr.parsedVisual, In), Dn ? In : stringify$1(In, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(nr) {
            return stringify$1(fastLerp(nr, this.option.parsedVisual), "rgba");
          },
          category: doMapCategory,
          piecewise: function(nr, Cn) {
            var Bn = getSpecifiedVisual.call(this, Cn);
            return Bn == null && (Bn = stringify$1(fastLerp(nr, this.option.parsedVisual), "rgba")), Bn;
          },
          fixed: doMapFixed
        }
      },
      colorHue: makePartialColorVisualHandler(function(nr, Cn) {
        return modifyHSL(nr, Cn);
      }),
      colorSaturation: makePartialColorVisualHandler(function(nr, Cn) {
        return modifyHSL(nr, null, Cn);
      }),
      colorLightness: makePartialColorVisualHandler(function(nr, Cn) {
        return modifyHSL(nr, null, null, Cn);
      }),
      colorAlpha: makePartialColorVisualHandler(function(nr, Cn) {
        return modifyAlpha(nr, Cn);
      }),
      decal: {
        applyVisual: makeApplyVisual("decal"),
        _normalizedToVisual: {
          linear: null,
          category: doMapCategory,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: makeApplyVisual("opacity"),
        _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
      },
      liftZ: {
        applyVisual: makeApplyVisual("liftZ"),
        _normalizedToVisual: {
          linear: doMapFixed,
          category: doMapFixed,
          piecewise: doMapFixed,
          fixed: doMapFixed
        }
      },
      symbol: {
        applyVisual: function(nr, Cn, Bn) {
          var In = this.mapValueToVisual(nr);
          Bn("symbol", In);
        },
        _normalizedToVisual: {
          linear: doMapToArray,
          category: doMapCategory,
          piecewise: function(nr, Cn) {
            var Bn = getSpecifiedVisual.call(this, Cn);
            return Bn == null && (Bn = doMapToArray.call(this, nr)), Bn;
          },
          fixed: doMapFixed
        }
      },
      symbolSize: {
        applyVisual: makeApplyVisual("symbolSize"),
        _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
      }
    }, _n;
  }()
);
function preprocessForPiecewise(_n) {
  var nr = _n.pieceList;
  _n.hasSpecialVisual = !1, each$f(nr, function(Cn, Bn) {
    Cn.originIndex = Bn, Cn.visual != null && (_n.hasSpecialVisual = !0);
  });
}
function preprocessForSpecifiedCategory(_n) {
  var nr = _n.categories, Cn = _n.categoryMap = {}, Bn = _n.visual;
  if (each$c(nr, function(Ln, $n) {
    Cn[Ln] = $n;
  }), !isArray$4(Bn)) {
    var In = [];
    isObject$6(Bn) ? each$c(Bn, function(Ln, $n) {
      var Nn = Cn[$n];
      In[Nn ?? CATEGORY_DEFAULT_VISUAL_INDEX] = Ln;
    }) : In[CATEGORY_DEFAULT_VISUAL_INDEX] = Bn, Bn = setVisualToOption(_n, In);
  }
  for (var Dn = nr.length - 1; Dn >= 0; Dn--)
    Bn[Dn] == null && (delete Cn[nr[Dn]], nr.pop());
}
function normalizeVisualRange(_n, nr) {
  var Cn = _n.visual, Bn = [];
  isObject$6(Cn) ? each$c(Cn, function(Dn) {
    Bn.push(Dn);
  }) : Cn != null && Bn.push(Cn);
  var In = {
    color: 1,
    symbol: 1
  };
  !nr && Bn.length === 1 && !In.hasOwnProperty(_n.type) && (Bn[1] = Bn[0]), setVisualToOption(_n, Bn);
}
function makePartialColorVisualHandler(_n) {
  return {
    applyVisual: function(nr, Cn, Bn) {
      var In = this.mapValueToVisual(nr);
      Bn("color", _n(Cn("color"), In));
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  };
}
function doMapToArray(_n) {
  var nr = this.option.visual;
  return nr[Math.round(linearMap$2(_n, [0, 1], [0, nr.length - 1], !0))] || {};
}
function makeApplyVisual(_n) {
  return function(nr, Cn, Bn) {
    Bn(_n, this.mapValueToVisual(nr));
  };
}
function doMapCategory(_n) {
  var nr = this.option.visual;
  return nr[this.option.loop && _n !== CATEGORY_DEFAULT_VISUAL_INDEX ? _n % nr.length : _n];
}
function doMapFixed() {
  return this.option.visual[0];
}
function createNormalizedToNumericVisual(_n) {
  return {
    linear: function(nr) {
      return linearMap$2(nr, _n, this.option.visual, !0);
    },
    category: doMapCategory,
    piecewise: function(nr, Cn) {
      var Bn = getSpecifiedVisual.call(this, Cn);
      return Bn == null && (Bn = linearMap$2(nr, _n, this.option.visual, !0)), Bn;
    },
    fixed: doMapFixed
  };
}
function getSpecifiedVisual(_n) {
  var nr = this.option, Cn = nr.pieceList;
  if (nr.hasSpecialVisual) {
    var Bn = VisualMapping.findPieceIndex(_n, Cn), In = Cn[Bn];
    if (In && In.visual)
      return In.visual[this.type];
  }
}
function setVisualToOption(_n, nr) {
  return _n.visual = nr, _n.type === "color" && (_n.parsedVisual = map$1(nr, function(Cn) {
    var Bn = parse$2(Cn);
    return !Bn && process.env.NODE_ENV !== "production" && warn("'" + Cn + "' is an illegal color, fallback to '#000000'", !0), Bn || [0, 0, 0, 1];
  })), nr;
}
var normalizers = {
  linear: function(_n) {
    return linearMap$2(_n, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(_n) {
    var nr = this.option.pieceList, Cn = VisualMapping.findPieceIndex(_n, nr, !0);
    if (Cn != null)
      return linearMap$2(Cn, [0, nr.length - 1], [0, 1], !0);
  },
  category: function(_n) {
    var nr = this.option.categories ? this.option.categoryMap[_n] : _n;
    return nr ?? CATEGORY_DEFAULT_VISUAL_INDEX;
  },
  fixed: noop$1
};
function littleThan(_n, nr, Cn) {
  return _n ? nr <= Cn : nr < Cn;
}
const VisualMapping$1 = VisualMapping;
var ITEM_STYLE_NORMAL = "itemStyle", inner$c = makeInner();
const treemapVisual = {
  seriesType: "treemap",
  reset: function(_n) {
    var nr = _n.getData().tree, Cn = nr.root;
    Cn.isRemoved() || travelTree(
      Cn,
      // Visual should calculate from tree root but not view root.
      {},
      _n.getViewRoot().getAncestors(),
      _n
    );
  }
};
function travelTree(_n, nr, Cn, Bn) {
  var In = _n.getModel(), Dn = _n.getLayout(), Ln = _n.hostTree.data;
  if (!(!Dn || Dn.invisible || !Dn.isInView)) {
    var $n = In.getModel(ITEM_STYLE_NORMAL), Nn = buildVisuals($n, nr, Bn), Rn = Ln.ensureUniqueItemVisual(_n.dataIndex, "style"), Fn = $n.get("borderColor"), Pn = $n.get("borderColorSaturation"), Un;
    Pn != null && (Un = calculateColor(Nn), Fn = calculateBorderColor(Pn, Un)), Rn.stroke = Fn;
    var Hn = _n.viewChildren;
    if (!Hn || !Hn.length)
      Un = calculateColor(Nn), Rn.fill = Un;
    else {
      var zn = buildVisualMapping(_n, In, Dn, $n, Nn, Hn);
      each$f(Hn, function(Gn, Yn) {
        if (Gn.depth >= Cn.length || Gn === Cn[Gn.depth]) {
          var Wn = mapVisual$1(In, Nn, Gn, Yn, zn, Bn);
          travelTree(Gn, Wn, Cn, Bn);
        }
      });
    }
  }
}
function buildVisuals(_n, nr, Cn) {
  var Bn = extend({}, nr), In = Cn.designatedVisualItemStyle;
  return each$f(["color", "colorAlpha", "colorSaturation"], function(Dn) {
    In[Dn] = nr[Dn];
    var Ln = _n.get(Dn);
    In[Dn] = null, Ln != null && (Bn[Dn] = Ln);
  }), Bn;
}
function calculateColor(_n) {
  var nr = getValueVisualDefine(_n, "color");
  if (nr) {
    var Cn = getValueVisualDefine(_n, "colorAlpha"), Bn = getValueVisualDefine(_n, "colorSaturation");
    return Bn && (nr = modifyHSL(nr, null, null, Bn)), Cn && (nr = modifyAlpha(nr, Cn)), nr;
  }
}
function calculateBorderColor(_n, nr) {
  return nr != null ? modifyHSL(nr, null, null, _n) : null;
}
function getValueVisualDefine(_n, nr) {
  var Cn = _n[nr];
  if (Cn != null && Cn !== "none")
    return Cn;
}
function buildVisualMapping(_n, nr, Cn, Bn, In, Dn) {
  if (!(!Dn || !Dn.length)) {
    var Ln = getRangeVisual(nr, "color") || In.color != null && In.color !== "none" && (getRangeVisual(nr, "colorAlpha") || getRangeVisual(nr, "colorSaturation"));
    if (Ln) {
      var $n = nr.get("visualMin"), Nn = nr.get("visualMax"), Rn = Cn.dataExtent.slice();
      $n != null && $n < Rn[0] && (Rn[0] = $n), Nn != null && Nn > Rn[1] && (Rn[1] = Nn);
      var Fn = nr.get("colorMappingBy"), Pn = {
        type: Ln.name,
        dataExtent: Rn,
        visual: Ln.range
      };
      Pn.type === "color" && (Fn === "index" || Fn === "id") ? (Pn.mappingMethod = "category", Pn.loop = !0) : Pn.mappingMethod = "linear";
      var Un = new VisualMapping$1(Pn);
      return inner$c(Un).drColorMappingBy = Fn, Un;
    }
  }
}
function getRangeVisual(_n, nr) {
  var Cn = _n.get(nr);
  return isArray$4(Cn) && Cn.length ? {
    name: nr,
    range: Cn
  } : null;
}
function mapVisual$1(_n, nr, Cn, Bn, In, Dn) {
  var Ln = extend({}, nr);
  if (In) {
    var $n = In.type, Nn = $n === "color" && inner$c(In).drColorMappingBy, Rn = Nn === "index" ? Bn : Nn === "id" ? Dn.mapIdToIndex(Cn.getId()) : Cn.getValue(_n.get("visualDimension"));
    Ln[$n] = In.mapValueToVisual(Rn);
  }
  return Ln;
}
var mathMax$3 = Math.max, mathMin$3 = Math.min, retrieveValue = retrieve, each$b = each$f, PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"], PATH_GAP_WIDTH = ["itemStyle", "gapWidth"], PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"], PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
const treemapLayout = {
  seriesType: "treemap",
  reset: function(_n, nr, Cn, Bn) {
    var In = Cn.getWidth(), Dn = Cn.getHeight(), Ln = _n.option, $n = getLayoutRect$1(_n.getBoxLayoutParams(), {
      width: Cn.getWidth(),
      height: Cn.getHeight()
    }), Nn = Ln.size || [], Rn = parsePercent(retrieveValue($n.width, Nn[0]), In), Fn = parsePercent(retrieveValue($n.height, Nn[1]), Dn), Pn = Bn && Bn.type, Un = ["treemapZoomToNode", "treemapRootToNode"], Hn = retrieveTargetInfo(Bn, Un, _n), zn = Pn === "treemapRender" || Pn === "treemapMove" ? Bn.rootRect : null, Gn = _n.getViewRoot(), Yn = getPathToRoot(Gn);
    if (Pn !== "treemapMove") {
      var Wn = Pn === "treemapZoomToNode" ? estimateRootSize(_n, Hn, Gn, Rn, Fn) : zn ? [zn.width, zn.height] : [Rn, Fn], Xn = Ln.sort;
      Xn && Xn !== "asc" && Xn !== "desc" && (Xn = "desc");
      var ea = {
        squareRatio: Ln.squareRatio,
        sort: Xn,
        leafDepth: Ln.leafDepth
      };
      Gn.hostTree.clearLayouts();
      var ta = {
        x: 0,
        y: 0,
        width: Wn[0],
        height: Wn[1],
        area: Wn[0] * Wn[1]
      };
      Gn.setLayout(ta), squarify(Gn, ea, !1, 0), ta = Gn.getLayout(), each$b(Yn, function(ra, aa) {
        var ia = (Yn[aa + 1] || Gn).getValue();
        ra.setLayout(extend({
          dataExtent: [ia, ia],
          borderWidth: 0,
          upperHeight: 0
        }, ta));
      });
    }
    var na = _n.getData().tree.root;
    na.setLayout(calculateRootPosition($n, zn, Hn), !0), _n.setLayoutInfo($n), prunning(
      na,
      // Transform to base element coordinate system.
      new BoundingRect$1(-$n.x, -$n.y, In, Dn),
      Yn,
      Gn,
      0
    );
  }
};
function squarify(_n, nr, Cn, Bn) {
  var In, Dn;
  if (!_n.isRemoved()) {
    var Ln = _n.getLayout();
    In = Ln.width, Dn = Ln.height;
    var $n = _n.getModel(), Nn = $n.get(PATH_BORDER_WIDTH), Rn = $n.get(PATH_GAP_WIDTH) / 2, Fn = getUpperLabelHeight($n), Pn = Math.max(Nn, Fn), Un = Nn - Rn, Hn = Pn - Rn;
    _n.setLayout({
      borderWidth: Nn,
      upperHeight: Pn,
      upperLabelHeight: Fn
    }, !0), In = mathMax$3(In - 2 * Un, 0), Dn = mathMax$3(Dn - Un - Hn, 0);
    var zn = In * Dn, Gn = initChildren$1(_n, $n, zn, nr, Cn, Bn);
    if (Gn.length) {
      var Yn = {
        x: Un,
        y: Hn,
        width: In,
        height: Dn
      }, Wn = mathMin$3(In, Dn), Xn = 1 / 0, ea = [];
      ea.area = 0;
      for (var ta = 0, na = Gn.length; ta < na; ) {
        var ra = Gn[ta];
        ea.push(ra), ea.area += ra.getLayout().area;
        var aa = worst(ea, Wn, nr.squareRatio);
        aa <= Xn ? (ta++, Xn = aa) : (ea.area -= ea.pop().getLayout().area, position(ea, Wn, Yn, Rn, !1), Wn = mathMin$3(Yn.width, Yn.height), ea.length = ea.area = 0, Xn = 1 / 0);
      }
      if (ea.length && position(ea, Wn, Yn, Rn, !0), !Cn) {
        var ia = $n.get("childrenVisibleMin");
        ia != null && zn < ia && (Cn = !0);
      }
      for (var ta = 0, na = Gn.length; ta < na; ta++)
        squarify(Gn[ta], nr, Cn, Bn + 1);
    }
  }
}
function initChildren$1(_n, nr, Cn, Bn, In, Dn) {
  var Ln = _n.children || [], $n = Bn.sort;
  $n !== "asc" && $n !== "desc" && ($n = null);
  var Nn = Bn.leafDepth != null && Bn.leafDepth <= Dn;
  if (In && !Nn)
    return _n.viewChildren = [];
  Ln = filter(Ln, function(Hn) {
    return !Hn.isRemoved();
  }), sort$1(Ln, $n);
  var Rn = statistic(nr, Ln, $n);
  if (Rn.sum === 0)
    return _n.viewChildren = [];
  if (Rn.sum = filterByThreshold(nr, Cn, Rn.sum, $n, Ln), Rn.sum === 0)
    return _n.viewChildren = [];
  for (var Fn = 0, Pn = Ln.length; Fn < Pn; Fn++) {
    var Un = Ln[Fn].getValue() / Rn.sum * Cn;
    Ln[Fn].setLayout({
      area: Un
    });
  }
  return Nn && (Ln.length && _n.setLayout({
    isLeafRoot: !0
  }, !0), Ln.length = 0), _n.viewChildren = Ln, _n.setLayout({
    dataExtent: Rn.dataExtent
  }, !0), Ln;
}
function filterByThreshold(_n, nr, Cn, Bn, In) {
  if (!Bn)
    return Cn;
  for (var Dn = _n.get("visibleMin"), Ln = In.length, $n = Ln, Nn = Ln - 1; Nn >= 0; Nn--) {
    var Rn = In[Bn === "asc" ? Ln - Nn - 1 : Nn].getValue();
    Rn / Cn * nr < Dn && ($n = Nn, Cn -= Rn);
  }
  return Bn === "asc" ? In.splice(0, Ln - $n) : In.splice($n, Ln - $n), Cn;
}
function sort$1(_n, nr) {
  return nr && _n.sort(function(Cn, Bn) {
    var In = nr === "asc" ? Cn.getValue() - Bn.getValue() : Bn.getValue() - Cn.getValue();
    return In === 0 ? nr === "asc" ? Cn.dataIndex - Bn.dataIndex : Bn.dataIndex - Cn.dataIndex : In;
  }), _n;
}
function statistic(_n, nr, Cn) {
  for (var Bn = 0, In = 0, Dn = nr.length; In < Dn; In++)
    Bn += nr[In].getValue();
  var Ln = _n.get("visualDimension"), $n;
  return !nr || !nr.length ? $n = [NaN, NaN] : Ln === "value" && Cn ? ($n = [nr[nr.length - 1].getValue(), nr[0].getValue()], Cn === "asc" && $n.reverse()) : ($n = [1 / 0, -1 / 0], each$b(nr, function(Nn) {
    var Rn = Nn.getValue(Ln);
    Rn < $n[0] && ($n[0] = Rn), Rn > $n[1] && ($n[1] = Rn);
  })), {
    sum: Bn,
    dataExtent: $n
  };
}
function worst(_n, nr, Cn) {
  for (var Bn = 0, In = 1 / 0, Dn = 0, Ln = void 0, $n = _n.length; Dn < $n; Dn++)
    Ln = _n[Dn].getLayout().area, Ln && (Ln < In && (In = Ln), Ln > Bn && (Bn = Ln));
  var Nn = _n.area * _n.area, Rn = nr * nr * Cn;
  return Nn ? mathMax$3(Rn * Bn / Nn, Nn / (Rn * In)) : 1 / 0;
}
function position(_n, nr, Cn, Bn, In) {
  var Dn = nr === Cn.width ? 0 : 1, Ln = 1 - Dn, $n = ["x", "y"], Nn = ["width", "height"], Rn = Cn[$n[Dn]], Fn = nr ? _n.area / nr : 0;
  (In || Fn > Cn[Nn[Ln]]) && (Fn = Cn[Nn[Ln]]);
  for (var Pn = 0, Un = _n.length; Pn < Un; Pn++) {
    var Hn = _n[Pn], zn = {}, Gn = Fn ? Hn.getLayout().area / Fn : 0, Yn = zn[Nn[Ln]] = mathMax$3(Fn - 2 * Bn, 0), Wn = Cn[$n[Dn]] + Cn[Nn[Dn]] - Rn, Xn = Pn === Un - 1 || Wn < Gn ? Wn : Gn, ea = zn[Nn[Dn]] = mathMax$3(Xn - 2 * Bn, 0);
    zn[$n[Ln]] = Cn[$n[Ln]] + mathMin$3(Bn, Yn / 2), zn[$n[Dn]] = Rn + mathMin$3(Bn, ea / 2), Rn += Xn, Hn.setLayout(zn, !0);
  }
  Cn[$n[Ln]] += Fn, Cn[Nn[Ln]] -= Fn;
}
function estimateRootSize(_n, nr, Cn, Bn, In) {
  var Dn = (nr || {}).node, Ln = [Bn, In];
  if (!Dn || Dn === Cn)
    return Ln;
  for (var $n, Nn = Bn * In, Rn = Nn * _n.option.zoomToNodeRatio; $n = Dn.parentNode; ) {
    for (var Fn = 0, Pn = $n.children, Un = 0, Hn = Pn.length; Un < Hn; Un++)
      Fn += Pn[Un].getValue();
    var zn = Dn.getValue();
    if (zn === 0)
      return Ln;
    Rn *= Fn / zn;
    var Gn = $n.getModel(), Yn = Gn.get(PATH_BORDER_WIDTH), Wn = Math.max(Yn, getUpperLabelHeight(Gn));
    Rn += 4 * Yn * Yn + (3 * Yn + Wn) * Math.pow(Rn, 0.5), Rn > MAX_SAFE_INTEGER$2 && (Rn = MAX_SAFE_INTEGER$2), Dn = $n;
  }
  Rn < Nn && (Rn = Nn);
  var Xn = Math.pow(Rn / Nn, 0.5);
  return [Bn * Xn, In * Xn];
}
function calculateRootPosition(_n, nr, Cn) {
  if (nr)
    return {
      x: nr.x,
      y: nr.y
    };
  var Bn = {
    x: 0,
    y: 0
  };
  if (!Cn)
    return Bn;
  var In = Cn.node, Dn = In.getLayout();
  if (!Dn)
    return Bn;
  for (var Ln = [Dn.width / 2, Dn.height / 2], $n = In; $n; ) {
    var Nn = $n.getLayout();
    Ln[0] += Nn.x, Ln[1] += Nn.y, $n = $n.parentNode;
  }
  return {
    x: _n.width / 2 - Ln[0],
    y: _n.height / 2 - Ln[1]
  };
}
function prunning(_n, nr, Cn, Bn, In) {
  var Dn = _n.getLayout(), Ln = Cn[In], $n = Ln && Ln === _n;
  if (!(Ln && !$n || In === Cn.length && _n !== Bn)) {
    _n.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !$n && !nr.intersect(Dn),
      isAboveViewRoot: $n
    }, !0);
    var Nn = new BoundingRect$1(nr.x - Dn.x, nr.y - Dn.y, nr.width, nr.height);
    each$b(_n.viewChildren || [], function(Rn) {
      prunning(Rn, Nn, Cn, Bn, In + 1);
    });
  }
}
function getUpperLabelHeight(_n) {
  return _n.get(PATH_UPPER_LABEL_SHOW) ? _n.get(PATH_UPPER_LABEL_HEIGHT) : 0;
}
function install$G(_n) {
  _n.registerSeriesModel(TreemapSeriesModel$1), _n.registerChartView(TreemapView$1), _n.registerVisual(treemapVisual), _n.registerLayout(treemapLayout), installTreemapAction(_n);
}
function categoryFilter(_n) {
  var nr = _n.findComponents({
    mainType: "legend"
  });
  !nr || !nr.length || _n.eachSeriesByType("graph", function(Cn) {
    var Bn = Cn.getCategoriesData(), In = Cn.getGraph(), Dn = In.data, Ln = Bn.mapArray(Bn.getName);
    Dn.filterSelf(function($n) {
      var Nn = Dn.getItemModel($n), Rn = Nn.getShallow("category");
      if (Rn != null) {
        isNumber(Rn) && (Rn = Ln[Rn]);
        for (var Fn = 0; Fn < nr.length; Fn++)
          if (!nr[Fn].isSelected(Rn))
            return !1;
      }
      return !0;
    });
  });
}
function categoryVisual(_n) {
  var nr = {};
  _n.eachSeriesByType("graph", function(Cn) {
    var Bn = Cn.getCategoriesData(), In = Cn.getData(), Dn = {};
    Bn.each(function(Ln) {
      var $n = Bn.getName(Ln);
      Dn["ec-" + $n] = Ln;
      var Nn = Bn.getItemModel(Ln), Rn = Nn.getModel("itemStyle").getItemStyle();
      Rn.fill || (Rn.fill = Cn.getColorFromPalette($n, nr)), Bn.setItemVisual(Ln, "style", Rn);
      for (var Fn = ["symbol", "symbolSize", "symbolKeepAspect"], Pn = 0; Pn < Fn.length; Pn++) {
        var Un = Nn.getShallow(Fn[Pn], !0);
        Un != null && Bn.setItemVisual(Ln, Fn[Pn], Un);
      }
    }), Bn.count() && In.each(function(Ln) {
      var $n = In.getItemModel(Ln), Nn = $n.getShallow("category");
      if (Nn != null) {
        isString$1(Nn) && (Nn = Dn["ec-" + Nn]);
        var Rn = Bn.getItemVisual(Nn, "style"), Fn = In.ensureUniqueItemVisual(Ln, "style");
        extend(Fn, Rn);
        for (var Pn = ["symbol", "symbolSize", "symbolKeepAspect"], Un = 0; Un < Pn.length; Un++)
          In.setItemVisual(Ln, Pn[Un], Bn.getItemVisual(Nn, Pn[Un]));
      }
    });
  });
}
function normalize$1(_n) {
  return _n instanceof Array || (_n = [_n, _n]), _n;
}
function graphEdgeVisual(_n) {
  _n.eachSeriesByType("graph", function(nr) {
    var Cn = nr.getGraph(), Bn = nr.getEdgeData(), In = normalize$1(nr.get("edgeSymbol")), Dn = normalize$1(nr.get("edgeSymbolSize"));
    Bn.setVisual("fromSymbol", In && In[0]), Bn.setVisual("toSymbol", In && In[1]), Bn.setVisual("fromSymbolSize", Dn && Dn[0]), Bn.setVisual("toSymbolSize", Dn && Dn[1]), Bn.setVisual("style", nr.getModel("lineStyle").getLineStyle()), Bn.each(function(Ln) {
      var $n = Bn.getItemModel(Ln), Nn = Cn.getEdgeByIndex(Ln), Rn = normalize$1($n.getShallow("symbol", !0)), Fn = normalize$1($n.getShallow("symbolSize", !0)), Pn = $n.getModel("lineStyle").getLineStyle(), Un = Bn.ensureUniqueItemVisual(Ln, "style");
      switch (extend(Un, Pn), Un.stroke) {
        case "source": {
          var Hn = Nn.node1.getVisual("style");
          Un.stroke = Hn && Hn.fill;
          break;
        }
        case "target": {
          var Hn = Nn.node2.getVisual("style");
          Un.stroke = Hn && Hn.fill;
          break;
        }
      }
      Rn[0] && Nn.setVisual("fromSymbol", Rn[0]), Rn[1] && Nn.setVisual("toSymbol", Rn[1]), Fn[0] && Nn.setVisual("fromSymbolSize", Fn[0]), Fn[1] && Nn.setVisual("toSymbolSize", Fn[1]);
    });
  });
}
var KEY_DELIMITER = "-->", getAutoCurvenessParams = function(_n) {
  return _n.get("autoCurveness") || null;
}, createCurveness = function(_n, nr) {
  var Cn = getAutoCurvenessParams(_n), Bn = 20, In = [];
  if (isNumber(Cn))
    Bn = Cn;
  else if (isArray$4(Cn)) {
    _n.__curvenessList = Cn;
    return;
  }
  nr > Bn && (Bn = nr);
  var Dn = Bn % 2 ? Bn + 2 : Bn + 3;
  In = [];
  for (var Ln = 0; Ln < Dn; Ln++)
    In.push((Ln % 2 ? Ln + 1 : Ln) / 10 * (Ln % 2 ? -1 : 1));
  _n.__curvenessList = In;
}, getKeyOfEdges = function(_n, nr, Cn) {
  var Bn = [_n.id, _n.dataIndex].join("."), In = [nr.id, nr.dataIndex].join(".");
  return [Cn.uid, Bn, In].join(KEY_DELIMITER);
}, getOppositeKey = function(_n) {
  var nr = _n.split(KEY_DELIMITER);
  return [nr[0], nr[2], nr[1]].join(KEY_DELIMITER);
}, getEdgeFromMap = function(_n, nr) {
  var Cn = getKeyOfEdges(_n.node1, _n.node2, nr);
  return nr.__edgeMap[Cn];
}, getTotalLengthBetweenNodes = function(_n, nr) {
  var Cn = getEdgeMapLengthWithKey(getKeyOfEdges(_n.node1, _n.node2, nr), nr), Bn = getEdgeMapLengthWithKey(getKeyOfEdges(_n.node2, _n.node1, nr), nr);
  return Cn + Bn;
}, getEdgeMapLengthWithKey = function(_n, nr) {
  var Cn = nr.__edgeMap;
  return Cn[_n] ? Cn[_n].length : 0;
};
function initCurvenessList(_n) {
  getAutoCurvenessParams(_n) && (_n.__curvenessList = [], _n.__edgeMap = {}, createCurveness(_n));
}
function createEdgeMapForCurveness(_n, nr, Cn, Bn) {
  if (getAutoCurvenessParams(Cn)) {
    var In = getKeyOfEdges(_n, nr, Cn), Dn = Cn.__edgeMap, Ln = Dn[getOppositeKey(In)];
    Dn[In] && !Ln ? Dn[In].isForward = !0 : Ln && Dn[In] && (Ln.isForward = !0, Dn[In].isForward = !1), Dn[In] = Dn[In] || [], Dn[In].push(Bn);
  }
}
function getCurvenessForEdge(_n, nr, Cn, Bn) {
  var In = getAutoCurvenessParams(nr), Dn = isArray$4(In);
  if (!In)
    return null;
  var Ln = getEdgeFromMap(_n, nr);
  if (!Ln)
    return null;
  for (var $n = -1, Nn = 0; Nn < Ln.length; Nn++)
    if (Ln[Nn] === Cn) {
      $n = Nn;
      break;
    }
  var Rn = getTotalLengthBetweenNodes(_n, nr);
  createCurveness(nr, Rn), _n.lineStyle = _n.lineStyle || {};
  var Fn = getKeyOfEdges(_n.node1, _n.node2, nr), Pn = nr.__curvenessList, Un = Dn || Rn % 2 ? 0 : 1;
  if (Ln.isForward)
    return Pn[Un + $n];
  var Hn = getOppositeKey(Fn), zn = getEdgeMapLengthWithKey(Hn, nr), Gn = Pn[$n + zn + Un];
  return Bn ? Dn ? In && In[0] === 0 ? (zn + Un) % 2 ? Gn : -Gn : ((zn % 2 ? 0 : 1) + Un) % 2 ? Gn : -Gn : (zn + Un) % 2 ? Gn : -Gn : Pn[$n + zn + Un];
}
function simpleLayout(_n) {
  var nr = _n.coordinateSystem;
  if (!(nr && nr.type !== "view")) {
    var Cn = _n.getGraph();
    Cn.eachNode(function(Bn) {
      var In = Bn.getModel();
      Bn.setLayout([+In.get("x"), +In.get("y")]);
    }), simpleLayoutEdge(Cn, _n);
  }
}
function simpleLayoutEdge(_n, nr) {
  _n.eachEdge(function(Cn, Bn) {
    var In = retrieve3(Cn.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(Cn, nr, Bn, !0), 0), Dn = clone$3(Cn.node1.getLayout()), Ln = clone$3(Cn.node2.getLayout()), $n = [Dn, Ln];
    +In && $n.push([(Dn[0] + Ln[0]) / 2 - (Dn[1] - Ln[1]) * In, (Dn[1] + Ln[1]) / 2 - (Ln[0] - Dn[0]) * In]), Cn.setLayout($n);
  });
}
function graphSimpleLayout(_n, nr) {
  _n.eachSeriesByType("graph", function(Cn) {
    var Bn = Cn.get("layout"), In = Cn.coordinateSystem;
    if (In && In.type !== "view") {
      var Dn = Cn.getData(), Ln = [];
      each$f(In.dimensions, function(Un) {
        Ln = Ln.concat(Dn.mapDimensionsAll(Un));
      });
      for (var $n = 0; $n < Dn.count(); $n++) {
        for (var Nn = [], Rn = !1, Fn = 0; Fn < Ln.length; Fn++) {
          var Pn = Dn.get(Ln[Fn], $n);
          isNaN(Pn) || (Rn = !0), Nn.push(Pn);
        }
        Rn ? Dn.setItemLayout($n, In.dataToPoint(Nn)) : Dn.setItemLayout($n, [NaN, NaN]);
      }
      simpleLayoutEdge(Dn.graph, Cn);
    } else
      (!Bn || Bn === "none") && simpleLayout(Cn);
  });
}
function getNodeGlobalScale(_n) {
  var nr = _n.coordinateSystem;
  if (nr.type !== "view")
    return 1;
  var Cn = _n.option.nodeScaleRatio, Bn = nr.scaleX, In = nr.getZoom(), Dn = (In - 1) * Cn + 1;
  return Dn / Bn;
}
function getSymbolSize(_n) {
  var nr = _n.getVisual("symbolSize");
  return nr instanceof Array && (nr = (nr[0] + nr[1]) / 2), +nr;
}
var PI$2 = Math.PI, _symbolRadiansHalf = [];
function circularLayout(_n, nr, Cn, Bn) {
  var In = _n.coordinateSystem;
  if (!(In && In.type !== "view")) {
    var Dn = In.getBoundingRect(), Ln = _n.getData(), $n = Ln.graph, Nn = Dn.width / 2 + Dn.x, Rn = Dn.height / 2 + Dn.y, Fn = Math.min(Dn.width, Dn.height) / 2, Pn = Ln.count();
    if (Ln.setLayout({
      cx: Nn,
      cy: Rn
    }), !!Pn) {
      if (Cn) {
        var Un = In.pointToData(Bn), Hn = Un[0], zn = Un[1], Gn = [Hn - Nn, zn - Rn];
        normalize$3(Gn, Gn), scale$2(Gn, Gn, Fn), Cn.setLayout([Nn + Gn[0], Rn + Gn[1]], !0);
        var Yn = _n.get(["circular", "rotateLabel"]);
        rotateNodeLabel(Cn, Yn, Nn, Rn);
      }
      _layoutNodesBasedOn[nr](_n, $n, Ln, Fn, Nn, Rn, Pn), $n.eachEdge(function(Wn, Xn) {
        var ea = retrieve3(Wn.getModel().get(["lineStyle", "curveness"]), getCurvenessForEdge(Wn, _n, Xn), 0), ta = clone$3(Wn.node1.getLayout()), na = clone$3(Wn.node2.getLayout()), ra, aa = (ta[0] + na[0]) / 2, ia = (ta[1] + na[1]) / 2;
        +ea && (ea *= 3, ra = [Nn * ea + aa * (1 - ea), Rn * ea + ia * (1 - ea)]), Wn.setLayout([ta, na, ra]);
      });
    }
  }
}
var _layoutNodesBasedOn = {
  value: function(_n, nr, Cn, Bn, In, Dn, Ln) {
    var $n = 0, Nn = Cn.getSum("value"), Rn = Math.PI * 2 / (Nn || Ln);
    nr.eachNode(function(Fn) {
      var Pn = Fn.getValue("value"), Un = Rn * (Nn ? Pn : 1) / 2;
      $n += Un, Fn.setLayout([Bn * Math.cos($n) + In, Bn * Math.sin($n) + Dn]), $n += Un;
    });
  },
  symbolSize: function(_n, nr, Cn, Bn, In, Dn, Ln) {
    var $n = 0;
    _symbolRadiansHalf.length = Ln;
    var Nn = getNodeGlobalScale(_n);
    nr.eachNode(function(Pn) {
      var Un = getSymbolSize(Pn);
      isNaN(Un) && (Un = 2), Un < 0 && (Un = 0), Un *= Nn;
      var Hn = Math.asin(Un / 2 / Bn);
      isNaN(Hn) && (Hn = PI$2 / 2), _symbolRadiansHalf[Pn.dataIndex] = Hn, $n += Hn * 2;
    });
    var Rn = (2 * PI$2 - $n) / Ln / 2, Fn = 0;
    nr.eachNode(function(Pn) {
      var Un = Rn + _symbolRadiansHalf[Pn.dataIndex];
      Fn += Un, (!Pn.getLayout() || !Pn.getLayout().fixed) && Pn.setLayout([Bn * Math.cos(Fn) + In, Bn * Math.sin(Fn) + Dn]), Fn += Un;
    });
  }
};
function rotateNodeLabel(_n, nr, Cn, Bn) {
  var In = _n.getGraphicEl();
  if (In) {
    var Dn = _n.getModel(), Ln = Dn.get(["label", "rotate"]) || 0, $n = In.getSymbolPath();
    if (nr) {
      var Nn = _n.getLayout(), Rn = Math.atan2(Nn[1] - Bn, Nn[0] - Cn);
      Rn < 0 && (Rn = Math.PI * 2 + Rn);
      var Fn = Nn[0] < Cn;
      Fn && (Rn = Rn - Math.PI);
      var Pn = Fn ? "left" : "right";
      $n.setTextConfig({
        rotation: -Rn,
        position: Pn,
        origin: "center"
      });
      var Un = $n.ensureState("emphasis");
      extend(Un.textConfig || (Un.textConfig = {}), {
        position: Pn
      });
    } else
      $n.setTextConfig({
        rotation: Ln *= Math.PI / 180
      });
  }
}
function graphCircularLayout(_n) {
  _n.eachSeriesByType("graph", function(nr) {
    nr.get("layout") === "circular" && circularLayout(nr, "symbolSize");
  });
}
var scaleAndAdd = scaleAndAdd$1;
function forceLayout(_n, nr, Cn) {
  for (var Bn = _n, In = nr, Dn = Cn.rect, Ln = Dn.width, $n = Dn.height, Nn = [Dn.x + Ln / 2, Dn.y + $n / 2], Rn = Cn.gravity == null ? 0.1 : Cn.gravity, Fn = 0; Fn < Bn.length; Fn++) {
    var Pn = Bn[Fn];
    Pn.p || (Pn.p = create$2(Ln * (Math.random() - 0.5) + Nn[0], $n * (Math.random() - 0.5) + Nn[1])), Pn.pp = clone$3(Pn.p), Pn.edges = null;
  }
  var Un = Cn.friction == null ? 0.6 : Cn.friction, Hn = Un, zn, Gn;
  return {
    warmUp: function() {
      Hn = Un * 0.8;
    },
    setFixed: function(Yn) {
      Bn[Yn].fixed = !0;
    },
    setUnfixed: function(Yn) {
      Bn[Yn].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(Yn) {
      zn = Yn;
    },
    /**
     * After step hook
     */
    afterStep: function(Yn) {
      Gn = Yn;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(Yn) {
      zn && zn(Bn, In);
      for (var Wn = [], Xn = Bn.length, ea = 0; ea < In.length; ea++) {
        var ta = In[ea];
        if (!ta.ignoreForceLayout) {
          var na = ta.n1, ra = ta.n2;
          sub(Wn, ra.p, na.p);
          var aa = len(Wn) - ta.d, ia = ra.w / (na.w + ra.w);
          isNaN(ia) && (ia = 0), normalize$3(Wn, Wn), !na.fixed && scaleAndAdd(na.p, na.p, Wn, ia * aa * Hn), !ra.fixed && scaleAndAdd(ra.p, ra.p, Wn, -(1 - ia) * aa * Hn);
        }
      }
      for (var ea = 0; ea < Xn; ea++) {
        var Aa = Bn[ea];
        Aa.fixed || (sub(Wn, Nn, Aa.p), scaleAndAdd(Aa.p, Aa.p, Wn, Rn * Hn));
      }
      for (var ea = 0; ea < Xn; ea++)
        for (var na = Bn[ea], sa = ea + 1; sa < Xn; sa++) {
          var ra = Bn[sa];
          sub(Wn, ra.p, na.p);
          var aa = len(Wn);
          aa === 0 && (set$2(Wn, Math.random() - 0.5, Math.random() - 0.5), aa = 1);
          var oa = (na.rep + ra.rep) / aa / aa;
          !na.fixed && scaleAndAdd(na.pp, na.pp, Wn, oa), !ra.fixed && scaleAndAdd(ra.pp, ra.pp, Wn, -oa);
        }
      for (var la = [], ea = 0; ea < Xn; ea++) {
        var Aa = Bn[ea];
        Aa.fixed || (sub(la, Aa.p, Aa.pp), scaleAndAdd(Aa.p, Aa.p, la, Hn), copy$1(Aa.pp, Aa.p));
      }
      Hn = Hn * 0.992;
      var ua = Hn < 0.01;
      Gn && Gn(Bn, In, ua), Yn && Yn(ua);
    }
  };
}
function graphForceLayout(_n) {
  _n.eachSeriesByType("graph", function(nr) {
    var Cn = nr.coordinateSystem;
    if (!(Cn && Cn.type !== "view"))
      if (nr.get("layout") === "force") {
        var Bn = nr.preservedPoints || {}, In = nr.getGraph(), Dn = In.data, Ln = In.edgeData, $n = nr.getModel("force"), Nn = $n.get("initLayout");
        nr.preservedPoints ? Dn.each(function(ea) {
          var ta = Dn.getId(ea);
          Dn.setItemLayout(ea, Bn[ta] || [NaN, NaN]);
        }) : !Nn || Nn === "none" ? simpleLayout(nr) : Nn === "circular" && circularLayout(nr, "value");
        var Rn = Dn.getDataExtent("value"), Fn = Ln.getDataExtent("value"), Pn = $n.get("repulsion"), Un = $n.get("edgeLength"), Hn = isArray$4(Pn) ? Pn : [Pn, Pn], zn = isArray$4(Un) ? Un : [Un, Un];
        zn = [zn[1], zn[0]];
        var Gn = Dn.mapArray("value", function(ea, ta) {
          var na = Dn.getItemLayout(ta), ra = linearMap$2(ea, Rn, Hn);
          return isNaN(ra) && (ra = (Hn[0] + Hn[1]) / 2), {
            w: ra,
            rep: ra,
            fixed: Dn.getItemModel(ta).get("fixed"),
            p: !na || isNaN(na[0]) || isNaN(na[1]) ? null : na
          };
        }), Yn = Ln.mapArray("value", function(ea, ta) {
          var na = In.getEdgeByIndex(ta), ra = linearMap$2(ea, Fn, zn);
          isNaN(ra) && (ra = (zn[0] + zn[1]) / 2);
          var aa = na.getModel(), ia = retrieve3(na.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(na, nr, ta, !0), 0);
          return {
            n1: Gn[na.node1.dataIndex],
            n2: Gn[na.node2.dataIndex],
            d: ra,
            curveness: ia,
            ignoreForceLayout: aa.get("ignoreForceLayout")
          };
        }), Wn = Cn.getBoundingRect(), Xn = forceLayout(Gn, Yn, {
          rect: Wn,
          gravity: $n.get("gravity"),
          friction: $n.get("friction")
        });
        Xn.beforeStep(function(ea, ta) {
          for (var na = 0, ra = ea.length; na < ra; na++)
            ea[na].fixed && copy$1(ea[na].p, In.getNodeByIndex(na).getLayout());
        }), Xn.afterStep(function(ea, ta, na) {
          for (var ra = 0, aa = ea.length; ra < aa; ra++)
            ea[ra].fixed || In.getNodeByIndex(ra).setLayout(ea[ra].p), Bn[Dn.getId(ra)] = ea[ra].p;
          for (var ra = 0, aa = ta.length; ra < aa; ra++) {
            var ia = ta[ra], Aa = In.getEdgeByIndex(ra), sa = ia.n1.p, oa = ia.n2.p, la = Aa.getLayout();
            la = la ? la.slice() : [], la[0] = la[0] || [], la[1] = la[1] || [], copy$1(la[0], sa), copy$1(la[1], oa), +ia.curveness && (la[2] = [(sa[0] + oa[0]) / 2 - (sa[1] - oa[1]) * ia.curveness, (sa[1] + oa[1]) / 2 - (oa[0] - sa[0]) * ia.curveness]), Aa.setLayout(la);
          }
        }), nr.forceLayout = Xn, nr.preservedPoints = Bn, Xn.step();
      } else
        nr.forceLayout = null;
  });
}
function getViewRect$3(_n, nr, Cn) {
  var Bn = extend(_n.getBoxLayoutParams(), {
    aspect: Cn
  });
  return getLayoutRect$1(Bn, {
    width: nr.getWidth(),
    height: nr.getHeight()
  });
}
function createViewCoordSys(_n, nr) {
  var Cn = [];
  return _n.eachSeriesByType("graph", function(Bn) {
    var In = Bn.get("coordinateSystem");
    if (!In || In === "view") {
      var Dn = Bn.getData(), Ln = Dn.mapArray(function(Yn) {
        var Wn = Dn.getItemModel(Yn);
        return [+Wn.get("x"), +Wn.get("y")];
      }), $n = [], Nn = [];
      fromPoints(Ln, $n, Nn), Nn[0] - $n[0] === 0 && (Nn[0] += 1, $n[0] -= 1), Nn[1] - $n[1] === 0 && (Nn[1] += 1, $n[1] -= 1);
      var Rn = (Nn[0] - $n[0]) / (Nn[1] - $n[1]), Fn = getViewRect$3(Bn, nr, Rn);
      isNaN(Rn) && ($n = [Fn.x, Fn.y], Nn = [Fn.x + Fn.width, Fn.y + Fn.height]);
      var Pn = Nn[0] - $n[0], Un = Nn[1] - $n[1], Hn = Fn.width, zn = Fn.height, Gn = Bn.coordinateSystem = new View$1();
      Gn.zoomLimit = Bn.get("scaleLimit"), Gn.setBoundingRect($n[0], $n[1], Pn, Un), Gn.setViewRect(Fn.x, Fn.y, Hn, zn), Gn.setCenter(Bn.get("center"), nr), Gn.setZoom(Bn.get("zoom")), Cn.push(Gn);
    }
  }), Cn;
}
var straightLineProto = Line$3.prototype, bezierCurveProto = BezierCurve$2.prototype, StraightLineShape = (
  /** @class */
  function() {
    function _n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return _n;
  }()
);
(function(_n) {
  __extends$2(nr, _n);
  function nr() {
    return _n !== null && _n.apply(this, arguments) || this;
  }
  return nr;
})(StraightLineShape);
function isStraightLine(_n) {
  return isNaN(+_n.cpx1) || isNaN(+_n.cpy1);
}
var ECLinePath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "ec-line", Bn;
    }
    return nr.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, nr.prototype.getDefaultShape = function() {
      return new StraightLineShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      isStraightLine(Bn) ? straightLineProto.buildPath.call(this, Cn, Bn) : bezierCurveProto.buildPath.call(this, Cn, Bn);
    }, nr.prototype.pointAt = function(Cn) {
      return isStraightLine(this.shape) ? straightLineProto.pointAt.call(this, Cn) : bezierCurveProto.pointAt.call(this, Cn);
    }, nr.prototype.tangentAt = function(Cn) {
      var Bn = this.shape, In = isStraightLine(Bn) ? [Bn.x2 - Bn.x1, Bn.y2 - Bn.y1] : bezierCurveProto.tangentAt.call(this, Cn);
      return normalize$3(In, In);
    }, nr;
  }(Path$1)
);
const ECLinePath$1 = ECLinePath;
var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
function makeSymbolTypeKey(_n) {
  return "_" + _n + "Type";
}
function makeSymbolTypeValue(_n, nr, Cn) {
  var Bn = nr.getItemVisual(Cn, _n);
  if (!Bn || Bn === "none")
    return Bn;
  var In = nr.getItemVisual(Cn, _n + "Size"), Dn = nr.getItemVisual(Cn, _n + "Rotate"), Ln = nr.getItemVisual(Cn, _n + "Offset"), $n = nr.getItemVisual(Cn, _n + "KeepAspect"), Nn = normalizeSymbolSize(In), Rn = normalizeSymbolOffset(Ln || 0, Nn);
  return Bn + Nn + Rn + (Dn || "") + ($n || "");
}
function createSymbol(_n, nr, Cn) {
  var Bn = nr.getItemVisual(Cn, _n);
  if (!(!Bn || Bn === "none")) {
    var In = nr.getItemVisual(Cn, _n + "Size"), Dn = nr.getItemVisual(Cn, _n + "Rotate"), Ln = nr.getItemVisual(Cn, _n + "Offset"), $n = nr.getItemVisual(Cn, _n + "KeepAspect"), Nn = normalizeSymbolSize(In), Rn = normalizeSymbolOffset(Ln || 0, Nn), Fn = createSymbol$1(Bn, -Nn[0] / 2 + Rn[0], -Nn[1] / 2 + Rn[1], Nn[0], Nn[1], null, $n);
    return Fn.__specifiedRotation = Dn == null || isNaN(Dn) ? void 0 : +Dn * Math.PI / 180 || 0, Fn.name = _n, Fn;
  }
}
function createLine(_n) {
  var nr = new ECLinePath$1({
    name: "line",
    subPixelOptimize: !0
  });
  return setLinePoints(nr.shape, _n), nr;
}
function setLinePoints(_n, nr) {
  _n.x1 = nr[0][0], _n.y1 = nr[0][1], _n.x2 = nr[1][0], _n.y2 = nr[1][1], _n.percent = 1;
  var Cn = nr[2];
  Cn ? (_n.cpx1 = Cn[0], _n.cpy1 = Cn[1]) : (_n.cpx1 = NaN, _n.cpy1 = NaN);
}
var Line = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In) {
      var Dn = _n.call(this) || this;
      return Dn._createLine(Cn, Bn, In), Dn;
    }
    return nr.prototype._createLine = function(Cn, Bn, In) {
      var Dn = Cn.hostModel, Ln = Cn.getItemLayout(Bn), $n = createLine(Ln);
      $n.shape.percent = 0, initProps($n, {
        shape: {
          percent: 1
        }
      }, Dn, Bn), this.add($n), each$f(SYMBOL_CATEGORIES, function(Nn) {
        var Rn = createSymbol(Nn, Cn, Bn);
        this.add(Rn), this[makeSymbolTypeKey(Nn)] = makeSymbolTypeValue(Nn, Cn, Bn);
      }, this), this._updateCommonStl(Cn, Bn, In);
    }, nr.prototype.updateData = function(Cn, Bn, In) {
      var Dn = Cn.hostModel, Ln = this.childOfName("line"), $n = Cn.getItemLayout(Bn), Nn = {
        shape: {}
      };
      setLinePoints(Nn.shape, $n), updateProps$1(Ln, Nn, Dn, Bn), each$f(SYMBOL_CATEGORIES, function(Rn) {
        var Fn = makeSymbolTypeValue(Rn, Cn, Bn), Pn = makeSymbolTypeKey(Rn);
        if (this[Pn] !== Fn) {
          this.remove(this.childOfName(Rn));
          var Un = createSymbol(Rn, Cn, Bn);
          this.add(Un);
        }
        this[Pn] = Fn;
      }, this), this._updateCommonStl(Cn, Bn, In);
    }, nr.prototype.getLinePath = function() {
      return this.childAt(0);
    }, nr.prototype._updateCommonStl = function(Cn, Bn, In) {
      var Dn = Cn.hostModel, Ln = this.childOfName("line"), $n = In && In.emphasisLineStyle, Nn = In && In.blurLineStyle, Rn = In && In.selectLineStyle, Fn = In && In.labelStatesModels, Pn = In && In.emphasisDisabled, Un = In && In.focus, Hn = In && In.blurScope;
      if (!In || Cn.hasItemOption) {
        var zn = Cn.getItemModel(Bn), Gn = zn.getModel("emphasis");
        $n = Gn.getModel("lineStyle").getLineStyle(), Nn = zn.getModel(["blur", "lineStyle"]).getLineStyle(), Rn = zn.getModel(["select", "lineStyle"]).getLineStyle(), Pn = Gn.get("disabled"), Un = Gn.get("focus"), Hn = Gn.get("blurScope"), Fn = getLabelStatesModels(zn);
      }
      var Yn = Cn.getItemVisual(Bn, "style"), Wn = Yn.stroke;
      Ln.useStyle(Yn), Ln.style.fill = null, Ln.style.strokeNoScale = !0, Ln.ensureState("emphasis").style = $n, Ln.ensureState("blur").style = Nn, Ln.ensureState("select").style = Rn, each$f(SYMBOL_CATEGORIES, function(ra) {
        var aa = this.childOfName(ra);
        if (aa) {
          aa.setColor(Wn), aa.style.opacity = Yn.opacity;
          for (var ia = 0; ia < SPECIAL_STATES.length; ia++) {
            var Aa = SPECIAL_STATES[ia], sa = Ln.getState(Aa);
            if (sa) {
              var oa = sa.style || {}, la = aa.ensureState(Aa), ua = la.style || (la.style = {});
              oa.stroke != null && (ua[aa.__isEmptyBrush ? "stroke" : "fill"] = oa.stroke), oa.opacity != null && (ua.opacity = oa.opacity);
            }
          }
          aa.markRedraw();
        }
      }, this);
      var Xn = Dn.getRawValue(Bn);
      setLabelStyle(this, Fn, {
        labelDataIndex: Bn,
        labelFetcher: {
          getFormattedLabel: function(ra, aa) {
            return Dn.getFormattedLabel(ra, aa, Cn.dataType);
          }
        },
        inheritColor: Wn || "#000",
        defaultOpacity: Yn.opacity,
        defaultText: (Xn == null ? Cn.getName(Bn) : isFinite(Xn) ? round$4(Xn) : Xn) + ""
      });
      var ea = this.getTextContent();
      if (ea) {
        var ta = Fn.normal;
        ea.__align = ea.style.align, ea.__verticalAlign = ea.style.verticalAlign, ea.__position = ta.get("position") || "middle";
        var na = ta.get("distance");
        isArray$4(na) || (na = [na, na]), ea.__labelDistance = na;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), toggleHoverEmphasis(this, Un, Hn, Pn);
    }, nr.prototype.highlight = function() {
      enterEmphasis(this);
    }, nr.prototype.downplay = function() {
      leaveEmphasis(this);
    }, nr.prototype.updateLayout = function(Cn, Bn) {
      this.setLinePoints(Cn.getItemLayout(Bn));
    }, nr.prototype.setLinePoints = function(Cn) {
      var Bn = this.childOfName("line");
      setLinePoints(Bn.shape, Cn), Bn.dirty();
    }, nr.prototype.beforeUpdate = function() {
      var Cn = this, Bn = Cn.childOfName("fromSymbol"), In = Cn.childOfName("toSymbol"), Dn = Cn.getTextContent();
      if (!Bn && !In && (!Dn || Dn.ignore))
        return;
      for (var Ln = 1, $n = this.parent; $n; )
        $n.scaleX && (Ln /= $n.scaleX), $n = $n.parent;
      var Nn = Cn.childOfName("line");
      if (!this.__dirty && !Nn.__dirty)
        return;
      var Rn = Nn.shape.percent, Fn = Nn.pointAt(0), Pn = Nn.pointAt(Rn), Un = sub([], Pn, Fn);
      normalize$3(Un, Un);
      function Hn(sa, oa) {
        var la = sa.__specifiedRotation;
        if (la == null) {
          var ua = Nn.tangentAt(oa);
          sa.attr("rotation", (oa === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(ua[1], ua[0]));
        } else
          sa.attr("rotation", la);
      }
      if (Bn && (Bn.setPosition(Fn), Hn(Bn, 0), Bn.scaleX = Bn.scaleY = Ln * Rn, Bn.markRedraw()), In && (In.setPosition(Pn), Hn(In, 1), In.scaleX = In.scaleY = Ln * Rn, In.markRedraw()), Dn && !Dn.ignore) {
        Dn.x = Dn.y = 0, Dn.originX = Dn.originY = 0;
        var zn = void 0, Gn = void 0, Yn = Dn.__labelDistance, Wn = Yn[0] * Ln, Xn = Yn[1] * Ln, ea = Rn / 2, ta = Nn.tangentAt(ea), na = [ta[1], -ta[0]], ra = Nn.pointAt(ea);
        na[1] > 0 && (na[0] = -na[0], na[1] = -na[1]);
        var aa = ta[0] < 0 ? -1 : 1;
        if (Dn.__position !== "start" && Dn.__position !== "end") {
          var ia = -Math.atan2(ta[1], ta[0]);
          Pn[0] < Fn[0] && (ia = Math.PI + ia), Dn.rotation = ia;
        }
        var Aa = void 0;
        switch (Dn.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            Aa = -Xn, Gn = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            Aa = Xn, Gn = "top";
            break;
          default:
            Aa = 0, Gn = "middle";
        }
        switch (Dn.__position) {
          case "end":
            Dn.x = Un[0] * Wn + Pn[0], Dn.y = Un[1] * Xn + Pn[1], zn = Un[0] > 0.8 ? "left" : Un[0] < -0.8 ? "right" : "center", Gn = Un[1] > 0.8 ? "top" : Un[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            Dn.x = -Un[0] * Wn + Fn[0], Dn.y = -Un[1] * Xn + Fn[1], zn = Un[0] > 0.8 ? "right" : Un[0] < -0.8 ? "left" : "center", Gn = Un[1] > 0.8 ? "bottom" : Un[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            Dn.x = Wn * aa + Fn[0], Dn.y = Fn[1] + Aa, zn = ta[0] < 0 ? "right" : "left", Dn.originX = -Wn * aa, Dn.originY = -Aa;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            Dn.x = ra[0], Dn.y = ra[1] + Aa, zn = "center", Dn.originY = -Aa;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            Dn.x = -Wn * aa + Pn[0], Dn.y = Pn[1] + Aa, zn = ta[0] >= 0 ? "right" : "left", Dn.originX = Wn * aa, Dn.originY = -Aa;
            break;
        }
        Dn.scaleX = Dn.scaleY = Ln, Dn.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: Dn.__verticalAlign || Gn,
          align: Dn.__align || zn
        });
      }
    }, nr;
  }(Group$4)
);
const Line$1 = Line;
var LineDraw = (
  /** @class */
  function() {
    function _n(nr) {
      this.group = new Group$4(), this._LineCtor = nr || Line$1;
    }
    return _n.prototype.updateData = function(nr) {
      var Cn = this;
      this._progressiveEls = null;
      var Bn = this, In = Bn.group, Dn = Bn._lineData;
      Bn._lineData = nr, Dn || In.removeAll();
      var Ln = makeSeriesScope$1(nr);
      nr.diff(Dn).add(function($n) {
        Cn._doAdd(nr, $n, Ln);
      }).update(function($n, Nn) {
        Cn._doUpdate(Dn, nr, Nn, $n, Ln);
      }).remove(function($n) {
        In.remove(Dn.getItemGraphicEl($n));
      }).execute();
    }, _n.prototype.updateLayout = function() {
      var nr = this._lineData;
      nr && nr.eachItemGraphicEl(function(Cn, Bn) {
        Cn.updateLayout(nr, Bn);
      }, this);
    }, _n.prototype.incrementalPrepareUpdate = function(nr) {
      this._seriesScope = makeSeriesScope$1(nr), this._lineData = null, this.group.removeAll();
    }, _n.prototype.incrementalUpdate = function(nr, Cn) {
      this._progressiveEls = [];
      function Bn($n) {
        !$n.isGroup && !isEffectObject($n) && ($n.incremental = !0, $n.ensureState("emphasis").hoverLayer = !0);
      }
      for (var In = nr.start; In < nr.end; In++) {
        var Dn = Cn.getItemLayout(In);
        if (lineNeedsDraw(Dn)) {
          var Ln = new this._LineCtor(Cn, In, this._seriesScope);
          Ln.traverse(Bn), this.group.add(Ln), Cn.setItemGraphicEl(In, Ln), this._progressiveEls.push(Ln);
        }
      }
    }, _n.prototype.remove = function() {
      this.group.removeAll();
    }, _n.prototype.eachRendered = function(nr) {
      traverseElements(this._progressiveEls || this.group, nr);
    }, _n.prototype._doAdd = function(nr, Cn, Bn) {
      var In = nr.getItemLayout(Cn);
      if (lineNeedsDraw(In)) {
        var Dn = new this._LineCtor(nr, Cn, Bn);
        nr.setItemGraphicEl(Cn, Dn), this.group.add(Dn);
      }
    }, _n.prototype._doUpdate = function(nr, Cn, Bn, In, Dn) {
      var Ln = nr.getItemGraphicEl(Bn);
      if (!lineNeedsDraw(Cn.getItemLayout(In))) {
        this.group.remove(Ln);
        return;
      }
      Ln ? Ln.updateData(Cn, In, Dn) : Ln = new this._LineCtor(Cn, In, Dn), Cn.setItemGraphicEl(In, Ln), this.group.add(Ln);
    }, _n;
  }()
);
function isEffectObject(_n) {
  return _n.animators && _n.animators.length > 0;
}
function makeSeriesScope$1(_n) {
  var nr = _n.hostModel, Cn = nr.getModel("emphasis");
  return {
    lineStyle: nr.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: Cn.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: nr.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: nr.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: Cn.get("disabled"),
    blurScope: Cn.get("blurScope"),
    focus: Cn.get("focus"),
    labelStatesModels: getLabelStatesModels(nr)
  };
}
function isPointNaN(_n) {
  return isNaN(_n[0]) || isNaN(_n[1]);
}
function lineNeedsDraw(_n) {
  return _n && !isPointNaN(_n[0]) && !isPointNaN(_n[1]);
}
const LineDraw$1 = LineDraw;
var v1 = [], v2 = [], v3 = [], quadraticAt = quadraticAt$1, v2DistSquare = distSquare, mathAbs = Math.abs;
function intersectCurveCircle(_n, nr, Cn) {
  for (var Bn = _n[0], In = _n[1], Dn = _n[2], Ln = 1 / 0, $n, Nn = Cn * Cn, Rn = 0.1, Fn = 0.1; Fn <= 0.9; Fn += 0.1) {
    v1[0] = quadraticAt(Bn[0], In[0], Dn[0], Fn), v1[1] = quadraticAt(Bn[1], In[1], Dn[1], Fn);
    var Pn = mathAbs(v2DistSquare(v1, nr) - Nn);
    Pn < Ln && (Ln = Pn, $n = Fn);
  }
  for (var Un = 0; Un < 32; Un++) {
    var Hn = $n + Rn;
    v2[0] = quadraticAt(Bn[0], In[0], Dn[0], $n), v2[1] = quadraticAt(Bn[1], In[1], Dn[1], $n), v3[0] = quadraticAt(Bn[0], In[0], Dn[0], Hn), v3[1] = quadraticAt(Bn[1], In[1], Dn[1], Hn);
    var Pn = v2DistSquare(v2, nr) - Nn;
    if (mathAbs(Pn) < 0.01)
      break;
    var zn = v2DistSquare(v3, nr) - Nn;
    Rn /= 2, Pn < 0 ? zn >= 0 ? $n = $n + Rn : $n = $n - Rn : zn >= 0 ? $n = $n - Rn : $n = $n + Rn;
  }
  return $n;
}
function adjustEdge(_n, nr) {
  var Cn = [], Bn = quadraticSubdivide, In = [[], [], []], Dn = [[], []], Ln = [];
  nr /= 2, _n.eachEdge(function($n, Nn) {
    var Rn = $n.getLayout(), Fn = $n.getVisual("fromSymbol"), Pn = $n.getVisual("toSymbol");
    Rn.__original || (Rn.__original = [clone$3(Rn[0]), clone$3(Rn[1])], Rn[2] && Rn.__original.push(clone$3(Rn[2])));
    var Un = Rn.__original;
    if (Rn[2] != null) {
      if (copy$1(In[0], Un[0]), copy$1(In[1], Un[2]), copy$1(In[2], Un[1]), Fn && Fn !== "none") {
        var Hn = getSymbolSize($n.node1), zn = intersectCurveCircle(In, Un[0], Hn * nr);
        Bn(In[0][0], In[1][0], In[2][0], zn, Cn), In[0][0] = Cn[3], In[1][0] = Cn[4], Bn(In[0][1], In[1][1], In[2][1], zn, Cn), In[0][1] = Cn[3], In[1][1] = Cn[4];
      }
      if (Pn && Pn !== "none") {
        var Hn = getSymbolSize($n.node2), zn = intersectCurveCircle(In, Un[1], Hn * nr);
        Bn(In[0][0], In[1][0], In[2][0], zn, Cn), In[1][0] = Cn[1], In[2][0] = Cn[2], Bn(In[0][1], In[1][1], In[2][1], zn, Cn), In[1][1] = Cn[1], In[2][1] = Cn[2];
      }
      copy$1(Rn[0], In[0]), copy$1(Rn[1], In[2]), copy$1(Rn[2], In[1]);
    } else {
      if (copy$1(Dn[0], Un[0]), copy$1(Dn[1], Un[1]), sub(Ln, Dn[1], Dn[0]), normalize$3(Ln, Ln), Fn && Fn !== "none") {
        var Hn = getSymbolSize($n.node1);
        scaleAndAdd$1(Dn[0], Dn[0], Ln, Hn * nr);
      }
      if (Pn && Pn !== "none") {
        var Hn = getSymbolSize($n.node2);
        scaleAndAdd$1(Dn[1], Dn[1], Ln, -Hn * nr);
      }
      copy$1(Rn[0], Dn[0]), copy$1(Rn[1], Dn[1]);
    }
  });
}
function isViewCoordSys(_n) {
  return _n.type === "view";
}
var GraphView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      var In = new SymbolDraw$1(), Dn = new LineDraw$1(), Ln = this.group;
      this._controller = new RoamController$1(Bn.getZr()), this._controllerHost = {
        target: Ln
      }, Ln.add(In.group), Ln.add(Dn.group), this._symbolDraw = In, this._lineDraw = Dn, this._firstRender = !0;
    }, nr.prototype.render = function(Cn, Bn, In) {
      var Dn = this, Ln = Cn.coordinateSystem;
      this._model = Cn;
      var $n = this._symbolDraw, Nn = this._lineDraw, Rn = this.group;
      if (isViewCoordSys(Ln)) {
        var Fn = {
          x: Ln.x,
          y: Ln.y,
          scaleX: Ln.scaleX,
          scaleY: Ln.scaleY
        };
        this._firstRender ? Rn.attr(Fn) : updateProps$1(Rn, Fn, Cn);
      }
      adjustEdge(Cn.getGraph(), getNodeGlobalScale(Cn));
      var Pn = Cn.getData();
      $n.updateData(Pn);
      var Un = Cn.getEdgeData();
      Nn.updateData(Un), this._updateNodeAndLinkScale(), this._updateController(Cn, Bn, In), clearTimeout(this._layoutTimeout);
      var Hn = Cn.forceLayout, zn = Cn.get(["force", "layoutAnimation"]);
      Hn && this._startForceLayoutIteration(Hn, zn);
      var Gn = Cn.get("layout");
      Pn.graph.eachNode(function(ea) {
        var ta = ea.dataIndex, na = ea.getGraphicEl(), ra = ea.getModel();
        if (na) {
          na.off("drag").off("dragend");
          var aa = ra.get("draggable");
          aa && na.on("drag", function(Aa) {
            switch (Gn) {
              case "force":
                Hn.warmUp(), !Dn._layouting && Dn._startForceLayoutIteration(Hn, zn), Hn.setFixed(ta), Pn.setItemLayout(ta, [na.x, na.y]);
                break;
              case "circular":
                Pn.setItemLayout(ta, [na.x, na.y]), ea.setLayout({
                  fixed: !0
                }, !0), circularLayout(Cn, "symbolSize", ea, [Aa.offsetX, Aa.offsetY]), Dn.updateLayout(Cn);
                break;
              case "none":
              default:
                Pn.setItemLayout(ta, [na.x, na.y]), simpleLayoutEdge(Cn.getGraph(), Cn), Dn.updateLayout(Cn);
                break;
            }
          }).on("dragend", function() {
            Hn && Hn.setUnfixed(ta);
          }), na.setDraggable(aa, !!ra.get("cursor"));
          var ia = ra.get(["emphasis", "focus"]);
          ia === "adjacency" && (getECData(na).focus = ea.getAdjacentDataIndices());
        }
      }), Pn.graph.eachEdge(function(ea) {
        var ta = ea.getGraphicEl(), na = ea.getModel().get(["emphasis", "focus"]);
        ta && na === "adjacency" && (getECData(ta).focus = {
          edge: [ea.dataIndex],
          node: [ea.node1.dataIndex, ea.node2.dataIndex]
        });
      });
      var Yn = Cn.get("layout") === "circular" && Cn.get(["circular", "rotateLabel"]), Wn = Pn.getLayout("cx"), Xn = Pn.getLayout("cy");
      Pn.graph.eachNode(function(ea) {
        rotateNodeLabel(ea, Yn, Wn, Xn);
      }), this._firstRender = !1;
    }, nr.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, nr.prototype._startForceLayoutIteration = function(Cn, Bn) {
      var In = this;
      (function Dn() {
        Cn.step(function(Ln) {
          In.updateLayout(In._model), (In._layouting = !Ln) && (Bn ? In._layoutTimeout = setTimeout(Dn, 16) : Dn());
        });
      })();
    }, nr.prototype._updateController = function(Cn, Bn, In) {
      var Dn = this, Ln = this._controller, $n = this._controllerHost, Nn = this.group;
      if (Ln.setPointerChecker(function(Rn, Fn, Pn) {
        var Un = Nn.getBoundingRect();
        return Un.applyTransform(Nn.transform), Un.contain(Fn, Pn) && !onIrrelevantElement(Rn, In, Cn);
      }), !isViewCoordSys(Cn.coordinateSystem)) {
        Ln.disable();
        return;
      }
      Ln.enable(Cn.get("roam")), $n.zoomLimit = Cn.get("scaleLimit"), $n.zoom = Cn.coordinateSystem.getZoom(), Ln.off("pan").off("zoom").on("pan", function(Rn) {
        updateViewOnPan($n, Rn.dx, Rn.dy), In.dispatchAction({
          seriesId: Cn.id,
          type: "graphRoam",
          dx: Rn.dx,
          dy: Rn.dy
        });
      }).on("zoom", function(Rn) {
        updateViewOnZoom($n, Rn.scale, Rn.originX, Rn.originY), In.dispatchAction({
          seriesId: Cn.id,
          type: "graphRoam",
          zoom: Rn.scale,
          originX: Rn.originX,
          originY: Rn.originY
        }), Dn._updateNodeAndLinkScale(), adjustEdge(Cn.getGraph(), getNodeGlobalScale(Cn)), Dn._lineDraw.updateLayout(), In.updateLabelLayout();
      });
    }, nr.prototype._updateNodeAndLinkScale = function() {
      var Cn = this._model, Bn = Cn.getData(), In = getNodeGlobalScale(Cn);
      Bn.eachItemGraphicEl(function(Dn, Ln) {
        Dn && Dn.setSymbolScale(In);
      });
    }, nr.prototype.updateLayout = function(Cn) {
      adjustEdge(Cn.getGraph(), getNodeGlobalScale(Cn)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, nr.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, nr.type = "graph", nr;
  }(ChartView$1)
);
const GraphView$1 = GraphView;
function generateNodeKey(_n) {
  return "_EC_" + _n;
}
var Graph = (
  /** @class */
  function() {
    function _n(nr) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = nr || !1;
    }
    return _n.prototype.isDirected = function() {
      return this._directed;
    }, _n.prototype.addNode = function(nr, Cn) {
      nr = nr == null ? "" + Cn : "" + nr;
      var Bn = this._nodesMap;
      if (Bn[generateNodeKey(nr)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var In = new GraphNode(nr, Cn);
      return In.hostGraph = this, this.nodes.push(In), Bn[generateNodeKey(nr)] = In, In;
    }, _n.prototype.getNodeByIndex = function(nr) {
      var Cn = this.data.getRawIndex(nr);
      return this.nodes[Cn];
    }, _n.prototype.getNodeById = function(nr) {
      return this._nodesMap[generateNodeKey(nr)];
    }, _n.prototype.addEdge = function(nr, Cn, Bn) {
      var In = this._nodesMap, Dn = this._edgesMap;
      if (isNumber(nr) && (nr = this.nodes[nr]), isNumber(Cn) && (Cn = this.nodes[Cn]), nr instanceof GraphNode || (nr = In[generateNodeKey(nr)]), Cn instanceof GraphNode || (Cn = In[generateNodeKey(Cn)]), !(!nr || !Cn)) {
        var Ln = nr.id + "-" + Cn.id, $n = new GraphEdge(nr, Cn, Bn);
        return $n.hostGraph = this, this._directed && (nr.outEdges.push($n), Cn.inEdges.push($n)), nr.edges.push($n), nr !== Cn && Cn.edges.push($n), this.edges.push($n), Dn[Ln] = $n, $n;
      }
    }, _n.prototype.getEdgeByIndex = function(nr) {
      var Cn = this.edgeData.getRawIndex(nr);
      return this.edges[Cn];
    }, _n.prototype.getEdge = function(nr, Cn) {
      nr instanceof GraphNode && (nr = nr.id), Cn instanceof GraphNode && (Cn = Cn.id);
      var Bn = this._edgesMap;
      return this._directed ? Bn[nr + "-" + Cn] : Bn[nr + "-" + Cn] || Bn[Cn + "-" + nr];
    }, _n.prototype.eachNode = function(nr, Cn) {
      for (var Bn = this.nodes, In = Bn.length, Dn = 0; Dn < In; Dn++)
        Bn[Dn].dataIndex >= 0 && nr.call(Cn, Bn[Dn], Dn);
    }, _n.prototype.eachEdge = function(nr, Cn) {
      for (var Bn = this.edges, In = Bn.length, Dn = 0; Dn < In; Dn++)
        Bn[Dn].dataIndex >= 0 && Bn[Dn].node1.dataIndex >= 0 && Bn[Dn].node2.dataIndex >= 0 && nr.call(Cn, Bn[Dn], Dn);
    }, _n.prototype.breadthFirstTraverse = function(nr, Cn, Bn, In) {
      if (Cn instanceof GraphNode || (Cn = this._nodesMap[generateNodeKey(Cn)]), !!Cn) {
        for (var Dn = Bn === "out" ? "outEdges" : Bn === "in" ? "inEdges" : "edges", Ln = 0; Ln < this.nodes.length; Ln++)
          this.nodes[Ln].__visited = !1;
        if (!nr.call(In, Cn, null))
          for (var $n = [Cn]; $n.length; )
            for (var Nn = $n.shift(), Rn = Nn[Dn], Ln = 0; Ln < Rn.length; Ln++) {
              var Fn = Rn[Ln], Pn = Fn.node1 === Nn ? Fn.node2 : Fn.node1;
              if (!Pn.__visited) {
                if (nr.call(In, Pn, Nn))
                  return;
                $n.push(Pn), Pn.__visited = !0;
              }
            }
      }
    }, _n.prototype.update = function() {
      for (var nr = this.data, Cn = this.edgeData, Bn = this.nodes, In = this.edges, Dn = 0, Ln = Bn.length; Dn < Ln; Dn++)
        Bn[Dn].dataIndex = -1;
      for (var Dn = 0, Ln = nr.count(); Dn < Ln; Dn++)
        Bn[nr.getRawIndex(Dn)].dataIndex = Dn;
      Cn.filterSelf(function($n) {
        var Nn = In[Cn.getRawIndex($n)];
        return Nn.node1.dataIndex >= 0 && Nn.node2.dataIndex >= 0;
      });
      for (var Dn = 0, Ln = In.length; Dn < Ln; Dn++)
        In[Dn].dataIndex = -1;
      for (var Dn = 0, Ln = Cn.count(); Dn < Ln; Dn++)
        In[Cn.getRawIndex(Dn)].dataIndex = Dn;
    }, _n.prototype.clone = function() {
      for (var nr = new _n(this._directed), Cn = this.nodes, Bn = this.edges, In = 0; In < Cn.length; In++)
        nr.addNode(Cn[In].id, Cn[In].dataIndex);
      for (var In = 0; In < Bn.length; In++) {
        var Dn = Bn[In];
        nr.addEdge(Dn.node1.id, Dn.node2.id, Dn.dataIndex);
      }
      return nr;
    }, _n;
  }()
), GraphNode = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = nr ?? "", this.dataIndex = Cn ?? -1;
    }
    return _n.prototype.degree = function() {
      return this.edges.length;
    }, _n.prototype.inDegree = function() {
      return this.inEdges.length;
    }, _n.prototype.outDegree = function() {
      return this.outEdges.length;
    }, _n.prototype.getModel = function(nr) {
      if (!(this.dataIndex < 0)) {
        var Cn = this.hostGraph, Bn = Cn.data.getItemModel(this.dataIndex);
        return Bn.getModel(nr);
      }
    }, _n.prototype.getAdjacentDataIndices = function() {
      for (var nr = {
        edge: [],
        node: []
      }, Cn = 0; Cn < this.edges.length; Cn++) {
        var Bn = this.edges[Cn];
        Bn.dataIndex < 0 || (nr.edge.push(Bn.dataIndex), nr.node.push(Bn.node1.dataIndex, Bn.node2.dataIndex));
      }
      return nr;
    }, _n.prototype.getTrajectoryDataIndices = function() {
      for (var nr = createHashMap(), Cn = createHashMap(), Bn = 0; Bn < this.edges.length; Bn++) {
        var In = this.edges[Bn];
        if (!(In.dataIndex < 0)) {
          nr.set(In.dataIndex, !0);
          for (var Dn = [In.node1], Ln = [In.node2], $n = 0; $n < Dn.length; ) {
            var Nn = Dn[$n];
            $n++, Cn.set(Nn.dataIndex, !0);
            for (var Rn = 0; Rn < Nn.inEdges.length; Rn++)
              nr.set(Nn.inEdges[Rn].dataIndex, !0), Dn.push(Nn.inEdges[Rn].node1);
          }
          for ($n = 0; $n < Ln.length; ) {
            var Fn = Ln[$n];
            $n++, Cn.set(Fn.dataIndex, !0);
            for (var Rn = 0; Rn < Fn.outEdges.length; Rn++)
              nr.set(Fn.outEdges[Rn].dataIndex, !0), Ln.push(Fn.outEdges[Rn].node2);
          }
        }
      }
      return {
        edge: nr.keys(),
        node: Cn.keys()
      };
    }, _n;
  }()
), GraphEdge = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.dataIndex = -1, this.node1 = nr, this.node2 = Cn, this.dataIndex = Bn ?? -1;
    }
    return _n.prototype.getModel = function(nr) {
      if (!(this.dataIndex < 0)) {
        var Cn = this.hostGraph, Bn = Cn.edgeData.getItemModel(this.dataIndex);
        return Bn.getModel(nr);
      }
    }, _n.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, _n.prototype.getTrajectoryDataIndices = function() {
      var nr = createHashMap(), Cn = createHashMap();
      nr.set(this.dataIndex, !0);
      for (var Bn = [this.node1], In = [this.node2], Dn = 0; Dn < Bn.length; ) {
        var Ln = Bn[Dn];
        Dn++, Cn.set(Ln.dataIndex, !0);
        for (var $n = 0; $n < Ln.inEdges.length; $n++)
          nr.set(Ln.inEdges[$n].dataIndex, !0), Bn.push(Ln.inEdges[$n].node1);
      }
      for (Dn = 0; Dn < In.length; ) {
        var Nn = In[Dn];
        Dn++, Cn.set(Nn.dataIndex, !0);
        for (var $n = 0; $n < Nn.outEdges.length; $n++)
          nr.set(Nn.outEdges[$n].dataIndex, !0), In.push(Nn.outEdges[$n].node2);
      }
      return {
        edge: nr.keys(),
        node: Cn.keys()
      };
    }, _n;
  }()
);
function createGraphDataProxyMixin(_n, nr) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(Cn) {
      var Bn = this[_n][nr];
      return Bn.getStore().get(Bn.getDimensionIndex(Cn || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(Cn, Bn) {
      this.dataIndex >= 0 && this[_n][nr].setItemVisual(this.dataIndex, Cn, Bn);
    },
    getVisual: function(Cn) {
      return this[_n][nr].getItemVisual(this.dataIndex, Cn);
    },
    setLayout: function(Cn, Bn) {
      this.dataIndex >= 0 && this[_n][nr].setItemLayout(this.dataIndex, Cn, Bn);
    },
    getLayout: function() {
      return this[_n][nr].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[_n][nr].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[_n][nr].getRawIndex(this.dataIndex);
    }
  };
}
mixin(GraphNode, createGraphDataProxyMixin("hostGraph", "data"));
mixin(GraphEdge, createGraphDataProxyMixin("hostGraph", "edgeData"));
const Graph$1 = Graph;
function createGraphFromNodeEdge(_n, nr, Cn, Bn, In) {
  for (var Dn = new Graph$1(Bn), Ln = 0; Ln < _n.length; Ln++)
    Dn.addNode(retrieve(
      // Id, name, dataIndex
      _n[Ln].id,
      _n[Ln].name,
      Ln
    ), Ln);
  for (var $n = [], Nn = [], Rn = 0, Ln = 0; Ln < nr.length; Ln++) {
    var Fn = nr[Ln], Pn = Fn.source, Un = Fn.target;
    Dn.addEdge(Pn, Un, Rn) && (Nn.push(Fn), $n.push(retrieve(convertOptionIdName(Fn.id, null), Pn + " > " + Un)), Rn++);
  }
  var Hn = Cn.get("coordinateSystem"), zn;
  if (Hn === "cartesian2d" || Hn === "polar")
    zn = createSeriesData(_n, Cn);
  else {
    var Gn = CoordinateSystem.get(Hn), Yn = Gn ? Gn.dimensions || [] : [];
    indexOf(Yn, "value") < 0 && Yn.concat(["value"]);
    var Wn = prepareSeriesDataSchema(_n, {
      coordDimensions: Yn,
      encodeDefine: Cn.getEncode()
    }).dimensions;
    zn = new SeriesData$1(Wn, Cn), zn.initData(_n);
  }
  var Xn = new SeriesData$1(["value"], Cn);
  return Xn.initData(Nn, $n), In && In(zn, Xn), linkSeriesData({
    mainData: zn,
    struct: Dn,
    structAttr: "graph",
    datas: {
      node: zn,
      edge: Xn
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), Dn.update(), Dn;
}
var GraphSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.hasSymbolVisual = !0, Cn;
    }
    return nr.prototype.init = function(Cn) {
      _n.prototype.init.apply(this, arguments);
      var Bn = this;
      function In() {
        return Bn._categoriesData;
      }
      this.legendVisualProvider = new LegendVisualProvider$1(In, In), this.fillDataTextStyle(Cn.edges || Cn.links), this._updateCategoriesData();
    }, nr.prototype.mergeOption = function(Cn) {
      _n.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(Cn.edges || Cn.links), this._updateCategoriesData();
    }, nr.prototype.mergeDefaultAndTheme = function(Cn) {
      _n.prototype.mergeDefaultAndTheme.apply(this, arguments), defaultEmphasis(Cn, "edgeLabel", ["show"]);
    }, nr.prototype.getInitialData = function(Cn, Bn) {
      var In = Cn.edges || Cn.links || [], Dn = Cn.data || Cn.nodes || [], Ln = this;
      if (Dn && In) {
        initCurvenessList(this);
        var $n = createGraphFromNodeEdge(Dn, In, this, !0, Nn);
        return each$f($n.edges, function(Rn) {
          createEdgeMapForCurveness(Rn.node1, Rn.node2, this, Rn.dataIndex);
        }, this), $n.data;
      }
      function Nn(Rn, Fn) {
        Rn.wrapMethod("getItemModel", function(zn) {
          var Gn = Ln._categoriesModels, Yn = zn.getShallow("category"), Wn = Gn[Yn];
          return Wn && (Wn.parentModel = zn.parentModel, zn.parentModel = Wn), zn;
        });
        var Pn = Model$1.prototype.getModel;
        function Un(zn, Gn) {
          var Yn = Pn.call(this, zn, Gn);
          return Yn.resolveParentPath = Hn, Yn;
        }
        Fn.wrapMethod("getItemModel", function(zn) {
          return zn.resolveParentPath = Hn, zn.getModel = Un, zn;
        });
        function Hn(zn) {
          if (zn && (zn[0] === "label" || zn[1] === "label")) {
            var Gn = zn.slice();
            return zn[0] === "label" ? Gn[0] = "edgeLabel" : zn[1] === "label" && (Gn[1] = "edgeLabel"), Gn;
          }
          return zn;
        }
      }
    }, nr.prototype.getGraph = function() {
      return this.getData().graph;
    }, nr.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, nr.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      if (In === "edge") {
        var Dn = this.getData(), Ln = this.getDataParams(Cn, In), $n = Dn.graph.getEdgeByIndex(Cn), Nn = Dn.getName($n.node1.dataIndex), Rn = Dn.getName($n.node2.dataIndex), Fn = [];
        return Nn != null && Fn.push(Nn), Rn != null && Fn.push(Rn), createTooltipMarkup("nameValue", {
          name: Fn.join(" > "),
          value: Ln.value,
          noValue: Ln.value == null
        });
      }
      var Pn = defaultSeriesFormatTooltip({
        series: this,
        dataIndex: Cn,
        multipleSeries: Bn
      });
      return Pn;
    }, nr.prototype._updateCategoriesData = function() {
      var Cn = map$1(this.option.categories || [], function(In) {
        return In.value != null ? In : extend({
          value: 0
        }, In);
      }), Bn = new SeriesData$1(["value"], this);
      Bn.initData(Cn), this._categoriesData = Bn, this._categoriesModels = Bn.mapArray(function(In) {
        return Bn.getItemModel(In);
      });
    }, nr.prototype.setZoom = function(Cn) {
      this.option.zoom = Cn;
    }, nr.prototype.setCenter = function(Cn) {
      this.option.center = Cn;
    }, nr.prototype.isAnimationEnabled = function() {
      return _n.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, nr.type = "series.graph", nr.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, nr;
  }(SeriesModel$1)
);
const GraphSeriesModel$1 = GraphSeriesModel;
var actionInfo$1 = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function install$F(_n) {
  _n.registerChartView(GraphView$1), _n.registerSeriesModel(GraphSeriesModel$1), _n.registerProcessor(categoryFilter), _n.registerVisual(categoryVisual), _n.registerVisual(graphEdgeVisual), _n.registerLayout(graphSimpleLayout), _n.registerLayout(_n.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout), _n.registerLayout(graphForceLayout), _n.registerCoordinateSystem("graphView", {
    dimensions: View$1.dimensions,
    create: createViewCoordSys
  }), _n.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, noop$1), _n.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, noop$1), _n.registerAction(actionInfo$1, function(nr, Cn, Bn) {
    Cn.eachComponent({
      mainType: "series",
      query: nr
    }, function(In) {
      var Dn = In.coordinateSystem, Ln = updateCenterAndZoom(Dn, nr, void 0, Bn);
      In.setCenter && In.setCenter(Ln.center), In.setZoom && In.setZoom(Ln.zoom);
    });
  });
}
var PointerShape = (
  /** @class */
  function() {
    function _n() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return _n;
  }()
), PointerPath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "pointer", Bn;
    }
    return nr.prototype.getDefaultShape = function() {
      return new PointerShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Math.cos, Dn = Math.sin, Ln = Bn.r, $n = Bn.width, Nn = Bn.angle, Rn = Bn.x - In(Nn) * $n * ($n >= Ln / 3 ? 1 : 2), Fn = Bn.y - Dn(Nn) * $n * ($n >= Ln / 3 ? 1 : 2);
      Nn = Bn.angle - Math.PI / 2, Cn.moveTo(Rn, Fn), Cn.lineTo(Bn.x + In(Nn) * $n, Bn.y + Dn(Nn) * $n), Cn.lineTo(Bn.x + In(Bn.angle) * Ln, Bn.y + Dn(Bn.angle) * Ln), Cn.lineTo(Bn.x - In(Nn) * $n, Bn.y - Dn(Nn) * $n), Cn.lineTo(Rn, Fn);
    }, nr;
  }(Path$1)
);
const PointerPath$1 = PointerPath;
function parsePosition(_n, nr) {
  var Cn = _n.get("center"), Bn = nr.getWidth(), In = nr.getHeight(), Dn = Math.min(Bn, In), Ln = parsePercent(Cn[0], nr.getWidth()), $n = parsePercent(Cn[1], nr.getHeight()), Nn = parsePercent(_n.get("radius"), Dn / 2);
  return {
    cx: Ln,
    cy: $n,
    r: Nn
  };
}
function formatLabel(_n, nr) {
  var Cn = _n == null ? "" : _n + "";
  return nr && (isString$1(nr) ? Cn = nr.replace("{value}", Cn) : isFunction$1(nr) && (Cn = nr(_n))), Cn;
}
var GaugeView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      this.group.removeAll();
      var Dn = Cn.get(["axisLine", "lineStyle", "color"]), Ln = parsePosition(Cn, In);
      this._renderMain(Cn, Bn, In, Dn, Ln), this._data = Cn.getData();
    }, nr.prototype.dispose = function() {
    }, nr.prototype._renderMain = function(Cn, Bn, In, Dn, Ln) {
      var $n = this.group, Nn = Cn.get("clockwise"), Rn = -Cn.get("startAngle") / 180 * Math.PI, Fn = -Cn.get("endAngle") / 180 * Math.PI, Pn = Cn.getModel("axisLine"), Un = Pn.get("roundCap"), Hn = Un ? Sausage : Sector$1, zn = Pn.get("show"), Gn = Pn.getModel("lineStyle"), Yn = Gn.get("width"), Wn = [Rn, Fn];
      normalizeArcAngles(Wn, !Nn), Rn = Wn[0], Fn = Wn[1];
      for (var Xn = Fn - Rn, ea = Rn, ta = [], na = 0; zn && na < Dn.length; na++) {
        var ra = Math.min(Math.max(Dn[na][0], 0), 1);
        Fn = Rn + Xn * ra;
        var aa = new Hn({
          shape: {
            startAngle: ea,
            endAngle: Fn,
            cx: Ln.cx,
            cy: Ln.cy,
            clockwise: Nn,
            r0: Ln.r - Yn,
            r: Ln.r
          },
          silent: !0
        });
        aa.setStyle({
          fill: Dn[na][1]
        }), aa.setStyle(Gn.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), ta.push(aa), ea = Fn;
      }
      ta.reverse(), each$f(ta, function(Aa) {
        return $n.add(Aa);
      });
      var ia = function(Aa) {
        if (Aa <= 0)
          return Dn[0][1];
        var sa;
        for (sa = 0; sa < Dn.length; sa++)
          if (Dn[sa][0] >= Aa && (sa === 0 ? 0 : Dn[sa - 1][0]) < Aa)
            return Dn[sa][1];
        return Dn[sa - 1][1];
      };
      this._renderTicks(Cn, Bn, In, ia, Ln, Rn, Fn, Nn, Yn), this._renderTitleAndDetail(Cn, Bn, In, ia, Ln), this._renderAnchor(Cn, Ln), this._renderPointer(Cn, Bn, In, ia, Ln, Rn, Fn, Nn, Yn);
    }, nr.prototype._renderTicks = function(Cn, Bn, In, Dn, Ln, $n, Nn, Rn, Fn) {
      for (var Pn = this.group, Un = Ln.cx, Hn = Ln.cy, zn = Ln.r, Gn = +Cn.get("min"), Yn = +Cn.get("max"), Wn = Cn.getModel("splitLine"), Xn = Cn.getModel("axisTick"), ea = Cn.getModel("axisLabel"), ta = Cn.get("splitNumber"), na = Xn.get("splitNumber"), ra = parsePercent(Wn.get("length"), zn), aa = parsePercent(Xn.get("length"), zn), ia = $n, Aa = (Nn - $n) / ta, sa = Aa / na, oa = Wn.getModel("lineStyle").getLineStyle(), la = Xn.getModel("lineStyle").getLineStyle(), ua = Wn.get("distance"), ca, fa, ha = 0; ha <= ta; ha++) {
        if (ca = Math.cos(ia), fa = Math.sin(ia), Wn.get("show")) {
          var pa = ua ? ua + Fn : Fn, ya = new Line$3({
            shape: {
              x1: ca * (zn - pa) + Un,
              y1: fa * (zn - pa) + Hn,
              x2: ca * (zn - ra - pa) + Un,
              y2: fa * (zn - ra - pa) + Hn
            },
            style: oa,
            silent: !0
          });
          oa.stroke === "auto" && ya.setStyle({
            stroke: Dn(ha / ta)
          }), Pn.add(ya);
        }
        if (ea.get("show")) {
          var pa = ea.get("distance") + ua, da = formatLabel(round$4(ha / ta * (Yn - Gn) + Gn), ea.get("formatter")), Ca = Dn(ha / ta), ma = ca * (zn - ra - pa) + Un, va = fa * (zn - ra - pa) + Hn, ga = ea.get("rotate"), xa = 0;
          ga === "radial" ? (xa = -ia + 2 * Math.PI, xa > Math.PI / 2 && (xa += Math.PI)) : ga === "tangential" ? xa = -ia - Math.PI / 2 : isNumber(ga) && (xa = ga * Math.PI / 180), xa === 0 ? Pn.add(new ZRText$1({
            style: createTextStyle$1(ea, {
              text: da,
              x: ma,
              y: va,
              verticalAlign: fa < -0.8 ? "top" : fa > 0.8 ? "bottom" : "middle",
              align: ca < -0.4 ? "left" : ca > 0.4 ? "right" : "center"
            }, {
              inheritColor: Ca
            }),
            silent: !0
          })) : Pn.add(new ZRText$1({
            style: createTextStyle$1(ea, {
              text: da,
              x: ma,
              y: va,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: Ca
            }),
            silent: !0,
            originX: ma,
            originY: va,
            rotation: xa
          }));
        }
        if (Xn.get("show") && ha !== ta) {
          var pa = Xn.get("distance");
          pa = pa ? pa + Fn : Fn;
          for (var wa = 0; wa <= na; wa++) {
            ca = Math.cos(ia), fa = Math.sin(ia);
            var ba = new Line$3({
              shape: {
                x1: ca * (zn - pa) + Un,
                y1: fa * (zn - pa) + Hn,
                x2: ca * (zn - aa - pa) + Un,
                y2: fa * (zn - aa - pa) + Hn
              },
              silent: !0,
              style: la
            });
            la.stroke === "auto" && ba.setStyle({
              stroke: Dn((ha + wa / na) / ta)
            }), Pn.add(ba), ia += sa;
          }
          ia -= sa;
        } else
          ia += Aa;
      }
    }, nr.prototype._renderPointer = function(Cn, Bn, In, Dn, Ln, $n, Nn, Rn, Fn) {
      var Pn = this.group, Un = this._data, Hn = this._progressEls, zn = [], Gn = Cn.get(["pointer", "show"]), Yn = Cn.getModel("progress"), Wn = Yn.get("show"), Xn = Cn.getData(), ea = Xn.mapDimension("value"), ta = +Cn.get("min"), na = +Cn.get("max"), ra = [ta, na], aa = [$n, Nn];
      function ia(sa, oa) {
        var la = Xn.getItemModel(sa), ua = la.getModel("pointer"), ca = parsePercent(ua.get("width"), Ln.r), fa = parsePercent(ua.get("length"), Ln.r), ha = Cn.get(["pointer", "icon"]), pa = ua.get("offsetCenter"), ya = parsePercent(pa[0], Ln.r), da = parsePercent(pa[1], Ln.r), Ca = ua.get("keepAspect"), ma;
        return ha ? ma = createSymbol$1(ha, ya - ca / 2, da - fa, ca, fa, null, Ca) : ma = new PointerPath$1({
          shape: {
            angle: -Math.PI / 2,
            width: ca,
            r: fa,
            x: ya,
            y: da
          }
        }), ma.rotation = -(oa + Math.PI / 2), ma.x = Ln.cx, ma.y = Ln.cy, ma;
      }
      function Aa(sa, oa) {
        var la = Yn.get("roundCap"), ua = la ? Sausage : Sector$1, ca = Yn.get("overlap"), fa = ca ? Yn.get("width") : Fn / Xn.count(), ha = ca ? Ln.r - fa : Ln.r - (sa + 1) * fa, pa = ca ? Ln.r : Ln.r - sa * fa, ya = new ua({
          shape: {
            startAngle: $n,
            endAngle: oa,
            cx: Ln.cx,
            cy: Ln.cy,
            clockwise: Rn,
            r0: ha,
            r: pa
          }
        });
        return ca && (ya.z2 = linearMap$2(Xn.get(ea, sa), [ta, na], [100, 0], !0)), ya;
      }
      (Wn || Gn) && (Xn.diff(Un).add(function(sa) {
        var oa = Xn.get(ea, sa);
        if (Gn) {
          var la = ia(sa, $n);
          initProps(la, {
            rotation: -((isNaN(+oa) ? aa[0] : linearMap$2(oa, ra, aa, !0)) + Math.PI / 2)
          }, Cn), Pn.add(la), Xn.setItemGraphicEl(sa, la);
        }
        if (Wn) {
          var ua = Aa(sa, $n), ca = Yn.get("clip");
          initProps(ua, {
            shape: {
              endAngle: linearMap$2(oa, ra, aa, ca)
            }
          }, Cn), Pn.add(ua), setCommonECData(Cn.seriesIndex, Xn.dataType, sa, ua), zn[sa] = ua;
        }
      }).update(function(sa, oa) {
        var la = Xn.get(ea, sa);
        if (Gn) {
          var ua = Un.getItemGraphicEl(oa), ca = ua ? ua.rotation : $n, fa = ia(sa, ca);
          fa.rotation = ca, updateProps$1(fa, {
            rotation: -((isNaN(+la) ? aa[0] : linearMap$2(la, ra, aa, !0)) + Math.PI / 2)
          }, Cn), Pn.add(fa), Xn.setItemGraphicEl(sa, fa);
        }
        if (Wn) {
          var ha = Hn[oa], pa = ha ? ha.shape.endAngle : $n, ya = Aa(sa, pa), da = Yn.get("clip");
          updateProps$1(ya, {
            shape: {
              endAngle: linearMap$2(la, ra, aa, da)
            }
          }, Cn), Pn.add(ya), setCommonECData(Cn.seriesIndex, Xn.dataType, sa, ya), zn[sa] = ya;
        }
      }).execute(), Xn.each(function(sa) {
        var oa = Xn.getItemModel(sa), la = oa.getModel("emphasis"), ua = la.get("focus"), ca = la.get("blurScope"), fa = la.get("disabled");
        if (Gn) {
          var ha = Xn.getItemGraphicEl(sa), pa = Xn.getItemVisual(sa, "style"), ya = pa.fill;
          if (ha instanceof ZRImage$1) {
            var da = ha.style;
            ha.useStyle(extend({
              image: da.image,
              x: da.x,
              y: da.y,
              width: da.width,
              height: da.height
            }, pa));
          } else
            ha.useStyle(pa), ha.type !== "pointer" && ha.setColor(ya);
          ha.setStyle(oa.getModel(["pointer", "itemStyle"]).getItemStyle()), ha.style.fill === "auto" && ha.setStyle("fill", Dn(linearMap$2(Xn.get(ea, sa), ra, [0, 1], !0))), ha.z2EmphasisLift = 0, setStatesStylesFromModel(ha, oa), toggleHoverEmphasis(ha, ua, ca, fa);
        }
        if (Wn) {
          var Ca = zn[sa];
          Ca.useStyle(Xn.getItemVisual(sa, "style")), Ca.setStyle(oa.getModel(["progress", "itemStyle"]).getItemStyle()), Ca.z2EmphasisLift = 0, setStatesStylesFromModel(Ca, oa), toggleHoverEmphasis(Ca, ua, ca, fa);
        }
      }), this._progressEls = zn);
    }, nr.prototype._renderAnchor = function(Cn, Bn) {
      var In = Cn.getModel("anchor"), Dn = In.get("show");
      if (Dn) {
        var Ln = In.get("size"), $n = In.get("icon"), Nn = In.get("offsetCenter"), Rn = In.get("keepAspect"), Fn = createSymbol$1($n, Bn.cx - Ln / 2 + parsePercent(Nn[0], Bn.r), Bn.cy - Ln / 2 + parsePercent(Nn[1], Bn.r), Ln, Ln, null, Rn);
        Fn.z2 = In.get("showAbove") ? 1 : 0, Fn.setStyle(In.getModel("itemStyle").getItemStyle()), this.group.add(Fn);
      }
    }, nr.prototype._renderTitleAndDetail = function(Cn, Bn, In, Dn, Ln) {
      var $n = this, Nn = Cn.getData(), Rn = Nn.mapDimension("value"), Fn = +Cn.get("min"), Pn = +Cn.get("max"), Un = new Group$4(), Hn = [], zn = [], Gn = Cn.isAnimationEnabled(), Yn = Cn.get(["pointer", "showAbove"]);
      Nn.diff(this._data).add(function(Wn) {
        Hn[Wn] = new ZRText$1({
          silent: !0
        }), zn[Wn] = new ZRText$1({
          silent: !0
        });
      }).update(function(Wn, Xn) {
        Hn[Wn] = $n._titleEls[Xn], zn[Wn] = $n._detailEls[Xn];
      }).execute(), Nn.each(function(Wn) {
        var Xn = Nn.getItemModel(Wn), ea = Nn.get(Rn, Wn), ta = new Group$4(), na = Dn(linearMap$2(ea, [Fn, Pn], [0, 1], !0)), ra = Xn.getModel("title");
        if (ra.get("show")) {
          var aa = ra.get("offsetCenter"), ia = Ln.cx + parsePercent(aa[0], Ln.r), Aa = Ln.cy + parsePercent(aa[1], Ln.r), sa = Hn[Wn];
          sa.attr({
            z2: Yn ? 0 : 2,
            style: createTextStyle$1(ra, {
              x: ia,
              y: Aa,
              text: Nn.getName(Wn),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: na
            })
          }), ta.add(sa);
        }
        var oa = Xn.getModel("detail");
        if (oa.get("show")) {
          var la = oa.get("offsetCenter"), ua = Ln.cx + parsePercent(la[0], Ln.r), ca = Ln.cy + parsePercent(la[1], Ln.r), fa = parsePercent(oa.get("width"), Ln.r), ha = parsePercent(oa.get("height"), Ln.r), pa = Cn.get(["progress", "show"]) ? Nn.getItemVisual(Wn, "style").fill : na, sa = zn[Wn], ya = oa.get("formatter");
          sa.attr({
            z2: Yn ? 0 : 2,
            style: createTextStyle$1(oa, {
              x: ua,
              y: ca,
              text: formatLabel(ea, ya),
              width: isNaN(fa) ? null : fa,
              height: isNaN(ha) ? null : ha,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: pa
            })
          }), setLabelValueAnimation(sa, {
            normal: oa
          }, ea, function(Ca) {
            return formatLabel(Ca, ya);
          }), Gn && animateLabelValue(sa, Wn, Nn, Cn, {
            getFormattedLabel: function(Ca, ma, va, ga, xa, wa) {
              return formatLabel(wa ? wa.interpolatedValue : ea, ya);
            }
          }), ta.add(sa);
        }
        Un.add(ta);
      }), this.group.add(Un), this._titleEls = Hn, this._detailEls = zn;
    }, nr.type = "gauge", nr;
  }(ChartView$1)
);
const GaugeView$1 = GaugeView;
var GaugeSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.visualStyleAccessPath = "itemStyle", Cn;
    }
    return nr.prototype.getInitialData = function(Cn, Bn) {
      return createSeriesDataSimply(this, ["value"]);
    }, nr.type = "series.gauge", nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 最小值
      min: 0,
      // 最大值
      max: 100,
      // 分割段数，默认为10
      splitNumber: 10,
      // 坐标轴线
      axisLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, "#E6EBF8"]],
          width: 10
        }
      },
      // 坐标轴线
      progress: {
        // 默认显示，属性show控制显示与否
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 分隔线
      splitLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        // 属性length控制线长
        length: 10,
        distance: 10,
        // 属性lineStyle（详见lineStyle）控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      // 坐标轴小标记
      axisTick: {
        // 属性show控制显示与否，默认不显示
        show: !0,
        // 每份split细分多少段
        splitNumber: 5,
        // 属性length控制线长
        length: 6,
        distance: 10,
        // 属性lineStyle控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: !0,
        // x, y，单位px
        offsetCenter: [0, "20%"],
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [5, 10],
        // x, y，单位px
        offsetCenter: [0, "40%"],
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, nr;
  }(SeriesModel$1)
);
const GaugeSeriesModel$1 = GaugeSeriesModel;
function install$E(_n) {
  _n.registerChartView(GaugeView$1), _n.registerSeriesModel(GaugeSeriesModel$1);
}
var opacityAccessPath$1 = ["itemStyle", "opacity"], FunnelPiece = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this) || this, Dn = In, Ln = new Polyline$3(), $n = new ZRText$1();
      return Dn.setTextContent($n), In.setTextGuideLine(Ln), In.updateData(Cn, Bn, !0), In;
    }
    return nr.prototype.updateData = function(Cn, Bn, In) {
      var Dn = this, Ln = Cn.hostModel, $n = Cn.getItemModel(Bn), Nn = Cn.getItemLayout(Bn), Rn = $n.getModel("emphasis"), Fn = $n.get(opacityAccessPath$1);
      Fn = Fn ?? 1, In || saveOldStyle(Dn), Dn.useStyle(Cn.getItemVisual(Bn, "style")), Dn.style.lineJoin = "round", In ? (Dn.setShape({
        points: Nn.points
      }), Dn.style.opacity = 0, initProps(Dn, {
        style: {
          opacity: Fn
        }
      }, Ln, Bn)) : updateProps$1(Dn, {
        style: {
          opacity: Fn
        },
        shape: {
          points: Nn.points
        }
      }, Ln, Bn), setStatesStylesFromModel(Dn, $n), this._updateLabel(Cn, Bn), toggleHoverEmphasis(this, Rn.get("focus"), Rn.get("blurScope"), Rn.get("disabled"));
    }, nr.prototype._updateLabel = function(Cn, Bn) {
      var In = this, Dn = this.getTextGuideLine(), Ln = In.getTextContent(), $n = Cn.hostModel, Nn = Cn.getItemModel(Bn), Rn = Cn.getItemLayout(Bn), Fn = Rn.label, Pn = Cn.getItemVisual(Bn, "style"), Un = Pn.fill;
      setLabelStyle(
        // position will not be used in setLabelStyle
        Ln,
        getLabelStatesModels(Nn),
        {
          labelFetcher: Cn.hostModel,
          labelDataIndex: Bn,
          defaultOpacity: Pn.opacity,
          defaultText: Cn.getName(Bn)
        },
        {
          normal: {
            align: Fn.textAlign,
            verticalAlign: Fn.verticalAlign
          }
        }
      ), In.setTextConfig({
        local: !0,
        inside: !!Fn.inside,
        insideStroke: Un,
        // insideFill: 'auto',
        outsideFill: Un
      });
      var Hn = Fn.linePoints;
      Dn.setShape({
        points: Hn
      }), In.textGuideLineConfig = {
        anchor: Hn ? new Point$1(Hn[0][0], Hn[0][1]) : null
      }, updateProps$1(Ln, {
        style: {
          x: Fn.x,
          y: Fn.y
        }
      }, $n, Bn), Ln.attr({
        rotation: Fn.rotation,
        originX: Fn.x,
        originY: Fn.y,
        z2: 10
      }), setLabelLineStyle(In, getLabelLineStatesModels(Nn), {
        // Default use item visual color
        stroke: Un
      });
    }, nr;
  }(Polygon$1)
), FunnelView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.ignoreLabelLineUpdate = !0, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = this._data, $n = this.group;
      Dn.diff(Ln).add(function(Nn) {
        var Rn = new FunnelPiece(Dn, Nn);
        Dn.setItemGraphicEl(Nn, Rn), $n.add(Rn);
      }).update(function(Nn, Rn) {
        var Fn = Ln.getItemGraphicEl(Rn);
        Fn.updateData(Dn, Nn), $n.add(Fn), Dn.setItemGraphicEl(Nn, Fn);
      }).remove(function(Nn) {
        var Rn = Ln.getItemGraphicEl(Nn);
        removeElementWithFadeOut(Rn, Cn, Nn);
      }).execute(), this._data = Dn;
    }, nr.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, nr.prototype.dispose = function() {
    }, nr.type = "funnel", nr;
  }(ChartView$1)
);
const FunnelView$1 = FunnelView;
var FunnelSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function(Cn) {
      _n.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this)), this._defaultLabelLine(Cn);
    }, nr.prototype.getInitialData = function(Cn, Bn) {
      return createSeriesDataSimply(this, {
        coordDimensions: ["value"],
        encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
      });
    }, nr.prototype._defaultLabelLine = function(Cn) {
      defaultEmphasis(Cn, "labelLine", ["show"]);
      var Bn = Cn.labelLine, In = Cn.emphasis.labelLine;
      Bn.show = Bn.show && Cn.label.show, In.show = In.show && Cn.emphasis.label.show;
    }, nr.prototype.getDataParams = function(Cn) {
      var Bn = this.getData(), In = _n.prototype.getDataParams.call(this, Cn), Dn = Bn.mapDimension("value"), Ln = Bn.getSum(Dn);
      return In.percent = Ln ? +(Bn.get(Dn, Cn) / Ln * 100).toFixed(2) : 0, In.$vars.push("percent"), In;
    }, nr.type = "series.funnel", nr.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 默认取数据最小最大值
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: 各异,
          width: 1
        }
      },
      itemStyle: {
        // color: 各异,
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, nr;
  }(SeriesModel$1)
);
const FunnelSeriesModel$1 = FunnelSeriesModel;
function getViewRect$2(_n, nr) {
  return getLayoutRect$1(_n.getBoxLayoutParams(), {
    width: nr.getWidth(),
    height: nr.getHeight()
  });
}
function getSortedIndices(_n, nr) {
  for (var Cn = _n.mapDimension("value"), Bn = _n.mapArray(Cn, function(Nn) {
    return Nn;
  }), In = [], Dn = nr === "ascending", Ln = 0, $n = _n.count(); Ln < $n; Ln++)
    In[Ln] = Ln;
  return isFunction$1(nr) ? In.sort(nr) : nr !== "none" && In.sort(function(Nn, Rn) {
    return Dn ? Bn[Nn] - Bn[Rn] : Bn[Rn] - Bn[Nn];
  }), In;
}
function labelLayout(_n) {
  var nr = _n.hostModel, Cn = nr.get("orient");
  _n.each(function(Bn) {
    var In = _n.getItemModel(Bn), Dn = In.getModel("label"), Ln = Dn.get("position"), $n = In.getModel("labelLine"), Nn = _n.getItemLayout(Bn), Rn = Nn.points, Fn = Ln === "inner" || Ln === "inside" || Ln === "center" || Ln === "insideLeft" || Ln === "insideRight", Pn, Un, Hn, zn;
    if (Fn)
      Ln === "insideLeft" ? (Un = (Rn[0][0] + Rn[3][0]) / 2 + 5, Hn = (Rn[0][1] + Rn[3][1]) / 2, Pn = "left") : Ln === "insideRight" ? (Un = (Rn[1][0] + Rn[2][0]) / 2 - 5, Hn = (Rn[1][1] + Rn[2][1]) / 2, Pn = "right") : (Un = (Rn[0][0] + Rn[1][0] + Rn[2][0] + Rn[3][0]) / 4, Hn = (Rn[0][1] + Rn[1][1] + Rn[2][1] + Rn[3][1]) / 4, Pn = "center"), zn = [[Un, Hn], [Un, Hn]];
    else {
      var Gn = void 0, Yn = void 0, Wn = void 0, Xn = void 0, ea = $n.get("length");
      process.env.NODE_ENV !== "production" && (Cn === "vertical" && ["top", "bottom"].indexOf(Ln) > -1 && (Ln = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), Cn === "horizontal" && ["left", "right"].indexOf(Ln) > -1 && (Ln = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), Ln === "left" ? (Gn = (Rn[3][0] + Rn[0][0]) / 2, Yn = (Rn[3][1] + Rn[0][1]) / 2, Wn = Gn - ea, Un = Wn - 5, Pn = "right") : Ln === "right" ? (Gn = (Rn[1][0] + Rn[2][0]) / 2, Yn = (Rn[1][1] + Rn[2][1]) / 2, Wn = Gn + ea, Un = Wn + 5, Pn = "left") : Ln === "top" ? (Gn = (Rn[3][0] + Rn[0][0]) / 2, Yn = (Rn[3][1] + Rn[0][1]) / 2, Xn = Yn - ea, Hn = Xn - 5, Pn = "center") : Ln === "bottom" ? (Gn = (Rn[1][0] + Rn[2][0]) / 2, Yn = (Rn[1][1] + Rn[2][1]) / 2, Xn = Yn + ea, Hn = Xn + 5, Pn = "center") : Ln === "rightTop" ? (Gn = Cn === "horizontal" ? Rn[3][0] : Rn[1][0], Yn = Cn === "horizontal" ? Rn[3][1] : Rn[1][1], Cn === "horizontal" ? (Xn = Yn - ea, Hn = Xn - 5, Pn = "center") : (Wn = Gn + ea, Un = Wn + 5, Pn = "top")) : Ln === "rightBottom" ? (Gn = Rn[2][0], Yn = Rn[2][1], Cn === "horizontal" ? (Xn = Yn + ea, Hn = Xn + 5, Pn = "center") : (Wn = Gn + ea, Un = Wn + 5, Pn = "bottom")) : Ln === "leftTop" ? (Gn = Rn[0][0], Yn = Cn === "horizontal" ? Rn[0][1] : Rn[1][1], Cn === "horizontal" ? (Xn = Yn - ea, Hn = Xn - 5, Pn = "center") : (Wn = Gn - ea, Un = Wn - 5, Pn = "right")) : Ln === "leftBottom" ? (Gn = Cn === "horizontal" ? Rn[1][0] : Rn[3][0], Yn = Cn === "horizontal" ? Rn[1][1] : Rn[2][1], Cn === "horizontal" ? (Xn = Yn + ea, Hn = Xn + 5, Pn = "center") : (Wn = Gn - ea, Un = Wn - 5, Pn = "right")) : (Gn = (Rn[1][0] + Rn[2][0]) / 2, Yn = (Rn[1][1] + Rn[2][1]) / 2, Cn === "horizontal" ? (Xn = Yn + ea, Hn = Xn + 5, Pn = "center") : (Wn = Gn + ea, Un = Wn + 5, Pn = "left")), Cn === "horizontal" ? (Wn = Gn, Un = Wn) : (Xn = Yn, Hn = Xn), zn = [[Gn, Yn], [Wn, Xn]];
    }
    Nn.label = {
      linePoints: zn,
      x: Un,
      y: Hn,
      verticalAlign: "middle",
      textAlign: Pn,
      inside: Fn
    };
  });
}
function funnelLayout(_n, nr) {
  _n.eachSeriesByType("funnel", function(Cn) {
    var Bn = Cn.getData(), In = Bn.mapDimension("value"), Dn = Cn.get("sort"), Ln = getViewRect$2(Cn, nr), $n = Cn.get("orient"), Nn = Ln.width, Rn = Ln.height, Fn = getSortedIndices(Bn, Dn), Pn = Ln.x, Un = Ln.y, Hn = $n === "horizontal" ? [parsePercent(Cn.get("minSize"), Rn), parsePercent(Cn.get("maxSize"), Rn)] : [parsePercent(Cn.get("minSize"), Nn), parsePercent(Cn.get("maxSize"), Nn)], zn = Bn.getDataExtent(In), Gn = Cn.get("min"), Yn = Cn.get("max");
    Gn == null && (Gn = Math.min(zn[0], 0)), Yn == null && (Yn = zn[1]);
    var Wn = Cn.get("funnelAlign"), Xn = Cn.get("gap"), ea = $n === "horizontal" ? Nn : Rn, ta = (ea - Xn * (Bn.count() - 1)) / Bn.count(), na = function(ca, fa) {
      if ($n === "horizontal") {
        var ha = Bn.get(In, ca) || 0, pa = linearMap$2(ha, [Gn, Yn], Hn, !0), ya = void 0;
        switch (Wn) {
          case "top":
            ya = Un;
            break;
          case "center":
            ya = Un + (Rn - pa) / 2;
            break;
          case "bottom":
            ya = Un + (Rn - pa);
            break;
        }
        return [[fa, ya], [fa, ya + pa]];
      }
      var da = Bn.get(In, ca) || 0, Ca = linearMap$2(da, [Gn, Yn], Hn, !0), ma;
      switch (Wn) {
        case "left":
          ma = Pn;
          break;
        case "center":
          ma = Pn + (Nn - Ca) / 2;
          break;
        case "right":
          ma = Pn + Nn - Ca;
          break;
      }
      return [[ma, fa], [ma + Ca, fa]];
    };
    Dn === "ascending" && (ta = -ta, Xn = -Xn, $n === "horizontal" ? Pn += Nn : Un += Rn, Fn = Fn.reverse());
    for (var ra = 0; ra < Fn.length; ra++) {
      var aa = Fn[ra], ia = Fn[ra + 1], Aa = Bn.getItemModel(aa);
      if ($n === "horizontal") {
        var sa = Aa.get(["itemStyle", "width"]);
        sa == null ? sa = ta : (sa = parsePercent(sa, Nn), Dn === "ascending" && (sa = -sa));
        var oa = na(aa, Pn), la = na(ia, Pn + sa);
        Pn += sa + Xn, Bn.setItemLayout(aa, {
          points: oa.concat(la.slice().reverse())
        });
      } else {
        var ua = Aa.get(["itemStyle", "height"]);
        ua == null ? ua = ta : (ua = parsePercent(ua, Rn), Dn === "ascending" && (ua = -ua));
        var oa = na(aa, Un), la = na(ia, Un + ua);
        Un += ua + Xn, Bn.setItemLayout(aa, {
          points: oa.concat(la.slice().reverse())
        });
      }
    }
    labelLayout(Bn);
  });
}
function install$D(_n) {
  _n.registerChartView(FunnelView$1), _n.registerSeriesModel(FunnelSeriesModel$1), _n.registerLayout(funnelLayout), _n.registerProcessor(dataFilter$1("funnel"));
}
var DEFAULT_SMOOTH = 0.3, ParallelView$2 = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn._dataGroup = new Group$4(), Cn._initialized = !1, Cn;
    }
    return nr.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, nr.prototype.render = function(Cn, Bn, In, Dn) {
      this._progressiveEls = null;
      var Ln = this._dataGroup, $n = Cn.getData(), Nn = this._data, Rn = Cn.coordinateSystem, Fn = Rn.dimensions, Pn = makeSeriesScope(Cn);
      $n.diff(Nn).add(Un).update(Hn).remove(zn).execute();
      function Un(Yn) {
        var Wn = addEl($n, Ln, Yn, Fn, Rn);
        updateElCommon(Wn, $n, Yn, Pn);
      }
      function Hn(Yn, Wn) {
        var Xn = Nn.getItemGraphicEl(Wn), ea = createLinePoints($n, Yn, Fn, Rn);
        $n.setItemGraphicEl(Yn, Xn), updateProps$1(Xn, {
          shape: {
            points: ea
          }
        }, Cn, Yn), saveOldStyle(Xn), updateElCommon(Xn, $n, Yn, Pn);
      }
      function zn(Yn) {
        var Wn = Nn.getItemGraphicEl(Yn);
        Ln.remove(Wn);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var Gn = createGridClipShape$2(Rn, Cn, function() {
          setTimeout(function() {
            Ln.removeClipPath();
          });
        });
        Ln.setClipPath(Gn);
      }
      this._data = $n;
    }, nr.prototype.incrementalPrepareRender = function(Cn, Bn, In) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, nr.prototype.incrementalRender = function(Cn, Bn, In) {
      for (var Dn = Bn.getData(), Ln = Bn.coordinateSystem, $n = Ln.dimensions, Nn = makeSeriesScope(Bn), Rn = this._progressiveEls = [], Fn = Cn.start; Fn < Cn.end; Fn++) {
        var Pn = addEl(Dn, this._dataGroup, Fn, $n, Ln);
        Pn.incremental = !0, updateElCommon(Pn, Dn, Fn, Nn), Rn.push(Pn);
      }
    }, nr.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, nr.type = "parallel", nr;
  }(ChartView$1)
);
function createGridClipShape$2(_n, nr, Cn) {
  var Bn = _n.model, In = _n.getRect(), Dn = new Rect$3({
    shape: {
      x: In.x,
      y: In.y,
      width: In.width,
      height: In.height
    }
  }), Ln = Bn.get("layout") === "horizontal" ? "width" : "height";
  return Dn.setShape(Ln, 0), initProps(Dn, {
    shape: {
      width: In.width,
      height: In.height
    }
  }, nr, Cn), Dn;
}
function createLinePoints(_n, nr, Cn, Bn) {
  for (var In = [], Dn = 0; Dn < Cn.length; Dn++) {
    var Ln = Cn[Dn], $n = _n.get(_n.mapDimension(Ln), nr);
    isEmptyValue($n, Bn.getAxis(Ln).type) || In.push(Bn.dataToPoint($n, Ln));
  }
  return In;
}
function addEl(_n, nr, Cn, Bn, In) {
  var Dn = createLinePoints(_n, Cn, Bn, In), Ln = new Polyline$3({
    shape: {
      points: Dn
    },
    // silent: true,
    z2: 10
  });
  return nr.add(Ln), _n.setItemGraphicEl(Cn, Ln), Ln;
}
function makeSeriesScope(_n) {
  var nr = _n.get("smooth", !0);
  return nr === !0 && (nr = DEFAULT_SMOOTH), nr = numericToNumber(nr), eqNaN(nr) && (nr = 0), {
    smooth: nr
  };
}
function updateElCommon(_n, nr, Cn, Bn) {
  _n.useStyle(nr.getItemVisual(Cn, "style")), _n.style.fill = null, _n.setShape("smooth", Bn.smooth);
  var In = nr.getItemModel(Cn), Dn = In.getModel("emphasis");
  setStatesStylesFromModel(_n, In, "lineStyle"), toggleHoverEmphasis(_n, Dn.get("focus"), Dn.get("blurScope"), Dn.get("disabled"));
}
function isEmptyValue(_n, nr) {
  return nr === "category" ? _n == null : _n == null || isNaN(_n);
}
const ParallelView$3 = ParallelView$2;
var ParallelSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.visualStyleAccessPath = "lineStyle", Cn.visualDrawType = "stroke", Cn;
    }
    return nr.prototype.getInitialData = function(Cn, Bn) {
      return createSeriesData(null, this, {
        useEncodeDefaulter: bind$1(makeDefaultEncode, null, this)
      });
    }, nr.prototype.getRawIndicesByActiveState = function(Cn) {
      var Bn = this.coordinateSystem, In = this.getData(), Dn = [];
      return Bn.eachActiveState(In, function(Ln, $n) {
        Cn === Ln && Dn.push(In.getRawIndex($n));
      }), Dn;
    }, nr.type = "series.parallel", nr.dependencies = ["parallel"], nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, nr;
  }(SeriesModel$1)
);
function makeDefaultEncode(_n) {
  var nr = _n.ecModel.getComponent("parallel", _n.get("parallelIndex"));
  if (nr) {
    var Cn = {};
    return each$f(nr.dimensions, function(Bn) {
      var In = convertDimNameToNumber(Bn);
      Cn[Bn] = In;
    }), Cn;
  }
}
function convertDimNameToNumber(_n) {
  return +_n.replace("dim", "");
}
const ParallelSeriesModel$1 = ParallelSeriesModel;
var opacityAccessPath = ["lineStyle", "opacity"], parallelVisual = {
  seriesType: "parallel",
  reset: function(_n, nr) {
    var Cn = _n.coordinateSystem, Bn = {
      normal: _n.get(["lineStyle", "opacity"]),
      active: _n.get("activeOpacity"),
      inactive: _n.get("inactiveOpacity")
    };
    return {
      progress: function(In, Dn) {
        Cn.eachActiveState(Dn, function(Ln, $n) {
          var Nn = Bn[Ln];
          if (Ln === "normal" && Dn.hasItemOption) {
            var Rn = Dn.getItemModel($n).get(opacityAccessPath, !0);
            Rn != null && (Nn = Rn);
          }
          var Fn = Dn.ensureUniqueItemVisual($n, "style");
          Fn.opacity = Nn;
        }, In.start, In.end);
      }
    };
  }
};
const parallelVisual$1 = parallelVisual;
function parallelPreprocessor(_n) {
  createParallelIfNeeded(_n), mergeAxisOptionFromParallel(_n);
}
function createParallelIfNeeded(_n) {
  if (!_n.parallel) {
    var nr = !1;
    each$f(_n.series, function(Cn) {
      Cn && Cn.type === "parallel" && (nr = !0);
    }), nr && (_n.parallel = [{}]);
  }
}
function mergeAxisOptionFromParallel(_n) {
  var nr = normalizeToArray(_n.parallelAxis);
  each$f(nr, function(Cn) {
    if (isObject$6(Cn)) {
      var Bn = Cn.parallelIndex || 0, In = normalizeToArray(_n.parallel)[Bn];
      In && In.parallelAxisDefault && merge$1(Cn, In.parallelAxisDefault, !1);
    }
  });
}
var CLICK_THRESHOLD = 5, ParallelView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      this._model = Cn, this._api = In, this._handlers || (this._handlers = {}, each$f(handlers$1, function(Dn, Ln) {
        In.getZr().on(Ln, this._handlers[Ln] = bind$1(Dn, this));
      }, this)), createOrUpdate(this, "_throttledDispatchExpand", Cn.get("axisExpandRate"), "fixRate");
    }, nr.prototype.dispose = function(Cn, Bn) {
      clear$1(this, "_throttledDispatchExpand"), each$f(this._handlers, function(In, Dn) {
        Bn.getZr().off(Dn, In);
      }), this._handlers = null;
    }, nr.prototype._throttledDispatchExpand = function(Cn) {
      this._dispatchExpand(Cn);
    }, nr.prototype._dispatchExpand = function(Cn) {
      Cn && this._api.dispatchAction(extend({
        type: "parallelAxisExpand"
      }, Cn));
    }, nr.type = "parallel", nr;
  }(ComponentView$1)
), handlers$1 = {
  mousedown: function(_n) {
    checkTrigger(this, "click") && (this._mouseDownPoint = [_n.offsetX, _n.offsetY]);
  },
  mouseup: function(_n) {
    var nr = this._mouseDownPoint;
    if (checkTrigger(this, "click") && nr) {
      var Cn = [_n.offsetX, _n.offsetY], Bn = Math.pow(nr[0] - Cn[0], 2) + Math.pow(nr[1] - Cn[1], 2);
      if (Bn > CLICK_THRESHOLD)
        return;
      var In = this._model.coordinateSystem.getSlidedAxisExpandWindow([_n.offsetX, _n.offsetY]);
      In.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: In.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(_n) {
    if (!(this._mouseDownPoint || !checkTrigger(this, "mousemove"))) {
      var nr = this._model, Cn = nr.coordinateSystem.getSlidedAxisExpandWindow([_n.offsetX, _n.offsetY]), Bn = Cn.behavior;
      Bn === "jump" && this._throttledDispatchExpand.debounceNextCall(nr.get("axisExpandDebounce")), this._throttledDispatchExpand(Bn === "none" ? null : {
        axisExpandWindow: Cn.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: Bn === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function checkTrigger(_n, nr) {
  var Cn = _n._model;
  return Cn.get("axisExpandable") && Cn.get("axisExpandTriggerOn") === nr;
}
const ParallelView$1 = ParallelView;
var ParallelModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function() {
      _n.prototype.init.apply(this, arguments), this.mergeOption({});
    }, nr.prototype.mergeOption = function(Cn) {
      var Bn = this.option;
      Cn && merge$1(Bn, Cn, !0), this._initDimensions();
    }, nr.prototype.contains = function(Cn, Bn) {
      var In = Cn.get("parallelIndex");
      return In != null && Bn.getComponent("parallel", In) === this;
    }, nr.prototype.setAxisExpand = function(Cn) {
      each$f(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(Bn) {
        Cn.hasOwnProperty(Bn) && (this.option[Bn] = Cn[Bn]);
      }, this);
    }, nr.prototype._initDimensions = function() {
      var Cn = this.dimensions = [], Bn = this.parallelAxisIndex = [], In = filter(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(Dn) {
        return (Dn.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      each$f(In, function(Dn) {
        Cn.push("dim" + Dn.get("dim")), Bn.push(Dn.componentIndex);
      });
    }, nr.type = "parallel", nr.dependencies = ["parallelAxis"], nr.layoutMode = "box", nr.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, nr;
  }(ComponentModel$1)
);
const ParallelModel$1 = ParallelModel;
var ParallelAxis = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In, Dn, Ln) {
      var $n = _n.call(this, Cn, Bn, In) || this;
      return $n.type = Dn || "value", $n.axisIndex = Ln, $n;
    }
    return nr.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, nr;
  }(Axis$1)
);
const ParallelAxis$1 = ParallelAxis;
function sliderMove(_n, nr, Cn, Bn, In, Dn) {
  _n = _n || 0;
  var Ln = Cn[1] - Cn[0];
  if (In != null && (In = restrict$1(In, [0, Ln])), Dn != null && (Dn = Math.max(Dn, In ?? 0)), Bn === "all") {
    var $n = Math.abs(nr[1] - nr[0]);
    $n = restrict$1($n, [0, Ln]), In = Dn = restrict$1($n, [In, Dn]), Bn = 0;
  }
  nr[0] = restrict$1(nr[0], Cn), nr[1] = restrict$1(nr[1], Cn);
  var Nn = getSpanSign(nr, Bn);
  nr[Bn] += _n;
  var Rn = In || 0, Fn = Cn.slice();
  Nn.sign < 0 ? Fn[0] += Rn : Fn[1] -= Rn, nr[Bn] = restrict$1(nr[Bn], Fn);
  var Pn;
  return Pn = getSpanSign(nr, Bn), In != null && (Pn.sign !== Nn.sign || Pn.span < In) && (nr[1 - Bn] = nr[Bn] + Nn.sign * In), Pn = getSpanSign(nr, Bn), Dn != null && Pn.span > Dn && (nr[1 - Bn] = nr[Bn] + Pn.sign * Dn), nr;
}
function getSpanSign(_n, nr) {
  var Cn = _n[nr] - _n[1 - nr];
  return {
    span: Math.abs(Cn),
    sign: Cn > 0 ? -1 : Cn < 0 ? 1 : nr ? -1 : 1
  };
}
function restrict$1(_n, nr) {
  return Math.min(nr[1] != null ? nr[1] : 1 / 0, Math.max(nr[0] != null ? nr[0] : -1 / 0, _n));
}
var each$a = each$f, mathMin$2 = Math.min, mathMax$2 = Math.max, mathFloor = Math.floor, mathCeil = Math.ceil, round = round$4, PI$1 = Math.PI, Parallel = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.type = "parallel", this._axesMap = createHashMap(), this._axesLayout = {}, this.dimensions = nr.dimensions, this._model = nr, this._init(nr, Cn, Bn);
    }
    return _n.prototype._init = function(nr, Cn, Bn) {
      var In = nr.dimensions, Dn = nr.parallelAxisIndex;
      each$a(In, function(Ln, $n) {
        var Nn = Dn[$n], Rn = Cn.getComponent("parallelAxis", Nn), Fn = this._axesMap.set(Ln, new ParallelAxis$1(Ln, createScaleByModel$1(Rn), [0, 0], Rn.get("type"), Nn)), Pn = Fn.type === "category";
        Fn.onBand = Pn && Rn.get("boundaryGap"), Fn.inverse = Rn.get("inverse"), Rn.axis = Fn, Fn.model = Rn, Fn.coordinateSystem = Rn.coordinateSystem = this;
      }, this);
    }, _n.prototype.update = function(nr, Cn) {
      this._updateAxesFromSeries(this._model, nr);
    }, _n.prototype.containPoint = function(nr) {
      var Cn = this._makeLayoutInfo(), Bn = Cn.axisBase, In = Cn.layoutBase, Dn = Cn.pixelDimIndex, Ln = nr[1 - Dn], $n = nr[Dn];
      return Ln >= Bn && Ln <= Bn + Cn.axisLength && $n >= In && $n <= In + Cn.layoutLength;
    }, _n.prototype.getModel = function() {
      return this._model;
    }, _n.prototype._updateAxesFromSeries = function(nr, Cn) {
      Cn.eachSeries(function(Bn) {
        if (nr.contains(Bn, Cn)) {
          var In = Bn.getData();
          each$a(this.dimensions, function(Dn) {
            var Ln = this._axesMap.get(Dn);
            Ln.scale.unionExtentFromData(In, In.mapDimension(Dn)), niceScaleExtent(Ln.scale, Ln.model);
          }, this);
        }
      }, this);
    }, _n.prototype.resize = function(nr, Cn) {
      this._rect = getLayoutRect$1(nr.getBoxLayoutParams(), {
        width: Cn.getWidth(),
        height: Cn.getHeight()
      }), this._layoutAxes();
    }, _n.prototype.getRect = function() {
      return this._rect;
    }, _n.prototype._makeLayoutInfo = function() {
      var nr = this._model, Cn = this._rect, Bn = ["x", "y"], In = ["width", "height"], Dn = nr.get("layout"), Ln = Dn === "horizontal" ? 0 : 1, $n = Cn[In[Ln]], Nn = [0, $n], Rn = this.dimensions.length, Fn = restrict(nr.get("axisExpandWidth"), Nn), Pn = restrict(nr.get("axisExpandCount") || 0, [0, Rn]), Un = nr.get("axisExpandable") && Rn > 3 && Rn > Pn && Pn > 1 && Fn > 0 && $n > 0, Hn = nr.get("axisExpandWindow"), zn;
      if (Hn)
        zn = restrict(Hn[1] - Hn[0], Nn), Hn[1] = Hn[0] + zn;
      else {
        zn = restrict(Fn * (Pn - 1), Nn);
        var Gn = nr.get("axisExpandCenter") || mathFloor(Rn / 2);
        Hn = [Fn * Gn - zn / 2], Hn[1] = Hn[0] + zn;
      }
      var Yn = ($n - zn) / (Rn - Pn);
      Yn < 3 && (Yn = 0);
      var Wn = [mathFloor(round(Hn[0] / Fn, 1)) + 1, mathCeil(round(Hn[1] / Fn, 1)) - 1], Xn = Yn / Fn * Hn[0];
      return {
        layout: Dn,
        pixelDimIndex: Ln,
        layoutBase: Cn[Bn[Ln]],
        layoutLength: $n,
        axisBase: Cn[Bn[1 - Ln]],
        axisLength: Cn[In[1 - Ln]],
        axisExpandable: Un,
        axisExpandWidth: Fn,
        axisCollapseWidth: Yn,
        axisExpandWindow: Hn,
        axisCount: Rn,
        winInnerIndices: Wn,
        axisExpandWindow0Pos: Xn
      };
    }, _n.prototype._layoutAxes = function() {
      var nr = this._rect, Cn = this._axesMap, Bn = this.dimensions, In = this._makeLayoutInfo(), Dn = In.layout;
      Cn.each(function(Ln) {
        var $n = [0, In.axisLength], Nn = Ln.inverse ? 1 : 0;
        Ln.setExtent($n[Nn], $n[1 - Nn]);
      }), each$a(Bn, function(Ln, $n) {
        var Nn = (In.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)($n, In), Rn = {
          horizontal: {
            x: Nn.position,
            y: In.axisLength
          },
          vertical: {
            x: 0,
            y: Nn.position
          }
        }, Fn = {
          horizontal: PI$1 / 2,
          vertical: 0
        }, Pn = [Rn[Dn].x + nr.x, Rn[Dn].y + nr.y], Un = Fn[Dn], Hn = create$1();
        rotate(Hn, Hn, Un), translate(Hn, Hn, Pn), this._axesLayout[Ln] = {
          position: Pn,
          rotation: Un,
          transform: Hn,
          axisNameAvailableWidth: Nn.axisNameAvailableWidth,
          axisLabelShow: Nn.axisLabelShow,
          nameTruncateMaxWidth: Nn.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, _n.prototype.getAxis = function(nr) {
      return this._axesMap.get(nr);
    }, _n.prototype.dataToPoint = function(nr, Cn) {
      return this.axisCoordToPoint(this._axesMap.get(Cn).dataToCoord(nr), Cn);
    }, _n.prototype.eachActiveState = function(nr, Cn, Bn, In) {
      Bn == null && (Bn = 0), In == null && (In = nr.count());
      var Dn = this._axesMap, Ln = this.dimensions, $n = [], Nn = [];
      each$f(Ln, function(Yn) {
        $n.push(nr.mapDimension(Yn)), Nn.push(Dn.get(Yn).model);
      });
      for (var Rn = this.hasAxisBrushed(), Fn = Bn; Fn < In; Fn++) {
        var Pn = void 0;
        if (!Rn)
          Pn = "normal";
        else {
          Pn = "active";
          for (var Un = nr.getValues($n, Fn), Hn = 0, zn = Ln.length; Hn < zn; Hn++) {
            var Gn = Nn[Hn].getActiveState(Un[Hn]);
            if (Gn === "inactive") {
              Pn = "inactive";
              break;
            }
          }
        }
        Cn(Pn, Fn);
      }
    }, _n.prototype.hasAxisBrushed = function() {
      for (var nr = this.dimensions, Cn = this._axesMap, Bn = !1, In = 0, Dn = nr.length; In < Dn; In++)
        Cn.get(nr[In]).model.getActiveState() !== "normal" && (Bn = !0);
      return Bn;
    }, _n.prototype.axisCoordToPoint = function(nr, Cn) {
      var Bn = this._axesLayout[Cn];
      return applyTransform([nr, 0], Bn.transform);
    }, _n.prototype.getAxisLayout = function(nr) {
      return clone$4(this._axesLayout[nr]);
    }, _n.prototype.getSlidedAxisExpandWindow = function(nr) {
      var Cn = this._makeLayoutInfo(), Bn = Cn.pixelDimIndex, In = Cn.axisExpandWindow.slice(), Dn = In[1] - In[0], Ln = [0, Cn.axisExpandWidth * (Cn.axisCount - 1)];
      if (!this.containPoint(nr))
        return {
          behavior: "none",
          axisExpandWindow: In
        };
      var $n = nr[Bn] - Cn.layoutBase - Cn.axisExpandWindow0Pos, Nn, Rn = "slide", Fn = Cn.axisCollapseWidth, Pn = this._model.get("axisExpandSlideTriggerArea"), Un = Pn[0] != null;
      if (Fn)
        Un && Fn && $n < Dn * Pn[0] ? (Rn = "jump", Nn = $n - Dn * Pn[2]) : Un && Fn && $n > Dn * (1 - Pn[0]) ? (Rn = "jump", Nn = $n - Dn * (1 - Pn[2])) : (Nn = $n - Dn * Pn[1]) >= 0 && (Nn = $n - Dn * (1 - Pn[1])) <= 0 && (Nn = 0), Nn *= Cn.axisExpandWidth / Fn, Nn ? sliderMove(Nn, In, Ln, "all") : Rn = "none";
      else {
        var Hn = In[1] - In[0], zn = Ln[1] * $n / Hn;
        In = [mathMax$2(0, zn - Hn / 2)], In[1] = mathMin$2(Ln[1], In[0] + Hn), In[0] = In[1] - Hn;
      }
      return {
        axisExpandWindow: In,
        behavior: Rn
      };
    }, _n;
  }()
);
function restrict(_n, nr) {
  return mathMin$2(mathMax$2(_n, nr[0]), nr[1]);
}
function layoutAxisWithoutExpand(_n, nr) {
  var Cn = nr.layoutLength / (nr.axisCount - 1);
  return {
    position: Cn * _n,
    axisNameAvailableWidth: Cn,
    axisLabelShow: !0
  };
}
function layoutAxisWithExpand(_n, nr) {
  var Cn = nr.layoutLength, Bn = nr.axisExpandWidth, In = nr.axisCount, Dn = nr.axisCollapseWidth, Ln = nr.winInnerIndices, $n, Nn = Dn, Rn = !1, Fn;
  return _n < Ln[0] ? ($n = _n * Dn, Fn = Dn) : _n <= Ln[1] ? ($n = nr.axisExpandWindow0Pos + _n * Bn - nr.axisExpandWindow[0], Nn = Bn, Rn = !0) : ($n = Cn - (In - 1 - _n) * Dn, Fn = Dn), {
    position: $n,
    axisNameAvailableWidth: Nn,
    axisLabelShow: Rn,
    nameTruncateMaxWidth: Fn
  };
}
const Parallel$1 = Parallel;
function createParallelCoordSys(_n, nr) {
  var Cn = [];
  return _n.eachComponent("parallel", function(Bn, In) {
    var Dn = new Parallel$1(Bn, _n, nr);
    Dn.name = "parallel_" + In, Dn.resize(Bn, nr), Bn.coordinateSystem = Dn, Dn.model = Bn, Cn.push(Dn);
  }), _n.eachSeries(function(Bn) {
    if (Bn.get("coordinateSystem") === "parallel") {
      var In = Bn.getReferringComponents("parallel", SINGLE_REFERRING).models[0];
      Bn.coordinateSystem = In.coordinateSystem;
    }
  }), Cn;
}
var parallelCoordSysCreator = {
  create: createParallelCoordSys
};
const parallelCoordSysCreator$1 = parallelCoordSysCreator;
var ParallelAxisModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.activeIntervals = [], Cn;
    }
    return nr.prototype.getAreaSelectStyle = function() {
      return makeStyleMapper([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, nr.prototype.setActiveIntervals = function(Cn) {
      var Bn = this.activeIntervals = clone$4(Cn);
      if (Bn)
        for (var In = Bn.length - 1; In >= 0; In--)
          asc$2(Bn[In]);
    }, nr.prototype.getActiveState = function(Cn) {
      var Bn = this.activeIntervals;
      if (!Bn.length)
        return "normal";
      if (Cn == null || isNaN(+Cn))
        return "inactive";
      if (Bn.length === 1) {
        var In = Bn[0];
        if (In[0] <= Cn && Cn <= In[1])
          return "active";
      } else
        for (var Dn = 0, Ln = Bn.length; Dn < Ln; Dn++)
          if (Bn[Dn][0] <= Cn && Cn <= Bn[Dn][1])
            return "active";
      return "inactive";
    }, nr;
  }(ComponentModel$1)
);
mixin(ParallelAxisModel, AxisModelCommonMixin);
const ParallelAxisModel$1 = ParallelAxisModel;
var BRUSH_PANEL_GLOBAL = !0, mathMin$1 = Math.min, mathMax$1 = Math.max, mathPow = Math.pow, COVER_Z = 1e4, UNSELECT_THRESHOLD = 6, MIN_RESIZE_LINE_WIDTH = 6, MUTEX_RESOURCE_KEY = "globalPan", DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, CURSOR_MAP = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, baseUID = 0, BrushController = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this) || this;
      return Bn._track = [], Bn._covers = [], Bn._handlers = {}, process.env.NODE_ENV !== "production" && assert(Cn), Bn._zr = Cn, Bn.group = new Group$4(), Bn._uid = "brushController_" + baseUID++, each$f(pointerHandlers, function(In, Dn) {
        this._handlers[Dn] = bind$1(In, this);
      }, Bn), Bn;
    }
    return nr.prototype.enableBrush = function(Cn) {
      return process.env.NODE_ENV !== "production" && assert(this._mounted), this._brushType && this._doDisableBrush(), Cn.brushType && this._doEnableBrush(Cn), this;
    }, nr.prototype._doEnableBrush = function(Cn) {
      var Bn = this._zr;
      this._enableGlobalPan || take(Bn, MUTEX_RESOURCE_KEY, this._uid), each$f(this._handlers, function(In, Dn) {
        Bn.on(Dn, In);
      }), this._brushType = Cn.brushType, this._brushOption = merge$1(clone$4(DEFAULT_BRUSH_OPT), Cn, !0);
    }, nr.prototype._doDisableBrush = function() {
      var Cn = this._zr;
      release(Cn, MUTEX_RESOURCE_KEY, this._uid), each$f(this._handlers, function(Bn, In) {
        Cn.off(In, Bn);
      }), this._brushType = this._brushOption = null;
    }, nr.prototype.setPanels = function(Cn) {
      if (Cn && Cn.length) {
        var Bn = this._panels = {};
        each$f(Cn, function(In) {
          Bn[In.panelId] = clone$4(In);
        });
      } else
        this._panels = null;
      return this;
    }, nr.prototype.mount = function(Cn) {
      Cn = Cn || {}, process.env.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = Cn.enableGlobalPan;
      var Bn = this.group;
      return this._zr.add(Bn), Bn.attr({
        x: Cn.x || 0,
        y: Cn.y || 0,
        rotation: Cn.rotation || 0,
        scaleX: Cn.scaleX || 1,
        scaleY: Cn.scaleY || 1
      }), this._transform = Bn.getLocalTransform(), this;
    }, nr.prototype.updateCovers = function(Cn) {
      process.env.NODE_ENV !== "production" && assert(this._mounted), Cn = map$1(Cn, function(Un) {
        return merge$1(clone$4(DEFAULT_BRUSH_OPT), Un, !0);
      });
      var Bn = "\0-brush-index-", In = this._covers, Dn = this._covers = [], Ln = this, $n = this._creatingCover;
      return new DataDiffer$1(In, Cn, Rn, Nn).add(Fn).update(Fn).remove(Pn).execute(), this;
      function Nn(Un, Hn) {
        return (Un.id != null ? Un.id : Bn + Hn) + "-" + Un.brushType;
      }
      function Rn(Un, Hn) {
        return Nn(Un.__brushOption, Hn);
      }
      function Fn(Un, Hn) {
        var zn = Cn[Un];
        if (Hn != null && In[Hn] === $n)
          Dn[Un] = In[Hn];
        else {
          var Gn = Dn[Un] = Hn != null ? (In[Hn].__brushOption = zn, In[Hn]) : endCreating(Ln, createCover(Ln, zn));
          updateCoverAfterCreation(Ln, Gn);
        }
      }
      function Pn(Un) {
        In[Un] !== $n && Ln.group.remove(In[Un]);
      }
    }, nr.prototype.unmount = function() {
      if (!(process.env.NODE_ENV !== "production" && !this._mounted))
        return this.enableBrush(!1), clearCovers(this), this._zr.remove(this.group), process.env.NODE_ENV !== "production" && (this._mounted = !1), this;
    }, nr.prototype.dispose = function() {
      this.unmount(), this.off();
    }, nr;
  }(Eventful$1)
);
function createCover(_n, nr) {
  var Cn = coverRenderers[nr.brushType].createCover(_n, nr);
  return Cn.__brushOption = nr, updateZ$1(Cn, nr), _n.group.add(Cn), Cn;
}
function endCreating(_n, nr) {
  var Cn = getCoverRenderer(nr);
  return Cn.endCreating && (Cn.endCreating(_n, nr), updateZ$1(nr, nr.__brushOption)), nr;
}
function updateCoverShape(_n, nr) {
  var Cn = nr.__brushOption;
  getCoverRenderer(nr).updateCoverShape(_n, nr, Cn.range, Cn);
}
function updateZ$1(_n, nr) {
  var Cn = nr.z;
  Cn == null && (Cn = COVER_Z), _n.traverse(function(Bn) {
    Bn.z = Cn, Bn.z2 = Cn;
  });
}
function updateCoverAfterCreation(_n, nr) {
  getCoverRenderer(nr).updateCommon(_n, nr), updateCoverShape(_n, nr);
}
function getCoverRenderer(_n) {
  return coverRenderers[_n.__brushOption.brushType];
}
function getPanelByPoint(_n, nr, Cn) {
  var Bn = _n._panels;
  if (!Bn)
    return BRUSH_PANEL_GLOBAL;
  var In, Dn = _n._transform;
  return each$f(Bn, function(Ln) {
    Ln.isTargetByCursor(nr, Cn, Dn) && (In = Ln);
  }), In;
}
function getPanelByCover(_n, nr) {
  var Cn = _n._panels;
  if (!Cn)
    return BRUSH_PANEL_GLOBAL;
  var Bn = nr.__brushOption.panelId;
  return Bn != null ? Cn[Bn] : BRUSH_PANEL_GLOBAL;
}
function clearCovers(_n) {
  var nr = _n._covers, Cn = nr.length;
  return each$f(nr, function(Bn) {
    _n.group.remove(Bn);
  }, _n), nr.length = 0, !!Cn;
}
function trigger(_n, nr) {
  var Cn = map$1(_n._covers, function(Bn) {
    var In = Bn.__brushOption, Dn = clone$4(In.range);
    return {
      brushType: In.brushType,
      panelId: In.panelId,
      range: Dn
    };
  });
  _n.trigger("brush", {
    areas: Cn,
    isEnd: !!nr.isEnd,
    removeOnClick: !!nr.removeOnClick
  });
}
function shouldShowCover(_n) {
  var nr = _n._track;
  if (!nr.length)
    return !1;
  var Cn = nr[nr.length - 1], Bn = nr[0], In = Cn[0] - Bn[0], Dn = Cn[1] - Bn[1], Ln = mathPow(In * In + Dn * Dn, 0.5);
  return Ln > UNSELECT_THRESHOLD;
}
function getTrackEnds(_n) {
  var nr = _n.length - 1;
  return nr < 0 && (nr = 0), [_n[0], _n[nr]];
}
function createBaseRectCover(_n, nr, Cn, Bn) {
  var In = new Group$4();
  return In.add(new Rect$3({
    name: "main",
    style: makeStyle(Cn),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: curry$1(driftRect, _n, nr, In, ["n", "s", "w", "e"]),
    ondragend: curry$1(trigger, nr, {
      isEnd: !0
    })
  })), each$f(Bn, function(Dn) {
    In.add(new Rect$3({
      name: Dn.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: curry$1(driftRect, _n, nr, In, Dn),
      ondragend: curry$1(trigger, nr, {
        isEnd: !0
      })
    }));
  }), In;
}
function updateBaseRect(_n, nr, Cn, Bn) {
  var In = Bn.brushStyle.lineWidth || 0, Dn = mathMax$1(In, MIN_RESIZE_LINE_WIDTH), Ln = Cn[0][0], $n = Cn[1][0], Nn = Ln - In / 2, Rn = $n - In / 2, Fn = Cn[0][1], Pn = Cn[1][1], Un = Fn - Dn + In / 2, Hn = Pn - Dn + In / 2, zn = Fn - Ln, Gn = Pn - $n, Yn = zn + In, Wn = Gn + In;
  updateRectShape(_n, nr, "main", Ln, $n, zn, Gn), Bn.transformable && (updateRectShape(_n, nr, "w", Nn, Rn, Dn, Wn), updateRectShape(_n, nr, "e", Un, Rn, Dn, Wn), updateRectShape(_n, nr, "n", Nn, Rn, Yn, Dn), updateRectShape(_n, nr, "s", Nn, Hn, Yn, Dn), updateRectShape(_n, nr, "nw", Nn, Rn, Dn, Dn), updateRectShape(_n, nr, "ne", Un, Rn, Dn, Dn), updateRectShape(_n, nr, "sw", Nn, Hn, Dn, Dn), updateRectShape(_n, nr, "se", Un, Hn, Dn, Dn));
}
function updateCommon$1(_n, nr) {
  var Cn = nr.__brushOption, Bn = Cn.transformable, In = nr.childAt(0);
  In.useStyle(makeStyle(Cn)), In.attr({
    silent: !Bn,
    cursor: Bn ? "move" : "default"
  }), each$f([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(Dn) {
    var Ln = nr.childOfName(Dn.join("")), $n = Dn.length === 1 ? getGlobalDirection1(_n, Dn[0]) : getGlobalDirection2(_n, Dn);
    Ln && Ln.attr({
      silent: !Bn,
      invisible: !Bn,
      cursor: Bn ? CURSOR_MAP[$n] + "-resize" : null
    });
  });
}
function updateRectShape(_n, nr, Cn, Bn, In, Dn, Ln) {
  var $n = nr.childOfName(Cn);
  $n && $n.setShape(pointsToRect(clipByPanel(_n, nr, [[Bn, In], [Bn + Dn, In + Ln]])));
}
function makeStyle(_n) {
  return defaults({
    strokeNoScale: !0
  }, _n.brushStyle);
}
function formatRectRange(_n, nr, Cn, Bn) {
  var In = [mathMin$1(_n, Cn), mathMin$1(nr, Bn)], Dn = [mathMax$1(_n, Cn), mathMax$1(nr, Bn)];
  return [
    [In[0], Dn[0]],
    [In[1], Dn[1]]
    // y range
  ];
}
function getTransform(_n) {
  return getTransform$1(_n.group);
}
function getGlobalDirection1(_n, nr) {
  var Cn = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, Bn = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, In = transformDirection(Cn[nr], getTransform(_n));
  return Bn[In];
}
function getGlobalDirection2(_n, nr) {
  var Cn = [getGlobalDirection1(_n, nr[0]), getGlobalDirection1(_n, nr[1])];
  return (Cn[0] === "e" || Cn[0] === "w") && Cn.reverse(), Cn.join("");
}
function driftRect(_n, nr, Cn, Bn, In, Dn) {
  var Ln = Cn.__brushOption, $n = _n.toRectRange(Ln.range), Nn = toLocalDelta(nr, In, Dn);
  each$f(Bn, function(Rn) {
    var Fn = DIRECTION_MAP[Rn];
    $n[Fn[0]][Fn[1]] += Nn[Fn[0]];
  }), Ln.range = _n.fromRectRange(formatRectRange($n[0][0], $n[1][0], $n[0][1], $n[1][1])), updateCoverAfterCreation(nr, Cn), trigger(nr, {
    isEnd: !1
  });
}
function driftPolygon(_n, nr, Cn, Bn) {
  var In = nr.__brushOption.range, Dn = toLocalDelta(_n, Cn, Bn);
  each$f(In, function(Ln) {
    Ln[0] += Dn[0], Ln[1] += Dn[1];
  }), updateCoverAfterCreation(_n, nr), trigger(_n, {
    isEnd: !1
  });
}
function toLocalDelta(_n, nr, Cn) {
  var Bn = _n.group, In = Bn.transformCoordToLocal(nr, Cn), Dn = Bn.transformCoordToLocal(0, 0);
  return [In[0] - Dn[0], In[1] - Dn[1]];
}
function clipByPanel(_n, nr, Cn) {
  var Bn = getPanelByCover(_n, nr);
  return Bn && Bn !== BRUSH_PANEL_GLOBAL ? Bn.clipPath(Cn, _n._transform) : clone$4(Cn);
}
function pointsToRect(_n) {
  var nr = mathMin$1(_n[0][0], _n[1][0]), Cn = mathMin$1(_n[0][1], _n[1][1]), Bn = mathMax$1(_n[0][0], _n[1][0]), In = mathMax$1(_n[0][1], _n[1][1]);
  return {
    x: nr,
    y: Cn,
    width: Bn - nr,
    height: In - Cn
  };
}
function resetCursor(_n, nr, Cn) {
  if (
    // Check active
    !(!_n._brushType || isOutsideZrArea(_n, nr.offsetX, nr.offsetY))
  ) {
    var Bn = _n._zr, In = _n._covers, Dn = getPanelByPoint(_n, nr, Cn);
    if (!_n._dragging)
      for (var Ln = 0; Ln < In.length; Ln++) {
        var $n = In[Ln].__brushOption;
        if (Dn && (Dn === BRUSH_PANEL_GLOBAL || $n.panelId === Dn.panelId) && coverRenderers[$n.brushType].contain(In[Ln], Cn[0], Cn[1]))
          return;
      }
    Dn && Bn.setCursorStyle("crosshair");
  }
}
function preventDefault(_n) {
  var nr = _n.event;
  nr.preventDefault && nr.preventDefault();
}
function mainShapeContain(_n, nr, Cn) {
  return _n.childOfName("main").contain(nr, Cn);
}
function updateCoverByMouse(_n, nr, Cn, Bn) {
  var In = _n._creatingCover, Dn = _n._creatingPanel, Ln = _n._brushOption, $n;
  if (_n._track.push(Cn.slice()), shouldShowCover(_n) || In) {
    if (Dn && !In) {
      Ln.brushMode === "single" && clearCovers(_n);
      var Nn = clone$4(Ln);
      Nn.brushType = determineBrushType(Nn.brushType, Dn), Nn.panelId = Dn === BRUSH_PANEL_GLOBAL ? null : Dn.panelId, In = _n._creatingCover = createCover(_n, Nn), _n._covers.push(In);
    }
    if (In) {
      var Rn = coverRenderers[determineBrushType(_n._brushType, Dn)], Fn = In.__brushOption;
      Fn.range = Rn.getCreatingRange(clipByPanel(_n, In, _n._track)), Bn && (endCreating(_n, In), Rn.updateCommon(_n, In)), updateCoverShape(_n, In), $n = {
        isEnd: Bn
      };
    }
  } else
    Bn && Ln.brushMode === "single" && Ln.removeOnClick && getPanelByPoint(_n, nr, Cn) && clearCovers(_n) && ($n = {
      isEnd: Bn,
      removeOnClick: !0
    });
  return $n;
}
function determineBrushType(_n, nr) {
  return _n === "auto" ? (process.env.NODE_ENV !== "production" && assert(nr && nr.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), nr.defaultBrushType) : _n;
}
var pointerHandlers = {
  mousedown: function(_n) {
    if (this._dragging)
      handleDragEnd(this, _n);
    else if (!_n.target || !_n.target.draggable) {
      preventDefault(_n);
      var nr = this.group.transformCoordToLocal(_n.offsetX, _n.offsetY);
      this._creatingCover = null;
      var Cn = this._creatingPanel = getPanelByPoint(this, _n, nr);
      Cn && (this._dragging = !0, this._track = [nr.slice()]);
    }
  },
  mousemove: function(_n) {
    var nr = _n.offsetX, Cn = _n.offsetY, Bn = this.group.transformCoordToLocal(nr, Cn);
    if (resetCursor(this, _n, Bn), this._dragging) {
      preventDefault(_n);
      var In = updateCoverByMouse(this, _n, Bn, !1);
      In && trigger(this, In);
    }
  },
  mouseup: function(_n) {
    handleDragEnd(this, _n);
  }
};
function handleDragEnd(_n, nr) {
  if (_n._dragging) {
    preventDefault(nr);
    var Cn = nr.offsetX, Bn = nr.offsetY, In = _n.group.transformCoordToLocal(Cn, Bn), Dn = updateCoverByMouse(_n, nr, In, !0);
    _n._dragging = !1, _n._track = [], _n._creatingCover = null, Dn && trigger(_n, Dn);
  }
}
function isOutsideZrArea(_n, nr, Cn) {
  var Bn = _n._zr;
  return nr < 0 || nr > Bn.getWidth() || Cn < 0 || Cn > Bn.getHeight();
}
var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function(_n, nr) {
      function Cn(Bn) {
        return Bn;
      }
      return createBaseRectCover({
        toRectRange: Cn,
        fromRectRange: Cn
      }, _n, nr, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(_n) {
      var nr = getTrackEnds(_n);
      return formatRectRange(nr[1][0], nr[1][1], nr[0][0], nr[0][1]);
    },
    updateCoverShape: function(_n, nr, Cn, Bn) {
      updateBaseRect(_n, nr, Cn, Bn);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function(_n, nr) {
      var Cn = new Group$4();
      return Cn.add(new Polyline$3({
        name: "main",
        style: makeStyle(nr),
        silent: !0
      })), Cn;
    },
    getCreatingRange: function(_n) {
      return _n;
    },
    endCreating: function(_n, nr) {
      nr.remove(nr.childAt(0)), nr.add(new Polygon$1({
        name: "main",
        draggable: !0,
        drift: curry$1(driftPolygon, _n, nr),
        ondragend: curry$1(trigger, _n, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(_n, nr, Cn, Bn) {
      nr.childAt(0).setShape({
        points: clipByPanel(_n, nr, Cn)
      });
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  }
};
function getLineRenderer(_n) {
  return {
    createCover: function(nr, Cn) {
      return createBaseRectCover({
        toRectRange: function(Bn) {
          var In = [Bn, [0, 100]];
          return _n && In.reverse(), In;
        },
        fromRectRange: function(Bn) {
          return Bn[_n];
        }
      }, nr, Cn, [[["w"], ["e"]], [["n"], ["s"]]][_n]);
    },
    getCreatingRange: function(nr) {
      var Cn = getTrackEnds(nr), Bn = mathMin$1(Cn[0][_n], Cn[1][_n]), In = mathMax$1(Cn[0][_n], Cn[1][_n]);
      return [Bn, In];
    },
    updateCoverShape: function(nr, Cn, Bn, In) {
      var Dn, Ln = getPanelByCover(nr, Cn);
      if (Ln !== BRUSH_PANEL_GLOBAL && Ln.getLinearBrushOtherExtent)
        Dn = Ln.getLinearBrushOtherExtent(_n);
      else {
        var $n = nr._zr;
        Dn = [0, [$n.getWidth(), $n.getHeight()][1 - _n]];
      }
      var Nn = [Bn, Dn];
      _n && Nn.reverse(), updateBaseRect(nr, Cn, Nn, In);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  };
}
const BrushController$1 = BrushController;
function makeRectPanelClipPath(_n) {
  return _n = normalizeRect(_n), function(nr) {
    return clipPointsByRect(nr, _n);
  };
}
function makeLinearBrushOtherExtent(_n, nr) {
  return _n = normalizeRect(_n), function(Cn) {
    var Bn = nr ?? Cn, In = Bn ? _n.width : _n.height, Dn = Bn ? _n.x : _n.y;
    return [Dn, Dn + (In || 0)];
  };
}
function makeRectIsTargetByCursor(_n, nr, Cn) {
  var Bn = normalizeRect(_n);
  return function(In, Dn) {
    return Bn.contain(Dn[0], Dn[1]) && !onIrrelevantElement(In, nr, Cn);
  };
}
function normalizeRect(_n) {
  return BoundingRect$1.create(_n);
}
var elementList$1 = ["axisLine", "axisTickLabel", "axisName"], ParallelAxisView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      _n.prototype.init.apply(this, arguments), (this._brushController = new BrushController$1(Bn.getZr())).on("brush", bind$1(this._onBrush, this));
    }, nr.prototype.render = function(Cn, Bn, In, Dn) {
      if (!fromAxisAreaSelect(Cn, Bn, Dn)) {
        this.axisModel = Cn, this.api = In, this.group.removeAll();
        var Ln = this._axisGroup;
        if (this._axisGroup = new Group$4(), this.group.add(this._axisGroup), !!Cn.get("show")) {
          var $n = getCoordSysModel(Cn, Bn), Nn = $n.coordinateSystem, Rn = Cn.getAreaSelectStyle(), Fn = Rn.width, Pn = Cn.axis.dim, Un = Nn.getAxisLayout(Pn), Hn = extend({
            strokeContainThreshold: Fn
          }, Un), zn = new AxisBuilder$1(Cn, Hn);
          each$f(elementList$1, zn.add, zn), this._axisGroup.add(zn.getGroup()), this._refreshBrushController(Hn, Rn, Cn, $n, Fn, In), groupTransition(Ln, this._axisGroup, Cn);
        }
      }
    }, nr.prototype._refreshBrushController = function(Cn, Bn, In, Dn, Ln, $n) {
      var Nn = In.axis.getExtent(), Rn = Nn[1] - Nn[0], Fn = Math.min(30, Math.abs(Rn) * 0.1), Pn = BoundingRect$1.create({
        x: Nn[0],
        y: -Ln / 2,
        width: Rn,
        height: Ln
      });
      Pn.x -= Fn, Pn.width += 2 * Fn, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: Cn.rotation,
        x: Cn.position[0],
        y: Cn.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: makeRectPanelClipPath(Pn),
        isTargetByCursor: makeRectIsTargetByCursor(Pn, $n, Dn),
        getLinearBrushOtherExtent: makeLinearBrushOtherExtent(Pn, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: Bn,
        removeOnClick: !0
      }).updateCovers(getCoverInfoList(In));
    }, nr.prototype._onBrush = function(Cn) {
      var Bn = Cn.areas, In = this.axisModel, Dn = In.axis, Ln = map$1(Bn, function($n) {
        return [Dn.coordToData($n.range[0], !0), Dn.coordToData($n.range[1], !0)];
      });
      (!In.option.realtime === Cn.isEnd || Cn.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: In.id,
        intervals: Ln
      });
    }, nr.prototype.dispose = function() {
      this._brushController.dispose();
    }, nr.type = "parallelAxis", nr;
  }(ComponentView$1)
);
function fromAxisAreaSelect(_n, nr, Cn) {
  return Cn && Cn.type === "axisAreaSelect" && nr.findComponents({
    mainType: "parallelAxis",
    query: Cn
  })[0] === _n;
}
function getCoverInfoList(_n) {
  var nr = _n.axis;
  return map$1(_n.activeIntervals, function(Cn) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [nr.dataToCoord(Cn[0], !0), nr.dataToCoord(Cn[1], !0)]
    };
  });
}
function getCoordSysModel(_n, nr) {
  return nr.getComponent("parallel", _n.get("parallelIndex"));
}
const ParallelAxisView$1 = ParallelAxisView;
var actionInfo = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function installParallelActions(_n) {
  _n.registerAction(actionInfo, function(nr, Cn) {
    Cn.eachComponent({
      mainType: "parallelAxis",
      query: nr
    }, function(Bn) {
      Bn.axis.model.setActiveIntervals(nr.intervals);
    });
  }), _n.registerAction("parallelAxisExpand", function(nr, Cn) {
    Cn.eachComponent({
      mainType: "parallel",
      query: nr
    }, function(Bn) {
      Bn.setAxisExpand(nr);
    });
  });
}
var defaultAxisOption = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function install$C(_n) {
  _n.registerComponentView(ParallelView$1), _n.registerComponentModel(ParallelModel$1), _n.registerCoordinateSystem("parallel", parallelCoordSysCreator$1), _n.registerPreprocessor(parallelPreprocessor), _n.registerComponentModel(ParallelAxisModel$1), _n.registerComponentView(ParallelAxisView$1), axisModelCreator(_n, "parallel", ParallelAxisModel$1, defaultAxisOption), installParallelActions(_n);
}
function install$B(_n) {
  use(install$C), _n.registerChartView(ParallelView$3), _n.registerSeriesModel(ParallelSeriesModel$1), _n.registerVisual(_n.PRIORITY.VISUAL.BRUSH, parallelVisual$1);
}
var SankeyPathShape = (
  /** @class */
  function() {
    function _n() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return _n;
  }()
), SankeyPath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      return _n.call(this, Cn) || this;
    }
    return nr.prototype.getDefaultShape = function() {
      return new SankeyPathShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Bn.extent;
      Cn.moveTo(Bn.x1, Bn.y1), Cn.bezierCurveTo(Bn.cpx1, Bn.cpy1, Bn.cpx2, Bn.cpy2, Bn.x2, Bn.y2), Bn.orient === "vertical" ? (Cn.lineTo(Bn.x2 + In, Bn.y2), Cn.bezierCurveTo(Bn.cpx2 + In, Bn.cpy2, Bn.cpx1 + In, Bn.cpy1, Bn.x1 + In, Bn.y1)) : (Cn.lineTo(Bn.x2, Bn.y2 + In), Cn.bezierCurveTo(Bn.cpx2, Bn.cpy2 + In, Bn.cpx1, Bn.cpy1 + In, Bn.x1, Bn.y1 + In)), Cn.closePath();
    }, nr.prototype.highlight = function() {
      enterEmphasis(this);
    }, nr.prototype.downplay = function() {
      leaveEmphasis(this);
    }, nr;
  }(Path$1)
), SankeyView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn._focusAdjacencyDisabled = !1, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = this, Ln = Cn.getGraph(), $n = this.group, Nn = Cn.layoutInfo, Rn = Nn.width, Fn = Nn.height, Pn = Cn.getData(), Un = Cn.getData("edge"), Hn = Cn.get("orient");
      this._model = Cn, $n.removeAll(), $n.x = Nn.x, $n.y = Nn.y, Ln.eachEdge(function(zn) {
        var Gn = new SankeyPath(), Yn = getECData(Gn);
        Yn.dataIndex = zn.dataIndex, Yn.seriesIndex = Cn.seriesIndex, Yn.dataType = "edge";
        var Wn = zn.getModel(), Xn = Wn.getModel("lineStyle"), ea = Xn.get("curveness"), ta = zn.node1.getLayout(), na = zn.node1.getModel(), ra = na.get("localX"), aa = na.get("localY"), ia = zn.node2.getLayout(), Aa = zn.node2.getModel(), sa = Aa.get("localX"), oa = Aa.get("localY"), la = zn.getLayout(), ua, ca, fa, ha, pa, ya, da, Ca;
        Gn.shape.extent = Math.max(1, la.dy), Gn.shape.orient = Hn, Hn === "vertical" ? (ua = (ra != null ? ra * Rn : ta.x) + la.sy, ca = (aa != null ? aa * Fn : ta.y) + ta.dy, fa = (sa != null ? sa * Rn : ia.x) + la.ty, ha = oa != null ? oa * Fn : ia.y, pa = ua, ya = ca * (1 - ea) + ha * ea, da = fa, Ca = ca * ea + ha * (1 - ea)) : (ua = (ra != null ? ra * Rn : ta.x) + ta.dx, ca = (aa != null ? aa * Fn : ta.y) + la.sy, fa = sa != null ? sa * Rn : ia.x, ha = (oa != null ? oa * Fn : ia.y) + la.ty, pa = ua * (1 - ea) + fa * ea, ya = ca, da = ua * ea + fa * (1 - ea), Ca = ha), Gn.setShape({
          x1: ua,
          y1: ca,
          x2: fa,
          y2: ha,
          cpx1: pa,
          cpy1: ya,
          cpx2: da,
          cpy2: Ca
        }), Gn.useStyle(Xn.getItemStyle()), applyCurveStyle(Gn.style, Hn, zn);
        var ma = "" + Wn.get("value"), va = getLabelStatesModels(Wn, "edgeLabel");
        setLabelStyle(Gn, va, {
          labelFetcher: {
            getFormattedLabel: function(wa, ba, Ta, Sa, Ea, Ia) {
              return Cn.getFormattedLabel(
                wa,
                ba,
                "edge",
                Sa,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                retrieve3(Ea, va.normal && va.normal.get("formatter"), ma),
                Ia
              );
            }
          },
          labelDataIndex: zn.dataIndex,
          defaultText: ma
        }), Gn.setTextConfig({
          position: "inside"
        });
        var ga = Wn.getModel("emphasis");
        setStatesStylesFromModel(Gn, Wn, "lineStyle", function(wa) {
          var ba = wa.getItemStyle();
          return applyCurveStyle(ba, Hn, zn), ba;
        }), $n.add(Gn), Un.setItemGraphicEl(zn.dataIndex, Gn);
        var xa = ga.get("focus");
        toggleHoverEmphasis(Gn, xa === "adjacency" ? zn.getAdjacentDataIndices() : xa === "trajectory" ? zn.getTrajectoryDataIndices() : xa, ga.get("blurScope"), ga.get("disabled"));
      }), Ln.eachNode(function(zn) {
        var Gn = zn.getLayout(), Yn = zn.getModel(), Wn = Yn.get("localX"), Xn = Yn.get("localY"), ea = Yn.getModel("emphasis"), ta = Yn.get(["itemStyle", "borderRadius"]) || 0, na = new Rect$3({
          shape: {
            x: Wn != null ? Wn * Rn : Gn.x,
            y: Xn != null ? Xn * Fn : Gn.y,
            width: Gn.dx,
            height: Gn.dy,
            r: ta
          },
          style: Yn.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        setLabelStyle(na, getLabelStatesModels(Yn), {
          labelFetcher: {
            getFormattedLabel: function(aa, ia) {
              return Cn.getFormattedLabel(aa, ia, "node");
            }
          },
          labelDataIndex: zn.dataIndex,
          defaultText: zn.id
        }), na.disableLabelAnimation = !0, na.setStyle("fill", zn.getVisual("color")), na.setStyle("decal", zn.getVisual("style").decal), setStatesStylesFromModel(na, Yn), $n.add(na), Pn.setItemGraphicEl(zn.dataIndex, na), getECData(na).dataType = "node";
        var ra = ea.get("focus");
        toggleHoverEmphasis(na, ra === "adjacency" ? zn.getAdjacentDataIndices() : ra === "trajectory" ? zn.getTrajectoryDataIndices() : ra, ea.get("blurScope"), ea.get("disabled"));
      }), Pn.eachItemGraphicEl(function(zn, Gn) {
        var Yn = Pn.getItemModel(Gn);
        Yn.get("draggable") && (zn.drift = function(Wn, Xn) {
          Dn._focusAdjacencyDisabled = !0, this.shape.x += Wn, this.shape.y += Xn, this.dirty(), In.dispatchAction({
            type: "dragNode",
            seriesId: Cn.id,
            dataIndex: Pn.getRawIndex(Gn),
            localX: this.shape.x / Rn,
            localY: this.shape.y / Fn
          });
        }, zn.ondragend = function() {
          Dn._focusAdjacencyDisabled = !1;
        }, zn.draggable = !0, zn.cursor = "move");
      }), !this._data && Cn.isAnimationEnabled() && $n.setClipPath(createGridClipShape$1($n.getBoundingRect(), Cn, function() {
        $n.removeClipPath();
      })), this._data = Cn.getData();
    }, nr.prototype.dispose = function() {
    }, nr.type = "sankey", nr;
  }(ChartView$1)
);
function applyCurveStyle(_n, nr, Cn) {
  switch (_n.fill) {
    case "source":
      _n.fill = Cn.node1.getVisual("color"), _n.decal = Cn.node1.getVisual("style").decal;
      break;
    case "target":
      _n.fill = Cn.node2.getVisual("color"), _n.decal = Cn.node2.getVisual("style").decal;
      break;
    case "gradient":
      var Bn = Cn.node1.getVisual("color"), In = Cn.node2.getVisual("color");
      isString$1(Bn) && isString$1(In) && (_n.fill = new LinearGradient$1(0, 0, +(nr === "horizontal"), +(nr === "vertical"), [{
        color: Bn,
        offset: 0
      }, {
        color: In,
        offset: 1
      }]));
  }
}
function createGridClipShape$1(_n, nr, Cn) {
  var Bn = new Rect$3({
    shape: {
      x: _n.x - 10,
      y: _n.y - 10,
      width: 0,
      height: _n.height + 20
    }
  });
  return initProps(Bn, {
    shape: {
      width: _n.width + 20
    }
  }, nr, Cn), Bn;
}
const SankeyView$1 = SankeyView;
var SankeySeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.getInitialData = function(Cn, Bn) {
      var In = Cn.edges || Cn.links || [], Dn = Cn.data || Cn.nodes || [], Ln = Cn.levels || [];
      this.levelModels = [];
      for (var $n = this.levelModels, Nn = 0; Nn < Ln.length; Nn++)
        if (Ln[Nn].depth != null && Ln[Nn].depth >= 0)
          $n[Ln[Nn].depth] = new Model$1(Ln[Nn], this, Bn);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      var Rn = createGraphFromNodeEdge(Dn, In, this, !0, Fn);
      return Rn.data;
      function Fn(Pn, Un) {
        Pn.wrapMethod("getItemModel", function(Hn, zn) {
          var Gn = Hn.parentModel, Yn = Gn.getData().getItemLayout(zn);
          if (Yn) {
            var Wn = Yn.depth, Xn = Gn.levelModels[Wn];
            Xn && (Hn.parentModel = Xn);
          }
          return Hn;
        }), Un.wrapMethod("getItemModel", function(Hn, zn) {
          var Gn = Hn.parentModel, Yn = Gn.getGraph().getEdgeByIndex(zn), Wn = Yn.node1.getLayout();
          if (Wn) {
            var Xn = Wn.depth, ea = Gn.levelModels[Xn];
            ea && (Hn.parentModel = ea);
          }
          return Hn;
        });
      }
    }, nr.prototype.setNodePosition = function(Cn, Bn) {
      var In = this.option.data || this.option.nodes, Dn = In[Cn];
      Dn.localX = Bn[0], Dn.localY = Bn[1];
    }, nr.prototype.getGraph = function() {
      return this.getData().graph;
    }, nr.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      function Dn(Hn) {
        return isNaN(Hn) || Hn == null;
      }
      if (In === "edge") {
        var Ln = this.getDataParams(Cn, In), $n = Ln.data, Nn = Ln.value, Rn = $n.source + " -- " + $n.target;
        return createTooltipMarkup("nameValue", {
          name: Rn,
          value: Nn,
          noValue: Dn(Nn)
        });
      } else {
        var Fn = this.getGraph().getNodeByIndex(Cn), Pn = Fn.getLayout().value, Un = this.getDataParams(Cn, In).data.name;
        return createTooltipMarkup("nameValue", {
          name: Un != null ? Un + "" : null,
          value: Pn,
          noValue: Dn(Pn)
        });
      }
    }, nr.prototype.optionUpdated = function() {
    }, nr.prototype.getDataParams = function(Cn, Bn) {
      var In = _n.prototype.getDataParams.call(this, Cn, Bn);
      if (In.value == null && Bn === "node") {
        var Dn = this.getGraph().getNodeByIndex(Cn), Ln = Dn.getLayout().value;
        In.value = Ln;
      }
      return In;
    }, nr.type = "series.sankey", nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, nr;
  }(SeriesModel$1)
);
const SankeySeriesModel$1 = SankeySeriesModel;
function sankeyLayout(_n, nr) {
  _n.eachSeriesByType("sankey", function(Cn) {
    var Bn = Cn.get("nodeWidth"), In = Cn.get("nodeGap"), Dn = getViewRect$1(Cn, nr);
    Cn.layoutInfo = Dn;
    var Ln = Dn.width, $n = Dn.height, Nn = Cn.getGraph(), Rn = Nn.nodes, Fn = Nn.edges;
    computeNodeValues(Rn);
    var Pn = filter(Rn, function(Gn) {
      return Gn.getLayout().value === 0;
    }), Un = Pn.length !== 0 ? 0 : Cn.get("layoutIterations"), Hn = Cn.get("orient"), zn = Cn.get("nodeAlign");
    layoutSankey(Rn, Fn, Bn, In, Ln, $n, Un, Hn, zn);
  });
}
function getViewRect$1(_n, nr) {
  return getLayoutRect$1(_n.getBoxLayoutParams(), {
    width: nr.getWidth(),
    height: nr.getHeight()
  });
}
function layoutSankey(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn) {
  computeNodeBreadths(_n, nr, Cn, In, Dn, $n, Nn), computeNodeDepths(_n, nr, Dn, In, Bn, Ln, $n), computeEdgeDepths(_n, $n);
}
function computeNodeValues(_n) {
  each$f(_n, function(nr) {
    var Cn = sum(nr.outEdges, getEdgeValue), Bn = sum(nr.inEdges, getEdgeValue), In = nr.getValue() || 0, Dn = Math.max(Cn, Bn, In);
    nr.setLayout({
      value: Dn
    }, !0);
  });
}
function computeNodeBreadths(_n, nr, Cn, Bn, In, Dn, Ln) {
  for (var $n = [], Nn = [], Rn = [], Fn = [], Pn = 0, Un = 0; Un < nr.length; Un++)
    $n[Un] = 1;
  for (var Un = 0; Un < _n.length; Un++)
    Nn[Un] = _n[Un].inEdges.length, Nn[Un] === 0 && Rn.push(_n[Un]);
  for (var Hn = -1; Rn.length; ) {
    for (var zn = 0; zn < Rn.length; zn++) {
      var Gn = Rn[zn], Yn = Gn.hostGraph.data.getRawDataItem(Gn.dataIndex), Wn = Yn.depth != null && Yn.depth >= 0;
      Wn && Yn.depth > Hn && (Hn = Yn.depth), Gn.setLayout({
        depth: Wn ? Yn.depth : Pn
      }, !0), Dn === "vertical" ? Gn.setLayout({
        dy: Cn
      }, !0) : Gn.setLayout({
        dx: Cn
      }, !0);
      for (var Xn = 0; Xn < Gn.outEdges.length; Xn++) {
        var ea = Gn.outEdges[Xn], ta = nr.indexOf(ea);
        $n[ta] = 0;
        var na = ea.node2, ra = _n.indexOf(na);
        --Nn[ra] === 0 && Fn.indexOf(na) < 0 && Fn.push(na);
      }
    }
    ++Pn, Rn = Fn, Fn = [];
  }
  for (var Un = 0; Un < $n.length; Un++)
    if ($n[Un] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var aa = Hn > Pn - 1 ? Hn : Pn - 1;
  Ln && Ln !== "left" && adjustNodeWithNodeAlign(_n, Ln, Dn, aa);
  var ia = Dn === "vertical" ? (In - Cn) / aa : (Bn - Cn) / aa;
  scaleNodeBreadths(_n, ia, Dn);
}
function isNodeDepth(_n) {
  var nr = _n.hostGraph.data.getRawDataItem(_n.dataIndex);
  return nr.depth != null && nr.depth >= 0;
}
function adjustNodeWithNodeAlign(_n, nr, Cn, Bn) {
  if (nr === "right") {
    for (var In = [], Dn = _n, Ln = 0; Dn.length; ) {
      for (var $n = 0; $n < Dn.length; $n++) {
        var Nn = Dn[$n];
        Nn.setLayout({
          skNodeHeight: Ln
        }, !0);
        for (var Rn = 0; Rn < Nn.inEdges.length; Rn++) {
          var Fn = Nn.inEdges[Rn];
          In.indexOf(Fn.node1) < 0 && In.push(Fn.node1);
        }
      }
      Dn = In, In = [], ++Ln;
    }
    each$f(_n, function(Pn) {
      isNodeDepth(Pn) || Pn.setLayout({
        depth: Math.max(0, Bn - Pn.getLayout().skNodeHeight)
      }, !0);
    });
  } else
    nr === "justify" && moveSinksRight(_n, Bn);
}
function moveSinksRight(_n, nr) {
  each$f(_n, function(Cn) {
    !isNodeDepth(Cn) && !Cn.outEdges.length && Cn.setLayout({
      depth: nr
    }, !0);
  });
}
function scaleNodeBreadths(_n, nr, Cn) {
  each$f(_n, function(Bn) {
    var In = Bn.getLayout().depth * nr;
    Cn === "vertical" ? Bn.setLayout({
      y: In
    }, !0) : Bn.setLayout({
      x: In
    }, !0);
  });
}
function computeNodeDepths(_n, nr, Cn, Bn, In, Dn, Ln) {
  var $n = prepareNodesByBreadth(_n, Ln);
  initializeNodeDepth($n, nr, Cn, Bn, In, Ln), resolveCollisions($n, In, Cn, Bn, Ln);
  for (var Nn = 1; Dn > 0; Dn--)
    Nn *= 0.99, relaxRightToLeft($n, Nn, Ln), resolveCollisions($n, In, Cn, Bn, Ln), relaxLeftToRight($n, Nn, Ln), resolveCollisions($n, In, Cn, Bn, Ln);
}
function prepareNodesByBreadth(_n, nr) {
  var Cn = [], Bn = nr === "vertical" ? "y" : "x", In = groupData(_n, function(Dn) {
    return Dn.getLayout()[Bn];
  });
  return In.keys.sort(function(Dn, Ln) {
    return Dn - Ln;
  }), each$f(In.keys, function(Dn) {
    Cn.push(In.buckets.get(Dn));
  }), Cn;
}
function initializeNodeDepth(_n, nr, Cn, Bn, In, Dn) {
  var Ln = 1 / 0;
  each$f(_n, function($n) {
    var Nn = $n.length, Rn = 0;
    each$f($n, function(Pn) {
      Rn += Pn.getLayout().value;
    });
    var Fn = Dn === "vertical" ? (Bn - (Nn - 1) * In) / Rn : (Cn - (Nn - 1) * In) / Rn;
    Fn < Ln && (Ln = Fn);
  }), each$f(_n, function($n) {
    each$f($n, function(Nn, Rn) {
      var Fn = Nn.getLayout().value * Ln;
      Dn === "vertical" ? (Nn.setLayout({
        x: Rn
      }, !0), Nn.setLayout({
        dx: Fn
      }, !0)) : (Nn.setLayout({
        y: Rn
      }, !0), Nn.setLayout({
        dy: Fn
      }, !0));
    });
  }), each$f(nr, function($n) {
    var Nn = +$n.getValue() * Ln;
    $n.setLayout({
      dy: Nn
    }, !0);
  });
}
function resolveCollisions(_n, nr, Cn, Bn, In) {
  var Dn = In === "vertical" ? "x" : "y";
  each$f(_n, function(Ln) {
    Ln.sort(function(Gn, Yn) {
      return Gn.getLayout()[Dn] - Yn.getLayout()[Dn];
    });
    for (var $n, Nn, Rn, Fn = 0, Pn = Ln.length, Un = In === "vertical" ? "dx" : "dy", Hn = 0; Hn < Pn; Hn++)
      Nn = Ln[Hn], Rn = Fn - Nn.getLayout()[Dn], Rn > 0 && ($n = Nn.getLayout()[Dn] + Rn, In === "vertical" ? Nn.setLayout({
        x: $n
      }, !0) : Nn.setLayout({
        y: $n
      }, !0)), Fn = Nn.getLayout()[Dn] + Nn.getLayout()[Un] + nr;
    var zn = In === "vertical" ? Bn : Cn;
    if (Rn = Fn - nr - zn, Rn > 0) {
      $n = Nn.getLayout()[Dn] - Rn, In === "vertical" ? Nn.setLayout({
        x: $n
      }, !0) : Nn.setLayout({
        y: $n
      }, !0), Fn = $n;
      for (var Hn = Pn - 2; Hn >= 0; --Hn)
        Nn = Ln[Hn], Rn = Nn.getLayout()[Dn] + Nn.getLayout()[Un] + nr - Fn, Rn > 0 && ($n = Nn.getLayout()[Dn] - Rn, In === "vertical" ? Nn.setLayout({
          x: $n
        }, !0) : Nn.setLayout({
          y: $n
        }, !0)), Fn = Nn.getLayout()[Dn];
    }
  });
}
function relaxRightToLeft(_n, nr, Cn) {
  each$f(_n.slice().reverse(), function(Bn) {
    each$f(Bn, function(In) {
      if (In.outEdges.length) {
        var Dn = sum(In.outEdges, weightedTarget, Cn) / sum(In.outEdges, getEdgeValue);
        if (isNaN(Dn)) {
          var Ln = In.outEdges.length;
          Dn = Ln ? sum(In.outEdges, centerTarget, Cn) / Ln : 0;
        }
        if (Cn === "vertical") {
          var $n = In.getLayout().x + (Dn - center(In, Cn)) * nr;
          In.setLayout({
            x: $n
          }, !0);
        } else {
          var Nn = In.getLayout().y + (Dn - center(In, Cn)) * nr;
          In.setLayout({
            y: Nn
          }, !0);
        }
      }
    });
  });
}
function weightedTarget(_n, nr) {
  return center(_n.node2, nr) * _n.getValue();
}
function centerTarget(_n, nr) {
  return center(_n.node2, nr);
}
function weightedSource(_n, nr) {
  return center(_n.node1, nr) * _n.getValue();
}
function centerSource(_n, nr) {
  return center(_n.node1, nr);
}
function center(_n, nr) {
  return nr === "vertical" ? _n.getLayout().x + _n.getLayout().dx / 2 : _n.getLayout().y + _n.getLayout().dy / 2;
}
function getEdgeValue(_n) {
  return _n.getValue();
}
function sum(_n, nr, Cn) {
  for (var Bn = 0, In = _n.length, Dn = -1; ++Dn < In; ) {
    var Ln = +nr(_n[Dn], Cn);
    isNaN(Ln) || (Bn += Ln);
  }
  return Bn;
}
function relaxLeftToRight(_n, nr, Cn) {
  each$f(_n, function(Bn) {
    each$f(Bn, function(In) {
      if (In.inEdges.length) {
        var Dn = sum(In.inEdges, weightedSource, Cn) / sum(In.inEdges, getEdgeValue);
        if (isNaN(Dn)) {
          var Ln = In.inEdges.length;
          Dn = Ln ? sum(In.inEdges, centerSource, Cn) / Ln : 0;
        }
        if (Cn === "vertical") {
          var $n = In.getLayout().x + (Dn - center(In, Cn)) * nr;
          In.setLayout({
            x: $n
          }, !0);
        } else {
          var Nn = In.getLayout().y + (Dn - center(In, Cn)) * nr;
          In.setLayout({
            y: Nn
          }, !0);
        }
      }
    });
  });
}
function computeEdgeDepths(_n, nr) {
  var Cn = nr === "vertical" ? "x" : "y";
  each$f(_n, function(Bn) {
    Bn.outEdges.sort(function(In, Dn) {
      return In.node2.getLayout()[Cn] - Dn.node2.getLayout()[Cn];
    }), Bn.inEdges.sort(function(In, Dn) {
      return In.node1.getLayout()[Cn] - Dn.node1.getLayout()[Cn];
    });
  }), each$f(_n, function(Bn) {
    var In = 0, Dn = 0;
    each$f(Bn.outEdges, function(Ln) {
      Ln.setLayout({
        sy: In
      }, !0), In += Ln.getLayout().dy;
    }), each$f(Bn.inEdges, function(Ln) {
      Ln.setLayout({
        ty: Dn
      }, !0), Dn += Ln.getLayout().dy;
    });
  });
}
function sankeyVisual(_n) {
  _n.eachSeriesByType("sankey", function(nr) {
    var Cn = nr.getGraph(), Bn = Cn.nodes, In = Cn.edges;
    if (Bn.length) {
      var Dn = 1 / 0, Ln = -1 / 0;
      each$f(Bn, function($n) {
        var Nn = $n.getLayout().value;
        Nn < Dn && (Dn = Nn), Nn > Ln && (Ln = Nn);
      }), each$f(Bn, function($n) {
        var Nn = new VisualMapping$1({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [Dn, Ln],
          visual: nr.get("color")
        }), Rn = Nn.mapValueToVisual($n.getLayout().value), Fn = $n.getModel().get(["itemStyle", "color"]);
        Fn != null ? ($n.setVisual("color", Fn), $n.setVisual("style", {
          fill: Fn
        })) : ($n.setVisual("color", Rn), $n.setVisual("style", {
          fill: Rn
        }));
      });
    }
    In.length && each$f(In, function($n) {
      var Nn = $n.getModel().get("lineStyle");
      $n.setVisual("style", Nn);
    });
  });
}
function install$A(_n) {
  _n.registerChartView(SankeyView$1), _n.registerSeriesModel(SankeySeriesModel$1), _n.registerLayout(sankeyLayout), _n.registerVisual(sankeyVisual), _n.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(nr, Cn) {
    Cn.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: nr
    }, function(Bn) {
      Bn.setNodePosition(nr.dataIndex, [nr.localX, nr.localY]);
    });
  });
}
var WhiskerBoxCommonMixin = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype._hasEncodeRule = function(nr) {
      var Cn = this.getEncode();
      return Cn && Cn.get(nr) != null;
    }, _n.prototype.getInitialData = function(nr, Cn) {
      var Bn, In = Cn.getComponent("xAxis", this.get("xAxisIndex")), Dn = Cn.getComponent("yAxis", this.get("yAxisIndex")), Ln = In.get("type"), $n = Dn.get("type"), Nn;
      Ln === "category" ? (nr.layout = "horizontal", Bn = In.getOrdinalMeta(), Nn = !this._hasEncodeRule("x")) : $n === "category" ? (nr.layout = "vertical", Bn = Dn.getOrdinalMeta(), Nn = !this._hasEncodeRule("y")) : nr.layout = nr.layout || "horizontal";
      var Rn = ["x", "y"], Fn = nr.layout === "horizontal" ? 0 : 1, Pn = this._baseAxisDim = Rn[Fn], Un = Rn[1 - Fn], Hn = [In, Dn], zn = Hn[Fn].get("type"), Gn = Hn[1 - Fn].get("type"), Yn = nr.data;
      if (Yn && Nn) {
        var Wn = [];
        each$f(Yn, function(ta, na) {
          var ra;
          isArray$4(ta) ? (ra = ta.slice(), ta.unshift(na)) : isArray$4(ta.value) ? (ra = extend({}, ta), ra.value = ra.value.slice(), ta.value.unshift(na)) : ra = ta, Wn.push(ra);
        }), nr.data = Wn;
      }
      var Xn = this.defaultValueDimensions, ea = [{
        name: Pn,
        type: getDimensionTypeByAxis(zn),
        ordinalMeta: Bn,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: Un,
        type: getDimensionTypeByAxis(Gn),
        dimsDef: Xn.slice()
      }];
      return createSeriesDataSimply(this, {
        coordDimensions: ea,
        dimensionsCount: Xn.length + 1,
        encodeDefaulter: curry$1(makeSeriesEncodeForAxisCoordSys, ea, this)
      });
    }, _n.prototype.getBaseAxis = function() {
      var nr = this._baseAxisDim;
      return this.ecModel.getComponent(nr + "Axis", this.get(nr + "AxisIndex")).axis;
    }, _n;
  }()
), BoxplotSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], Cn.visualDrawType = "stroke", Cn;
    }
    return nr.type = "series.boxplot", nr.dependencies = ["xAxis", "yAxis", "grid"], nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, nr;
  }(SeriesModel$1)
);
mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, !0);
const BoxplotSeriesModel$1 = BoxplotSeriesModel;
var BoxplotView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = this.group, $n = this._data;
      this._data || Ln.removeAll();
      var Nn = Cn.get("layout") === "horizontal" ? 1 : 0;
      Dn.diff($n).add(function(Rn) {
        if (Dn.hasValue(Rn)) {
          var Fn = Dn.getItemLayout(Rn), Pn = createNormalBox$1(Fn, Dn, Rn, Nn, !0);
          Dn.setItemGraphicEl(Rn, Pn), Ln.add(Pn);
        }
      }).update(function(Rn, Fn) {
        var Pn = $n.getItemGraphicEl(Fn);
        if (!Dn.hasValue(Rn)) {
          Ln.remove(Pn);
          return;
        }
        var Un = Dn.getItemLayout(Rn);
        Pn ? (saveOldStyle(Pn), updateNormalBoxData(Un, Pn, Dn, Rn)) : Pn = createNormalBox$1(Un, Dn, Rn, Nn), Ln.add(Pn), Dn.setItemGraphicEl(Rn, Pn);
      }).remove(function(Rn) {
        var Fn = $n.getItemGraphicEl(Rn);
        Fn && Ln.remove(Fn);
      }).execute(), this._data = Dn;
    }, nr.prototype.remove = function(Cn) {
      var Bn = this.group, In = this._data;
      this._data = null, In && In.eachItemGraphicEl(function(Dn) {
        Dn && Bn.remove(Dn);
      });
    }, nr.type = "boxplot", nr;
  }(ChartView$1)
), BoxPathShape = (
  /** @class */
  function() {
    function _n() {
    }
    return _n;
  }()
), BoxPath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "boxplotBoxPath", Bn;
    }
    return nr.prototype.getDefaultShape = function() {
      return new BoxPathShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Bn.points, Dn = 0;
      for (Cn.moveTo(In[Dn][0], In[Dn][1]), Dn++; Dn < 4; Dn++)
        Cn.lineTo(In[Dn][0], In[Dn][1]);
      for (Cn.closePath(); Dn < In.length; Dn++)
        Cn.moveTo(In[Dn][0], In[Dn][1]), Dn++, Cn.lineTo(In[Dn][0], In[Dn][1]);
    }, nr;
  }(Path$1)
);
function createNormalBox$1(_n, nr, Cn, Bn, In) {
  var Dn = _n.ends, Ln = new BoxPath({
    shape: {
      points: In ? transInit$1(Dn, Bn, _n) : Dn
    }
  });
  return updateNormalBoxData(_n, Ln, nr, Cn, In), Ln;
}
function updateNormalBoxData(_n, nr, Cn, Bn, In) {
  var Dn = Cn.hostModel, Ln = graphic$1[In ? "initProps" : "updateProps"];
  Ln(nr, {
    shape: {
      points: _n.ends
    }
  }, Dn, Bn), nr.useStyle(Cn.getItemVisual(Bn, "style")), nr.style.strokeNoScale = !0, nr.z2 = 100;
  var $n = Cn.getItemModel(Bn), Nn = $n.getModel("emphasis");
  setStatesStylesFromModel(nr, $n), toggleHoverEmphasis(nr, Nn.get("focus"), Nn.get("blurScope"), Nn.get("disabled"));
}
function transInit$1(_n, nr, Cn) {
  return map$1(_n, function(Bn) {
    return Bn = Bn.slice(), Bn[nr] = Cn.initBaseline, Bn;
  });
}
const BoxplotView$1 = BoxplotView;
var each$9 = each$f;
function boxplotLayout(_n) {
  var nr = groupSeriesByAxis(_n);
  each$9(nr, function(Cn) {
    var Bn = Cn.seriesModels;
    Bn.length && (calculateBase(Cn), each$9(Bn, function(In, Dn) {
      layoutSingleSeries(In, Cn.boxOffsetList[Dn], Cn.boxWidthList[Dn]);
    }));
  });
}
function groupSeriesByAxis(_n) {
  var nr = [], Cn = [];
  return _n.eachSeriesByType("boxplot", function(Bn) {
    var In = Bn.getBaseAxis(), Dn = indexOf(Cn, In);
    Dn < 0 && (Dn = Cn.length, Cn[Dn] = In, nr[Dn] = {
      axis: In,
      seriesModels: []
    }), nr[Dn].seriesModels.push(Bn);
  }), nr;
}
function calculateBase(_n) {
  var nr = _n.axis, Cn = _n.seriesModels, Bn = Cn.length, In = _n.boxWidthList = [], Dn = _n.boxOffsetList = [], Ln = [], $n;
  if (nr.type === "category")
    $n = nr.getBandWidth();
  else {
    var Nn = 0;
    each$9(Cn, function(zn) {
      Nn = Math.max(Nn, zn.getData().count());
    });
    var Rn = nr.getExtent();
    $n = Math.abs(Rn[1] - Rn[0]) / Nn;
  }
  each$9(Cn, function(zn) {
    var Gn = zn.get("boxWidth");
    isArray$4(Gn) || (Gn = [Gn, Gn]), Ln.push([parsePercent(Gn[0], $n) || 0, parsePercent(Gn[1], $n) || 0]);
  });
  var Fn = $n * 0.8 - 2, Pn = Fn / Bn * 0.3, Un = (Fn - Pn * (Bn - 1)) / Bn, Hn = Un / 2 - Fn / 2;
  each$9(Cn, function(zn, Gn) {
    Dn.push(Hn), Hn += Pn + Un, In.push(Math.min(Math.max(Un, Ln[Gn][0]), Ln[Gn][1]));
  });
}
function layoutSingleSeries(_n, nr, Cn) {
  var Bn = _n.coordinateSystem, In = _n.getData(), Dn = Cn / 2, Ln = _n.get("layout") === "horizontal" ? 0 : 1, $n = 1 - Ln, Nn = ["x", "y"], Rn = In.mapDimension(Nn[Ln]), Fn = In.mapDimensionsAll(Nn[$n]);
  if (Rn == null || Fn.length < 5)
    return;
  for (var Pn = 0; Pn < In.count(); Pn++) {
    var Un = In.get(Rn, Pn), Hn = ea(Un, Fn[2], Pn), zn = ea(Un, Fn[0], Pn), Gn = ea(Un, Fn[1], Pn), Yn = ea(Un, Fn[3], Pn), Wn = ea(Un, Fn[4], Pn), Xn = [];
    ta(Xn, Gn, !1), ta(Xn, Yn, !0), Xn.push(zn, Gn, Wn, Yn), na(Xn, zn), na(Xn, Wn), na(Xn, Hn), In.setItemLayout(Pn, {
      initBaseline: Hn[$n],
      ends: Xn
    });
  }
  function ea(ra, aa, ia) {
    var Aa = In.get(aa, ia), sa = [];
    sa[Ln] = ra, sa[$n] = Aa;
    var oa;
    return isNaN(ra) || isNaN(Aa) ? oa = [NaN, NaN] : (oa = Bn.dataToPoint(sa), oa[Ln] += nr), oa;
  }
  function ta(ra, aa, ia) {
    var Aa = aa.slice(), sa = aa.slice();
    Aa[Ln] += Dn, sa[Ln] -= Dn, ia ? ra.push(Aa, sa) : ra.push(sa, Aa);
  }
  function na(ra, aa) {
    var ia = aa.slice(), Aa = aa.slice();
    ia[Ln] -= Dn, Aa[Ln] += Dn, ra.push(ia, Aa);
  }
}
function prepareBoxplotData(_n, nr) {
  nr = nr || {};
  for (var Cn = [], Bn = [], In = nr.boundIQR, Dn = In === "none" || In === 0, Ln = 0; Ln < _n.length; Ln++) {
    var $n = asc$2(_n[Ln].slice()), Nn = quantile($n, 0.25), Rn = quantile($n, 0.5), Fn = quantile($n, 0.75), Pn = $n[0], Un = $n[$n.length - 1], Hn = (In ?? 1.5) * (Fn - Nn), zn = Dn ? Pn : Math.max(Pn, Nn - Hn), Gn = Dn ? Un : Math.min(Un, Fn + Hn), Yn = nr.itemNameFormatter, Wn = isFunction$1(Yn) ? Yn({
      value: Ln
    }) : isString$1(Yn) ? Yn.replace("{value}", Ln + "") : Ln + "";
    Cn.push([Wn, zn, Nn, Rn, Fn, Gn]);
    for (var Xn = 0; Xn < $n.length; Xn++) {
      var ea = $n[Xn];
      if (ea < zn || ea > Gn) {
        var ta = [Wn, ea];
        Bn.push(ta);
      }
    }
  }
  return {
    boxData: Cn,
    outliers: Bn
  };
}
var boxplotTransform = {
  type: "echarts:boxplot",
  transform: function _n(nr) {
    var Cn = nr.upstream;
    if (Cn.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
      var Bn = "";
      process.env.NODE_ENV !== "production" && (Bn = makePrintable("source data is not applicable for this boxplot transform. Expect number[][].")), throwError(Bn);
    }
    var In = prepareBoxplotData(Cn.getRawData(), nr.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: In.boxData
    }, {
      data: In.outliers
    }];
  }
};
function install$z(_n) {
  _n.registerSeriesModel(BoxplotSeriesModel$1), _n.registerChartView(BoxplotView$1), _n.registerLayout(boxplotLayout), _n.registerTransform(boxplotTransform);
}
var positiveBorderColorQuery = ["itemStyle", "borderColor"], negativeBorderColorQuery = ["itemStyle", "borderColor0"], dojiBorderColorQuery = ["itemStyle", "borderColorDoji"], positiveColorQuery = ["itemStyle", "color"], negativeColorQuery = ["itemStyle", "color0"];
function getColor(_n, nr) {
  return nr.get(_n > 0 ? positiveColorQuery : negativeColorQuery);
}
function getBorderColor(_n, nr) {
  return nr.get(_n === 0 ? dojiBorderColorQuery : _n > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
}
var candlestickVisual = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  // For legend.
  performRawSeries: !0,
  reset: function(_n, nr) {
    if (!nr.isSeriesFiltered(_n)) {
      var Cn = _n.pipelineContext.large;
      return !Cn && {
        progress: function(Bn, In) {
          for (var Dn; (Dn = Bn.next()) != null; ) {
            var Ln = In.getItemModel(Dn), $n = In.getItemLayout(Dn).sign, Nn = Ln.getItemStyle();
            Nn.fill = getColor($n, Ln), Nn.stroke = getBorderColor($n, Ln) || Nn.fill;
            var Rn = In.ensureUniqueItemVisual(Dn, "style");
            extend(Rn, Nn);
          }
        }
      };
    }
  }
};
const candlestickVisual$1 = candlestickVisual;
var SKIP_PROPS = ["color", "borderColor"], CandlestickView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(Cn), this._isLargeDraw ? this._renderLarge(Cn) : this._renderNormal(Cn);
    }, nr.prototype.incrementalPrepareRender = function(Cn, Bn, In) {
      this._clear(), this._updateDrawMode(Cn);
    }, nr.prototype.incrementalRender = function(Cn, Bn, In, Dn) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(Cn, Bn) : this._incrementalRenderNormal(Cn, Bn);
    }, nr.prototype.eachRendered = function(Cn) {
      traverseElements(this._progressiveEls || this.group, Cn);
    }, nr.prototype._updateDrawMode = function(Cn) {
      var Bn = Cn.pipelineContext.large;
      (this._isLargeDraw == null || Bn !== this._isLargeDraw) && (this._isLargeDraw = Bn, this._clear());
    }, nr.prototype._renderNormal = function(Cn) {
      var Bn = Cn.getData(), In = this._data, Dn = this.group, Ln = Bn.getLayout("isSimpleBox"), $n = Cn.get("clip", !0), Nn = Cn.coordinateSystem, Rn = Nn.getArea && Nn.getArea();
      this._data || Dn.removeAll(), Bn.diff(In).add(function(Fn) {
        if (Bn.hasValue(Fn)) {
          var Pn = Bn.getItemLayout(Fn);
          if ($n && isNormalBoxClipped(Rn, Pn))
            return;
          var Un = createNormalBox(Pn, Fn, !0);
          initProps(Un, {
            shape: {
              points: Pn.ends
            }
          }, Cn, Fn), setBoxCommon(Un, Bn, Fn, Ln), Dn.add(Un), Bn.setItemGraphicEl(Fn, Un);
        }
      }).update(function(Fn, Pn) {
        var Un = In.getItemGraphicEl(Pn);
        if (!Bn.hasValue(Fn)) {
          Dn.remove(Un);
          return;
        }
        var Hn = Bn.getItemLayout(Fn);
        if ($n && isNormalBoxClipped(Rn, Hn)) {
          Dn.remove(Un);
          return;
        }
        Un ? (updateProps$1(Un, {
          shape: {
            points: Hn.ends
          }
        }, Cn, Fn), saveOldStyle(Un)) : Un = createNormalBox(Hn), setBoxCommon(Un, Bn, Fn, Ln), Dn.add(Un), Bn.setItemGraphicEl(Fn, Un);
      }).remove(function(Fn) {
        var Pn = In.getItemGraphicEl(Fn);
        Pn && Dn.remove(Pn);
      }).execute(), this._data = Bn;
    }, nr.prototype._renderLarge = function(Cn) {
      this._clear(), createLarge(Cn, this.group);
      var Bn = Cn.get("clip", !0) ? createClipPath(Cn.coordinateSystem, !1, Cn) : null;
      Bn ? this.group.setClipPath(Bn) : this.group.removeClipPath();
    }, nr.prototype._incrementalRenderNormal = function(Cn, Bn) {
      for (var In = Bn.getData(), Dn = In.getLayout("isSimpleBox"), Ln; (Ln = Cn.next()) != null; ) {
        var $n = In.getItemLayout(Ln), Nn = createNormalBox($n);
        setBoxCommon(Nn, In, Ln, Dn), Nn.incremental = !0, this.group.add(Nn), this._progressiveEls.push(Nn);
      }
    }, nr.prototype._incrementalRenderLarge = function(Cn, Bn) {
      createLarge(Bn, this.group, this._progressiveEls, !0);
    }, nr.prototype.remove = function(Cn) {
      this._clear();
    }, nr.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, nr.type = "candlestick", nr;
  }(ChartView$1)
), NormalBoxPathShape = (
  /** @class */
  function() {
    function _n() {
    }
    return _n;
  }()
), NormalBoxPath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "normalCandlestickBox", Bn;
    }
    return nr.prototype.getDefaultShape = function() {
      return new NormalBoxPathShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Bn.points;
      this.__simpleBox ? (Cn.moveTo(In[4][0], In[4][1]), Cn.lineTo(In[6][0], In[6][1])) : (Cn.moveTo(In[0][0], In[0][1]), Cn.lineTo(In[1][0], In[1][1]), Cn.lineTo(In[2][0], In[2][1]), Cn.lineTo(In[3][0], In[3][1]), Cn.closePath(), Cn.moveTo(In[4][0], In[4][1]), Cn.lineTo(In[5][0], In[5][1]), Cn.moveTo(In[6][0], In[6][1]), Cn.lineTo(In[7][0], In[7][1]));
    }, nr;
  }(Path$1)
);
function createNormalBox(_n, nr, Cn) {
  var Bn = _n.ends;
  return new NormalBoxPath({
    shape: {
      points: Cn ? transInit(Bn, _n) : Bn
    },
    z2: 100
  });
}
function isNormalBoxClipped(_n, nr) {
  for (var Cn = !0, Bn = 0; Bn < nr.ends.length; Bn++)
    if (_n.contain(nr.ends[Bn][0], nr.ends[Bn][1])) {
      Cn = !1;
      break;
    }
  return Cn;
}
function setBoxCommon(_n, nr, Cn, Bn) {
  var In = nr.getItemModel(Cn);
  _n.useStyle(nr.getItemVisual(Cn, "style")), _n.style.strokeNoScale = !0, _n.__simpleBox = Bn, setStatesStylesFromModel(_n, In);
  var Dn = nr.getItemLayout(Cn).sign;
  each$f(_n.states, function($n, Nn) {
    var Rn = In.getModel(Nn), Fn = getColor(Dn, Rn), Pn = getBorderColor(Dn, Rn) || Fn, Un = $n.style || ($n.style = {});
    Fn && (Un.fill = Fn), Pn && (Un.stroke = Pn);
  });
  var Ln = In.getModel("emphasis");
  toggleHoverEmphasis(_n, Ln.get("focus"), Ln.get("blurScope"), Ln.get("disabled"));
}
function transInit(_n, nr) {
  return map$1(_n, function(Cn) {
    return Cn = Cn.slice(), Cn[1] = nr.initBaseline, Cn;
  });
}
var LargeBoxPathShape = (
  /** @class */
  function() {
    function _n() {
    }
    return _n;
  }()
), LargeBoxPath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn.type = "largeCandlestickBox", Bn;
    }
    return nr.prototype.getDefaultShape = function() {
      return new LargeBoxPathShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      for (var In = Bn.points, Dn = 0; Dn < In.length; )
        if (this.__sign === In[Dn++]) {
          var Ln = In[Dn++];
          Cn.moveTo(Ln, In[Dn++]), Cn.lineTo(Ln, In[Dn++]);
        } else
          Dn += 3;
    }, nr;
  }(Path$1)
);
function createLarge(_n, nr, Cn, Bn) {
  var In = _n.getData(), Dn = In.getLayout("largePoints"), Ln = new LargeBoxPath({
    shape: {
      points: Dn
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  nr.add(Ln);
  var $n = new LargeBoxPath({
    shape: {
      points: Dn
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  nr.add($n);
  var Nn = new LargeBoxPath({
    shape: {
      points: Dn
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  nr.add(Nn), setLargeStyle(1, Ln, _n), setLargeStyle(-1, $n, _n), setLargeStyle(0, Nn, _n), Bn && (Ln.incremental = !0, $n.incremental = !0), Cn && Cn.push(Ln, $n);
}
function setLargeStyle(_n, nr, Cn, Bn) {
  var In = getBorderColor(_n, Cn) || getColor(_n, Cn), Dn = Cn.getModel("itemStyle").getItemStyle(SKIP_PROPS);
  nr.useStyle(Dn), nr.style.fill = null, nr.style.stroke = In;
}
const CandlestickView$1 = CandlestickView;
var CandlestickSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], Cn;
    }
    return nr.prototype.getShadowDim = function() {
      return "open";
    }, nr.prototype.brushSelector = function(Cn, Bn, In) {
      var Dn = Bn.getItemLayout(Cn);
      return Dn && In.rect(Dn.brushRect);
    }, nr.type = "series.candlestick", nr.dependencies = ["xAxis", "yAxis", "grid"], nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, nr;
  }(SeriesModel$1)
);
mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, !0);
const CandlestickSeriesModel$1 = CandlestickSeriesModel;
function candlestickPreprocessor(_n) {
  !_n || !isArray$4(_n.series) || each$f(_n.series, function(nr) {
    isObject$6(nr) && nr.type === "k" && (nr.type = "candlestick");
  });
}
var candlestickLayout = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  reset: function(_n) {
    var nr = _n.coordinateSystem, Cn = _n.getData(), Bn = calculateCandleWidth(_n, Cn), In = 0, Dn = 1, Ln = ["x", "y"], $n = Cn.getDimensionIndex(Cn.mapDimension(Ln[In])), Nn = map$1(Cn.mapDimensionsAll(Ln[Dn]), Cn.getDimensionIndex, Cn), Rn = Nn[0], Fn = Nn[1], Pn = Nn[2], Un = Nn[3];
    if (Cn.setLayout({
      candleWidth: Bn,
      // The value is experimented visually.
      isSimpleBox: Bn <= 1.3
    }), $n < 0 || Nn.length < 4)
      return;
    return {
      progress: _n.pipelineContext.large ? zn : Hn
    };
    function Hn(Gn, Yn) {
      for (var Wn, Xn = Yn.getStore(); (Wn = Gn.next()) != null; ) {
        var ea = Xn.get($n, Wn), ta = Xn.get(Rn, Wn), na = Xn.get(Fn, Wn), ra = Xn.get(Pn, Wn), aa = Xn.get(Un, Wn), ia = Math.min(ta, na), Aa = Math.max(ta, na), sa = pa(ia, ea), oa = pa(Aa, ea), la = pa(ra, ea), ua = pa(aa, ea), ca = [];
        ya(ca, oa, 0), ya(ca, sa, 1), ca.push(Ca(ua), Ca(oa), Ca(la), Ca(sa));
        var fa = Yn.getItemModel(Wn), ha = !!fa.get(["itemStyle", "borderColorDoji"]);
        Yn.setItemLayout(Wn, {
          sign: getSign(Xn, Wn, ta, na, Fn, ha),
          initBaseline: ta > na ? oa[Dn] : sa[Dn],
          ends: ca,
          brushRect: da(ra, aa, ea)
        });
      }
      function pa(ma, va) {
        var ga = [];
        return ga[In] = va, ga[Dn] = ma, isNaN(va) || isNaN(ma) ? [NaN, NaN] : nr.dataToPoint(ga);
      }
      function ya(ma, va, ga) {
        var xa = va.slice(), wa = va.slice();
        xa[In] = subPixelOptimize(xa[In] + Bn / 2, 1, !1), wa[In] = subPixelOptimize(wa[In] - Bn / 2, 1, !0), ga ? ma.push(xa, wa) : ma.push(wa, xa);
      }
      function da(ma, va, ga) {
        var xa = pa(ma, ga), wa = pa(va, ga);
        return xa[In] -= Bn / 2, wa[In] -= Bn / 2, {
          x: xa[0],
          y: xa[1],
          width: Bn,
          height: wa[1] - xa[1]
        };
      }
      function Ca(ma) {
        return ma[In] = subPixelOptimize(ma[In], 1), ma;
      }
    }
    function zn(Gn, Yn) {
      for (var Wn = createFloat32Array(Gn.count * 4), Xn = 0, ea, ta = [], na = [], ra, aa = Yn.getStore(), ia = !!_n.get(["itemStyle", "borderColorDoji"]); (ra = Gn.next()) != null; ) {
        var Aa = aa.get($n, ra), sa = aa.get(Rn, ra), oa = aa.get(Fn, ra), la = aa.get(Pn, ra), ua = aa.get(Un, ra);
        if (isNaN(Aa) || isNaN(la) || isNaN(ua)) {
          Wn[Xn++] = NaN, Xn += 3;
          continue;
        }
        Wn[Xn++] = getSign(aa, ra, sa, oa, Fn, ia), ta[In] = Aa, ta[Dn] = la, ea = nr.dataToPoint(ta, null, na), Wn[Xn++] = ea ? ea[0] : NaN, Wn[Xn++] = ea ? ea[1] : NaN, ta[Dn] = ua, ea = nr.dataToPoint(ta, null, na), Wn[Xn++] = ea ? ea[1] : NaN;
      }
      Yn.setLayout("largePoints", Wn);
    }
  }
};
function getSign(_n, nr, Cn, Bn, In, Dn) {
  var Ln;
  return Cn > Bn ? Ln = -1 : Cn < Bn ? Ln = 1 : Ln = Dn ? 0 : nr > 0 ? _n.get(In, nr - 1) <= Bn ? 1 : -1 : 1, Ln;
}
function calculateCandleWidth(_n, nr) {
  var Cn = _n.getBaseAxis(), Bn, In = Cn.type === "category" ? Cn.getBandWidth() : (Bn = Cn.getExtent(), Math.abs(Bn[1] - Bn[0]) / nr.count()), Dn = parsePercent(retrieve2(_n.get("barMaxWidth"), In), In), Ln = parsePercent(retrieve2(_n.get("barMinWidth"), 1), In), $n = _n.get("barWidth");
  return $n != null ? parsePercent($n, In) : Math.max(Math.min(In / 2, Dn), Ln);
}
const candlestickLayout$1 = candlestickLayout;
function install$y(_n) {
  _n.registerChartView(CandlestickView$1), _n.registerSeriesModel(CandlestickSeriesModel$1), _n.registerPreprocessor(candlestickPreprocessor), _n.registerVisual(candlestickVisual$1), _n.registerLayout(candlestickLayout$1);
}
function updateRipplePath(_n, nr) {
  var Cn = nr.rippleEffectColor || nr.color;
  _n.eachChild(function(Bn) {
    Bn.attr({
      z: nr.z,
      zlevel: nr.zlevel,
      style: {
        stroke: nr.brushType === "stroke" ? Cn : null,
        fill: nr.brushType === "fill" ? Cn : null
      }
    });
  });
}
var EffectSymbol = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn) {
      var In = _n.call(this) || this, Dn = new SymbolClz(Cn, Bn), Ln = new Group$4();
      return In.add(Dn), In.add(Ln), In.updateData(Cn, Bn), In;
    }
    return nr.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, nr.prototype.startEffectAnimation = function(Cn) {
      for (var Bn = Cn.symbolType, In = Cn.color, Dn = Cn.rippleNumber, Ln = this.childAt(1), $n = 0; $n < Dn; $n++) {
        var Nn = createSymbol$1(Bn, -1, -1, 2, 2, In);
        Nn.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var Rn = -$n / Dn * Cn.period + Cn.effectOffset;
        Nn.animate("", !0).when(Cn.period, {
          scaleX: Cn.rippleScale / 2,
          scaleY: Cn.rippleScale / 2
        }).delay(Rn).start(), Nn.animateStyle(!0).when(Cn.period, {
          opacity: 0
        }).delay(Rn).start(), Ln.add(Nn);
      }
      updateRipplePath(Ln, Cn);
    }, nr.prototype.updateEffectAnimation = function(Cn) {
      for (var Bn = this._effectCfg, In = this.childAt(1), Dn = ["symbolType", "period", "rippleScale", "rippleNumber"], Ln = 0; Ln < Dn.length; Ln++) {
        var $n = Dn[Ln];
        if (Bn[$n] !== Cn[$n]) {
          this.stopEffectAnimation(), this.startEffectAnimation(Cn);
          return;
        }
      }
      updateRipplePath(In, Cn);
    }, nr.prototype.highlight = function() {
      enterEmphasis(this);
    }, nr.prototype.downplay = function() {
      leaveEmphasis(this);
    }, nr.prototype.getSymbolType = function() {
      var Cn = this.childAt(0);
      return Cn && Cn.getSymbolType();
    }, nr.prototype.updateData = function(Cn, Bn) {
      var In = this, Dn = Cn.hostModel;
      this.childAt(0).updateData(Cn, Bn);
      var Ln = this.childAt(1), $n = Cn.getItemModel(Bn), Nn = Cn.getItemVisual(Bn, "symbol"), Rn = normalizeSymbolSize(Cn.getItemVisual(Bn, "symbolSize")), Fn = Cn.getItemVisual(Bn, "style"), Pn = Fn && Fn.fill, Un = $n.getModel("emphasis");
      Ln.setScale(Rn), Ln.traverse(function(Yn) {
        Yn.setStyle("fill", Pn);
      });
      var Hn = normalizeSymbolOffset(Cn.getItemVisual(Bn, "symbolOffset"), Rn);
      Hn && (Ln.x = Hn[0], Ln.y = Hn[1]);
      var zn = Cn.getItemVisual(Bn, "symbolRotate");
      Ln.rotation = (zn || 0) * Math.PI / 180 || 0;
      var Gn = {};
      Gn.showEffectOn = Dn.get("showEffectOn"), Gn.rippleScale = $n.get(["rippleEffect", "scale"]), Gn.brushType = $n.get(["rippleEffect", "brushType"]), Gn.period = $n.get(["rippleEffect", "period"]) * 1e3, Gn.effectOffset = Bn / Cn.count(), Gn.z = Dn.getShallow("z") || 0, Gn.zlevel = Dn.getShallow("zlevel") || 0, Gn.symbolType = Nn, Gn.color = Pn, Gn.rippleEffectColor = $n.get(["rippleEffect", "color"]), Gn.rippleNumber = $n.get(["rippleEffect", "number"]), Gn.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(Gn) : this.startEffectAnimation(Gn), this._effectCfg = Gn) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(Yn) {
        Yn === "emphasis" ? Gn.showEffectOn !== "render" && In.startEffectAnimation(Gn) : Yn === "normal" && Gn.showEffectOn !== "render" && In.stopEffectAnimation();
      }), this._effectCfg = Gn, toggleHoverEmphasis(this, Un.get("focus"), Un.get("blurScope"), Un.get("disabled"));
    }, nr.prototype.fadeOut = function(Cn) {
      Cn && Cn();
    }, nr;
  }(Group$4)
);
const EffectSymbol$1 = EffectSymbol;
var EffectScatterView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function() {
      this._symbolDraw = new SymbolDraw$1(EffectSymbol$1);
    }, nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = this._symbolDraw;
      Ln.updateData(Dn, {
        clipShape: this._getClipShape(Cn)
      }), this.group.add(Ln.group);
    }, nr.prototype._getClipShape = function(Cn) {
      var Bn = Cn.coordinateSystem, In = Bn && Bn.getArea && Bn.getArea();
      return Cn.get("clip", !0) ? In : null;
    }, nr.prototype.updateTransform = function(Cn, Bn, In) {
      var Dn = Cn.getData();
      this.group.dirty();
      var Ln = pointsLayout("").reset(Cn, Bn, In);
      Ln.progress && Ln.progress({
        start: 0,
        end: Dn.count(),
        count: Dn.count()
      }, Dn), this._symbolDraw.updateLayout();
    }, nr.prototype._updateGroupTransform = function(Cn) {
      var Bn = Cn.coordinateSystem;
      Bn && Bn.getRoamTransform && (this.group.transform = clone$2(Bn.getRoamTransform()), this.group.decomposeTransform());
    }, nr.prototype.remove = function(Cn, Bn) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, nr.type = "effectScatter", nr;
  }(ChartView$1)
);
const EffectScatterView$1 = EffectScatterView;
var EffectScatterSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.hasSymbolVisual = !0, Cn;
    }
    return nr.prototype.getInitialData = function(Cn, Bn) {
      return createSeriesData(null, this, {
        useEncodeDefaulter: !0
      });
    }, nr.prototype.brushSelector = function(Cn, Bn, In) {
      return In.point(Bn.getItemLayout(Cn));
    }, nr.type = "series.effectScatter", nr.dependencies = ["grid", "polar"], nr.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 图形类型
      symbolSize: 10
      // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
      // symbolRotate: null,  // 图形旋转控制
      // itemStyle: {
      //     opacity: 1
      // }
    }, nr;
  }(SeriesModel$1)
);
const EffectScatterSeriesModel$1 = EffectScatterSeriesModel;
function install$x(_n) {
  _n.registerChartView(EffectScatterView$1), _n.registerSeriesModel(EffectScatterSeriesModel$1), _n.registerLayout(pointsLayout("effectScatter"));
}
var EffectLine = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In) {
      var Dn = _n.call(this) || this;
      return Dn.add(Dn.createLine(Cn, Bn, In)), Dn._updateEffectSymbol(Cn, Bn), Dn;
    }
    return nr.prototype.createLine = function(Cn, Bn, In) {
      return new Line$1(Cn, Bn, In);
    }, nr.prototype._updateEffectSymbol = function(Cn, Bn) {
      var In = Cn.getItemModel(Bn), Dn = In.getModel("effect"), Ln = Dn.get("symbolSize"), $n = Dn.get("symbol");
      isArray$4(Ln) || (Ln = [Ln, Ln]);
      var Nn = Cn.getItemVisual(Bn, "style"), Rn = Dn.get("color") || Nn && Nn.stroke, Fn = this.childAt(1);
      this._symbolType !== $n && (this.remove(Fn), Fn = createSymbol$1($n, -0.5, -0.5, 1, 1, Rn), Fn.z2 = 100, Fn.culling = !0, this.add(Fn)), Fn && (Fn.setStyle("shadowColor", Rn), Fn.setStyle(Dn.getItemStyle(["color"])), Fn.scaleX = Ln[0], Fn.scaleY = Ln[1], Fn.setColor(Rn), this._symbolType = $n, this._symbolScale = Ln, this._updateEffectAnimation(Cn, Dn, Bn));
    }, nr.prototype._updateEffectAnimation = function(Cn, Bn, In) {
      var Dn = this.childAt(1);
      if (Dn) {
        var Ln = Cn.getItemLayout(In), $n = Bn.get("period") * 1e3, Nn = Bn.get("loop"), Rn = Bn.get("roundTrip"), Fn = Bn.get("constantSpeed"), Pn = retrieve(Bn.get("delay"), function(Hn) {
          return Hn / Cn.count() * $n / 3;
        });
        if (Dn.ignore = !0, this._updateAnimationPoints(Dn, Ln), Fn > 0 && ($n = this._getLineLength(Dn) / Fn * 1e3), $n !== this._period || Nn !== this._loop || Rn !== this._roundTrip) {
          Dn.stopAnimation();
          var Un = void 0;
          isFunction$1(Pn) ? Un = Pn(In) : Un = Pn, Dn.__t > 0 && (Un = -$n * Dn.__t), this._animateSymbol(Dn, $n, Un, Nn, Rn);
        }
        this._period = $n, this._loop = Nn, this._roundTrip = Rn;
      }
    }, nr.prototype._animateSymbol = function(Cn, Bn, In, Dn, Ln) {
      if (Bn > 0) {
        Cn.__t = 0;
        var $n = this, Nn = Cn.animate("", Dn).when(Ln ? Bn * 2 : Bn, {
          __t: Ln ? 2 : 1
        }).delay(In).during(function() {
          $n._updateSymbolPosition(Cn);
        });
        Dn || Nn.done(function() {
          $n.remove(Cn);
        }), Nn.start();
      }
    }, nr.prototype._getLineLength = function(Cn) {
      return dist$1(Cn.__p1, Cn.__cp1) + dist$1(Cn.__cp1, Cn.__p2);
    }, nr.prototype._updateAnimationPoints = function(Cn, Bn) {
      Cn.__p1 = Bn[0], Cn.__p2 = Bn[1], Cn.__cp1 = Bn[2] || [(Bn[0][0] + Bn[1][0]) / 2, (Bn[0][1] + Bn[1][1]) / 2];
    }, nr.prototype.updateData = function(Cn, Bn, In) {
      this.childAt(0).updateData(Cn, Bn, In), this._updateEffectSymbol(Cn, Bn);
    }, nr.prototype._updateSymbolPosition = function(Cn) {
      var Bn = Cn.__p1, In = Cn.__p2, Dn = Cn.__cp1, Ln = Cn.__t < 1 ? Cn.__t : 2 - Cn.__t, $n = [Cn.x, Cn.y], Nn = $n.slice(), Rn = quadraticAt$1, Fn = quadraticDerivativeAt;
      $n[0] = Rn(Bn[0], Dn[0], In[0], Ln), $n[1] = Rn(Bn[1], Dn[1], In[1], Ln);
      var Pn = Cn.__t < 1 ? Fn(Bn[0], Dn[0], In[0], Ln) : Fn(In[0], Dn[0], Bn[0], 1 - Ln), Un = Cn.__t < 1 ? Fn(Bn[1], Dn[1], In[1], Ln) : Fn(In[1], Dn[1], Bn[1], 1 - Ln);
      Cn.rotation = -Math.atan2(Un, Pn) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (Cn.__lastT !== void 0 && Cn.__lastT < Cn.__t ? (Cn.scaleY = dist$1(Nn, $n) * 1.05, Ln === 1 && ($n[0] = Nn[0] + ($n[0] - Nn[0]) / 2, $n[1] = Nn[1] + ($n[1] - Nn[1]) / 2)) : Cn.__lastT === 1 ? Cn.scaleY = 2 * dist$1(Bn, $n) : Cn.scaleY = this._symbolScale[1]), Cn.__lastT = Cn.__t, Cn.ignore = !1, Cn.x = $n[0], Cn.y = $n[1];
    }, nr.prototype.updateLayout = function(Cn, Bn) {
      this.childAt(0).updateLayout(Cn, Bn);
      var In = Cn.getItemModel(Bn).getModel("effect");
      this._updateEffectAnimation(Cn, In, Bn);
    }, nr;
  }(Group$4)
);
const EffectLine$1 = EffectLine;
var Polyline = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In) {
      var Dn = _n.call(this) || this;
      return Dn._createPolyline(Cn, Bn, In), Dn;
    }
    return nr.prototype._createPolyline = function(Cn, Bn, In) {
      var Dn = Cn.getItemLayout(Bn), Ln = new Polyline$3({
        shape: {
          points: Dn
        }
      });
      this.add(Ln), this._updateCommonStl(Cn, Bn, In);
    }, nr.prototype.updateData = function(Cn, Bn, In) {
      var Dn = Cn.hostModel, Ln = this.childAt(0), $n = {
        shape: {
          points: Cn.getItemLayout(Bn)
        }
      };
      updateProps$1(Ln, $n, Dn, Bn), this._updateCommonStl(Cn, Bn, In);
    }, nr.prototype._updateCommonStl = function(Cn, Bn, In) {
      var Dn = this.childAt(0), Ln = Cn.getItemModel(Bn), $n = In && In.emphasisLineStyle, Nn = In && In.focus, Rn = In && In.blurScope, Fn = In && In.emphasisDisabled;
      if (!In || Cn.hasItemOption) {
        var Pn = Ln.getModel("emphasis");
        $n = Pn.getModel("lineStyle").getLineStyle(), Fn = Pn.get("disabled"), Nn = Pn.get("focus"), Rn = Pn.get("blurScope");
      }
      Dn.useStyle(Cn.getItemVisual(Bn, "style")), Dn.style.fill = null, Dn.style.strokeNoScale = !0;
      var Un = Dn.ensureState("emphasis");
      Un.style = $n, toggleHoverEmphasis(this, Nn, Rn, Fn);
    }, nr.prototype.updateLayout = function(Cn, Bn) {
      var In = this.childAt(0);
      In.setShape("points", Cn.getItemLayout(Bn));
    }, nr;
  }(Group$4)
);
const Polyline$1 = Polyline;
var EffectPolyline = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn._lastFrame = 0, Cn._lastFramePercent = 0, Cn;
    }
    return nr.prototype.createLine = function(Cn, Bn, In) {
      return new Polyline$1(Cn, Bn, In);
    }, nr.prototype._updateAnimationPoints = function(Cn, Bn) {
      this._points = Bn;
      for (var In = [0], Dn = 0, Ln = 1; Ln < Bn.length; Ln++) {
        var $n = Bn[Ln - 1], Nn = Bn[Ln];
        Dn += dist$1($n, Nn), In.push(Dn);
      }
      if (Dn === 0) {
        this._length = 0;
        return;
      }
      for (var Ln = 0; Ln < In.length; Ln++)
        In[Ln] /= Dn;
      this._offsets = In, this._length = Dn;
    }, nr.prototype._getLineLength = function() {
      return this._length;
    }, nr.prototype._updateSymbolPosition = function(Cn) {
      var Bn = Cn.__t < 1 ? Cn.__t : 2 - Cn.__t, In = this._points, Dn = this._offsets, Ln = In.length;
      if (Dn) {
        var $n = this._lastFrame, Nn;
        if (Bn < this._lastFramePercent) {
          var Rn = Math.min($n + 1, Ln - 1);
          for (Nn = Rn; Nn >= 0 && !(Dn[Nn] <= Bn); Nn--)
            ;
          Nn = Math.min(Nn, Ln - 2);
        } else {
          for (Nn = $n; Nn < Ln && !(Dn[Nn] > Bn); Nn++)
            ;
          Nn = Math.min(Nn - 1, Ln - 2);
        }
        var Fn = (Bn - Dn[Nn]) / (Dn[Nn + 1] - Dn[Nn]), Pn = In[Nn], Un = In[Nn + 1];
        Cn.x = Pn[0] * (1 - Fn) + Fn * Un[0], Cn.y = Pn[1] * (1 - Fn) + Fn * Un[1];
        var Hn = Cn.__t < 1 ? Un[0] - Pn[0] : Pn[0] - Un[0], zn = Cn.__t < 1 ? Un[1] - Pn[1] : Pn[1] - Un[1];
        Cn.rotation = -Math.atan2(zn, Hn) - Math.PI / 2, this._lastFrame = Nn, this._lastFramePercent = Bn, Cn.ignore = !1;
      }
    }, nr;
  }(EffectLine$1)
);
const EffectPolyline$1 = EffectPolyline;
var LargeLinesPathShape = (
  /** @class */
  function() {
    function _n() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return _n;
  }()
), LargeLinesPath = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn) {
      var Bn = _n.call(this, Cn) || this;
      return Bn._off = 0, Bn.hoverDataIdx = -1, Bn;
    }
    return nr.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, nr.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, nr.prototype.getDefaultShape = function() {
      return new LargeLinesPathShape();
    }, nr.prototype.buildPath = function(Cn, Bn) {
      var In = Bn.segs, Dn = Bn.curveness, Ln;
      if (Bn.polyline)
        for (Ln = this._off; Ln < In.length; ) {
          var $n = In[Ln++];
          if ($n > 0) {
            Cn.moveTo(In[Ln++], In[Ln++]);
            for (var Nn = 1; Nn < $n; Nn++)
              Cn.lineTo(In[Ln++], In[Ln++]);
          }
        }
      else
        for (Ln = this._off; Ln < In.length; ) {
          var Rn = In[Ln++], Fn = In[Ln++], Pn = In[Ln++], Un = In[Ln++];
          if (Cn.moveTo(Rn, Fn), Dn > 0) {
            var Hn = (Rn + Pn) / 2 - (Fn - Un) * Dn, zn = (Fn + Un) / 2 - (Pn - Rn) * Dn;
            Cn.quadraticCurveTo(Hn, zn, Pn, Un);
          } else
            Cn.lineTo(Pn, Un);
        }
      this.incremental && (this._off = Ln, this.notClear = !0);
    }, nr.prototype.findDataIndex = function(Cn, Bn) {
      var In = this.shape, Dn = In.segs, Ln = In.curveness, $n = this.style.lineWidth;
      if (In.polyline)
        for (var Nn = 0, Rn = 0; Rn < Dn.length; ) {
          var Fn = Dn[Rn++];
          if (Fn > 0)
            for (var Pn = Dn[Rn++], Un = Dn[Rn++], Hn = 1; Hn < Fn; Hn++) {
              var zn = Dn[Rn++], Gn = Dn[Rn++];
              if (containStroke$4(Pn, Un, zn, Gn, $n, Cn, Bn))
                return Nn;
            }
          Nn++;
        }
      else
        for (var Nn = 0, Rn = 0; Rn < Dn.length; ) {
          var Pn = Dn[Rn++], Un = Dn[Rn++], zn = Dn[Rn++], Gn = Dn[Rn++];
          if (Ln > 0) {
            var Yn = (Pn + zn) / 2 - (Un - Gn) * Ln, Wn = (Un + Gn) / 2 - (zn - Pn) * Ln;
            if (containStroke$2(Pn, Un, Yn, Wn, zn, Gn, $n, Cn, Bn))
              return Nn;
          } else if (containStroke$4(Pn, Un, zn, Gn, $n, Cn, Bn))
            return Nn;
          Nn++;
        }
      return -1;
    }, nr.prototype.contain = function(Cn, Bn) {
      var In = this.transformCoordToLocal(Cn, Bn), Dn = this.getBoundingRect();
      if (Cn = In[0], Bn = In[1], Dn.contain(Cn, Bn)) {
        var Ln = this.hoverDataIdx = this.findDataIndex(Cn, Bn);
        return Ln >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, nr.prototype.getBoundingRect = function() {
      var Cn = this._rect;
      if (!Cn) {
        for (var Bn = this.shape, In = Bn.segs, Dn = 1 / 0, Ln = 1 / 0, $n = -1 / 0, Nn = -1 / 0, Rn = 0; Rn < In.length; ) {
          var Fn = In[Rn++], Pn = In[Rn++];
          Dn = Math.min(Fn, Dn), $n = Math.max(Fn, $n), Ln = Math.min(Pn, Ln), Nn = Math.max(Pn, Nn);
        }
        Cn = this._rect = new BoundingRect$1(Dn, Ln, $n, Nn);
      }
      return Cn;
    }, nr;
  }(Path$1)
), LargeLineDraw = (
  /** @class */
  function() {
    function _n() {
      this.group = new Group$4();
    }
    return _n.prototype.updateData = function(nr) {
      this._clear();
      var Cn = this._create();
      Cn.setShape({
        segs: nr.getLayout("linesPoints")
      }), this._setCommon(Cn, nr);
    }, _n.prototype.incrementalPrepareUpdate = function(nr) {
      this.group.removeAll(), this._clear();
    }, _n.prototype.incrementalUpdate = function(nr, Cn) {
      var Bn = this._newAdded[0], In = Cn.getLayout("linesPoints"), Dn = Bn && Bn.shape.segs;
      if (Dn && Dn.length < 2e4) {
        var Ln = Dn.length, $n = new Float32Array(Ln + In.length);
        $n.set(Dn), $n.set(In, Ln), Bn.setShape({
          segs: $n
        });
      } else {
        this._newAdded = [];
        var Nn = this._create();
        Nn.incremental = !0, Nn.setShape({
          segs: In
        }), this._setCommon(Nn, Cn), Nn.__startIndex = nr.start;
      }
    }, _n.prototype.remove = function() {
      this._clear();
    }, _n.prototype.eachRendered = function(nr) {
      this._newAdded[0] && nr(this._newAdded[0]);
    }, _n.prototype._create = function() {
      var nr = new LargeLinesPath({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(nr), this.group.add(nr), nr;
    }, _n.prototype._setCommon = function(nr, Cn, Bn) {
      var In = Cn.hostModel;
      nr.setShape({
        polyline: In.get("polyline"),
        curveness: In.get(["lineStyle", "curveness"])
      }), nr.useStyle(In.getModel("lineStyle").getLineStyle()), nr.style.strokeNoScale = !0;
      var Dn = Cn.getVisual("style");
      Dn && Dn.stroke && nr.setStyle("stroke", Dn.stroke), nr.setStyle("fill", null);
      var Ln = getECData(nr);
      Ln.seriesIndex = In.seriesIndex, nr.on("mousemove", function($n) {
        Ln.dataIndex = null;
        var Nn = nr.hoverDataIdx;
        Nn > 0 && (Ln.dataIndex = Nn + nr.__startIndex);
      });
    }, _n.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, _n;
  }()
);
const LargeLineDraw$1 = LargeLineDraw;
var linesLayout = {
  seriesType: "lines",
  plan: createRenderPlanner(),
  reset: function(_n) {
    var nr = _n.coordinateSystem;
    if (!nr) {
      process.env.NODE_ENV !== "production" && error("The lines series must have a coordinate system.");
      return;
    }
    var Cn = _n.get("polyline"), Bn = _n.pipelineContext.large;
    return {
      progress: function(In, Dn) {
        var Ln = [];
        if (Bn) {
          var $n = void 0, Nn = In.end - In.start;
          if (Cn) {
            for (var Rn = 0, Fn = In.start; Fn < In.end; Fn++)
              Rn += _n.getLineCoordsCount(Fn);
            $n = new Float32Array(Nn + Rn * 2);
          } else
            $n = new Float32Array(Nn * 4);
          for (var Pn = 0, Un = [], Fn = In.start; Fn < In.end; Fn++) {
            var Hn = _n.getLineCoords(Fn, Ln);
            Cn && ($n[Pn++] = Hn);
            for (var zn = 0; zn < Hn; zn++)
              Un = nr.dataToPoint(Ln[zn], !1, Un), $n[Pn++] = Un[0], $n[Pn++] = Un[1];
          }
          Dn.setLayout("linesPoints", $n);
        } else
          for (var Fn = In.start; Fn < In.end; Fn++) {
            var Gn = Dn.getItemModel(Fn), Hn = _n.getLineCoords(Fn, Ln), Yn = [];
            if (Cn)
              for (var Wn = 0; Wn < Hn; Wn++)
                Yn.push(nr.dataToPoint(Ln[Wn]));
            else {
              Yn[0] = nr.dataToPoint(Ln[0]), Yn[1] = nr.dataToPoint(Ln[1]);
              var Xn = Gn.get(["lineStyle", "curveness"]);
              +Xn && (Yn[2] = [(Yn[0][0] + Yn[1][0]) / 2 - (Yn[0][1] - Yn[1][1]) * Xn, (Yn[0][1] + Yn[1][1]) / 2 - (Yn[1][0] - Yn[0][0]) * Xn]);
            }
            Dn.setItemLayout(Fn, Yn);
          }
      }
    };
  }
};
const linesLayout$1 = linesLayout;
var LinesView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = this._updateLineDraw(Dn, Cn), $n = Cn.get("zlevel"), Nn = Cn.get(["effect", "trailLength"]), Rn = In.getZr(), Fn = Rn.painter.getType() === "svg";
      Fn || Rn.painter.getLayer($n).clear(!0), this._lastZlevel != null && !Fn && Rn.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(Cn) && Nn > 0 && (Fn ? process.env.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : Rn.configLayer($n, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(Nn / 10 + 0.9, 1), 0)
      })), Ln.updateData(Dn);
      var Pn = Cn.get("clip", !0) && createClipPath(Cn.coordinateSystem, !1, Cn);
      Pn ? this.group.setClipPath(Pn) : this.group.removeClipPath(), this._lastZlevel = $n, this._finished = !0;
    }, nr.prototype.incrementalPrepareRender = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = this._updateLineDraw(Dn, Cn);
      Ln.incrementalPrepareUpdate(Dn), this._clearLayer(In), this._finished = !1;
    }, nr.prototype.incrementalRender = function(Cn, Bn, In) {
      this._lineDraw.incrementalUpdate(Cn, Bn.getData()), this._finished = Cn.end === Bn.getData().count();
    }, nr.prototype.eachRendered = function(Cn) {
      this._lineDraw && this._lineDraw.eachRendered(Cn);
    }, nr.prototype.updateTransform = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = Cn.pipelineContext;
      if (!this._finished || Ln.large || Ln.progressiveRender)
        return {
          update: !0
        };
      var $n = linesLayout$1.reset(Cn, Bn, In);
      $n.progress && $n.progress({
        start: 0,
        end: Dn.count(),
        count: Dn.count()
      }, Dn), this._lineDraw.updateLayout(), this._clearLayer(In);
    }, nr.prototype._updateLineDraw = function(Cn, Bn) {
      var In = this._lineDraw, Dn = this._showEffect(Bn), Ln = !!Bn.get("polyline"), $n = Bn.pipelineContext, Nn = $n.large;
      return process.env.NODE_ENV !== "production" && Dn && Nn && console.warn("Large lines not support effect"), (!In || Dn !== this._hasEffet || Ln !== this._isPolyline || Nn !== this._isLargeDraw) && (In && In.remove(), In = this._lineDraw = Nn ? new LargeLineDraw$1() : new LineDraw$1(Ln ? Dn ? EffectPolyline$1 : Polyline$1 : Dn ? EffectLine$1 : Line$1), this._hasEffet = Dn, this._isPolyline = Ln, this._isLargeDraw = Nn), this.group.add(In.group), In;
    }, nr.prototype._showEffect = function(Cn) {
      return !!Cn.get(["effect", "show"]);
    }, nr.prototype._clearLayer = function(Cn) {
      var Bn = Cn.getZr(), In = Bn.painter.getType() === "svg";
      !In && this._lastZlevel != null && Bn.painter.getLayer(this._lastZlevel).clear(!0);
    }, nr.prototype.remove = function(Cn, Bn) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(Bn);
    }, nr.prototype.dispose = function(Cn, Bn) {
      this.remove(Cn, Bn);
    }, nr.type = "lines", nr;
  }(ChartView$1)
);
const LinesView$1 = LinesView;
var Uint32Arr = typeof Uint32Array > "u" ? Array : Uint32Array, Float64Arr = typeof Float64Array > "u" ? Array : Float64Array;
function compatEc2(_n) {
  var nr = _n.data;
  nr && nr[0] && nr[0][0] && nr[0][0].coord && (process.env.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), _n.data = map$1(nr, function(Cn) {
    var Bn = [Cn[0].coord, Cn[1].coord], In = {
      coords: Bn
    };
    return Cn[0].name && (In.fromName = Cn[0].name), Cn[1].name && (In.toName = Cn[1].name), mergeAll([In, Cn[0], Cn[1]]);
  }));
}
var LinesSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.visualStyleAccessPath = "lineStyle", Cn.visualDrawType = "stroke", Cn;
    }
    return nr.prototype.init = function(Cn) {
      Cn.data = Cn.data || [], compatEc2(Cn);
      var Bn = this._processFlatCoordsArray(Cn.data);
      this._flatCoords = Bn.flatCoords, this._flatCoordsOffset = Bn.flatCoordsOffset, Bn.flatCoords && (Cn.data = new Float32Array(Bn.count)), _n.prototype.init.apply(this, arguments);
    }, nr.prototype.mergeOption = function(Cn) {
      if (compatEc2(Cn), Cn.data) {
        var Bn = this._processFlatCoordsArray(Cn.data);
        this._flatCoords = Bn.flatCoords, this._flatCoordsOffset = Bn.flatCoordsOffset, Bn.flatCoords && (Cn.data = new Float32Array(Bn.count));
      }
      _n.prototype.mergeOption.apply(this, arguments);
    }, nr.prototype.appendData = function(Cn) {
      var Bn = this._processFlatCoordsArray(Cn.data);
      Bn.flatCoords && (this._flatCoords ? (this._flatCoords = concatArray(this._flatCoords, Bn.flatCoords), this._flatCoordsOffset = concatArray(this._flatCoordsOffset, Bn.flatCoordsOffset)) : (this._flatCoords = Bn.flatCoords, this._flatCoordsOffset = Bn.flatCoordsOffset), Cn.data = new Float32Array(Bn.count)), this.getRawData().appendData(Cn.data);
    }, nr.prototype._getCoordsFromItemModel = function(Cn) {
      var Bn = this.getData().getItemModel(Cn), In = Bn.option instanceof Array ? Bn.option : Bn.getShallow("coords");
      if (process.env.NODE_ENV !== "production" && !(In instanceof Array && In.length > 0 && In[0] instanceof Array))
        throw new Error("Invalid coords " + JSON.stringify(In) + ". Lines must have 2d coords array in data item.");
      return In;
    }, nr.prototype.getLineCoordsCount = function(Cn) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[Cn * 2 + 1] : this._getCoordsFromItemModel(Cn).length;
    }, nr.prototype.getLineCoords = function(Cn, Bn) {
      if (this._flatCoordsOffset) {
        for (var In = this._flatCoordsOffset[Cn * 2], Dn = this._flatCoordsOffset[Cn * 2 + 1], Ln = 0; Ln < Dn; Ln++)
          Bn[Ln] = Bn[Ln] || [], Bn[Ln][0] = this._flatCoords[In + Ln * 2], Bn[Ln][1] = this._flatCoords[In + Ln * 2 + 1];
        return Dn;
      } else {
        for (var $n = this._getCoordsFromItemModel(Cn), Ln = 0; Ln < $n.length; Ln++)
          Bn[Ln] = Bn[Ln] || [], Bn[Ln][0] = $n[Ln][0], Bn[Ln][1] = $n[Ln][1];
        return $n.length;
      }
    }, nr.prototype._processFlatCoordsArray = function(Cn) {
      var Bn = 0;
      if (this._flatCoords && (Bn = this._flatCoords.length), isNumber(Cn[0])) {
        for (var In = Cn.length, Dn = new Uint32Arr(In), Ln = new Float64Arr(In), $n = 0, Nn = 0, Rn = 0, Fn = 0; Fn < In; ) {
          Rn++;
          var Pn = Cn[Fn++];
          Dn[Nn++] = $n + Bn, Dn[Nn++] = Pn;
          for (var Un = 0; Un < Pn; Un++) {
            var Hn = Cn[Fn++], zn = Cn[Fn++];
            if (Ln[$n++] = Hn, Ln[$n++] = zn, Fn > In && process.env.NODE_ENV !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(Dn.buffer, 0, Nn),
          flatCoords: Ln,
          count: Rn
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: Cn.length
      };
    }, nr.prototype.getInitialData = function(Cn, Bn) {
      if (process.env.NODE_ENV !== "production") {
        var In = CoordinateSystem.get(Cn.coordinateSystem);
        if (!In)
          throw new Error("Unknown coordinate system " + Cn.coordinateSystem);
      }
      var Dn = new SeriesData$1(["value"], this);
      return Dn.hasItemOption = !1, Dn.initData(Cn.data, [], function(Ln, $n, Nn, Rn) {
        if (Ln instanceof Array)
          return NaN;
        Dn.hasItemOption = !0;
        var Fn = Ln.value;
        if (Fn != null)
          return Fn instanceof Array ? Fn[Rn] : Fn;
      }), Dn;
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      var Dn = this.getData(), Ln = Dn.getItemModel(Cn), $n = Ln.get("name");
      if ($n)
        return $n;
      var Nn = Ln.get("fromName"), Rn = Ln.get("toName"), Fn = [];
      return Nn != null && Fn.push(Nn), Rn != null && Fn.push(Rn), createTooltipMarkup("nameValue", {
        name: Fn.join(" > ")
      });
    }, nr.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, nr.prototype.getProgressive = function() {
      var Cn = this.option.progressive;
      return Cn ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, nr.prototype.getProgressiveThreshold = function() {
      var Cn = this.option.progressiveThreshold;
      return Cn ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, nr.prototype.getZLevelKey = function() {
      var Cn = this.getModel("effect"), Bn = Cn.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : Cn.get("show") && Bn > 0 ? Bn + "" : "";
    }, nr.type = "series.lines", nr.dependencies = ["grid", "polar", "geo", "calendar"], nr.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      lineStyle: {
        opacity: 0.5
      }
    }, nr;
  }(SeriesModel$1)
);
const LinesSeriesModel$1 = LinesSeriesModel;
function normalize(_n) {
  return _n instanceof Array || (_n = [_n, _n]), _n;
}
var linesVisual = {
  seriesType: "lines",
  reset: function(_n) {
    var nr = normalize(_n.get("symbol")), Cn = normalize(_n.get("symbolSize")), Bn = _n.getData();
    Bn.setVisual("fromSymbol", nr && nr[0]), Bn.setVisual("toSymbol", nr && nr[1]), Bn.setVisual("fromSymbolSize", Cn && Cn[0]), Bn.setVisual("toSymbolSize", Cn && Cn[1]);
    function In(Dn, Ln) {
      var $n = Dn.getItemModel(Ln), Nn = normalize($n.getShallow("symbol", !0)), Rn = normalize($n.getShallow("symbolSize", !0));
      Nn[0] && Dn.setItemVisual(Ln, "fromSymbol", Nn[0]), Nn[1] && Dn.setItemVisual(Ln, "toSymbol", Nn[1]), Rn[0] && Dn.setItemVisual(Ln, "fromSymbolSize", Rn[0]), Rn[1] && Dn.setItemVisual(Ln, "toSymbolSize", Rn[1]);
    }
    return {
      dataEach: Bn.hasItemOption ? In : null
    };
  }
};
const linesVisual$1 = linesVisual;
function install$w(_n) {
  _n.registerChartView(LinesView$1), _n.registerSeriesModel(LinesSeriesModel$1), _n.registerLayout(linesLayout$1), _n.registerVisual(linesVisual$1);
}
var GRADIENT_LEVELS = 256, HeatmapLayer = (
  /** @class */
  function() {
    function _n() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var nr = platformApi.createCanvas();
      this.canvas = nr;
    }
    return _n.prototype.update = function(nr, Cn, Bn, In, Dn, Ln) {
      var $n = this._getBrush(), Nn = this._getGradient(Dn, "inRange"), Rn = this._getGradient(Dn, "outOfRange"), Fn = this.pointSize + this.blurSize, Pn = this.canvas, Un = Pn.getContext("2d"), Hn = nr.length;
      Pn.width = Cn, Pn.height = Bn;
      for (var zn = 0; zn < Hn; ++zn) {
        var Gn = nr[zn], Yn = Gn[0], Wn = Gn[1], Xn = Gn[2], ea = In(Xn);
        Un.globalAlpha = ea, Un.drawImage($n, Yn - Fn, Wn - Fn);
      }
      if (!Pn.width || !Pn.height)
        return Pn;
      for (var ta = Un.getImageData(0, 0, Pn.width, Pn.height), na = ta.data, ra = 0, aa = na.length, ia = this.minOpacity, Aa = this.maxOpacity, sa = Aa - ia; ra < aa; ) {
        var ea = na[ra + 3] / 256, oa = Math.floor(ea * (GRADIENT_LEVELS - 1)) * 4;
        if (ea > 0) {
          var la = Ln(ea) ? Nn : Rn;
          ea > 0 && (ea = ea * sa + ia), na[ra++] = la[oa], na[ra++] = la[oa + 1], na[ra++] = la[oa + 2], na[ra++] = la[oa + 3] * ea * 256;
        } else
          ra += 4;
      }
      return Un.putImageData(ta, 0, 0), Pn;
    }, _n.prototype._getBrush = function() {
      var nr = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas()), Cn = this.pointSize + this.blurSize, Bn = Cn * 2;
      nr.width = Bn, nr.height = Bn;
      var In = nr.getContext("2d");
      return In.clearRect(0, 0, Bn, Bn), In.shadowOffsetX = Bn, In.shadowBlur = this.blurSize, In.shadowColor = "#000", In.beginPath(), In.arc(-Cn, Cn, this.pointSize, 0, Math.PI * 2, !0), In.closePath(), In.fill(), nr;
    }, _n.prototype._getGradient = function(nr, Cn) {
      for (var Bn = this._gradientPixels, In = Bn[Cn] || (Bn[Cn] = new Uint8ClampedArray(256 * 4)), Dn = [0, 0, 0, 0], Ln = 0, $n = 0; $n < 256; $n++)
        nr[Cn]($n / 255, !0, Dn), In[Ln++] = Dn[0], In[Ln++] = Dn[1], In[Ln++] = Dn[2], In[Ln++] = Dn[3];
      return In;
    }, _n;
  }()
);
const HeatmapLayer$1 = HeatmapLayer;
function getIsInPiecewiseRange(_n, nr, Cn) {
  var Bn = _n[1] - _n[0];
  nr = map$1(nr, function(Ln) {
    return {
      interval: [(Ln.interval[0] - _n[0]) / Bn, (Ln.interval[1] - _n[0]) / Bn]
    };
  });
  var In = nr.length, Dn = 0;
  return function(Ln) {
    var $n;
    for ($n = Dn; $n < In; $n++) {
      var Nn = nr[$n].interval;
      if (Nn[0] <= Ln && Ln <= Nn[1]) {
        Dn = $n;
        break;
      }
    }
    if ($n === In)
      for ($n = Dn - 1; $n >= 0; $n--) {
        var Nn = nr[$n].interval;
        if (Nn[0] <= Ln && Ln <= Nn[1]) {
          Dn = $n;
          break;
        }
      }
    return $n >= 0 && $n < In && Cn[$n];
  };
}
function getIsInContinuousRange(_n, nr) {
  var Cn = _n[1] - _n[0];
  return nr = [(nr[0] - _n[0]) / Cn, (nr[1] - _n[0]) / Cn], function(Bn) {
    return Bn >= nr[0] && Bn <= nr[1];
  };
}
function isGeoCoordSys(_n) {
  var nr = _n.dimensions;
  return nr[0] === "lng" && nr[1] === "lat";
}
var HeatmapView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn;
      if (Bn.eachComponent("visualMap", function($n) {
        $n.eachTargetSeries(function(Nn) {
          Nn === Cn && (Dn = $n);
        });
      }), process.env.NODE_ENV !== "production" && !Dn)
        throw new Error("Heatmap must use with visualMap");
      this._progressiveEls = null, this.group.removeAll();
      var Ln = Cn.coordinateSystem;
      Ln.type === "cartesian2d" || Ln.type === "calendar" ? this._renderOnCartesianAndCalendar(Cn, In, 0, Cn.getData().count()) : isGeoCoordSys(Ln) && this._renderOnGeo(Ln, Cn, Dn, In);
    }, nr.prototype.incrementalPrepareRender = function(Cn, Bn, In) {
      this.group.removeAll();
    }, nr.prototype.incrementalRender = function(Cn, Bn, In, Dn) {
      var Ln = Bn.coordinateSystem;
      Ln && (isGeoCoordSys(Ln) ? this.render(Bn, In, Dn) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(Bn, Dn, Cn.start, Cn.end, !0)));
    }, nr.prototype.eachRendered = function(Cn) {
      traverseElements(this._progressiveEls || this.group, Cn);
    }, nr.prototype._renderOnCartesianAndCalendar = function(Cn, Bn, In, Dn, Ln) {
      var $n = Cn.coordinateSystem, Nn = isCoordinateSystemType($n, "cartesian2d"), Rn, Fn, Pn, Un;
      if (Nn) {
        var Hn = $n.getAxis("x"), zn = $n.getAxis("y");
        if (process.env.NODE_ENV !== "production") {
          if (!(Hn.type === "category" && zn.type === "category"))
            throw new Error("Heatmap on cartesian must have two category axes");
          if (!(Hn.onBand && zn.onBand))
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
        Rn = Hn.getBandWidth() + 0.5, Fn = zn.getBandWidth() + 0.5, Pn = Hn.scale.getExtent(), Un = zn.scale.getExtent();
      }
      for (var Gn = this.group, Yn = Cn.getData(), Wn = Cn.getModel(["emphasis", "itemStyle"]).getItemStyle(), Xn = Cn.getModel(["blur", "itemStyle"]).getItemStyle(), ea = Cn.getModel(["select", "itemStyle"]).getItemStyle(), ta = Cn.get(["itemStyle", "borderRadius"]), na = getLabelStatesModels(Cn), ra = Cn.getModel("emphasis"), aa = ra.get("focus"), ia = ra.get("blurScope"), Aa = ra.get("disabled"), sa = Nn ? [Yn.mapDimension("x"), Yn.mapDimension("y"), Yn.mapDimension("value")] : [Yn.mapDimension("time"), Yn.mapDimension("value")], oa = In; oa < Dn; oa++) {
        var la = void 0, ua = Yn.getItemVisual(oa, "style");
        if (Nn) {
          var ca = Yn.get(sa[0], oa), fa = Yn.get(sa[1], oa);
          if (isNaN(Yn.get(sa[2], oa)) || isNaN(ca) || isNaN(fa) || ca < Pn[0] || ca > Pn[1] || fa < Un[0] || fa > Un[1])
            continue;
          var ha = $n.dataToPoint([ca, fa]);
          la = new Rect$3({
            shape: {
              x: ha[0] - Rn / 2,
              y: ha[1] - Fn / 2,
              width: Rn,
              height: Fn
            },
            style: ua
          });
        } else {
          if (isNaN(Yn.get(sa[1], oa)))
            continue;
          la = new Rect$3({
            z2: 1,
            shape: $n.dataToRect([Yn.get(sa[0], oa)]).contentShape,
            style: ua
          });
        }
        if (Yn.hasItemOption) {
          var pa = Yn.getItemModel(oa), ya = pa.getModel("emphasis");
          Wn = ya.getModel("itemStyle").getItemStyle(), Xn = pa.getModel(["blur", "itemStyle"]).getItemStyle(), ea = pa.getModel(["select", "itemStyle"]).getItemStyle(), ta = pa.get(["itemStyle", "borderRadius"]), aa = ya.get("focus"), ia = ya.get("blurScope"), Aa = ya.get("disabled"), na = getLabelStatesModels(pa);
        }
        la.shape.r = ta;
        var da = Cn.getRawValue(oa), Ca = "-";
        da && da[2] != null && (Ca = da[2] + ""), setLabelStyle(la, na, {
          labelFetcher: Cn,
          labelDataIndex: oa,
          defaultOpacity: ua.opacity,
          defaultText: Ca
        }), la.ensureState("emphasis").style = Wn, la.ensureState("blur").style = Xn, la.ensureState("select").style = ea, toggleHoverEmphasis(la, aa, ia, Aa), la.incremental = Ln, Ln && (la.states.emphasis.hoverLayer = !0), Gn.add(la), Yn.setItemGraphicEl(oa, la), this._progressiveEls && this._progressiveEls.push(la);
      }
    }, nr.prototype._renderOnGeo = function(Cn, Bn, In, Dn) {
      var Ln = In.targetVisuals.inRange, $n = In.targetVisuals.outOfRange, Nn = Bn.getData(), Rn = this._hmLayer || this._hmLayer || new HeatmapLayer$1();
      Rn.blurSize = Bn.get("blurSize"), Rn.pointSize = Bn.get("pointSize"), Rn.minOpacity = Bn.get("minOpacity"), Rn.maxOpacity = Bn.get("maxOpacity");
      var Fn = Cn.getViewRect().clone(), Pn = Cn.getRoamTransform();
      Fn.applyTransform(Pn);
      var Un = Math.max(Fn.x, 0), Hn = Math.max(Fn.y, 0), zn = Math.min(Fn.width + Fn.x, Dn.getWidth()), Gn = Math.min(Fn.height + Fn.y, Dn.getHeight()), Yn = zn - Un, Wn = Gn - Hn, Xn = [Nn.mapDimension("lng"), Nn.mapDimension("lat"), Nn.mapDimension("value")], ea = Nn.mapArray(Xn, function(aa, ia, Aa) {
        var sa = Cn.dataToPoint([aa, ia]);
        return sa[0] -= Un, sa[1] -= Hn, sa.push(Aa), sa;
      }), ta = In.getExtent(), na = In.type === "visualMap.continuous" ? getIsInContinuousRange(ta, In.option.range) : getIsInPiecewiseRange(ta, In.getPieceList(), In.option.selected);
      Rn.update(ea, Yn, Wn, Ln.color.getNormalizer(), {
        inRange: Ln.color.getColorMapper(),
        outOfRange: $n.color.getColorMapper()
      }, na);
      var ra = new ZRImage$1({
        style: {
          width: Yn,
          height: Wn,
          x: Un,
          y: Hn,
          image: Rn.canvas
        },
        silent: !0
      });
      this.group.add(ra);
    }, nr.type = "heatmap", nr;
  }(ChartView$1)
);
const HeatmapView$1 = HeatmapView;
var HeatmapSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.getInitialData = function(Cn, Bn) {
      return createSeriesData(null, this, {
        generateCoord: "value"
      });
    }, nr.prototype.preventIncremental = function() {
      var Cn = CoordinateSystem.get(this.get("coordinateSystem"));
      if (Cn && Cn.dimensions)
        return Cn.dimensions[0] === "lng" && Cn.dimensions[1] === "lat";
    }, nr.type = "series.heatmap", nr.dependencies = ["grid", "geo", "calendar"], nr.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, nr;
  }(SeriesModel$1)
);
const HeatmapSeriesModel$1 = HeatmapSeriesModel;
function install$v(_n) {
  _n.registerChartView(HeatmapView$1), _n.registerSeriesModel(HeatmapSeriesModel$1);
}
var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"], LAYOUT_ATTRS = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], pathForLineWidth = new Circle$1(), PictorialBarView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = this.group, Ln = Cn.getData(), $n = this._data, Nn = Cn.coordinateSystem, Rn = Nn.getBaseAxis(), Fn = Rn.isHorizontal(), Pn = Nn.master.getRect(), Un = {
        ecSize: {
          width: In.getWidth(),
          height: In.getHeight()
        },
        seriesModel: Cn,
        coordSys: Nn,
        coordSysExtent: [[Pn.x, Pn.x + Pn.width], [Pn.y, Pn.y + Pn.height]],
        isHorizontal: Fn,
        valueDim: LAYOUT_ATTRS[+Fn],
        categoryDim: LAYOUT_ATTRS[1 - +Fn]
      };
      Ln.diff($n).add(function(zn) {
        if (Ln.hasValue(zn)) {
          var Gn = getItemModel(Ln, zn), Yn = getSymbolMeta(Ln, zn, Gn, Un), Wn = createBar(Ln, Un, Yn);
          Ln.setItemGraphicEl(zn, Wn), Dn.add(Wn), updateCommon(Wn, Un, Yn);
        }
      }).update(function(zn, Gn) {
        var Yn = $n.getItemGraphicEl(Gn);
        if (!Ln.hasValue(zn)) {
          Dn.remove(Yn);
          return;
        }
        var Wn = getItemModel(Ln, zn), Xn = getSymbolMeta(Ln, zn, Wn, Un), ea = getShapeStr(Ln, Xn);
        Yn && ea !== Yn.__pictorialShapeStr && (Dn.remove(Yn), Ln.setItemGraphicEl(zn, null), Yn = null), Yn ? updateBar(Yn, Un, Xn) : Yn = createBar(Ln, Un, Xn, !0), Ln.setItemGraphicEl(zn, Yn), Yn.__pictorialSymbolMeta = Xn, Dn.add(Yn), updateCommon(Yn, Un, Xn);
      }).remove(function(zn) {
        var Gn = $n.getItemGraphicEl(zn);
        Gn && removeBar($n, zn, Gn.__pictorialSymbolMeta.animationModel, Gn);
      }).execute();
      var Hn = Cn.get("clip", !0) ? createClipPath(Cn.coordinateSystem, !1, Cn) : null;
      return Hn ? Dn.setClipPath(Hn) : Dn.removeClipPath(), this._data = Ln, this.group;
    }, nr.prototype.remove = function(Cn, Bn) {
      var In = this.group, Dn = this._data;
      Cn.get("animation") ? Dn && Dn.eachItemGraphicEl(function(Ln) {
        removeBar(Dn, getECData(Ln).dataIndex, Cn, Ln);
      }) : In.removeAll();
    }, nr.type = "pictorialBar", nr;
  }(ChartView$1)
);
function getSymbolMeta(_n, nr, Cn, Bn) {
  var In = _n.getItemLayout(nr), Dn = Cn.get("symbolRepeat"), Ln = Cn.get("symbolClip"), $n = Cn.get("symbolPosition") || "start", Nn = Cn.get("symbolRotate"), Rn = (Nn || 0) * Math.PI / 180 || 0, Fn = Cn.get("symbolPatternSize") || 2, Pn = Cn.isAnimationEnabled(), Un = {
    dataIndex: nr,
    layout: In,
    itemModel: Cn,
    symbolType: _n.getItemVisual(nr, "symbol") || "circle",
    style: _n.getItemVisual(nr, "style"),
    symbolClip: Ln,
    symbolRepeat: Dn,
    symbolRepeatDirection: Cn.get("symbolRepeatDirection"),
    symbolPatternSize: Fn,
    rotation: Rn,
    animationModel: Pn ? Cn : null,
    hoverScale: Pn && Cn.get(["emphasis", "scale"]),
    z2: Cn.getShallow("z", !0) || 0
  };
  prepareBarLength(Cn, Dn, In, Bn, Un), prepareSymbolSize(_n, nr, In, Dn, Ln, Un.boundingLength, Un.pxSign, Fn, Bn, Un), prepareLineWidth(Cn, Un.symbolScale, Rn, Bn, Un);
  var Hn = Un.symbolSize, zn = normalizeSymbolOffset(Cn.get("symbolOffset"), Hn);
  return prepareLayoutInfo(Cn, Hn, In, Dn, Ln, zn, $n, Un.valueLineWidth, Un.boundingLength, Un.repeatCutLength, Bn, Un), Un;
}
function prepareBarLength(_n, nr, Cn, Bn, In) {
  var Dn = Bn.valueDim, Ln = _n.get("symbolBoundingData"), $n = Bn.coordSys.getOtherAxis(Bn.coordSys.getBaseAxis()), Nn = $n.toGlobalCoord($n.dataToCoord(0)), Rn = 1 - +(Cn[Dn.wh] <= 0), Fn;
  if (isArray$4(Ln)) {
    var Pn = [convertToCoordOnAxis($n, Ln[0]) - Nn, convertToCoordOnAxis($n, Ln[1]) - Nn];
    Pn[1] < Pn[0] && Pn.reverse(), Fn = Pn[Rn];
  } else
    Ln != null ? Fn = convertToCoordOnAxis($n, Ln) - Nn : nr ? Fn = Bn.coordSysExtent[Dn.index][Rn] - Nn : Fn = Cn[Dn.wh];
  In.boundingLength = Fn, nr && (In.repeatCutLength = Cn[Dn.wh]);
  var Un = Dn.xy === "x", Hn = $n.inverse;
  In.pxSign = Un && !Hn || !Un && Hn ? Fn >= 0 ? 1 : -1 : Fn > 0 ? 1 : -1;
}
function convertToCoordOnAxis(_n, nr) {
  return _n.toGlobalCoord(_n.dataToCoord(_n.scale.parse(nr)));
}
function prepareSymbolSize(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn) {
  var Fn = Nn.valueDim, Pn = Nn.categoryDim, Un = Math.abs(Cn[Pn.wh]), Hn = _n.getItemVisual(nr, "symbolSize"), zn;
  isArray$4(Hn) ? zn = Hn.slice() : Hn == null ? zn = ["100%", "100%"] : zn = [Hn, Hn], zn[Pn.index] = parsePercent(zn[Pn.index], Un), zn[Fn.index] = parsePercent(zn[Fn.index], Bn ? Un : Math.abs(Dn)), Rn.symbolSize = zn;
  var Gn = Rn.symbolScale = [zn[0] / $n, zn[1] / $n];
  Gn[Fn.index] *= (Nn.isHorizontal ? -1 : 1) * Ln;
}
function prepareLineWidth(_n, nr, Cn, Bn, In) {
  var Dn = _n.get(BAR_BORDER_WIDTH_QUERY) || 0;
  Dn && (pathForLineWidth.attr({
    scaleX: nr[0],
    scaleY: nr[1],
    rotation: Cn
  }), pathForLineWidth.updateTransform(), Dn /= pathForLineWidth.getLineScale(), Dn *= nr[Bn.valueDim.index]), In.valueLineWidth = Dn || 0;
}
function prepareLayoutInfo(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn, Fn, Pn) {
  var Un = Fn.categoryDim, Hn = Fn.valueDim, zn = Pn.pxSign, Gn = Math.max(nr[Hn.index] + $n, 0), Yn = Gn;
  if (Bn) {
    var Wn = Math.abs(Nn), Xn = retrieve(_n.get("symbolMargin"), "15%") + "", ea = !1;
    Xn.lastIndexOf("!") === Xn.length - 1 && (ea = !0, Xn = Xn.slice(0, Xn.length - 1));
    var ta = parsePercent(Xn, nr[Hn.index]), na = Math.max(Gn + ta * 2, 0), ra = ea ? 0 : ta * 2, aa = isNumeric(Bn), ia = aa ? Bn : toIntTimes((Wn + ra) / na), Aa = Wn - ia * Gn;
    ta = Aa / 2 / (ea ? ia : Math.max(ia - 1, 1)), na = Gn + ta * 2, ra = ea ? 0 : ta * 2, !aa && Bn !== "fixed" && (ia = Rn ? toIntTimes((Math.abs(Rn) + ra) / na) : 0), Yn = ia * na - ra, Pn.repeatTimes = ia, Pn.symbolMargin = ta;
  }
  var sa = zn * (Yn / 2), oa = Pn.pathPosition = [];
  oa[Un.index] = Cn[Un.wh] / 2, oa[Hn.index] = Ln === "start" ? sa : Ln === "end" ? Nn - sa : Nn / 2, Dn && (oa[0] += Dn[0], oa[1] += Dn[1]);
  var la = Pn.bundlePosition = [];
  la[Un.index] = Cn[Un.xy], la[Hn.index] = Cn[Hn.xy];
  var ua = Pn.barRectShape = extend({}, Cn);
  ua[Hn.wh] = zn * Math.max(Math.abs(Cn[Hn.wh]), Math.abs(oa[Hn.index] + sa)), ua[Un.wh] = Cn[Un.wh];
  var ca = Pn.clipShape = {};
  ca[Un.xy] = -Cn[Un.xy], ca[Un.wh] = Fn.ecSize[Un.wh], ca[Hn.xy] = 0, ca[Hn.wh] = Cn[Hn.wh];
}
function createPath(_n) {
  var nr = _n.symbolPatternSize, Cn = createSymbol$1(
    // Consider texture img, make a big size.
    _n.symbolType,
    -nr / 2,
    -nr / 2,
    nr,
    nr
  );
  return Cn.attr({
    culling: !0
  }), Cn.type !== "image" && Cn.setStyle({
    strokeNoScale: !0
  }), Cn;
}
function createOrUpdateRepeatSymbols(_n, nr, Cn, Bn) {
  var In = _n.__pictorialBundle, Dn = Cn.symbolSize, Ln = Cn.valueLineWidth, $n = Cn.pathPosition, Nn = nr.valueDim, Rn = Cn.repeatTimes || 0, Fn = 0, Pn = Dn[nr.valueDim.index] + Ln + Cn.symbolMargin * 2;
  for (eachPath(_n, function(Gn) {
    Gn.__pictorialAnimationIndex = Fn, Gn.__pictorialRepeatTimes = Rn, Fn < Rn ? updateAttr(Gn, null, zn(Fn), Cn, Bn) : updateAttr(Gn, null, {
      scaleX: 0,
      scaleY: 0
    }, Cn, Bn, function() {
      In.remove(Gn);
    }), Fn++;
  }); Fn < Rn; Fn++) {
    var Un = createPath(Cn);
    Un.__pictorialAnimationIndex = Fn, Un.__pictorialRepeatTimes = Rn, In.add(Un);
    var Hn = zn(Fn);
    updateAttr(Un, {
      x: Hn.x,
      y: Hn.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: Hn.scaleX,
      scaleY: Hn.scaleY,
      rotation: Hn.rotation
    }, Cn, Bn);
  }
  function zn(Gn) {
    var Yn = $n.slice(), Wn = Cn.pxSign, Xn = Gn;
    return (Cn.symbolRepeatDirection === "start" ? Wn > 0 : Wn < 0) && (Xn = Rn - 1 - Gn), Yn[Nn.index] = Pn * (Xn - Rn / 2 + 0.5) + $n[Nn.index], {
      x: Yn[0],
      y: Yn[1],
      scaleX: Cn.symbolScale[0],
      scaleY: Cn.symbolScale[1],
      rotation: Cn.rotation
    };
  }
}
function createOrUpdateSingleSymbol(_n, nr, Cn, Bn) {
  var In = _n.__pictorialBundle, Dn = _n.__pictorialMainPath;
  Dn ? updateAttr(Dn, null, {
    x: Cn.pathPosition[0],
    y: Cn.pathPosition[1],
    scaleX: Cn.symbolScale[0],
    scaleY: Cn.symbolScale[1],
    rotation: Cn.rotation
  }, Cn, Bn) : (Dn = _n.__pictorialMainPath = createPath(Cn), In.add(Dn), updateAttr(Dn, {
    x: Cn.pathPosition[0],
    y: Cn.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: Cn.rotation
  }, {
    scaleX: Cn.symbolScale[0],
    scaleY: Cn.symbolScale[1]
  }, Cn, Bn));
}
function createOrUpdateBarRect(_n, nr, Cn) {
  var Bn = extend({}, nr.barRectShape), In = _n.__pictorialBarRect;
  In ? updateAttr(In, null, {
    shape: Bn
  }, nr, Cn) : (In = _n.__pictorialBarRect = new Rect$3({
    z2: 2,
    shape: Bn,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), In.disableMorphing = !0, _n.add(In));
}
function createOrUpdateClip(_n, nr, Cn, Bn) {
  if (Cn.symbolClip) {
    var In = _n.__pictorialClipPath, Dn = extend({}, Cn.clipShape), Ln = nr.valueDim, $n = Cn.animationModel, Nn = Cn.dataIndex;
    if (In)
      updateProps$1(In, {
        shape: Dn
      }, $n, Nn);
    else {
      Dn[Ln.wh] = 0, In = new Rect$3({
        shape: Dn
      }), _n.__pictorialBundle.setClipPath(In), _n.__pictorialClipPath = In;
      var Rn = {};
      Rn[Ln.wh] = Cn.clipShape[Ln.wh], graphic$1[Bn ? "updateProps" : "initProps"](In, {
        shape: Rn
      }, $n, Nn);
    }
  }
}
function getItemModel(_n, nr) {
  var Cn = _n.getItemModel(nr);
  return Cn.getAnimationDelayParams = getAnimationDelayParams, Cn.isAnimationEnabled = isAnimationEnabled, Cn;
}
function getAnimationDelayParams(_n) {
  return {
    index: _n.__pictorialAnimationIndex,
    count: _n.__pictorialRepeatTimes
  };
}
function isAnimationEnabled() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function createBar(_n, nr, Cn, Bn) {
  var In = new Group$4(), Dn = new Group$4();
  return In.add(Dn), In.__pictorialBundle = Dn, Dn.x = Cn.bundlePosition[0], Dn.y = Cn.bundlePosition[1], Cn.symbolRepeat ? createOrUpdateRepeatSymbols(In, nr, Cn) : createOrUpdateSingleSymbol(In, nr, Cn), createOrUpdateBarRect(In, Cn, Bn), createOrUpdateClip(In, nr, Cn, Bn), In.__pictorialShapeStr = getShapeStr(_n, Cn), In.__pictorialSymbolMeta = Cn, In;
}
function updateBar(_n, nr, Cn) {
  var Bn = Cn.animationModel, In = Cn.dataIndex, Dn = _n.__pictorialBundle;
  updateProps$1(Dn, {
    x: Cn.bundlePosition[0],
    y: Cn.bundlePosition[1]
  }, Bn, In), Cn.symbolRepeat ? createOrUpdateRepeatSymbols(_n, nr, Cn, !0) : createOrUpdateSingleSymbol(_n, nr, Cn, !0), createOrUpdateBarRect(_n, Cn, !0), createOrUpdateClip(_n, nr, Cn, !0);
}
function removeBar(_n, nr, Cn, Bn) {
  var In = Bn.__pictorialBarRect;
  In && In.removeTextContent();
  var Dn = [];
  eachPath(Bn, function(Ln) {
    Dn.push(Ln);
  }), Bn.__pictorialMainPath && Dn.push(Bn.__pictorialMainPath), Bn.__pictorialClipPath && (Cn = null), each$f(Dn, function(Ln) {
    removeElement(Ln, {
      scaleX: 0,
      scaleY: 0
    }, Cn, nr, function() {
      Bn.parent && Bn.parent.remove(Bn);
    });
  }), _n.setItemGraphicEl(nr, null);
}
function getShapeStr(_n, nr) {
  return [_n.getItemVisual(nr.dataIndex, "symbol") || "none", !!nr.symbolRepeat, !!nr.symbolClip].join(":");
}
function eachPath(_n, nr, Cn) {
  each$f(_n.__pictorialBundle.children(), function(Bn) {
    Bn !== _n.__pictorialBarRect && nr.call(Cn, Bn);
  });
}
function updateAttr(_n, nr, Cn, Bn, In, Dn) {
  nr && _n.attr(nr), Bn.symbolClip && !In ? Cn && _n.attr(Cn) : Cn && graphic$1[In ? "updateProps" : "initProps"](_n, Cn, Bn.animationModel, Bn.dataIndex, Dn);
}
function updateCommon(_n, nr, Cn) {
  var Bn = Cn.dataIndex, In = Cn.itemModel, Dn = In.getModel("emphasis"), Ln = Dn.getModel("itemStyle").getItemStyle(), $n = In.getModel(["blur", "itemStyle"]).getItemStyle(), Nn = In.getModel(["select", "itemStyle"]).getItemStyle(), Rn = In.getShallow("cursor"), Fn = Dn.get("focus"), Pn = Dn.get("blurScope"), Un = Dn.get("scale");
  eachPath(_n, function(Gn) {
    if (Gn instanceof ZRImage$1) {
      var Yn = Gn.style;
      Gn.useStyle(extend({
        // TODO other properties like dx, dy ?
        image: Yn.image,
        x: Yn.x,
        y: Yn.y,
        width: Yn.width,
        height: Yn.height
      }, Cn.style));
    } else
      Gn.useStyle(Cn.style);
    var Wn = Gn.ensureState("emphasis");
    Wn.style = Ln, Un && (Wn.scaleX = Gn.scaleX * 1.1, Wn.scaleY = Gn.scaleY * 1.1), Gn.ensureState("blur").style = $n, Gn.ensureState("select").style = Nn, Rn && (Gn.cursor = Rn), Gn.z2 = Cn.z2;
  });
  var Hn = nr.valueDim.posDesc[+(Cn.boundingLength > 0)], zn = _n.__pictorialBarRect;
  zn.ignoreClip = !0, setLabelStyle(zn, getLabelStatesModels(In), {
    labelFetcher: nr.seriesModel,
    labelDataIndex: Bn,
    defaultText: getDefaultLabel(nr.seriesModel.getData(), Bn),
    inheritColor: Cn.style.fill,
    defaultOpacity: Cn.style.opacity,
    defaultOutsidePosition: Hn
  }), toggleHoverEmphasis(_n, Fn, Pn, Dn.get("disabled"));
}
function toIntTimes(_n) {
  var nr = Math.round(_n);
  return Math.abs(_n - nr) < 1e-4 ? nr : Math.ceil(_n);
}
const PictorialBarView$1 = PictorialBarView;
var PictorialBarSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.hasSymbolVisual = !0, Cn.defaultSymbol = "roundRect", Cn;
    }
    return nr.prototype.getInitialData = function(Cn) {
      return Cn.stack = null, _n.prototype.getInitialData.apply(this, arguments);
    }, nr.type = "series.pictorialBar", nr.dependencies = ["grid"], nr.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // Pictorial bar do not clip by default because in many cases
      // xAxis and yAxis are not displayed and it's expected not to clip
      clip: !1,
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), nr;
  }(BaseBarSeriesModel$1)
);
const PictorialBarSeriesModel$1 = PictorialBarSeriesModel;
function install$u(_n) {
  _n.registerChartView(PictorialBarView$1), _n.registerSeriesModel(PictorialBarSeriesModel$1), _n.registerLayout(_n.PRIORITY.VISUAL.LAYOUT, curry$1(layout$3, "pictorialBar")), _n.registerLayout(_n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
}
var ThemeRiverView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn._layers = [], Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Cn.getData(), Ln = this, $n = this.group, Nn = Cn.getLayerSeries(), Rn = Dn.getLayout("layoutInfo"), Fn = Rn.rect, Pn = Rn.boundaryGap;
      $n.x = 0, $n.y = Fn.y + Pn[0];
      function Un(Yn) {
        return Yn.name;
      }
      var Hn = new DataDiffer$1(this._layersSeries || [], Nn, Un, Un), zn = [];
      Hn.add(bind$1(Gn, this, "add")).update(bind$1(Gn, this, "update")).remove(bind$1(Gn, this, "remove")).execute();
      function Gn(Yn, Wn, Xn) {
        var ea = Ln._layers;
        if (Yn === "remove") {
          $n.remove(ea[Wn]);
          return;
        }
        for (var ta = [], na = [], ra, aa = Nn[Wn].indices, ia = 0; ia < aa.length; ia++) {
          var Aa = Dn.getItemLayout(aa[ia]), sa = Aa.x, oa = Aa.y0, la = Aa.y;
          ta.push(sa, oa), na.push(sa, oa + la), ra = Dn.getItemVisual(aa[ia], "style");
        }
        var ua, ca = Dn.getItemLayout(aa[0]), fa = Cn.getModel("label"), ha = fa.get("margin"), pa = Cn.getModel("emphasis");
        if (Yn === "add") {
          var ya = zn[Wn] = new Group$4();
          ua = new ECPolygon({
            shape: {
              points: ta,
              stackedOnPoints: na,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), ya.add(ua), $n.add(ya), Cn.isAnimationEnabled() && ua.setClipPath(createGridClipShape(ua.getBoundingRect(), Cn, function() {
            ua.removeClipPath();
          }));
        } else {
          var ya = ea[Xn];
          ua = ya.childAt(0), $n.add(ya), zn[Wn] = ya, updateProps$1(ua, {
            shape: {
              points: ta,
              stackedOnPoints: na
            }
          }, Cn), saveOldStyle(ua);
        }
        setLabelStyle(ua, getLabelStatesModels(Cn), {
          labelDataIndex: aa[ia - 1],
          defaultText: Dn.getName(aa[ia - 1]),
          inheritColor: ra.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), ua.setTextConfig({
          position: null,
          local: !0
        });
        var da = ua.getTextContent();
        da && (da.x = ca.x - ha, da.y = ca.y0 + ca.y / 2), ua.useStyle(ra), Dn.setItemGraphicEl(Wn, ua), setStatesStylesFromModel(ua, Cn), toggleHoverEmphasis(ua, pa.get("focus"), pa.get("blurScope"), pa.get("disabled"));
      }
      this._layersSeries = Nn, this._layers = zn;
    }, nr.type = "themeRiver", nr;
  }(ChartView$1)
);
function createGridClipShape(_n, nr, Cn) {
  var Bn = new Rect$3({
    shape: {
      x: _n.x - 10,
      y: _n.y - 10,
      width: 0,
      height: _n.height + 20
    }
  });
  return initProps(Bn, {
    shape: {
      x: _n.x - 50,
      width: _n.width + 100,
      height: _n.height + 20
    }
  }, nr, Cn), Bn;
}
const ThemeRiverView$1 = ThemeRiverView;
var DATA_NAME_INDEX = 2, ThemeRiverSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function(Cn) {
      _n.prototype.init.apply(this, arguments), this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
    }, nr.prototype.fixData = function(Cn) {
      var Bn = Cn.length, In = {}, Dn = groupData(Cn, function(Un) {
        return In.hasOwnProperty(Un[0] + "") || (In[Un[0] + ""] = -1), Un[2];
      }), Ln = [];
      Dn.buckets.each(function(Un, Hn) {
        Ln.push({
          name: Hn,
          dataList: Un
        });
      });
      for (var $n = Ln.length, Nn = 0; Nn < $n; ++Nn) {
        for (var Rn = Ln[Nn].name, Fn = 0; Fn < Ln[Nn].dataList.length; ++Fn) {
          var Pn = Ln[Nn].dataList[Fn][0] + "";
          In[Pn] = Nn;
        }
        for (var Pn in In)
          In.hasOwnProperty(Pn) && In[Pn] !== Nn && (In[Pn] = Nn, Cn[Bn] = [Pn, 0, Rn], Bn++);
      }
      return Cn;
    }, nr.prototype.getInitialData = function(Cn, Bn) {
      for (var In = this.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0], Dn = In.get("type"), Ln = filter(Cn.data, function(zn) {
        return zn[2] !== void 0;
      }), $n = this.fixData(Ln || []), Nn = [], Rn = this.nameMap = createHashMap(), Fn = 0, Pn = 0; Pn < $n.length; ++Pn)
        Nn.push($n[Pn][DATA_NAME_INDEX]), Rn.get($n[Pn][DATA_NAME_INDEX]) || (Rn.set($n[Pn][DATA_NAME_INDEX], Fn), Fn++);
      var Un = prepareSeriesDataSchema($n, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: getDimensionTypeByAxis(Dn)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, Hn = new SeriesData$1(Un, this);
      return Hn.initData($n), Hn;
    }, nr.prototype.getLayerSeries = function() {
      for (var Cn = this.getData(), Bn = Cn.count(), In = [], Dn = 0; Dn < Bn; ++Dn)
        In[Dn] = Dn;
      var Ln = Cn.mapDimension("single"), $n = groupData(In, function(Rn) {
        return Cn.get("name", Rn);
      }), Nn = [];
      return $n.buckets.each(function(Rn, Fn) {
        Rn.sort(function(Pn, Un) {
          return Cn.get(Ln, Pn) - Cn.get(Ln, Un);
        }), Nn.push({
          name: Fn,
          indices: Rn
        });
      }), Nn;
    }, nr.prototype.getAxisTooltipData = function(Cn, Bn, In) {
      isArray$4(Cn) || (Cn = Cn ? [Cn] : []);
      for (var Dn = this.getData(), Ln = this.getLayerSeries(), $n = [], Nn = Ln.length, Rn, Fn = 0; Fn < Nn; ++Fn) {
        for (var Pn = Number.MAX_VALUE, Un = -1, Hn = Ln[Fn].indices.length, zn = 0; zn < Hn; ++zn) {
          var Gn = Dn.get(Cn[0], Ln[Fn].indices[zn]), Yn = Math.abs(Gn - Bn);
          Yn <= Pn && (Rn = Gn, Pn = Yn, Un = Ln[Fn].indices[zn]);
        }
        $n.push(Un);
      }
      return {
        dataIndices: $n,
        nestestValue: Rn
      };
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      var Dn = this.getData(), Ln = Dn.getName(Cn), $n = Dn.get(Dn.mapDimension("value"), Cn);
      return createTooltipMarkup("nameValue", {
        name: Ln,
        value: $n
      });
    }, nr.type = "series.themeRiver", nr.dependencies = ["singleAxis"], nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, nr;
  }(SeriesModel$1)
);
const ThemeRiverSeriesModel$1 = ThemeRiverSeriesModel;
function themeRiverLayout(_n, nr) {
  _n.eachSeriesByType("themeRiver", function(Cn) {
    var Bn = Cn.getData(), In = Cn.coordinateSystem, Dn = {}, Ln = In.getRect();
    Dn.rect = Ln;
    var $n = Cn.get("boundaryGap"), Nn = In.getAxis();
    if (Dn.boundaryGap = $n, Nn.orient === "horizontal") {
      $n[0] = parsePercent($n[0], Ln.height), $n[1] = parsePercent($n[1], Ln.height);
      var Rn = Ln.height - $n[0] - $n[1];
      doThemeRiverLayout(Bn, Cn, Rn);
    } else {
      $n[0] = parsePercent($n[0], Ln.width), $n[1] = parsePercent($n[1], Ln.width);
      var Fn = Ln.width - $n[0] - $n[1];
      doThemeRiverLayout(Bn, Cn, Fn);
    }
    Bn.setLayout("layoutInfo", Dn);
  });
}
function doThemeRiverLayout(_n, nr, Cn) {
  if (_n.count())
    for (var Bn = nr.coordinateSystem, In = nr.getLayerSeries(), Dn = _n.mapDimension("single"), Ln = _n.mapDimension("value"), $n = map$1(In, function(Yn) {
      return map$1(Yn.indices, function(Wn) {
        var Xn = Bn.dataToPoint(_n.get(Dn, Wn));
        return Xn[1] = _n.get(Ln, Wn), Xn;
      });
    }), Nn = computeBaseline($n), Rn = Nn.y0, Fn = Cn / Nn.max, Pn = In.length, Un = In[0].indices.length, Hn, zn = 0; zn < Un; ++zn) {
      Hn = Rn[zn] * Fn, _n.setItemLayout(In[0].indices[zn], {
        layerIndex: 0,
        x: $n[0][zn][0],
        y0: Hn,
        y: $n[0][zn][1] * Fn
      });
      for (var Gn = 1; Gn < Pn; ++Gn)
        Hn += $n[Gn - 1][zn][1] * Fn, _n.setItemLayout(In[Gn].indices[zn], {
          layerIndex: Gn,
          x: $n[Gn][zn][0],
          y0: Hn,
          y: $n[Gn][zn][1] * Fn
        });
    }
}
function computeBaseline(_n) {
  for (var nr = _n.length, Cn = _n[0].length, Bn = [], In = [], Dn = 0, Ln = 0; Ln < Cn; ++Ln) {
    for (var $n = 0, Nn = 0; Nn < nr; ++Nn)
      $n += _n[Nn][Ln][1];
    $n > Dn && (Dn = $n), Bn.push($n);
  }
  for (var Rn = 0; Rn < Cn; ++Rn)
    In[Rn] = (Dn - Bn[Rn]) / 2;
  Dn = 0;
  for (var Fn = 0; Fn < Cn; ++Fn) {
    var Pn = Bn[Fn] + In[Fn];
    Pn > Dn && (Dn = Pn);
  }
  return {
    y0: In,
    max: Dn
  };
}
function install$t(_n) {
  _n.registerChartView(ThemeRiverView$1), _n.registerSeriesModel(ThemeRiverSeriesModel$1), _n.registerLayout(themeRiverLayout), _n.registerProcessor(dataFilter$1("themeRiver"));
}
var DEFAULT_SECTOR_Z = 2, DEFAULT_TEXT_Z = 4, SunburstPiece = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In, Dn) {
      var Ln = _n.call(this) || this;
      Ln.z2 = DEFAULT_SECTOR_Z, Ln.textConfig = {
        inside: !0
      }, getECData(Ln).seriesIndex = Bn.seriesIndex;
      var $n = new ZRText$1({
        z2: DEFAULT_TEXT_Z,
        silent: Cn.getModel().get(["label", "silent"])
      });
      return Ln.setTextContent($n), Ln.updateData(!0, Cn, Bn, In, Dn), Ln;
    }
    return nr.prototype.updateData = function(Cn, Bn, In, Dn, Ln) {
      this.node = Bn, Bn.piece = this, In = In || this._seriesModel, Dn = Dn || this._ecModel;
      var $n = this;
      getECData($n).dataIndex = Bn.dataIndex;
      var Nn = Bn.getModel(), Rn = Nn.getModel("emphasis"), Fn = Bn.getLayout(), Pn = extend({}, Fn);
      Pn.label = null;
      var Un = Bn.getVisual("style");
      Un.lineJoin = "bevel";
      var Hn = Bn.getVisual("decal");
      Hn && (Un.decal = createOrUpdatePatternFromDecal(Hn, Ln));
      var zn = getSectorCornerRadius(Nn.getModel("itemStyle"), Pn, !0);
      extend(Pn, zn), each$f(SPECIAL_STATES, function(Xn) {
        var ea = $n.ensureState(Xn), ta = Nn.getModel([Xn, "itemStyle"]);
        ea.style = ta.getItemStyle();
        var na = getSectorCornerRadius(ta, Pn);
        na && (ea.shape = na);
      }), Cn ? ($n.setShape(Pn), $n.shape.r = Fn.r0, initProps($n, {
        shape: {
          r: Fn.r
        }
      }, In, Bn.dataIndex)) : (updateProps$1($n, {
        shape: Pn
      }, In), saveOldStyle($n)), $n.useStyle(Un), this._updateLabel(In);
      var Gn = Nn.getShallow("cursor");
      Gn && $n.attr("cursor", Gn), this._seriesModel = In || this._seriesModel, this._ecModel = Dn || this._ecModel;
      var Yn = Rn.get("focus"), Wn = Yn === "relative" ? concatArray(Bn.getAncestorsIndices(), Bn.getDescendantIndices()) : Yn === "ancestor" ? Bn.getAncestorsIndices() : Yn === "descendant" ? Bn.getDescendantIndices() : Yn;
      toggleHoverEmphasis(this, Wn, Rn.get("blurScope"), Rn.get("disabled"));
    }, nr.prototype._updateLabel = function(Cn) {
      var Bn = this, In = this.node.getModel(), Dn = In.getModel("label"), Ln = this.node.getLayout(), $n = Ln.endAngle - Ln.startAngle, Nn = (Ln.startAngle + Ln.endAngle) / 2, Rn = Math.cos(Nn), Fn = Math.sin(Nn), Pn = this, Un = Pn.getTextContent(), Hn = this.node.dataIndex, zn = Dn.get("minAngle") / 180 * Math.PI, Gn = Dn.get("show") && !(zn != null && Math.abs($n) < zn);
      Un.ignore = !Gn, each$f(DISPLAY_STATES, function(Wn) {
        var Xn = Wn === "normal" ? In.getModel("label") : In.getModel([Wn, "label"]), ea = Wn === "normal", ta = ea ? Un : Un.ensureState(Wn), na = Cn.getFormattedLabel(Hn, Wn);
        ea && (na = na || Bn.node.name), ta.style = createTextStyle$1(Xn, {}, null, Wn !== "normal", !0), na && (ta.style.text = na);
        var ra = Xn.get("show");
        ra != null && !ea && (ta.ignore = !ra);
        var aa = Yn(Xn, "position"), ia = ea ? Pn : Pn.states[Wn], Aa = ia.style.fill;
        ia.textConfig = {
          outsideFill: Xn.get("color") === "inherit" ? Aa : null,
          inside: aa !== "outside"
        };
        var sa, oa = Yn(Xn, "distance") || 0, la = Yn(Xn, "align"), ua = Yn(Xn, "rotate"), ca = Math.PI * 0.5, fa = Math.PI * 1.5, ha = normalizeRadian(ua === "tangential" ? Math.PI / 2 - Nn : Nn), pa = ha > ca && !isRadianAroundZero(ha - ca) && ha < fa;
        aa === "outside" ? (sa = Ln.r + oa, la = pa ? "right" : "left") : !la || la === "center" ? ($n === 2 * Math.PI && Ln.r0 === 0 ? sa = 0 : sa = (Ln.r + Ln.r0) / 2, la = "center") : la === "left" ? (sa = Ln.r0 + oa, la = pa ? "right" : "left") : la === "right" && (sa = Ln.r - oa, la = pa ? "left" : "right"), ta.style.align = la, ta.style.verticalAlign = Yn(Xn, "verticalAlign") || "middle", ta.x = sa * Rn + Ln.cx, ta.y = sa * Fn + Ln.cy;
        var ya = 0;
        ua === "radial" ? ya = normalizeRadian(-Nn) + (pa ? Math.PI : 0) : ua === "tangential" ? ya = normalizeRadian(Math.PI / 2 - Nn) + (pa ? Math.PI : 0) : isNumber(ua) && (ya = ua * Math.PI / 180), ta.rotation = normalizeRadian(ya);
      });
      function Yn(Wn, Xn) {
        var ea = Wn.get(Xn);
        return ea ?? Dn.get(Xn);
      }
      Un.dirtyStyle();
    }, nr;
  }(Sector$1)
);
const SunburstPiece$1 = SunburstPiece;
var ROOT_TO_NODE_ACTION = "sunburstRootToNode", HIGHLIGHT_ACTION = "sunburstHighlight", UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
function installSunburstAction(_n) {
  _n.registerAction({
    type: ROOT_TO_NODE_ACTION,
    update: "updateView"
  }, function(nr, Cn) {
    Cn.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: nr
    }, Bn);
    function Bn(In, Dn) {
      var Ln = retrieveTargetInfo(nr, [ROOT_TO_NODE_ACTION], In);
      if (Ln) {
        var $n = In.getViewRoot();
        $n && (nr.direction = aboveViewRoot($n, Ln.node) ? "rollUp" : "drillDown"), In.resetViewRoot(Ln.node);
      }
    }
  }), _n.registerAction({
    type: HIGHLIGHT_ACTION,
    update: "none"
  }, function(nr, Cn, Bn) {
    nr = extend({}, nr), Cn.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: nr
    }, In);
    function In(Dn) {
      var Ln = retrieveTargetInfo(nr, [HIGHLIGHT_ACTION], Dn);
      Ln && (nr.dataIndex = Ln.node.dataIndex);
    }
    process.env.NODE_ENV !== "production" && deprecateReplaceLog("sunburstHighlight", "highlight"), Bn.dispatchAction(extend(nr, {
      type: "highlight"
    }));
  }), _n.registerAction({
    type: UNHIGHLIGHT_ACTION,
    update: "updateView"
  }, function(nr, Cn, Bn) {
    nr = extend({}, nr), process.env.NODE_ENV !== "production" && deprecateReplaceLog("sunburstUnhighlight", "downplay"), Bn.dispatchAction(extend(nr, {
      type: "downplay"
    }));
  });
}
var SunburstView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      var Ln = this;
      this.seriesModel = Cn, this.api = In, this.ecModel = Bn;
      var $n = Cn.getData(), Nn = $n.tree.root, Rn = Cn.getViewRoot(), Fn = this.group, Pn = Cn.get("renderLabelForZeroData"), Un = [];
      Rn.eachNode(function(Xn) {
        Un.push(Xn);
      });
      var Hn = this._oldChildren || [];
      zn(Un, Hn), Wn(Nn, Rn), this._initEvents(), this._oldChildren = Un;
      function zn(Xn, ea) {
        if (Xn.length === 0 && ea.length === 0)
          return;
        new DataDiffer$1(ea, Xn, ta, ta).add(na).update(na).remove(curry$1(na, null)).execute();
        function ta(ra) {
          return ra.getId();
        }
        function na(ra, aa) {
          var ia = ra == null ? null : Xn[ra], Aa = aa == null ? null : ea[aa];
          Gn(ia, Aa);
        }
      }
      function Gn(Xn, ea) {
        if (!Pn && Xn && !Xn.getValue() && (Xn = null), Xn !== Nn && ea !== Nn) {
          if (ea && ea.piece)
            Xn ? (ea.piece.updateData(!1, Xn, Cn, Bn, In), $n.setItemGraphicEl(Xn.dataIndex, ea.piece)) : Yn(ea);
          else if (Xn) {
            var ta = new SunburstPiece$1(Xn, Cn, Bn, In);
            Fn.add(ta), $n.setItemGraphicEl(Xn.dataIndex, ta);
          }
        }
      }
      function Yn(Xn) {
        Xn && Xn.piece && (Fn.remove(Xn.piece), Xn.piece = null);
      }
      function Wn(Xn, ea) {
        ea.depth > 0 ? (Ln.virtualPiece ? Ln.virtualPiece.updateData(!1, Xn, Cn, Bn, In) : (Ln.virtualPiece = new SunburstPiece$1(Xn, Cn, Bn, In), Fn.add(Ln.virtualPiece)), ea.piece.off("click"), Ln.virtualPiece.on("click", function(ta) {
          Ln._rootToNode(ea.parentNode);
        })) : Ln.virtualPiece && (Fn.remove(Ln.virtualPiece), Ln.virtualPiece = null);
      }
    }, nr.prototype._initEvents = function() {
      var Cn = this;
      this.group.off("click"), this.group.on("click", function(Bn) {
        var In = !1, Dn = Cn.seriesModel.getViewRoot();
        Dn.eachNode(function(Ln) {
          if (!In && Ln.piece && Ln.piece === Bn.target) {
            var $n = Ln.getModel().get("nodeClick");
            if ($n === "rootToNode")
              Cn._rootToNode(Ln);
            else if ($n === "link") {
              var Nn = Ln.getModel(), Rn = Nn.get("link");
              if (Rn) {
                var Fn = Nn.get("target", !0) || "_blank";
                windowOpen(Rn, Fn);
              }
            }
            In = !0;
          }
        });
      });
    }, nr.prototype._rootToNode = function(Cn) {
      Cn !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: ROOT_TO_NODE_ACTION,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: Cn
      });
    }, nr.prototype.containPoint = function(Cn, Bn) {
      var In = Bn.getData(), Dn = In.getItemLayout(0);
      if (Dn) {
        var Ln = Cn[0] - Dn.cx, $n = Cn[1] - Dn.cy, Nn = Math.sqrt(Ln * Ln + $n * $n);
        return Nn <= Dn.r && Nn >= Dn.r0;
      }
    }, nr.type = "sunburst", nr;
  }(ChartView$1)
);
const SunburstView$1 = SunburstView;
var SunburstSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.ignoreStyleOnData = !0, Cn;
    }
    return nr.prototype.getInitialData = function(Cn, Bn) {
      var In = {
        name: Cn.name,
        children: Cn.data
      };
      completeTreeValue(In);
      var Dn = this._levelModels = map$1(Cn.levels || [], function(Nn) {
        return new Model$1(Nn, this, Bn);
      }, this), Ln = Tree$1.createTree(In, this, $n);
      function $n(Nn) {
        Nn.wrapMethod("getItemModel", function(Rn, Fn) {
          var Pn = Ln.getNodeByDataIndex(Fn), Un = Dn[Pn.depth];
          return Un && (Rn.parentModel = Un), Rn;
        });
      }
      return Ln.data;
    }, nr.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, nr.prototype.getDataParams = function(Cn) {
      var Bn = _n.prototype.getDataParams.apply(this, arguments), In = this.getData().tree.getNodeByDataIndex(Cn);
      return Bn.treePathInfo = wrapTreePathInfo(In, this), Bn;
    }, nr.prototype.getLevelModel = function(Cn) {
      return this._levelModels && this._levelModels[Cn.depth];
    }, nr.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, nr.prototype.resetViewRoot = function(Cn) {
      Cn ? this._viewRoot = Cn : Cn = this._viewRoot;
      var Bn = this.getRawData().tree.root;
      (!Cn || Cn !== Bn && !Bn.contains(Cn)) && (this._viewRoot = Bn);
    }, nr.prototype.enableAriaDecal = function() {
      enableAriaDecalForTree(this);
    }, nr.type = "series.sunburst", nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      // 最小角度改为0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, nr;
  }(SeriesModel$1)
);
function completeTreeValue(_n) {
  var nr = 0;
  each$f(_n.children, function(Bn) {
    completeTreeValue(Bn);
    var In = Bn.value;
    isArray$4(In) && (In = In[0]), nr += In;
  });
  var Cn = _n.value;
  isArray$4(Cn) && (Cn = Cn[0]), (Cn == null || isNaN(Cn)) && (Cn = nr), Cn < 0 && (Cn = 0), isArray$4(_n.value) ? _n.value[0] = Cn : _n.value = Cn;
}
const SunburstSeriesModel$1 = SunburstSeriesModel;
var RADIAN = Math.PI / 180;
function sunburstLayout(_n, nr, Cn) {
  nr.eachSeriesByType(_n, function(Bn) {
    var In = Bn.get("center"), Dn = Bn.get("radius");
    isArray$4(Dn) || (Dn = [0, Dn]), isArray$4(In) || (In = [In, In]);
    var Ln = Cn.getWidth(), $n = Cn.getHeight(), Nn = Math.min(Ln, $n), Rn = parsePercent(In[0], Ln), Fn = parsePercent(In[1], $n), Pn = parsePercent(Dn[0], Nn / 2), Un = parsePercent(Dn[1], Nn / 2), Hn = -Bn.get("startAngle") * RADIAN, zn = Bn.get("minAngle") * RADIAN, Gn = Bn.getData().tree.root, Yn = Bn.getViewRoot(), Wn = Yn.depth, Xn = Bn.get("sort");
    Xn != null && initChildren(Yn, Xn);
    var ea = 0;
    each$f(Yn.children, function(ha) {
      !isNaN(ha.getValue()) && ea++;
    });
    var ta = Yn.getValue(), na = Math.PI / (ta || ea) * 2, ra = Yn.depth > 0, aa = Yn.height - (ra ? -1 : 1), ia = (Un - Pn) / (aa || 1), Aa = Bn.get("clockwise"), sa = Bn.get("stillShowZeroSum"), oa = Aa ? 1 : -1, la = function(ha, pa) {
      if (ha) {
        var ya = pa;
        if (ha !== Gn) {
          var da = ha.getValue(), Ca = ta === 0 && sa ? na : da * na;
          Ca < zn && (Ca = zn), ya = pa + oa * Ca;
          var ma = ha.depth - Wn - (ra ? -1 : 1), va = Pn + ia * ma, ga = Pn + ia * (ma + 1), xa = Bn.getLevelModel(ha);
          if (xa) {
            var wa = xa.get("r0", !0), ba = xa.get("r", !0), Ta = xa.get("radius", !0);
            Ta != null && (wa = Ta[0], ba = Ta[1]), wa != null && (va = parsePercent(wa, Nn / 2)), ba != null && (ga = parsePercent(ba, Nn / 2));
          }
          ha.setLayout({
            angle: Ca,
            startAngle: pa,
            endAngle: ya,
            clockwise: Aa,
            cx: Rn,
            cy: Fn,
            r0: va,
            r: ga
          });
        }
        if (ha.children && ha.children.length) {
          var Sa = 0;
          each$f(ha.children, function(Ea) {
            Sa += la(Ea, pa + Sa);
          });
        }
        return ya - pa;
      }
    };
    if (ra) {
      var ua = Pn, ca = Pn + ia, fa = Math.PI * 2;
      Gn.setLayout({
        angle: fa,
        startAngle: Hn,
        endAngle: Hn + fa,
        clockwise: Aa,
        cx: Rn,
        cy: Fn,
        r0: ua,
        r: ca
      });
    }
    la(Yn, Hn);
  });
}
function initChildren(_n, nr) {
  var Cn = _n.children || [];
  _n.children = sort(Cn, nr), Cn.length && each$f(_n.children, function(Bn) {
    initChildren(Bn, nr);
  });
}
function sort(_n, nr) {
  if (isFunction$1(nr)) {
    var Cn = map$1(_n, function(In, Dn) {
      var Ln = In.getValue();
      return {
        params: {
          depth: In.depth,
          height: In.height,
          dataIndex: In.dataIndex,
          getValue: function() {
            return Ln;
          }
        },
        index: Dn
      };
    });
    return Cn.sort(function(In, Dn) {
      return nr(In.params, Dn.params);
    }), map$1(Cn, function(In) {
      return _n[In.index];
    });
  } else {
    var Bn = nr === "asc";
    return _n.sort(function(In, Dn) {
      var Ln = (In.getValue() - Dn.getValue()) * (Bn ? 1 : -1);
      return Ln === 0 ? (In.dataIndex - Dn.dataIndex) * (Bn ? -1 : 1) : Ln;
    });
  }
}
function sunburstVisual(_n) {
  var nr = {};
  function Cn(Bn, In, Dn) {
    for (var Ln = Bn; Ln && Ln.depth > 1; )
      Ln = Ln.parentNode;
    var $n = In.getColorFromPalette(Ln.name || Ln.dataIndex + "", nr);
    return Bn.depth > 1 && isString$1($n) && ($n = lift($n, (Bn.depth - 1) / (Dn - 1) * 0.5)), $n;
  }
  _n.eachSeriesByType("sunburst", function(Bn) {
    var In = Bn.getData(), Dn = In.tree;
    Dn.eachNode(function(Ln) {
      var $n = Ln.getModel(), Nn = $n.getModel("itemStyle").getItemStyle();
      Nn.fill || (Nn.fill = Cn(Ln, Bn, Dn.root.height));
      var Rn = In.ensureUniqueItemVisual(Ln.dataIndex, "style");
      extend(Rn, Nn);
    });
  });
}
function install$s(_n) {
  _n.registerChartView(SunburstView$1), _n.registerSeriesModel(SunburstSeriesModel$1), _n.registerLayout(curry$1(sunburstLayout, "sunburst")), _n.registerProcessor(curry$1(dataFilter$1, "sunburst")), _n.registerVisual(sunburstVisual), installSunburstAction(_n);
}
var STYLE_VISUAL_TYPE = {
  color: "fill",
  borderColor: "stroke"
}, NON_STYLE_VISUAL_PROPS = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, customInnerStore = makeInner(), CustomSeriesModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, nr.prototype.getInitialData = function(Cn, Bn) {
      return createSeriesData(null, this);
    }, nr.prototype.getDataParams = function(Cn, Bn, In) {
      var Dn = _n.prototype.getDataParams.call(this, Cn, Bn);
      return In && (Dn.info = customInnerStore(In).info), Dn;
    }, nr.type = "series.custom", nr.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], nr.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, nr;
  }(SeriesModel$1)
);
const CustomSeriesModel$1 = CustomSeriesModel;
function dataToCoordSize$3(_n, nr) {
  return nr = nr || [0, 0], map$1(["x", "y"], function(Cn, Bn) {
    var In = this.getAxis(Cn), Dn = nr[Bn], Ln = _n[Bn] / 2;
    return In.type === "category" ? In.getBandWidth() : Math.abs(In.dataToCoord(Dn - Ln) - In.dataToCoord(Dn + Ln));
  }, this);
}
function cartesianPrepareCustom(_n) {
  var nr = _n.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: nr.x,
      y: nr.y,
      width: nr.width,
      height: nr.height
    },
    api: {
      coord: function(Cn) {
        return _n.dataToPoint(Cn);
      },
      size: bind$1(dataToCoordSize$3, _n)
    }
  };
}
function dataToCoordSize$2(_n, nr) {
  return nr = nr || [0, 0], map$1([0, 1], function(Cn) {
    var Bn = nr[Cn], In = _n[Cn] / 2, Dn = [], Ln = [];
    return Dn[Cn] = Bn - In, Ln[Cn] = Bn + In, Dn[1 - Cn] = Ln[1 - Cn] = nr[1 - Cn], Math.abs(this.dataToPoint(Dn)[Cn] - this.dataToPoint(Ln)[Cn]);
  }, this);
}
function geoPrepareCustom(_n) {
  var nr = _n.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: nr.x,
      y: nr.y,
      width: nr.width,
      height: nr.height,
      zoom: _n.getZoom()
    },
    api: {
      coord: function(Cn) {
        return _n.dataToPoint(Cn);
      },
      size: bind$1(dataToCoordSize$2, _n)
    }
  };
}
function dataToCoordSize$1(_n, nr) {
  var Cn = this.getAxis(), Bn = nr instanceof Array ? nr[0] : nr, In = (_n instanceof Array ? _n[0] : _n) / 2;
  return Cn.type === "category" ? Cn.getBandWidth() : Math.abs(Cn.dataToCoord(Bn - In) - Cn.dataToCoord(Bn + In));
}
function singlePrepareCustom(_n) {
  var nr = _n.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: nr.x,
      y: nr.y,
      width: nr.width,
      height: nr.height
    },
    api: {
      coord: function(Cn) {
        return _n.dataToPoint(Cn);
      },
      size: bind$1(dataToCoordSize$1, _n)
    }
  };
}
function dataToCoordSize(_n, nr) {
  return nr = nr || [0, 0], map$1(["Radius", "Angle"], function(Cn, Bn) {
    var In = "get" + Cn + "Axis", Dn = this[In](), Ln = nr[Bn], $n = _n[Bn] / 2, Nn = Dn.type === "category" ? Dn.getBandWidth() : Math.abs(Dn.dataToCoord(Ln - $n) - Dn.dataToCoord(Ln + $n));
    return Cn === "Angle" && (Nn = Nn * Math.PI / 180), Nn;
  }, this);
}
function polarPrepareCustom(_n) {
  var nr = _n.getRadiusAxis(), Cn = _n.getAngleAxis(), Bn = nr.getExtent();
  return Bn[0] > Bn[1] && Bn.reverse(), {
    coordSys: {
      type: "polar",
      cx: _n.cx,
      cy: _n.cy,
      r: Bn[1],
      r0: Bn[0]
    },
    api: {
      coord: function(In) {
        var Dn = nr.dataToRadius(In[0]), Ln = Cn.dataToAngle(In[1]), $n = _n.coordToPoint([Dn, Ln]);
        return $n.push(Dn, Ln * Math.PI / 180), $n;
      },
      size: bind$1(dataToCoordSize, _n)
    }
  };
}
function calendarPrepareCustom(_n) {
  var nr = _n.getRect(), Cn = _n.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: nr.x,
      y: nr.y,
      width: nr.width,
      height: nr.height,
      cellWidth: _n.getCellWidth(),
      cellHeight: _n.getCellHeight(),
      rangeInfo: {
        start: Cn.start,
        end: Cn.end,
        weeks: Cn.weeks,
        dayCount: Cn.allDay
      }
    },
    api: {
      coord: function(Bn, In) {
        return _n.dataToPoint(Bn, In);
      }
    }
  };
}
var deprecatedLogs = {};
function isEC4CompatibleStyle(_n, nr, Cn, Bn) {
  return _n && (_n.legacy || _n.legacy !== !1 && !Cn && !Bn && nr !== "tspan" && (nr === "text" || hasOwn(_n, "text")));
}
function convertFromEC4CompatibleStyle(_n, nr, Cn) {
  var Bn = _n, In, Dn, Ln;
  if (nr === "text")
    Ln = Bn;
  else {
    Ln = {}, hasOwn(Bn, "text") && (Ln.text = Bn.text), hasOwn(Bn, "rich") && (Ln.rich = Bn.rich), hasOwn(Bn, "textFill") && (Ln.fill = Bn.textFill), hasOwn(Bn, "textStroke") && (Ln.stroke = Bn.textStroke), hasOwn(Bn, "fontFamily") && (Ln.fontFamily = Bn.fontFamily), hasOwn(Bn, "fontSize") && (Ln.fontSize = Bn.fontSize), hasOwn(Bn, "fontStyle") && (Ln.fontStyle = Bn.fontStyle), hasOwn(Bn, "fontWeight") && (Ln.fontWeight = Bn.fontWeight), Dn = {
      type: "text",
      style: Ln,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, In = {};
    var $n = hasOwn(Bn, "textPosition");
    Cn ? In.position = $n ? Bn.textPosition : "inside" : $n && (In.position = Bn.textPosition), hasOwn(Bn, "textPosition") && (In.position = Bn.textPosition), hasOwn(Bn, "textOffset") && (In.offset = Bn.textOffset), hasOwn(Bn, "textRotation") && (In.rotation = Bn.textRotation), hasOwn(Bn, "textDistance") && (In.distance = Bn.textDistance);
  }
  return convertEC4CompatibleRichItem(Ln, _n), each$f(Ln.rich, function(Nn) {
    convertEC4CompatibleRichItem(Nn, Nn);
  }), {
    textConfig: In,
    textContent: Dn
  };
}
function convertEC4CompatibleRichItem(_n, nr) {
  nr && (nr.font = nr.textFont || nr.font, hasOwn(nr, "textStrokeWidth") && (_n.lineWidth = nr.textStrokeWidth), hasOwn(nr, "textAlign") && (_n.align = nr.textAlign), hasOwn(nr, "textVerticalAlign") && (_n.verticalAlign = nr.textVerticalAlign), hasOwn(nr, "textLineHeight") && (_n.lineHeight = nr.textLineHeight), hasOwn(nr, "textWidth") && (_n.width = nr.textWidth), hasOwn(nr, "textHeight") && (_n.height = nr.textHeight), hasOwn(nr, "textBackgroundColor") && (_n.backgroundColor = nr.textBackgroundColor), hasOwn(nr, "textPadding") && (_n.padding = nr.textPadding), hasOwn(nr, "textBorderColor") && (_n.borderColor = nr.textBorderColor), hasOwn(nr, "textBorderWidth") && (_n.borderWidth = nr.textBorderWidth), hasOwn(nr, "textBorderRadius") && (_n.borderRadius = nr.textBorderRadius), hasOwn(nr, "textBoxShadowColor") && (_n.shadowColor = nr.textBoxShadowColor), hasOwn(nr, "textBoxShadowBlur") && (_n.shadowBlur = nr.textBoxShadowBlur), hasOwn(nr, "textBoxShadowOffsetX") && (_n.shadowOffsetX = nr.textBoxShadowOffsetX), hasOwn(nr, "textBoxShadowOffsetY") && (_n.shadowOffsetY = nr.textBoxShadowOffsetY));
}
function convertToEC4StyleForCustomSerise(_n, nr, Cn) {
  var Bn = _n;
  Bn.textPosition = Bn.textPosition || Cn.position || "inside", Cn.offset != null && (Bn.textOffset = Cn.offset), Cn.rotation != null && (Bn.textRotation = Cn.rotation), Cn.distance != null && (Bn.textDistance = Cn.distance);
  var In = Bn.textPosition.indexOf("inside") >= 0, Dn = _n.fill || "#000";
  convertToEC4RichItem(Bn, nr);
  var Ln = Bn.textFill == null;
  return In ? Ln && (Bn.textFill = Cn.insideFill || "#fff", !Bn.textStroke && Cn.insideStroke && (Bn.textStroke = Cn.insideStroke), !Bn.textStroke && (Bn.textStroke = Dn), Bn.textStrokeWidth == null && (Bn.textStrokeWidth = 2)) : (Ln && (Bn.textFill = _n.fill || Cn.outsideFill || "#000"), !Bn.textStroke && Cn.outsideStroke && (Bn.textStroke = Cn.outsideStroke)), Bn.text = nr.text, Bn.rich = nr.rich, each$f(nr.rich, function($n) {
    convertToEC4RichItem($n, $n);
  }), Bn;
}
function convertToEC4RichItem(_n, nr) {
  nr && (hasOwn(nr, "fill") && (_n.textFill = nr.fill), hasOwn(nr, "stroke") && (_n.textStroke = nr.fill), hasOwn(nr, "lineWidth") && (_n.textStrokeWidth = nr.lineWidth), hasOwn(nr, "font") && (_n.font = nr.font), hasOwn(nr, "fontStyle") && (_n.fontStyle = nr.fontStyle), hasOwn(nr, "fontWeight") && (_n.fontWeight = nr.fontWeight), hasOwn(nr, "fontSize") && (_n.fontSize = nr.fontSize), hasOwn(nr, "fontFamily") && (_n.fontFamily = nr.fontFamily), hasOwn(nr, "align") && (_n.textAlign = nr.align), hasOwn(nr, "verticalAlign") && (_n.textVerticalAlign = nr.verticalAlign), hasOwn(nr, "lineHeight") && (_n.textLineHeight = nr.lineHeight), hasOwn(nr, "width") && (_n.textWidth = nr.width), hasOwn(nr, "height") && (_n.textHeight = nr.height), hasOwn(nr, "backgroundColor") && (_n.textBackgroundColor = nr.backgroundColor), hasOwn(nr, "padding") && (_n.textPadding = nr.padding), hasOwn(nr, "borderColor") && (_n.textBorderColor = nr.borderColor), hasOwn(nr, "borderWidth") && (_n.textBorderWidth = nr.borderWidth), hasOwn(nr, "borderRadius") && (_n.textBorderRadius = nr.borderRadius), hasOwn(nr, "shadowColor") && (_n.textBoxShadowColor = nr.shadowColor), hasOwn(nr, "shadowBlur") && (_n.textBoxShadowBlur = nr.shadowBlur), hasOwn(nr, "shadowOffsetX") && (_n.textBoxShadowOffsetX = nr.shadowOffsetX), hasOwn(nr, "shadowOffsetY") && (_n.textBoxShadowOffsetY = nr.shadowOffsetY), hasOwn(nr, "textShadowColor") && (_n.textShadowColor = nr.textShadowColor), hasOwn(nr, "textShadowBlur") && (_n.textShadowBlur = nr.textShadowBlur), hasOwn(nr, "textShadowOffsetX") && (_n.textShadowOffsetX = nr.textShadowOffsetX), hasOwn(nr, "textShadowOffsetY") && (_n.textShadowOffsetY = nr.textShadowOffsetY));
}
function warnDeprecated(_n, nr) {
  if (process.env.NODE_ENV !== "production") {
    var Cn = _n + "^_^" + nr;
    deprecatedLogs[Cn] || (console.warn('[ECharts] DEPRECATED: "' + _n + '" has been deprecated. ' + nr), deprecatedLogs[Cn] = !0);
  }
}
var LEGACY_TRANSFORM_PROPS_MAP = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP), TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function(_n, nr) {
  return _n[nr] = 1, _n;
}, {}), transformPropNamesStr = TRANSFORMABLE_PROPS.join(", "), ELEMENT_ANIMATABLE_PROPS = ["", "style", "shape", "extra"], transitionInnerStore = makeInner();
function getElementAnimationConfig(_n, nr, Cn, Bn, In) {
  var Dn = _n + "Animation", Ln = getAnimationConfig(_n, Bn, In) || {}, $n = transitionInnerStore(nr).userDuring;
  return Ln.duration > 0 && (Ln.during = $n ? bind$1(duringCall, {
    el: nr,
    userDuring: $n
  }) : null, Ln.setToFinal = !0, Ln.scope = _n), extend(Ln, Cn[Dn]), Ln;
}
function applyUpdateTransition(_n, nr, Cn, Bn) {
  Bn = Bn || {};
  var In = Bn.dataIndex, Dn = Bn.isInit, Ln = Bn.clearStyle, $n = Cn.isAnimationEnabled(), Nn = transitionInnerStore(_n), Rn = nr.style;
  Nn.userDuring = nr.during;
  var Fn = {}, Pn = {};
  if (prepareTransformAllPropsFinal(_n, nr, Pn), prepareShapeOrExtraAllPropsFinal("shape", nr, Pn), prepareShapeOrExtraAllPropsFinal("extra", nr, Pn), !Dn && $n && (prepareTransformTransitionFrom(_n, nr, Fn), prepareShapeOrExtraTransitionFrom("shape", _n, nr, Fn), prepareShapeOrExtraTransitionFrom("extra", _n, nr, Fn), prepareStyleTransitionFrom(_n, nr, Rn, Fn)), Pn.style = Rn, applyPropsDirectly(_n, Pn, Ln), applyMiscProps(_n, nr), $n)
    if (Dn) {
      var Un = {};
      each$f(ELEMENT_ANIMATABLE_PROPS, function(zn) {
        var Gn = zn ? nr[zn] : nr;
        Gn && Gn.enterFrom && (zn && (Un[zn] = Un[zn] || {}), extend(zn ? Un[zn] : Un, Gn.enterFrom));
      });
      var Hn = getElementAnimationConfig("enter", _n, nr, Cn, In);
      Hn.duration > 0 && _n.animateFrom(Un, Hn);
    } else
      applyPropsTransition(_n, nr, In || 0, Cn, Fn);
  updateLeaveTo(_n, nr), Rn ? _n.dirty() : _n.markRedraw();
}
function updateLeaveTo(_n, nr) {
  for (var Cn = transitionInnerStore(_n).leaveToProps, Bn = 0; Bn < ELEMENT_ANIMATABLE_PROPS.length; Bn++) {
    var In = ELEMENT_ANIMATABLE_PROPS[Bn], Dn = In ? nr[In] : nr;
    Dn && Dn.leaveTo && (Cn || (Cn = transitionInnerStore(_n).leaveToProps = {}), In && (Cn[In] = Cn[In] || {}), extend(In ? Cn[In] : Cn, Dn.leaveTo));
  }
}
function applyLeaveTransition(_n, nr, Cn, Bn) {
  if (_n) {
    var In = _n.parent, Dn = transitionInnerStore(_n).leaveToProps;
    if (Dn) {
      var Ln = getElementAnimationConfig("update", _n, nr, Cn, 0);
      Ln.done = function() {
        In.remove(_n), Bn && Bn();
      }, _n.animateTo(Dn, Ln);
    } else
      In.remove(_n), Bn && Bn();
  }
}
function isTransitionAll(_n) {
  return _n === "all";
}
function applyPropsDirectly(_n, nr, Cn) {
  var Bn = nr.style;
  if (!_n.isGroup && Bn) {
    if (Cn) {
      _n.useStyle({});
      for (var In = _n.animators, Dn = 0; Dn < In.length; Dn++) {
        var Ln = In[Dn];
        Ln.targetName === "style" && Ln.changeTarget(_n.style);
      }
    }
    _n.setStyle(Bn);
  }
  nr && (nr.style = null, nr && _n.attr(nr), nr.style = Bn);
}
function applyPropsTransition(_n, nr, Cn, Bn, In) {
  if (In) {
    var Dn = getElementAnimationConfig("update", _n, nr, Bn, Cn);
    Dn.duration > 0 && _n.animateFrom(In, Dn);
  }
}
function applyMiscProps(_n, nr) {
  hasOwn(nr, "silent") && (_n.silent = nr.silent), hasOwn(nr, "ignore") && (_n.ignore = nr.ignore), _n instanceof Displayable$1 && hasOwn(nr, "invisible") && (_n.invisible = nr.invisible), _n instanceof Path$1 && hasOwn(nr, "autoBatch") && (_n.autoBatch = nr.autoBatch);
}
var tmpDuringScope = {}, transitionDuringAPI = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(_n, nr) {
    return process.env.NODE_ENV !== "production" && assert(hasOwn(TRANSFORM_PROPS_MAP, _n), "Only " + transformPropNamesStr + " available in `setTransform`."), tmpDuringScope.el[_n] = nr, this;
  },
  getTransform: function(_n) {
    return process.env.NODE_ENV !== "production" && assert(hasOwn(TRANSFORM_PROPS_MAP, _n), "Only " + transformPropNamesStr + " available in `getTransform`."), tmpDuringScope.el[_n];
  },
  setShape: function(_n, nr) {
    process.env.NODE_ENV !== "production" && assertNotReserved(_n);
    var Cn = tmpDuringScope.el, Bn = Cn.shape || (Cn.shape = {});
    return Bn[_n] = nr, Cn.dirtyShape && Cn.dirtyShape(), this;
  },
  getShape: function(_n) {
    process.env.NODE_ENV !== "production" && assertNotReserved(_n);
    var nr = tmpDuringScope.el.shape;
    if (nr)
      return nr[_n];
  },
  setStyle: function(_n, nr) {
    process.env.NODE_ENV !== "production" && assertNotReserved(_n);
    var Cn = tmpDuringScope.el, Bn = Cn.style;
    return Bn && (process.env.NODE_ENV !== "production" && eqNaN(nr) && warn("style." + _n + " must not be assigned with NaN."), Bn[_n] = nr, Cn.dirtyStyle && Cn.dirtyStyle()), this;
  },
  getStyle: function(_n) {
    process.env.NODE_ENV !== "production" && assertNotReserved(_n);
    var nr = tmpDuringScope.el.style;
    if (nr)
      return nr[_n];
  },
  setExtra: function(_n, nr) {
    process.env.NODE_ENV !== "production" && assertNotReserved(_n);
    var Cn = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
    return Cn[_n] = nr, this;
  },
  getExtra: function(_n) {
    process.env.NODE_ENV !== "production" && assertNotReserved(_n);
    var nr = tmpDuringScope.el.extra;
    if (nr)
      return nr[_n];
  }
};
function assertNotReserved(_n) {
  if (process.env.NODE_ENV !== "production" && (_n === "transition" || _n === "enterFrom" || _n === "leaveTo"))
    throw new Error('key must not be "' + _n + '"');
}
function duringCall() {
  var _n = this, nr = _n.el;
  if (nr) {
    var Cn = transitionInnerStore(nr).userDuring, Bn = _n.userDuring;
    if (Cn !== Bn) {
      _n.el = _n.userDuring = null;
      return;
    }
    tmpDuringScope.el = nr, Bn(transitionDuringAPI);
  }
}
function prepareShapeOrExtraTransitionFrom(_n, nr, Cn, Bn) {
  var In = Cn[_n];
  if (In) {
    var Dn = nr[_n], Ln;
    if (Dn) {
      var $n = Cn.transition, Nn = In.transition;
      if (Nn)
        if (!Ln && (Ln = Bn[_n] = {}), isTransitionAll(Nn))
          extend(Ln, Dn);
        else
          for (var Rn = normalizeToArray(Nn), Fn = 0; Fn < Rn.length; Fn++) {
            var Pn = Rn[Fn], Un = Dn[Pn];
            Ln[Pn] = Un;
          }
      else if (isTransitionAll($n) || indexOf($n, _n) >= 0) {
        !Ln && (Ln = Bn[_n] = {});
        for (var Hn = keys(Dn), Fn = 0; Fn < Hn.length; Fn++) {
          var Pn = Hn[Fn], Un = Dn[Pn];
          isNonStyleTransitionEnabled(In[Pn], Un) && (Ln[Pn] = Un);
        }
      }
    }
  }
}
function prepareShapeOrExtraAllPropsFinal(_n, nr, Cn) {
  var Bn = nr[_n];
  if (Bn)
    for (var In = Cn[_n] = {}, Dn = keys(Bn), Ln = 0; Ln < Dn.length; Ln++) {
      var $n = Dn[Ln];
      In[$n] = cloneValue(Bn[$n]);
    }
}
function prepareTransformTransitionFrom(_n, nr, Cn) {
  for (var Bn = nr.transition, In = isTransitionAll(Bn) ? TRANSFORMABLE_PROPS : normalizeToArray(Bn || []), Dn = 0; Dn < In.length; Dn++) {
    var Ln = In[Dn];
    if (!(Ln === "style" || Ln === "shape" || Ln === "extra")) {
      var $n = _n[Ln];
      process.env.NODE_ENV !== "production" && checkTransformPropRefer(Ln, "el.transition"), Cn[Ln] = $n;
    }
  }
}
function prepareTransformAllPropsFinal(_n, nr, Cn) {
  for (var Bn = 0; Bn < LEGACY_TRANSFORM_PROPS.length; Bn++) {
    var In = LEGACY_TRANSFORM_PROPS[Bn], Dn = LEGACY_TRANSFORM_PROPS_MAP[In], Ln = nr[In];
    Ln && (Cn[Dn[0]] = Ln[0], Cn[Dn[1]] = Ln[1]);
  }
  for (var Bn = 0; Bn < TRANSFORMABLE_PROPS.length; Bn++) {
    var $n = TRANSFORMABLE_PROPS[Bn];
    nr[$n] != null && (Cn[$n] = nr[$n]);
  }
}
function prepareStyleTransitionFrom(_n, nr, Cn, Bn) {
  if (Cn) {
    var In = _n.style, Dn;
    if (In) {
      var Ln = Cn.transition, $n = nr.transition;
      if (Ln && !isTransitionAll(Ln)) {
        var Nn = normalizeToArray(Ln);
        !Dn && (Dn = Bn.style = {});
        for (var Rn = 0; Rn < Nn.length; Rn++) {
          var Fn = Nn[Rn], Pn = In[Fn];
          Dn[Fn] = Pn;
        }
      } else if (_n.getAnimationStyleProps && (isTransitionAll($n) || isTransitionAll(Ln) || indexOf($n, "style") >= 0)) {
        var Un = _n.getAnimationStyleProps(), Hn = Un ? Un.style : null;
        if (Hn) {
          !Dn && (Dn = Bn.style = {});
          for (var zn = keys(Cn), Rn = 0; Rn < zn.length; Rn++) {
            var Fn = zn[Rn];
            if (Hn[Fn]) {
              var Pn = In[Fn];
              Dn[Fn] = Pn;
            }
          }
        }
      }
    }
  }
}
function isNonStyleTransitionEnabled(_n, nr) {
  return isArrayLike$1(_n) ? _n !== nr : _n != null && isFinite(_n);
}
var checkTransformPropRefer;
process.env.NODE_ENV !== "production" && (checkTransformPropRefer = function(_n, nr) {
  hasOwn(TRANSFORM_PROPS_MAP, _n) || warn("Prop `" + _n + "` is not a permitted in `" + nr + "`. Only `" + keys(TRANSFORM_PROPS_MAP).join("`, `") + "` are permitted.");
});
var getStateToRestore = makeInner(), KEYFRAME_EXCLUDE_KEYS = ["percent", "easing", "shape", "style", "extra"];
function stopPreviousKeyframeAnimationAndRestore(_n) {
  _n.stopAnimation("keyframe"), _n.attr(getStateToRestore(_n));
}
function applyKeyframeAnimation(_n, nr, Cn) {
  if (!(!Cn.isAnimationEnabled() || !nr)) {
    if (isArray$4(nr)) {
      each$f(nr, function($n) {
        applyKeyframeAnimation(_n, $n, Cn);
      });
      return;
    }
    var Bn = nr.keyframes, In = nr.duration;
    if (Cn && In == null) {
      var Dn = getAnimationConfig("enter", Cn, 0);
      In = Dn && Dn.duration;
    }
    if (!(!Bn || !In)) {
      var Ln = getStateToRestore(_n);
      each$f(ELEMENT_ANIMATABLE_PROPS, function($n) {
        if (!($n && !_n[$n])) {
          var Nn, Rn = !1;
          Bn.sort(function(Fn, Pn) {
            return Fn.percent - Pn.percent;
          }), each$f(Bn, function(Fn) {
            var Pn = _n.animators, Un = $n ? Fn[$n] : Fn;
            if (process.env.NODE_ENV !== "production" && Fn.percent >= 1 && (Rn = !0), !!Un) {
              var Hn = keys(Un);
              if ($n || (Hn = filter(Hn, function(Yn) {
                return indexOf(KEYFRAME_EXCLUDE_KEYS, Yn) < 0;
              })), !!Hn.length) {
                Nn || (Nn = _n.animate($n, nr.loop, !0), Nn.scope = "keyframe");
                for (var zn = 0; zn < Pn.length; zn++)
                  Pn[zn] !== Nn && Pn[zn].targetName === Nn.targetName && Pn[zn].stopTracks(Hn);
                $n && (Ln[$n] = Ln[$n] || {});
                var Gn = $n ? Ln[$n] : Ln;
                each$f(Hn, function(Yn) {
                  Gn[Yn] = (($n ? _n[$n] : _n) || {})[Yn];
                }), Nn.whenWithKeys(In * Fn.percent, Un, Hn, Fn.easing);
              }
            }
          }), Nn && (process.env.NODE_ENV !== "production" && (Rn || warn("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), Nn.delay(nr.delay || 0).duration(In).start(nr.easing));
        }
      });
    }
  }
}
var EMPHASIS = "emphasis", NORMAL = "normal", BLUR = "blur", SELECT = "select", STATES = [NORMAL, EMPHASIS, BLUR, SELECT], PATH_ITEM_STYLE = {
  normal: ["itemStyle"],
  emphasis: [EMPHASIS, "itemStyle"],
  blur: [BLUR, "itemStyle"],
  select: [SELECT, "itemStyle"]
}, PATH_LABEL = {
  normal: ["label"],
  emphasis: [EMPHASIS, "label"],
  blur: [BLUR, "label"],
  select: [SELECT, "label"]
}, DEFAULT_TRANSITION = ["x", "y"], GROUP_DIFF_PREFIX = "e\0\0", attachedTxInfoTmp = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, prepareCustoms = {
  cartesian2d: cartesianPrepareCustom,
  geo: geoPrepareCustom,
  single: singlePrepareCustom,
  polar: polarPrepareCustom,
  calendar: calendarPrepareCustom
};
function isPath(_n) {
  return _n instanceof Path$1;
}
function isDisplayable(_n) {
  return _n instanceof Displayable$1;
}
function copyElement(_n, nr) {
  nr.copyTransform(_n), isDisplayable(nr) && isDisplayable(_n) && (nr.setStyle(_n.style), nr.z = _n.z, nr.z2 = _n.z2, nr.zlevel = _n.zlevel, nr.invisible = _n.invisible, nr.ignore = _n.ignore, isPath(nr) && isPath(_n) && nr.setShape(_n.shape));
}
var CustomChartView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      this._progressiveEls = null;
      var Ln = this._data, $n = Cn.getData(), Nn = this.group, Rn = makeRenderItem(Cn, $n, Bn, In);
      Ln || Nn.removeAll(), $n.diff(Ln).add(function(Pn) {
        createOrUpdateItem(In, null, Pn, Rn(Pn, Dn), Cn, Nn, $n);
      }).remove(function(Pn) {
        var Un = Ln.getItemGraphicEl(Pn);
        Un && applyLeaveTransition(Un, customInnerStore(Un).option, Cn);
      }).update(function(Pn, Un) {
        var Hn = Ln.getItemGraphicEl(Un);
        createOrUpdateItem(In, Hn, Pn, Rn(Pn, Dn), Cn, Nn, $n);
      }).execute();
      var Fn = Cn.get("clip", !0) ? createClipPath(Cn.coordinateSystem, !1, Cn) : null;
      Fn ? Nn.setClipPath(Fn) : Nn.removeClipPath(), this._data = $n;
    }, nr.prototype.incrementalPrepareRender = function(Cn, Bn, In) {
      this.group.removeAll(), this._data = null;
    }, nr.prototype.incrementalRender = function(Cn, Bn, In, Dn, Ln) {
      var $n = Bn.getData(), Nn = makeRenderItem(Bn, $n, In, Dn), Rn = this._progressiveEls = [];
      function Fn(Hn) {
        Hn.isGroup || (Hn.incremental = !0, Hn.ensureState("emphasis").hoverLayer = !0);
      }
      for (var Pn = Cn.start; Pn < Cn.end; Pn++) {
        var Un = createOrUpdateItem(null, null, Pn, Nn(Pn, Ln), Bn, this.group, $n);
        Un && (Un.traverse(Fn), Rn.push(Un));
      }
    }, nr.prototype.eachRendered = function(Cn) {
      traverseElements(this._progressiveEls || this.group, Cn);
    }, nr.prototype.filterForExposedEvent = function(Cn, Bn, In, Dn) {
      var Ln = Bn.element;
      if (Ln == null || In.name === Ln)
        return !0;
      for (; (In = In.__hostTarget || In.parent) && In !== this.group; )
        if (In.name === Ln)
          return !0;
      return !1;
    }, nr.type = "custom", nr;
  }(ChartView$1)
);
const CustomChartView$1 = CustomChartView;
function createEl$1(_n) {
  var nr = _n.type, Cn;
  if (nr === "path") {
    var Bn = _n.shape, In = Bn.width != null && Bn.height != null ? {
      x: Bn.x || 0,
      y: Bn.y || 0,
      width: Bn.width,
      height: Bn.height
    } : null, Dn = getPathData(Bn);
    Cn = makePath(Dn, null, In, Bn.layout || "center"), customInnerStore(Cn).customPathData = Dn;
  } else if (nr === "image")
    Cn = new ZRImage$1({}), customInnerStore(Cn).customImagePath = _n.style.image;
  else if (nr === "text")
    Cn = new ZRText$1({});
  else if (nr === "group")
    Cn = new Group$4();
  else {
    if (nr === "compoundPath")
      throw new Error('"compoundPath" is not supported yet.');
    var Ln = getShapeClass(nr);
    if (!Ln) {
      var $n = "";
      process.env.NODE_ENV !== "production" && ($n = 'graphic type "' + nr + '" can not be found.'), throwError($n);
    }
    Cn = new Ln();
  }
  return customInnerStore(Cn).customGraphicType = nr, Cn.name = _n.name, Cn.z2EmphasisLift = 1, Cn.z2SelectLift = 1, Cn;
}
function updateElNormal(_n, nr, Cn, Bn, In, Dn, Ln) {
  stopPreviousKeyframeAnimationAndRestore(nr);
  var $n = In && In.normal.cfg;
  $n && nr.setTextConfig($n), Bn && Bn.transition == null && (Bn.transition = DEFAULT_TRANSITION);
  var Nn = Bn && Bn.style;
  if (Nn) {
    if (nr.type === "text") {
      var Rn = Nn;
      hasOwn(Rn, "textFill") && (Rn.fill = Rn.textFill), hasOwn(Rn, "textStroke") && (Rn.stroke = Rn.textStroke);
    }
    var Fn = void 0, Pn = isPath(nr) ? Nn.decal : null;
    _n && Pn && (Pn.dirty = !0, Fn = createOrUpdatePatternFromDecal(Pn, _n)), Nn.__decalPattern = Fn;
  }
  if (isDisplayable(nr) && Nn) {
    var Fn = Nn.__decalPattern;
    Fn && (Nn.decal = Fn);
  }
  applyUpdateTransition(nr, Bn, Dn, {
    dataIndex: Cn,
    isInit: Ln,
    clearStyle: !0
  }), applyKeyframeAnimation(nr, Bn.keyframeAnimation, Dn);
}
function updateElOnState(_n, nr, Cn, Bn, In) {
  var Dn = nr.isGroup ? null : nr, Ln = In && In[_n].cfg;
  if (Dn) {
    var $n = Dn.ensureState(_n);
    if (Bn === !1) {
      var Nn = Dn.getState(_n);
      Nn && (Nn.style = null);
    } else
      $n.style = Bn || null;
    Ln && ($n.textConfig = Ln), setDefaultStateProxy(Dn);
  }
}
function updateZ(_n, nr, Cn) {
  if (!_n.isGroup) {
    var Bn = _n, In = Cn.currentZ, Dn = Cn.currentZLevel;
    Bn.z = In, Bn.zlevel = Dn;
    var Ln = nr.z2;
    Ln != null && (Bn.z2 = Ln || 0);
    for (var $n = 0; $n < STATES.length; $n++)
      updateZForEachState(Bn, nr, STATES[$n]);
  }
}
function updateZForEachState(_n, nr, Cn) {
  var Bn = Cn === NORMAL, In = Bn ? nr : retrieveStateOption(nr, Cn), Dn = In ? In.z2 : null, Ln;
  Dn != null && (Ln = Bn ? _n : _n.ensureState(Cn), Ln.z2 = Dn || 0);
}
function makeRenderItem(_n, nr, Cn, Bn) {
  var In = _n.get("renderItem"), Dn = _n.coordinateSystem, Ln = {};
  Dn && (process.env.NODE_ENV !== "production" && (assert(In, "series.render is required."), assert(Dn.prepareCustoms || prepareCustoms[Dn.type], "This coordSys does not support custom series.")), Ln = Dn.prepareCustoms ? Dn.prepareCustoms(Dn) : prepareCustoms[Dn.type](Dn));
  for (var $n = defaults({
    getWidth: Bn.getWidth,
    getHeight: Bn.getHeight,
    getZr: Bn.getZr,
    getDevicePixelRatio: Bn.getDevicePixelRatio,
    value: ta,
    style: ra,
    ordinalRawValue: na,
    styleEmphasis: aa,
    visual: sa,
    barLayout: oa,
    currentSeriesIndices: la,
    font: ua
  }, Ln.api || {}), Nn = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: _n.id,
    seriesName: _n.name,
    seriesIndex: _n.seriesIndex,
    coordSys: Ln.coordSys,
    dataInsideLength: nr.count(),
    encode: wrapEncodeDef(_n.getData())
  }, Rn, Fn, Pn = {}, Un = {}, Hn = {}, zn = {}, Gn = 0; Gn < STATES.length; Gn++) {
    var Yn = STATES[Gn];
    Hn[Yn] = _n.getModel(PATH_ITEM_STYLE[Yn]), zn[Yn] = _n.getModel(PATH_LABEL[Yn]);
  }
  function Wn(ca) {
    return ca === Rn ? Fn || (Fn = nr.getItemModel(ca)) : nr.getItemModel(ca);
  }
  function Xn(ca, fa) {
    return nr.hasItemOption ? ca === Rn ? Pn[fa] || (Pn[fa] = Wn(ca).getModel(PATH_ITEM_STYLE[fa])) : Wn(ca).getModel(PATH_ITEM_STYLE[fa]) : Hn[fa];
  }
  function ea(ca, fa) {
    return nr.hasItemOption ? ca === Rn ? Un[fa] || (Un[fa] = Wn(ca).getModel(PATH_LABEL[fa])) : Wn(ca).getModel(PATH_LABEL[fa]) : zn[fa];
  }
  return function(ca, fa) {
    return Rn = ca, Fn = null, Pn = {}, Un = {}, In && In(defaults({
      dataIndexInside: ca,
      dataIndex: nr.getRawIndex(ca),
      // Can be used for optimization when zoom or roam.
      actionType: fa ? fa.type : null
    }, Nn), $n);
  };
  function ta(ca, fa) {
    return fa == null && (fa = Rn), nr.getStore().get(nr.getDimensionIndex(ca || 0), fa);
  }
  function na(ca, fa) {
    fa == null && (fa = Rn), ca = ca || 0;
    var ha = nr.getDimensionInfo(ca);
    if (!ha) {
      var pa = nr.getDimensionIndex(ca);
      return pa >= 0 ? nr.getStore().get(pa, fa) : void 0;
    }
    var ya = nr.get(ha.name, fa), da = ha && ha.ordinalMeta;
    return da ? da.categories[ya] : ya;
  }
  function ra(ca, fa) {
    process.env.NODE_ENV !== "production" && warnDeprecated("api.style", "Please write literal style directly instead."), fa == null && (fa = Rn);
    var ha = nr.getItemVisual(fa, "style"), pa = ha && ha.fill, ya = ha && ha.opacity, da = Xn(fa, NORMAL).getItemStyle();
    pa != null && (da.fill = pa), ya != null && (da.opacity = ya);
    var Ca = {
      inheritColor: isString$1(pa) ? pa : "#000"
    }, ma = ea(fa, NORMAL), va = createTextStyle$1(ma, null, Ca, !1, !0);
    va.text = ma.getShallow("show") ? retrieve2(_n.getFormattedLabel(fa, NORMAL), getDefaultLabel(nr, fa)) : null;
    var ga = createTextConfig(ma, Ca, !1);
    return Aa(ca, da), da = convertToEC4StyleForCustomSerise(da, va, ga), ca && ia(da, ca), da.legacy = !0, da;
  }
  function aa(ca, fa) {
    process.env.NODE_ENV !== "production" && warnDeprecated("api.styleEmphasis", "Please write literal style directly instead."), fa == null && (fa = Rn);
    var ha = Xn(fa, EMPHASIS).getItemStyle(), pa = ea(fa, EMPHASIS), ya = createTextStyle$1(pa, null, null, !0, !0);
    ya.text = pa.getShallow("show") ? retrieve3(_n.getFormattedLabel(fa, EMPHASIS), _n.getFormattedLabel(fa, NORMAL), getDefaultLabel(nr, fa)) : null;
    var da = createTextConfig(pa, null, !0);
    return Aa(ca, ha), ha = convertToEC4StyleForCustomSerise(ha, ya, da), ca && ia(ha, ca), ha.legacy = !0, ha;
  }
  function ia(ca, fa) {
    for (var ha in fa)
      hasOwn(fa, ha) && (ca[ha] = fa[ha]);
  }
  function Aa(ca, fa) {
    ca && (ca.textFill && (fa.textFill = ca.textFill), ca.textPosition && (fa.textPosition = ca.textPosition));
  }
  function sa(ca, fa) {
    if (fa == null && (fa = Rn), hasOwn(STYLE_VISUAL_TYPE, ca)) {
      var ha = nr.getItemVisual(fa, "style");
      return ha ? ha[STYLE_VISUAL_TYPE[ca]] : null;
    }
    if (hasOwn(NON_STYLE_VISUAL_PROPS, ca))
      return nr.getItemVisual(fa, ca);
  }
  function oa(ca) {
    if (Dn.type === "cartesian2d") {
      var fa = Dn.getBaseAxis();
      return getLayoutOnAxis(defaults({
        axis: fa
      }, ca));
    }
  }
  function la() {
    return Cn.getCurrentSeriesIndices();
  }
  function ua(ca) {
    return getFont(ca, Cn);
  }
}
function wrapEncodeDef(_n) {
  var nr = {};
  return each$f(_n.dimensions, function(Cn) {
    var Bn = _n.getDimensionInfo(Cn);
    if (!Bn.isExtraCoord) {
      var In = Bn.coordDim, Dn = nr[In] = nr[In] || [];
      Dn[Bn.coordDimIndex] = _n.getDimensionIndex(Cn);
    }
  }), nr;
}
function createOrUpdateItem(_n, nr, Cn, Bn, In, Dn, Ln) {
  if (!Bn) {
    Dn.remove(nr);
    return;
  }
  var $n = doCreateOrUpdateEl(_n, nr, Cn, Bn, In, Dn);
  return $n && Ln.setItemGraphicEl(Cn, $n), $n && toggleHoverEmphasis($n, Bn.focus, Bn.blurScope, Bn.emphasisDisabled), $n;
}
function doCreateOrUpdateEl(_n, nr, Cn, Bn, In, Dn) {
  process.env.NODE_ENV !== "production" && assert(Bn, "should not have an null/undefined element setting");
  var Ln = -1, $n = nr;
  nr && doesElNeedRecreate(nr, Bn, In) && (Ln = indexOf(Dn.childrenRef(), nr), nr = null);
  var Nn = !nr, Rn = nr;
  Rn ? Rn.clearStates() : (Rn = createEl$1(Bn), $n && copyElement($n, Rn)), Bn.morph === !1 ? Rn.disableMorphing = !0 : Rn.disableMorphing && (Rn.disableMorphing = !1), attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null, attachedTxInfoTmp.isLegacy = !1, doCreateOrUpdateAttachedTx(Rn, Cn, Bn, In, Nn, attachedTxInfoTmp), doCreateOrUpdateClipPath(Rn, Cn, Bn, In, Nn), updateElNormal(_n, Rn, Cn, Bn, attachedTxInfoTmp, In, Nn), hasOwn(Bn, "info") && (customInnerStore(Rn).info = Bn.info);
  for (var Fn = 0; Fn < STATES.length; Fn++) {
    var Pn = STATES[Fn];
    if (Pn !== NORMAL) {
      var Un = retrieveStateOption(Bn, Pn), Hn = retrieveStyleOptionOnState(Bn, Un, Pn);
      updateElOnState(Pn, Rn, Un, Hn, attachedTxInfoTmp);
    }
  }
  return updateZ(Rn, Bn, In), Bn.type === "group" && mergeChildren(_n, Rn, Cn, Bn, In), Ln >= 0 ? Dn.replaceAt(Rn, Ln) : Dn.add(Rn), Rn;
}
function doesElNeedRecreate(_n, nr, Cn) {
  var Bn = customInnerStore(_n), In = nr.type, Dn = nr.shape, Ln = nr.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    Cn.isUniversalTransitionEnabled() || In != null && In !== Bn.customGraphicType || In === "path" && hasOwnPathData(Dn) && getPathData(Dn) !== Bn.customPathData || In === "image" && hasOwn(Ln, "image") && Ln.image !== Bn.customImagePath
  );
}
function doCreateOrUpdateClipPath(_n, nr, Cn, Bn, In) {
  var Dn = Cn.clipPath;
  if (Dn === !1)
    _n && _n.getClipPath() && _n.removeClipPath();
  else if (Dn) {
    var Ln = _n.getClipPath();
    Ln && doesElNeedRecreate(Ln, Dn, Bn) && (Ln = null), Ln || (Ln = createEl$1(Dn), process.env.NODE_ENV !== "production" && assert(isPath(Ln), "Only any type of `path` can be used in `clipPath`, rather than " + Ln.type + "."), _n.setClipPath(Ln)), updateElNormal(null, Ln, nr, Dn, null, Bn, In);
  }
}
function doCreateOrUpdateAttachedTx(_n, nr, Cn, Bn, In, Dn) {
  if (!_n.isGroup) {
    processTxInfo(Cn, null, Dn), processTxInfo(Cn, EMPHASIS, Dn);
    var Ln = Dn.normal.conOpt, $n = Dn.emphasis.conOpt, Nn = Dn.blur.conOpt, Rn = Dn.select.conOpt;
    if (Ln != null || $n != null || Rn != null || Nn != null) {
      var Fn = _n.getTextContent();
      if (Ln === !1)
        Fn && _n.removeTextContent();
      else {
        Ln = Dn.normal.conOpt = Ln || {
          type: "text"
        }, Fn ? Fn.clearStates() : (Fn = createEl$1(Ln), _n.setTextContent(Fn)), updateElNormal(null, Fn, nr, Ln, null, Bn, In);
        for (var Pn = Ln && Ln.style, Un = 0; Un < STATES.length; Un++) {
          var Hn = STATES[Un];
          if (Hn !== NORMAL) {
            var zn = Dn[Hn].conOpt;
            updateElOnState(Hn, Fn, zn, retrieveStyleOptionOnState(Ln, zn, Hn), null);
          }
        }
        Pn ? Fn.dirty() : Fn.markRedraw();
      }
    }
  }
}
function processTxInfo(_n, nr, Cn) {
  var Bn = nr ? retrieveStateOption(_n, nr) : _n, In = nr ? retrieveStyleOptionOnState(_n, Bn, EMPHASIS) : _n.style, Dn = _n.type, Ln = Bn ? Bn.textConfig : null, $n = _n.textContent, Nn = $n ? nr ? retrieveStateOption($n, nr) : $n : null;
  if (In && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (Cn.isLegacy || isEC4CompatibleStyle(In, Dn, !!Ln, !!Nn))) {
    Cn.isLegacy = !0;
    var Rn = convertFromEC4CompatibleStyle(In, Dn, !nr);
    !Ln && Rn.textConfig && (Ln = Rn.textConfig), !Nn && Rn.textContent && (Nn = Rn.textContent);
  }
  if (!nr && Nn) {
    var Fn = Nn;
    !Fn.type && (Fn.type = "text"), process.env.NODE_ENV !== "production" && assert(Fn.type === "text", 'textContent.type must be "text"');
  }
  var Pn = nr ? Cn[nr] : Cn.normal;
  Pn.cfg = Ln, Pn.conOpt = Nn;
}
function retrieveStateOption(_n, nr) {
  return nr ? _n ? _n[nr] : null : _n;
}
function retrieveStyleOptionOnState(_n, nr, Cn) {
  var Bn = nr && nr.style;
  return Bn == null && Cn === EMPHASIS && _n && (Bn = _n.styleEmphasis), Bn;
}
function mergeChildren(_n, nr, Cn, Bn, In) {
  var Dn = Bn.children, Ln = Dn ? Dn.length : 0, $n = Bn.$mergeChildren, Nn = $n === "byName" || Bn.diffChildrenByName, Rn = $n === !1;
  if (!(!Ln && !Nn && !Rn)) {
    if (Nn) {
      diffGroupChildren({
        api: _n,
        oldChildren: nr.children() || [],
        newChildren: Dn || [],
        dataIndex: Cn,
        seriesModel: In,
        group: nr
      });
      return;
    }
    Rn && nr.removeAll();
    for (var Fn = 0; Fn < Ln; Fn++) {
      var Pn = Dn[Fn], Un = nr.childAt(Fn);
      Pn ? (Pn.ignore == null && (Pn.ignore = !1), doCreateOrUpdateEl(_n, Un, Cn, Pn, In, nr)) : (process.env.NODE_ENV !== "production" && assert(Un, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), Un.ignore = !0);
    }
    for (var Hn = nr.childCount() - 1; Hn >= Fn; Hn--) {
      var zn = nr.childAt(Hn);
      removeChildFromGroup(nr, zn, In);
    }
  }
}
function removeChildFromGroup(_n, nr, Cn) {
  nr && applyLeaveTransition(nr, customInnerStore(_n).option, Cn);
}
function diffGroupChildren(_n) {
  new DataDiffer$1(_n.oldChildren, _n.newChildren, getKey, getKey, _n).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
}
function getKey(_n, nr) {
  var Cn = _n && _n.name;
  return Cn ?? GROUP_DIFF_PREFIX + nr;
}
function processAddUpdate(_n, nr) {
  var Cn = this.context, Bn = _n != null ? Cn.newChildren[_n] : null, In = nr != null ? Cn.oldChildren[nr] : null;
  doCreateOrUpdateEl(Cn.api, In, Cn.dataIndex, Bn, Cn.seriesModel, Cn.group);
}
function processRemove(_n) {
  var nr = this.context, Cn = nr.oldChildren[_n];
  Cn && applyLeaveTransition(Cn, customInnerStore(Cn).option, nr.seriesModel);
}
function getPathData(_n) {
  return _n && (_n.pathData || _n.d);
}
function hasOwnPathData(_n) {
  return _n && (hasOwn(_n, "pathData") || hasOwn(_n, "d"));
}
function install$r(_n) {
  _n.registerChartView(CustomChartView$1), _n.registerSeriesModel(CustomSeriesModel$1);
}
var inner$b = makeInner(), clone$1 = clone$4, bind = bind$1, BaseAxisPointer = (
  /** @class */
  function() {
    function _n() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return _n.prototype.render = function(nr, Cn, Bn, In) {
      var Dn = Cn.get("value"), Ln = Cn.get("status");
      if (this._axisModel = nr, this._axisPointerModel = Cn, this._api = Bn, !(!In && this._lastValue === Dn && this._lastStatus === Ln)) {
        this._lastValue = Dn, this._lastStatus = Ln;
        var $n = this._group, Nn = this._handle;
        if (!Ln || Ln === "hide") {
          $n && $n.hide(), Nn && Nn.hide();
          return;
        }
        $n && $n.show(), Nn && Nn.show();
        var Rn = {};
        this.makeElOption(Rn, Dn, nr, Cn, Bn);
        var Fn = Rn.graphicKey;
        Fn !== this._lastGraphicKey && this.clear(Bn), this._lastGraphicKey = Fn;
        var Pn = this._moveAnimation = this.determineAnimation(nr, Cn);
        if (!$n)
          $n = this._group = new Group$4(), this.createPointerEl($n, Rn, nr, Cn), this.createLabelEl($n, Rn, nr, Cn), Bn.getZr().add($n);
        else {
          var Un = curry$1(updateProps, Cn, Pn);
          this.updatePointerEl($n, Rn, Un), this.updateLabelEl($n, Rn, Un, Cn);
        }
        updateMandatoryProps($n, Cn, !0), this._renderHandle(Dn);
      }
    }, _n.prototype.remove = function(nr) {
      this.clear(nr);
    }, _n.prototype.dispose = function(nr) {
      this.clear(nr);
    }, _n.prototype.determineAnimation = function(nr, Cn) {
      var Bn = Cn.get("animation"), In = nr.axis, Dn = In.type === "category", Ln = Cn.get("snap");
      if (!Ln && !Dn)
        return !1;
      if (Bn === "auto" || Bn == null) {
        var $n = this.animationThreshold;
        if (Dn && In.getBandWidth() > $n)
          return !0;
        if (Ln) {
          var Nn = getAxisInfo$1(nr).seriesDataCount, Rn = In.getExtent();
          return Math.abs(Rn[0] - Rn[1]) / Nn > $n;
        }
        return !1;
      }
      return Bn === !0;
    }, _n.prototype.makeElOption = function(nr, Cn, Bn, In, Dn) {
    }, _n.prototype.createPointerEl = function(nr, Cn, Bn, In) {
      var Dn = Cn.pointer;
      if (Dn) {
        var Ln = inner$b(nr).pointerEl = new graphic$1[Dn.type](clone$1(Cn.pointer));
        nr.add(Ln);
      }
    }, _n.prototype.createLabelEl = function(nr, Cn, Bn, In) {
      if (Cn.label) {
        var Dn = inner$b(nr).labelEl = new ZRText$1(clone$1(Cn.label));
        nr.add(Dn), updateLabelShowHide(Dn, In);
      }
    }, _n.prototype.updatePointerEl = function(nr, Cn, Bn) {
      var In = inner$b(nr).pointerEl;
      In && Cn.pointer && (In.setStyle(Cn.pointer.style), Bn(In, {
        shape: Cn.pointer.shape
      }));
    }, _n.prototype.updateLabelEl = function(nr, Cn, Bn, In) {
      var Dn = inner$b(nr).labelEl;
      Dn && (Dn.setStyle(Cn.label.style), Bn(Dn, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: Cn.label.x,
        y: Cn.label.y
      }), updateLabelShowHide(Dn, In));
    }, _n.prototype._renderHandle = function(nr) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var Cn = this._axisPointerModel, Bn = this._api.getZr(), In = this._handle, Dn = Cn.getModel("handle"), Ln = Cn.get("status");
        if (!Dn.get("show") || !Ln || Ln === "hide") {
          In && Bn.remove(In), this._handle = null;
          return;
        }
        var $n;
        this._handle || ($n = !0, In = this._handle = createIcon(Dn.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(Rn) {
            stop(Rn.event);
          },
          onmousedown: bind(this._onHandleDragMove, this, 0, 0),
          drift: bind(this._onHandleDragMove, this),
          ondragend: bind(this._onHandleDragEnd, this)
        }), Bn.add(In)), updateMandatoryProps(In, Cn, !1), In.setStyle(Dn.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var Nn = Dn.get("size");
        isArray$4(Nn) || (Nn = [Nn, Nn]), In.scaleX = Nn[0] / 2, In.scaleY = Nn[1] / 2, createOrUpdate(this, "_doDispatchAxisPointer", Dn.get("throttle") || 0, "fixRate"), this._moveHandleToValue(nr, $n);
      }
    }, _n.prototype._moveHandleToValue = function(nr, Cn) {
      updateProps(this._axisPointerModel, !Cn && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(nr, this._axisModel, this._axisPointerModel)));
    }, _n.prototype._onHandleDragMove = function(nr, Cn) {
      var Bn = this._handle;
      if (Bn) {
        this._dragging = !0;
        var In = this.updateHandleTransform(getHandleTransProps(Bn), [nr, Cn], this._axisModel, this._axisPointerModel);
        this._payloadInfo = In, Bn.stopAnimation(), Bn.attr(getHandleTransProps(In)), inner$b(Bn).lastProp = null, this._doDispatchAxisPointer();
      }
    }, _n.prototype._doDispatchAxisPointer = function() {
      var nr = this._handle;
      if (nr) {
        var Cn = this._payloadInfo, Bn = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: Cn.cursorPoint[0],
          y: Cn.cursorPoint[1],
          tooltipOption: Cn.tooltipOption,
          axesInfo: [{
            axisDim: Bn.axis.dim,
            axisIndex: Bn.componentIndex
          }]
        });
      }
    }, _n.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var nr = this._handle;
      if (nr) {
        var Cn = this._axisPointerModel.get("value");
        this._moveHandleToValue(Cn), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, _n.prototype.clear = function(nr) {
      this._lastValue = null, this._lastStatus = null;
      var Cn = nr.getZr(), Bn = this._group, In = this._handle;
      Cn && Bn && (this._lastGraphicKey = null, Bn && Cn.remove(Bn), In && Cn.remove(In), this._group = null, this._handle = null, this._payloadInfo = null), clear$1(this, "_doDispatchAxisPointer");
    }, _n.prototype.doClear = function() {
    }, _n.prototype.buildLabel = function(nr, Cn, Bn) {
      return Bn = Bn || 0, {
        x: nr[Bn],
        y: nr[1 - Bn],
        width: Cn[Bn],
        height: Cn[1 - Bn]
      };
    }, _n;
  }()
);
function updateProps(_n, nr, Cn, Bn) {
  propsEqual(inner$b(Cn).lastProp, Bn) || (inner$b(Cn).lastProp = Bn, nr ? updateProps$1(Cn, Bn, _n) : (Cn.stopAnimation(), Cn.attr(Bn)));
}
function propsEqual(_n, nr) {
  if (isObject$6(_n) && isObject$6(nr)) {
    var Cn = !0;
    return each$f(nr, function(Bn, In) {
      Cn = Cn && propsEqual(_n[In], Bn);
    }), !!Cn;
  } else
    return _n === nr;
}
function updateLabelShowHide(_n, nr) {
  _n[nr.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(_n) {
  return {
    x: _n.x || 0,
    y: _n.y || 0,
    rotation: _n.rotation || 0
  };
}
function updateMandatoryProps(_n, nr, Cn) {
  var Bn = nr.get("z"), In = nr.get("zlevel");
  _n && _n.traverse(function(Dn) {
    Dn.type !== "group" && (Bn != null && (Dn.z = Bn), In != null && (Dn.zlevel = In), Dn.silent = Cn);
  });
}
const BaseAxisPointer$1 = BaseAxisPointer;
function buildElStyle(_n) {
  var nr = _n.get("type"), Cn = _n.getModel(nr + "Style"), Bn;
  return nr === "line" ? (Bn = Cn.getLineStyle(), Bn.fill = null) : nr === "shadow" && (Bn = Cn.getAreaStyle(), Bn.stroke = null), Bn;
}
function buildLabelElOption(_n, nr, Cn, Bn, In) {
  var Dn = Cn.get("value"), Ln = getValueLabel(Dn, nr.axis, nr.ecModel, Cn.get("seriesDataIndices"), {
    precision: Cn.get(["label", "precision"]),
    formatter: Cn.get(["label", "formatter"])
  }), $n = Cn.getModel("label"), Nn = normalizeCssArray($n.get("padding") || 0), Rn = $n.getFont(), Fn = getBoundingRect(Ln, Rn), Pn = In.position, Un = Fn.width + Nn[1] + Nn[3], Hn = Fn.height + Nn[0] + Nn[2], zn = In.align;
  zn === "right" && (Pn[0] -= Un), zn === "center" && (Pn[0] -= Un / 2);
  var Gn = In.verticalAlign;
  Gn === "bottom" && (Pn[1] -= Hn), Gn === "middle" && (Pn[1] -= Hn / 2), confineInContainer(Pn, Un, Hn, Bn);
  var Yn = $n.get("backgroundColor");
  (!Yn || Yn === "auto") && (Yn = nr.get(["axisLine", "lineStyle", "color"])), _n.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: Pn[0],
    y: Pn[1],
    style: createTextStyle$1($n, {
      text: Ln,
      font: Rn,
      fill: $n.getTextColor(),
      padding: Nn,
      backgroundColor: Yn
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function confineInContainer(_n, nr, Cn, Bn) {
  var In = Bn.getWidth(), Dn = Bn.getHeight();
  _n[0] = Math.min(_n[0] + nr, In) - nr, _n[1] = Math.min(_n[1] + Cn, Dn) - Cn, _n[0] = Math.max(_n[0], 0), _n[1] = Math.max(_n[1], 0);
}
function getValueLabel(_n, nr, Cn, Bn, In) {
  _n = nr.scale.parse(_n);
  var Dn = nr.scale.getLabel({
    value: _n
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: In.precision
  }), Ln = In.formatter;
  if (Ln) {
    var $n = {
      value: getAxisRawValue(nr, {
        value: _n
      }),
      axisDimension: nr.dim,
      axisIndex: nr.index,
      seriesData: []
    };
    each$f(Bn, function(Nn) {
      var Rn = Cn.getSeriesByIndex(Nn.seriesIndex), Fn = Nn.dataIndexInside, Pn = Rn && Rn.getDataParams(Fn);
      Pn && $n.seriesData.push(Pn);
    }), isString$1(Ln) ? Dn = Ln.replace("{value}", Dn) : isFunction$1(Ln) && (Dn = Ln($n));
  }
  return Dn;
}
function getTransformedPosition(_n, nr, Cn) {
  var Bn = create$1();
  return rotate(Bn, Bn, Cn.rotation), translate(Bn, Bn, Cn.position), applyTransform([_n.dataToCoord(nr), (Cn.labelOffset || 0) + (Cn.labelDirection || 1) * (Cn.labelMargin || 0)], Bn);
}
function buildCartesianSingleLabelElOption(_n, nr, Cn, Bn, In, Dn) {
  var Ln = AxisBuilder$1.innerTextLayout(Cn.rotation, 0, Cn.labelDirection);
  Cn.labelMargin = In.get(["label", "margin"]), buildLabelElOption(nr, Bn, In, Dn, {
    position: getTransformedPosition(Bn.axis, _n, Cn),
    align: Ln.textAlign,
    verticalAlign: Ln.textVerticalAlign
  });
}
function makeLineShape(_n, nr, Cn) {
  return Cn = Cn || 0, {
    x1: _n[Cn],
    y1: _n[1 - Cn],
    x2: nr[Cn],
    y2: nr[1 - Cn]
  };
}
function makeRectShape(_n, nr, Cn) {
  return Cn = Cn || 0, {
    x: _n[Cn],
    y: _n[1 - Cn],
    width: nr[Cn],
    height: nr[1 - Cn]
  };
}
function makeSectorShape(_n, nr, Cn, Bn, In, Dn) {
  return {
    cx: _n,
    cy: nr,
    r0: Cn,
    r: Bn,
    startAngle: In,
    endAngle: Dn,
    clockwise: !0
  };
}
var CartesianAxisPointer = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.makeElOption = function(Cn, Bn, In, Dn, Ln) {
      var $n = In.axis, Nn = $n.grid, Rn = Dn.get("type"), Fn = getCartesian(Nn, $n).getOtherAxis($n).getGlobalExtent(), Pn = $n.toGlobalCoord($n.dataToCoord(Bn, !0));
      if (Rn && Rn !== "none") {
        var Un = buildElStyle(Dn), Hn = pointerShapeBuilder$2[Rn]($n, Pn, Fn);
        Hn.style = Un, Cn.graphicKey = Hn.type, Cn.pointer = Hn;
      }
      var zn = layout$2(Nn.model, In);
      buildCartesianSingleLabelElOption(
        // @ts-ignore
        Bn,
        Cn,
        zn,
        In,
        Dn,
        Ln
      );
    }, nr.prototype.getHandleTransform = function(Cn, Bn, In) {
      var Dn = layout$2(Bn.axis.grid.model, Bn, {
        labelInside: !1
      });
      Dn.labelMargin = In.get(["handle", "margin"]);
      var Ln = getTransformedPosition(Bn.axis, Cn, Dn);
      return {
        x: Ln[0],
        y: Ln[1],
        rotation: Dn.rotation + (Dn.labelDirection < 0 ? Math.PI : 0)
      };
    }, nr.prototype.updateHandleTransform = function(Cn, Bn, In, Dn) {
      var Ln = In.axis, $n = Ln.grid, Nn = Ln.getGlobalExtent(!0), Rn = getCartesian($n, Ln).getOtherAxis(Ln).getGlobalExtent(), Fn = Ln.dim === "x" ? 0 : 1, Pn = [Cn.x, Cn.y];
      Pn[Fn] += Bn[Fn], Pn[Fn] = Math.min(Nn[1], Pn[Fn]), Pn[Fn] = Math.max(Nn[0], Pn[Fn]);
      var Un = (Rn[1] + Rn[0]) / 2, Hn = [Un, Un];
      Hn[Fn] = Pn[Fn];
      var zn = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: Pn[0],
        y: Pn[1],
        rotation: Cn.rotation,
        cursorPoint: Hn,
        tooltipOption: zn[Fn]
      };
    }, nr;
  }(BaseAxisPointer$1)
);
function getCartesian(_n, nr) {
  var Cn = {};
  return Cn[nr.dim + "AxisIndex"] = nr.index, _n.getCartesian(Cn);
}
var pointerShapeBuilder$2 = {
  line: function(_n, nr, Cn) {
    var Bn = makeLineShape([nr, Cn[0]], [nr, Cn[1]], getAxisDimIndex(_n));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: Bn
    };
  },
  shadow: function(_n, nr, Cn) {
    var Bn = Math.max(1, _n.getBandWidth()), In = Cn[1] - Cn[0];
    return {
      type: "Rect",
      shape: makeRectShape([nr - Bn / 2, Cn[0]], [Bn, In], getAxisDimIndex(_n))
    };
  }
};
function getAxisDimIndex(_n) {
  return _n.dim === "x" ? 0 : 1;
}
const CartesianAxisPointer$1 = CartesianAxisPointer;
var AxisPointerModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "axisPointer", nr.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }, nr;
  }(ComponentModel$1)
);
const AxisPointerModel$1 = AxisPointerModel;
var inner$a = makeInner(), each$8 = each$f;
function register(_n, nr, Cn) {
  if (!env$1.node) {
    var Bn = nr.getZr();
    inner$a(Bn).records || (inner$a(Bn).records = {}), initGlobalListeners(Bn, nr);
    var In = inner$a(Bn).records[_n] || (inner$a(Bn).records[_n] = {});
    In.handler = Cn;
  }
}
function initGlobalListeners(_n, nr) {
  if (inner$a(_n).initialized)
    return;
  inner$a(_n).initialized = !0, Cn("click", curry$1(doEnter, "click")), Cn("mousemove", curry$1(doEnter, "mousemove")), Cn("globalout", onLeave);
  function Cn(Bn, In) {
    _n.on(Bn, function(Dn) {
      var Ln = makeDispatchAction$1(nr);
      each$8(inner$a(_n).records, function($n) {
        $n && In($n, Dn, Ln.dispatchAction);
      }), dispatchTooltipFinally(Ln.pendings, nr);
    });
  }
}
function dispatchTooltipFinally(_n, nr) {
  var Cn = _n.showTip.length, Bn = _n.hideTip.length, In;
  Cn ? In = _n.showTip[Cn - 1] : Bn && (In = _n.hideTip[Bn - 1]), In && (In.dispatchAction = null, nr.dispatchAction(In));
}
function onLeave(_n, nr, Cn) {
  _n.handler("leave", null, Cn);
}
function doEnter(_n, nr, Cn, Bn) {
  nr.handler(_n, Cn, Bn);
}
function makeDispatchAction$1(_n) {
  var nr = {
    showTip: [],
    hideTip: []
  }, Cn = function(Bn) {
    var In = nr[Bn.type];
    In ? In.push(Bn) : (Bn.dispatchAction = Cn, _n.dispatchAction(Bn));
  };
  return {
    dispatchAction: Cn,
    pendings: nr
  };
}
function unregister(_n, nr) {
  if (!env$1.node) {
    var Cn = nr.getZr(), Bn = (inner$a(Cn).records || {})[_n];
    Bn && (inner$a(Cn).records[_n] = null);
  }
}
var AxisPointerView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = Bn.getComponent("tooltip"), Ln = Cn.get("triggerOn") || Dn && Dn.get("triggerOn") || "mousemove|click";
      register("axisPointer", In, function($n, Nn, Rn) {
        Ln !== "none" && ($n === "leave" || Ln.indexOf($n) >= 0) && Rn({
          type: "updateAxisPointer",
          currTrigger: $n,
          x: Nn && Nn.offsetX,
          y: Nn && Nn.offsetY
        });
      });
    }, nr.prototype.remove = function(Cn, Bn) {
      unregister("axisPointer", Bn);
    }, nr.prototype.dispose = function(Cn, Bn) {
      unregister("axisPointer", Bn);
    }, nr.type = "axisPointer", nr;
  }(ComponentView$1)
);
const AxisPointerView$1 = AxisPointerView;
function findPointFromSeries(_n, nr) {
  var Cn = [], Bn = _n.seriesIndex, In;
  if (Bn == null || !(In = nr.getSeriesByIndex(Bn)))
    return {
      point: []
    };
  var Dn = In.getData(), Ln = queryDataIndex(Dn, _n);
  if (Ln == null || Ln < 0 || isArray$4(Ln))
    return {
      point: []
    };
  var $n = Dn.getItemGraphicEl(Ln), Nn = In.coordinateSystem;
  if (In.getTooltipPosition)
    Cn = In.getTooltipPosition(Ln) || [];
  else if (Nn && Nn.dataToPoint)
    if (_n.isStacked) {
      var Rn = Nn.getBaseAxis(), Fn = Nn.getOtherAxis(Rn), Pn = Fn.dim, Un = Rn.dim, Hn = Pn === "x" || Pn === "radius" ? 1 : 0, zn = Dn.mapDimension(Un), Gn = [];
      Gn[Hn] = Dn.get(zn, Ln), Gn[1 - Hn] = Dn.get(Dn.getCalculationInfo("stackResultDimension"), Ln), Cn = Nn.dataToPoint(Gn) || [];
    } else
      Cn = Nn.dataToPoint(Dn.getValues(map$1(Nn.dimensions, function(Wn) {
        return Dn.mapDimension(Wn);
      }), Ln)) || [];
  else if ($n) {
    var Yn = $n.getBoundingRect().clone();
    Yn.applyTransform($n.transform), Cn = [Yn.x + Yn.width / 2, Yn.y + Yn.height / 2];
  }
  return {
    point: Cn,
    el: $n
  };
}
var inner$9 = makeInner();
function axisTrigger(_n, nr, Cn) {
  var Bn = _n.currTrigger, In = [_n.x, _n.y], Dn = _n, Ln = _n.dispatchAction || bind$1(Cn.dispatchAction, Cn), $n = nr.getComponent("axisPointer").coordSysAxesInfo;
  if ($n) {
    illegalPoint(In) && (In = findPointFromSeries({
      seriesIndex: Dn.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: Dn.dataIndex
    }, nr).point);
    var Nn = illegalPoint(In), Rn = Dn.axesInfo, Fn = $n.axesInfo, Pn = Bn === "leave" || illegalPoint(In), Un = {}, Hn = {}, zn = {
      list: [],
      map: {}
    }, Gn = {
      showPointer: curry$1(showPointer, Hn),
      showTooltip: curry$1(showTooltip, zn)
    };
    each$f($n.coordSysMap, function(Wn, Xn) {
      var ea = Nn || Wn.containPoint(In);
      each$f($n.coordSysAxesInfo[Xn], function(ta, na) {
        var ra = ta.axis, aa = findInputAxisInfo(Rn, ta);
        if (!Pn && ea && (!Rn || aa)) {
          var ia = aa && aa.value;
          ia == null && !Nn && (ia = ra.pointToData(In)), ia != null && processOnAxis(ta, ia, Gn, !1, Un);
        }
      });
    });
    var Yn = {};
    return each$f(Fn, function(Wn, Xn) {
      var ea = Wn.linkGroup;
      ea && !Hn[Xn] && each$f(ea.axesInfo, function(ta, na) {
        var ra = Hn[na];
        if (ta !== Wn && ra) {
          var aa = ra.value;
          ea.mapper && (aa = Wn.axis.scale.parse(ea.mapper(aa, makeMapperParam(ta), makeMapperParam(Wn)))), Yn[Wn.key] = aa;
        }
      });
    }), each$f(Yn, function(Wn, Xn) {
      processOnAxis(Fn[Xn], Wn, Gn, !0, Un);
    }), updateModelActually(Hn, Fn, Un), dispatchTooltipActually(zn, In, _n, Ln), dispatchHighDownActually(Fn, Ln, Cn), Un;
  }
}
function processOnAxis(_n, nr, Cn, Bn, In) {
  var Dn = _n.axis;
  if (!(Dn.scale.isBlank() || !Dn.containData(nr))) {
    if (!_n.involveSeries) {
      Cn.showPointer(_n, nr);
      return;
    }
    var Ln = buildPayloadsBySeries(nr, _n), $n = Ln.payloadBatch, Nn = Ln.snapToValue;
    $n[0] && In.seriesIndex == null && extend(In, $n[0]), !Bn && _n.snap && Dn.containData(Nn) && Nn != null && (nr = Nn), Cn.showPointer(_n, nr, $n), Cn.showTooltip(_n, Ln, Nn);
  }
}
function buildPayloadsBySeries(_n, nr) {
  var Cn = nr.axis, Bn = Cn.dim, In = _n, Dn = [], Ln = Number.MAX_VALUE, $n = -1;
  return each$f(nr.seriesModels, function(Nn, Rn) {
    var Fn = Nn.getData().mapDimensionsAll(Bn), Pn, Un;
    if (Nn.getAxisTooltipData) {
      var Hn = Nn.getAxisTooltipData(Fn, _n, Cn);
      Un = Hn.dataIndices, Pn = Hn.nestestValue;
    } else {
      if (Un = Nn.getData().indicesOfNearest(
        Fn[0],
        _n,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        Cn.type === "category" ? 0.5 : null
      ), !Un.length)
        return;
      Pn = Nn.getData().get(Fn[0], Un[0]);
    }
    if (!(Pn == null || !isFinite(Pn))) {
      var zn = _n - Pn, Gn = Math.abs(zn);
      Gn <= Ln && ((Gn < Ln || zn >= 0 && $n < 0) && (Ln = Gn, $n = zn, In = Pn, Dn.length = 0), each$f(Un, function(Yn) {
        Dn.push({
          seriesIndex: Nn.seriesIndex,
          dataIndexInside: Yn,
          dataIndex: Nn.getData().getRawIndex(Yn)
        });
      }));
    }
  }), {
    payloadBatch: Dn,
    snapToValue: In
  };
}
function showPointer(_n, nr, Cn, Bn) {
  _n[nr.key] = {
    value: Cn,
    payloadBatch: Bn
  };
}
function showTooltip(_n, nr, Cn, Bn) {
  var In = Cn.payloadBatch, Dn = nr.axis, Ln = Dn.model, $n = nr.axisPointerModel;
  if (!(!nr.triggerTooltip || !In.length)) {
    var Nn = nr.coordSys.model, Rn = makeKey(Nn), Fn = _n.map[Rn];
    Fn || (Fn = _n.map[Rn] = {
      coordSysId: Nn.id,
      coordSysIndex: Nn.componentIndex,
      coordSysType: Nn.type,
      coordSysMainType: Nn.mainType,
      dataByAxis: []
    }, _n.list.push(Fn)), Fn.dataByAxis.push({
      axisDim: Dn.dim,
      axisIndex: Ln.componentIndex,
      axisType: Ln.type,
      axisId: Ln.id,
      value: Bn,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: $n.get(["label", "precision"]),
        formatter: $n.get(["label", "formatter"])
      },
      seriesDataIndices: In.slice()
    });
  }
}
function updateModelActually(_n, nr, Cn) {
  var Bn = Cn.axesInfo = [];
  each$f(nr, function(In, Dn) {
    var Ln = In.axisPointerModel.option, $n = _n[Dn];
    $n ? (!In.useHandle && (Ln.status = "show"), Ln.value = $n.value, Ln.seriesDataIndices = ($n.payloadBatch || []).slice()) : !In.useHandle && (Ln.status = "hide"), Ln.status === "show" && Bn.push({
      axisDim: In.axis.dim,
      axisIndex: In.axis.model.componentIndex,
      value: Ln.value
    });
  });
}
function dispatchTooltipActually(_n, nr, Cn, Bn) {
  if (illegalPoint(nr) || !_n.list.length) {
    Bn({
      type: "hideTip"
    });
    return;
  }
  var In = ((_n.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  Bn({
    type: "showTip",
    escapeConnect: !0,
    x: nr[0],
    y: nr[1],
    tooltipOption: Cn.tooltipOption,
    position: Cn.position,
    dataIndexInside: In.dataIndexInside,
    dataIndex: In.dataIndex,
    seriesIndex: In.seriesIndex,
    dataByCoordSys: _n.list
  });
}
function dispatchHighDownActually(_n, nr, Cn) {
  var Bn = Cn.getZr(), In = "axisPointerLastHighlights", Dn = inner$9(Bn)[In] || {}, Ln = inner$9(Bn)[In] = {};
  each$f(_n, function(Rn, Fn) {
    var Pn = Rn.axisPointerModel.option;
    Pn.status === "show" && Rn.triggerEmphasis && each$f(Pn.seriesDataIndices, function(Un) {
      var Hn = Un.seriesIndex + " | " + Un.dataIndex;
      Ln[Hn] = Un;
    });
  });
  var $n = [], Nn = [];
  each$f(Dn, function(Rn, Fn) {
    !Ln[Fn] && Nn.push(Rn);
  }), each$f(Ln, function(Rn, Fn) {
    !Dn[Fn] && $n.push(Rn);
  }), Nn.length && Cn.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: Nn
  }), $n.length && Cn.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: $n
  });
}
function findInputAxisInfo(_n, nr) {
  for (var Cn = 0; Cn < (_n || []).length; Cn++) {
    var Bn = _n[Cn];
    if (nr.axis.dim === Bn.axisDim && nr.axis.model.componentIndex === Bn.axisIndex)
      return Bn;
  }
}
function makeMapperParam(_n) {
  var nr = _n.axis.model, Cn = {}, Bn = Cn.axisDim = _n.axis.dim;
  return Cn.axisIndex = Cn[Bn + "AxisIndex"] = nr.componentIndex, Cn.axisName = Cn[Bn + "AxisName"] = nr.name, Cn.axisId = Cn[Bn + "AxisId"] = nr.id, Cn;
}
function illegalPoint(_n) {
  return !_n || _n[0] == null || isNaN(_n[0]) || _n[1] == null || isNaN(_n[1]);
}
function install$q(_n) {
  AxisView$1.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer$1), _n.registerComponentModel(AxisPointerModel$1), _n.registerComponentView(AxisPointerView$1), _n.registerPreprocessor(function(nr) {
    if (nr) {
      (!nr.axisPointer || nr.axisPointer.length === 0) && (nr.axisPointer = {});
      var Cn = nr.axisPointer.link;
      Cn && !isArray$4(Cn) && (nr.axisPointer.link = [Cn]);
    }
  }), _n.registerProcessor(_n.PRIORITY.PROCESSOR.STATISTIC, function(nr, Cn) {
    nr.getComponent("axisPointer").coordSysAxesInfo = collect(nr, Cn);
  }), _n.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger);
}
function install$p(_n) {
  use(install$N), use(install$q);
}
var PolarAxisPointer = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.makeElOption = function(Cn, Bn, In, Dn, Ln) {
      var $n = In.axis;
      $n.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var Nn = $n.polar, Rn = Nn.getOtherAxis($n), Fn = Rn.getExtent(), Pn = $n.dataToCoord(Bn), Un = Dn.get("type");
      if (Un && Un !== "none") {
        var Hn = buildElStyle(Dn), zn = pointerShapeBuilder$1[Un]($n, Nn, Pn, Fn);
        zn.style = Hn, Cn.graphicKey = zn.type, Cn.pointer = zn;
      }
      var Gn = Dn.get(["label", "margin"]), Yn = getLabelPosition(Bn, In, Dn, Nn, Gn);
      buildLabelElOption(Cn, In, Dn, Ln, Yn);
    }, nr;
  }(BaseAxisPointer$1)
);
function getLabelPosition(_n, nr, Cn, Bn, In) {
  var Dn = nr.axis, Ln = Dn.dataToCoord(_n), $n = Bn.getAngleAxis().getExtent()[0];
  $n = $n / 180 * Math.PI;
  var Nn = Bn.getRadiusAxis().getExtent(), Rn, Fn, Pn;
  if (Dn.dim === "radius") {
    var Un = create$1();
    rotate(Un, Un, $n), translate(Un, Un, [Bn.cx, Bn.cy]), Rn = applyTransform([Ln, -In], Un);
    var Hn = nr.getModel("axisLabel").get("rotate") || 0, zn = AxisBuilder$1.innerTextLayout($n, Hn * Math.PI / 180, -1);
    Fn = zn.textAlign, Pn = zn.textVerticalAlign;
  } else {
    var Gn = Nn[1];
    Rn = Bn.coordToPoint([Gn + In, Ln]);
    var Yn = Bn.cx, Wn = Bn.cy;
    Fn = Math.abs(Rn[0] - Yn) / Gn < 0.3 ? "center" : Rn[0] > Yn ? "left" : "right", Pn = Math.abs(Rn[1] - Wn) / Gn < 0.3 ? "middle" : Rn[1] > Wn ? "top" : "bottom";
  }
  return {
    position: Rn,
    align: Fn,
    verticalAlign: Pn
  };
}
var pointerShapeBuilder$1 = {
  line: function(_n, nr, Cn, Bn) {
    return _n.dim === "angle" ? {
      type: "Line",
      shape: makeLineShape(nr.coordToPoint([Bn[0], Cn]), nr.coordToPoint([Bn[1], Cn]))
    } : {
      type: "Circle",
      shape: {
        cx: nr.cx,
        cy: nr.cy,
        r: Cn
      }
    };
  },
  shadow: function(_n, nr, Cn, Bn) {
    var In = Math.max(1, _n.getBandWidth()), Dn = Math.PI / 180;
    return _n.dim === "angle" ? {
      type: "Sector",
      shape: makeSectorShape(
        nr.cx,
        nr.cy,
        Bn[0],
        Bn[1],
        // In ECharts y is negative if angle is positive
        (-Cn - In / 2) * Dn,
        (-Cn + In / 2) * Dn
      )
    } : {
      type: "Sector",
      shape: makeSectorShape(nr.cx, nr.cy, Cn - In / 2, Cn + In / 2, 0, Math.PI * 2)
    };
  }
};
const PolarAxisPointer$1 = PolarAxisPointer;
var PolarModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.findAxisModel = function(Cn) {
      var Bn, In = this.ecModel;
      return In.eachComponent(Cn, function(Dn) {
        Dn.getCoordSysModel() === this && (Bn = Dn);
      }, this), Bn;
    }, nr.type = "polar", nr.dependencies = ["radiusAxis", "angleAxis"], nr.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, nr;
  }(ComponentModel$1)
);
const PolarModel$1 = PolarModel;
var PolarAxisModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    }, nr.type = "polarAxis", nr;
  }(ComponentModel$1)
);
mixin(PolarAxisModel, AxisModelCommonMixin);
var AngleAxisModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "angleAxis", nr;
  }(PolarAxisModel)
), RadiusAxisModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "radiusAxis", nr;
  }(PolarAxisModel)
), RadiusAxis = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn) {
      return _n.call(this, "radius", Cn, Bn) || this;
    }
    return nr.prototype.pointToData = function(Cn, Bn) {
      return this.polar.pointToData(Cn, Bn)[this.dim === "radius" ? 0 : 1];
    }, nr;
  }(Axis$1)
);
RadiusAxis.prototype.dataToRadius = Axis$1.prototype.dataToCoord;
RadiusAxis.prototype.radiusToData = Axis$1.prototype.coordToData;
const RadiusAxis$1 = RadiusAxis;
var inner$8 = makeInner(), AngleAxis = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn) {
      return _n.call(this, "angle", Cn, Bn || [0, 360]) || this;
    }
    return nr.prototype.pointToData = function(Cn, Bn) {
      return this.polar.pointToData(Cn, Bn)[this.dim === "radius" ? 0 : 1];
    }, nr.prototype.calculateCategoryInterval = function() {
      var Cn = this, Bn = Cn.getLabelModel(), In = Cn.scale, Dn = In.getExtent(), Ln = In.count();
      if (Dn[1] - Dn[0] < 1)
        return 0;
      var $n = Dn[0], Nn = Cn.dataToCoord($n + 1) - Cn.dataToCoord($n), Rn = Math.abs(Nn), Fn = getBoundingRect($n == null ? "" : $n + "", Bn.getFont(), "center", "top"), Pn = Math.max(Fn.height, 7), Un = Pn / Rn;
      isNaN(Un) && (Un = 1 / 0);
      var Hn = Math.max(0, Math.floor(Un)), zn = inner$8(Cn.model), Gn = zn.lastAutoInterval, Yn = zn.lastTickCount;
      return Gn != null && Yn != null && Math.abs(Gn - Hn) <= 1 && Math.abs(Yn - Ln) <= 1 && Gn > Hn ? Hn = Gn : (zn.lastTickCount = Ln, zn.lastAutoInterval = Hn), Hn;
    }, nr;
  }(Axis$1)
);
AngleAxis.prototype.dataToAngle = Axis$1.prototype.dataToCoord;
AngleAxis.prototype.angleToData = Axis$1.prototype.coordToData;
const AngleAxis$1 = AngleAxis;
var polarDimensions = ["radius", "angle"], Polar = (
  /** @class */
  function() {
    function _n(nr) {
      this.dimensions = polarDimensions, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new RadiusAxis$1(), this._angleAxis = new AngleAxis$1(), this.axisPointerEnabled = !0, this.name = nr || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return _n.prototype.containPoint = function(nr) {
      var Cn = this.pointToCoord(nr);
      return this._radiusAxis.contain(Cn[0]) && this._angleAxis.contain(Cn[1]);
    }, _n.prototype.containData = function(nr) {
      return this._radiusAxis.containData(nr[0]) && this._angleAxis.containData(nr[1]);
    }, _n.prototype.getAxis = function(nr) {
      var Cn = "_" + nr + "Axis";
      return this[Cn];
    }, _n.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, _n.prototype.getAxesByScale = function(nr) {
      var Cn = [], Bn = this._angleAxis, In = this._radiusAxis;
      return Bn.scale.type === nr && Cn.push(Bn), In.scale.type === nr && Cn.push(In), Cn;
    }, _n.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, _n.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, _n.prototype.getOtherAxis = function(nr) {
      var Cn = this._angleAxis;
      return nr === Cn ? this._radiusAxis : Cn;
    }, _n.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, _n.prototype.getTooltipAxes = function(nr) {
      var Cn = nr != null && nr !== "auto" ? this.getAxis(nr) : this.getBaseAxis();
      return {
        baseAxes: [Cn],
        otherAxes: [this.getOtherAxis(Cn)]
      };
    }, _n.prototype.dataToPoint = function(nr, Cn) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(nr[0], Cn), this._angleAxis.dataToAngle(nr[1], Cn)]);
    }, _n.prototype.pointToData = function(nr, Cn) {
      var Bn = this.pointToCoord(nr);
      return [this._radiusAxis.radiusToData(Bn[0], Cn), this._angleAxis.angleToData(Bn[1], Cn)];
    }, _n.prototype.pointToCoord = function(nr) {
      var Cn = nr[0] - this.cx, Bn = nr[1] - this.cy, In = this.getAngleAxis(), Dn = In.getExtent(), Ln = Math.min(Dn[0], Dn[1]), $n = Math.max(Dn[0], Dn[1]);
      In.inverse ? Ln = $n - 360 : $n = Ln + 360;
      var Nn = Math.sqrt(Cn * Cn + Bn * Bn);
      Cn /= Nn, Bn /= Nn;
      for (var Rn = Math.atan2(-Bn, Cn) / Math.PI * 180, Fn = Rn < Ln ? 1 : -1; Rn < Ln || Rn > $n; )
        Rn += Fn * 360;
      return [Nn, Rn];
    }, _n.prototype.coordToPoint = function(nr) {
      var Cn = nr[0], Bn = nr[1] / 180 * Math.PI, In = Math.cos(Bn) * Cn + this.cx, Dn = -Math.sin(Bn) * Cn + this.cy;
      return [In, Dn];
    }, _n.prototype.getArea = function() {
      var nr = this.getAngleAxis(), Cn = this.getRadiusAxis(), Bn = Cn.getExtent().slice();
      Bn[0] > Bn[1] && Bn.reverse();
      var In = nr.getExtent(), Dn = Math.PI / 180, Ln = 1e-4;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: Bn[0],
        r: Bn[1],
        startAngle: -In[0] * Dn,
        endAngle: -In[1] * Dn,
        clockwise: nr.inverse,
        contain: function($n, Nn) {
          var Rn = $n - this.cx, Fn = Nn - this.cy, Pn = Rn * Rn + Fn * Fn, Un = this.r, Hn = this.r0;
          return Un !== Hn && Pn - Ln <= Un * Un && Pn + Ln >= Hn * Hn;
        }
      };
    }, _n.prototype.convertToPixel = function(nr, Cn, Bn) {
      var In = getCoordSys$2(Cn);
      return In === this ? this.dataToPoint(Bn) : null;
    }, _n.prototype.convertFromPixel = function(nr, Cn, Bn) {
      var In = getCoordSys$2(Cn);
      return In === this ? this.pointToData(Bn) : null;
    }, _n;
  }()
);
function getCoordSys$2(_n) {
  var nr = _n.seriesModel, Cn = _n.polarModel;
  return Cn && Cn.coordinateSystem || nr && nr.coordinateSystem;
}
const Polar$1 = Polar;
function resizePolar(_n, nr, Cn) {
  var Bn = nr.get("center"), In = Cn.getWidth(), Dn = Cn.getHeight();
  _n.cx = parsePercent(Bn[0], In), _n.cy = parsePercent(Bn[1], Dn);
  var Ln = _n.getRadiusAxis(), $n = Math.min(In, Dn) / 2, Nn = nr.get("radius");
  Nn == null ? Nn = [0, "100%"] : isArray$4(Nn) || (Nn = [0, Nn]);
  var Rn = [parsePercent(Nn[0], $n), parsePercent(Nn[1], $n)];
  Ln.inverse ? Ln.setExtent(Rn[1], Rn[0]) : Ln.setExtent(Rn[0], Rn[1]);
}
function updatePolarScale(_n, nr) {
  var Cn = this, Bn = Cn.getAngleAxis(), In = Cn.getRadiusAxis();
  if (Bn.scale.setExtent(1 / 0, -1 / 0), In.scale.setExtent(1 / 0, -1 / 0), _n.eachSeries(function($n) {
    if ($n.coordinateSystem === Cn) {
      var Nn = $n.getData();
      each$f(getDataDimensionsOnAxis(Nn, "radius"), function(Rn) {
        In.scale.unionExtentFromData(Nn, Rn);
      }), each$f(getDataDimensionsOnAxis(Nn, "angle"), function(Rn) {
        Bn.scale.unionExtentFromData(Nn, Rn);
      });
    }
  }), niceScaleExtent(Bn.scale, Bn.model), niceScaleExtent(In.scale, In.model), Bn.type === "category" && !Bn.onBand) {
    var Dn = Bn.getExtent(), Ln = 360 / Bn.scale.count();
    Bn.inverse ? Dn[1] += Ln : Dn[1] -= Ln, Bn.setExtent(Dn[0], Dn[1]);
  }
}
function isAngleAxisModel(_n) {
  return _n.mainType === "angleAxis";
}
function setAxis(_n, nr) {
  var Cn;
  if (_n.type = nr.get("type"), _n.scale = createScaleByModel$1(nr), _n.onBand = nr.get("boundaryGap") && _n.type === "category", _n.inverse = nr.get("inverse"), isAngleAxisModel(nr)) {
    _n.inverse = _n.inverse !== nr.get("clockwise");
    var Bn = nr.get("startAngle"), In = (Cn = nr.get("endAngle")) !== null && Cn !== void 0 ? Cn : Bn + (_n.inverse ? -360 : 360);
    _n.setExtent(Bn, In);
  }
  nr.axis = _n, _n.model = nr;
}
var polarCreator = {
  dimensions: polarDimensions,
  create: function(_n, nr) {
    var Cn = [];
    return _n.eachComponent("polar", function(Bn, In) {
      var Dn = new Polar$1(In + "");
      Dn.update = updatePolarScale;
      var Ln = Dn.getRadiusAxis(), $n = Dn.getAngleAxis(), Nn = Bn.findAxisModel("radiusAxis"), Rn = Bn.findAxisModel("angleAxis");
      setAxis(Ln, Nn), setAxis($n, Rn), resizePolar(Dn, Bn, nr), Cn.push(Dn), Bn.coordinateSystem = Dn, Dn.model = Bn;
    }), _n.eachSeries(function(Bn) {
      if (Bn.get("coordinateSystem") === "polar") {
        var In = Bn.getReferringComponents("polar", SINGLE_REFERRING).models[0];
        if (process.env.NODE_ENV !== "production" && !In)
          throw new Error('Polar "' + retrieve(Bn.get("polarIndex"), Bn.get("polarId"), 0) + '" not found');
        Bn.coordinateSystem = In.coordinateSystem;
      }
    }), Cn;
  }
};
const polarCreator$1 = polarCreator;
var elementList = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function getAxisLineShape(_n, nr, Cn) {
  nr[1] > nr[0] && (nr = nr.slice().reverse());
  var Bn = _n.coordToPoint([nr[0], Cn]), In = _n.coordToPoint([nr[1], Cn]);
  return {
    x1: Bn[0],
    y1: Bn[1],
    x2: In[0],
    y2: In[1]
  };
}
function getRadiusIdx(_n) {
  var nr = _n.getRadiusAxis();
  return nr.inverse ? 0 : 1;
}
function fixAngleOverlap(_n) {
  var nr = _n[0], Cn = _n[_n.length - 1];
  nr && Cn && Math.abs(Math.abs(nr.coord - Cn.coord) - 360) < 1e-4 && _n.pop();
}
var AngleAxisView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.axisPointerClass = "PolarAxisPointer", Cn;
    }
    return nr.prototype.render = function(Cn, Bn) {
      if (this.group.removeAll(), !!Cn.get("show")) {
        var In = Cn.axis, Dn = In.polar, Ln = Dn.getRadiusAxis().getExtent(), $n = In.getTicksCoords(), Nn = In.getMinorTicksCoords(), Rn = map$1(In.getViewLabels(), function(Fn) {
          Fn = clone$4(Fn);
          var Pn = In.scale, Un = Pn.type === "ordinal" ? Pn.getRawOrdinalNumber(Fn.tickValue) : Fn.tickValue;
          return Fn.coord = In.dataToCoord(Un), Fn;
        });
        fixAngleOverlap(Rn), fixAngleOverlap($n), each$f(elementList, function(Fn) {
          Cn.get([Fn, "show"]) && (!In.scale.isBlank() || Fn === "axisLine") && angelAxisElementsBuilders[Fn](this.group, Cn, Dn, $n, Nn, Ln, Rn);
        }, this);
      }
    }, nr.type = "angleAxis", nr;
  }(AxisView$1)
), angelAxisElementsBuilders = {
  axisLine: function(_n, nr, Cn, Bn, In, Dn) {
    var Ln = nr.getModel(["axisLine", "lineStyle"]), $n = Cn.getAngleAxis(), Nn = Math.PI / 180, Rn = $n.getExtent(), Fn = getRadiusIdx(Cn), Pn = Fn ? 0 : 1, Un, Hn = Math.abs(Rn[1] - Rn[0]) === 360 ? "Circle" : "Arc";
    Dn[Pn] === 0 ? Un = new graphic$1[Hn]({
      shape: {
        cx: Cn.cx,
        cy: Cn.cy,
        r: Dn[Fn],
        startAngle: -Rn[0] * Nn,
        endAngle: -Rn[1] * Nn,
        clockwise: $n.inverse
      },
      style: Ln.getLineStyle(),
      z2: 1,
      silent: !0
    }) : Un = new Ring$1({
      shape: {
        cx: Cn.cx,
        cy: Cn.cy,
        r: Dn[Fn],
        r0: Dn[Pn]
      },
      style: Ln.getLineStyle(),
      z2: 1,
      silent: !0
    }), Un.style.fill = null, _n.add(Un);
  },
  axisTick: function(_n, nr, Cn, Bn, In, Dn) {
    var Ln = nr.getModel("axisTick"), $n = (Ln.get("inside") ? -1 : 1) * Ln.get("length"), Nn = Dn[getRadiusIdx(Cn)], Rn = map$1(Bn, function(Fn) {
      return new Line$3({
        shape: getAxisLineShape(Cn, [Nn, Nn + $n], Fn.coord)
      });
    });
    _n.add(mergePath(Rn, {
      style: defaults(Ln.getModel("lineStyle").getLineStyle(), {
        stroke: nr.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(_n, nr, Cn, Bn, In, Dn) {
    if (In.length) {
      for (var Ln = nr.getModel("axisTick"), $n = nr.getModel("minorTick"), Nn = (Ln.get("inside") ? -1 : 1) * $n.get("length"), Rn = Dn[getRadiusIdx(Cn)], Fn = [], Pn = 0; Pn < In.length; Pn++)
        for (var Un = 0; Un < In[Pn].length; Un++)
          Fn.push(new Line$3({
            shape: getAxisLineShape(Cn, [Rn, Rn + Nn], In[Pn][Un].coord)
          }));
      _n.add(mergePath(Fn, {
        style: defaults($n.getModel("lineStyle").getLineStyle(), defaults(Ln.getLineStyle(), {
          stroke: nr.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(_n, nr, Cn, Bn, In, Dn, Ln) {
    var $n = nr.getCategories(!0), Nn = nr.getModel("axisLabel"), Rn = Nn.get("margin"), Fn = nr.get("triggerEvent");
    each$f(Ln, function(Pn, Un) {
      var Hn = Nn, zn = Pn.tickValue, Gn = Dn[getRadiusIdx(Cn)], Yn = Cn.coordToPoint([Gn + Rn, Pn.coord]), Wn = Cn.cx, Xn = Cn.cy, ea = Math.abs(Yn[0] - Wn) / Gn < 0.3 ? "center" : Yn[0] > Wn ? "left" : "right", ta = Math.abs(Yn[1] - Xn) / Gn < 0.3 ? "middle" : Yn[1] > Xn ? "top" : "bottom";
      if ($n && $n[zn]) {
        var na = $n[zn];
        isObject$6(na) && na.textStyle && (Hn = new Model$1(na.textStyle, Nn, Nn.ecModel));
      }
      var ra = new ZRText$1({
        silent: AxisBuilder$1.isLabelSilent(nr),
        style: createTextStyle$1(Hn, {
          x: Yn[0],
          y: Yn[1],
          fill: Hn.getTextColor() || nr.get(["axisLine", "lineStyle", "color"]),
          text: Pn.formattedLabel,
          align: ea,
          verticalAlign: ta
        })
      });
      if (_n.add(ra), Fn) {
        var aa = AxisBuilder$1.makeAxisEventDataBase(nr);
        aa.targetType = "axisLabel", aa.value = Pn.rawLabel, getECData(ra).eventData = aa;
      }
    }, this);
  },
  splitLine: function(_n, nr, Cn, Bn, In, Dn) {
    var Ln = nr.getModel("splitLine"), $n = Ln.getModel("lineStyle"), Nn = $n.get("color"), Rn = 0;
    Nn = Nn instanceof Array ? Nn : [Nn];
    for (var Fn = [], Pn = 0; Pn < Bn.length; Pn++) {
      var Un = Rn++ % Nn.length;
      Fn[Un] = Fn[Un] || [], Fn[Un].push(new Line$3({
        shape: getAxisLineShape(Cn, Dn, Bn[Pn].coord)
      }));
    }
    for (var Pn = 0; Pn < Fn.length; Pn++)
      _n.add(mergePath(Fn[Pn], {
        style: defaults({
          stroke: Nn[Pn % Nn.length]
        }, $n.getLineStyle()),
        silent: !0,
        z: nr.get("z")
      }));
  },
  minorSplitLine: function(_n, nr, Cn, Bn, In, Dn) {
    if (In.length) {
      for (var Ln = nr.getModel("minorSplitLine"), $n = Ln.getModel("lineStyle"), Nn = [], Rn = 0; Rn < In.length; Rn++)
        for (var Fn = 0; Fn < In[Rn].length; Fn++)
          Nn.push(new Line$3({
            shape: getAxisLineShape(Cn, Dn, In[Rn][Fn].coord)
          }));
      _n.add(mergePath(Nn, {
        style: $n.getLineStyle(),
        silent: !0,
        z: nr.get("z")
      }));
    }
  },
  splitArea: function(_n, nr, Cn, Bn, In, Dn) {
    if (Bn.length) {
      var Ln = nr.getModel("splitArea"), $n = Ln.getModel("areaStyle"), Nn = $n.get("color"), Rn = 0;
      Nn = Nn instanceof Array ? Nn : [Nn];
      for (var Fn = [], Pn = Math.PI / 180, Un = -Bn[0].coord * Pn, Hn = Math.min(Dn[0], Dn[1]), zn = Math.max(Dn[0], Dn[1]), Gn = nr.get("clockwise"), Yn = 1, Wn = Bn.length; Yn <= Wn; Yn++) {
        var Xn = Yn === Wn ? Bn[0].coord : Bn[Yn].coord, ea = Rn++ % Nn.length;
        Fn[ea] = Fn[ea] || [], Fn[ea].push(new Sector$1({
          shape: {
            cx: Cn.cx,
            cy: Cn.cy,
            r0: Hn,
            r: zn,
            startAngle: Un,
            endAngle: -Xn * Pn,
            clockwise: Gn
          },
          silent: !0
        })), Un = -Xn * Pn;
      }
      for (var Yn = 0; Yn < Fn.length; Yn++)
        _n.add(mergePath(Fn[Yn], {
          style: defaults({
            fill: Nn[Yn % Nn.length]
          }, $n.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
const AngleAxisView$1 = AngleAxisView;
var axisBuilderAttrs$1 = ["axisLine", "axisTickLabel", "axisName"], selfBuilderAttrs$1 = ["splitLine", "splitArea", "minorSplitLine"], RadiusAxisView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.axisPointerClass = "PolarAxisPointer", Cn;
    }
    return nr.prototype.render = function(Cn, Bn) {
      if (this.group.removeAll(), !!Cn.get("show")) {
        var In = this._axisGroup, Dn = this._axisGroup = new Group$4();
        this.group.add(Dn);
        var Ln = Cn.axis, $n = Ln.polar, Nn = $n.getAngleAxis(), Rn = Ln.getTicksCoords(), Fn = Ln.getMinorTicksCoords(), Pn = Nn.getExtent()[0], Un = Ln.getExtent(), Hn = layoutAxis($n, Cn, Pn), zn = new AxisBuilder$1(Cn, Hn);
        each$f(axisBuilderAttrs$1, zn.add, zn), Dn.add(zn.getGroup()), groupTransition(In, Dn, Cn), each$f(selfBuilderAttrs$1, function(Gn) {
          Cn.get([Gn, "show"]) && !Ln.scale.isBlank() && axisElementBuilders$1[Gn](this.group, Cn, $n, Pn, Un, Rn, Fn);
        }, this);
      }
    }, nr.type = "radiusAxis", nr;
  }(AxisView$1)
), axisElementBuilders$1 = {
  splitLine: function(_n, nr, Cn, Bn, In, Dn) {
    var Ln = nr.getModel("splitLine"), $n = Ln.getModel("lineStyle"), Nn = $n.get("color"), Rn = 0, Fn = Cn.getAngleAxis(), Pn = Math.PI / 180, Un = Fn.getExtent(), Hn = Math.abs(Un[1] - Un[0]) === 360 ? "Circle" : "Arc";
    Nn = Nn instanceof Array ? Nn : [Nn];
    for (var zn = [], Gn = 0; Gn < Dn.length; Gn++) {
      var Yn = Rn++ % Nn.length;
      zn[Yn] = zn[Yn] || [], zn[Yn].push(new graphic$1[Hn]({
        shape: {
          cx: Cn.cx,
          cy: Cn.cy,
          // ensure circle radius >= 0
          r: Math.max(Dn[Gn].coord, 0),
          startAngle: -Un[0] * Pn,
          endAngle: -Un[1] * Pn,
          clockwise: Fn.inverse
        }
      }));
    }
    for (var Gn = 0; Gn < zn.length; Gn++)
      _n.add(mergePath(zn[Gn], {
        style: defaults({
          stroke: Nn[Gn % Nn.length],
          fill: null
        }, $n.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(_n, nr, Cn, Bn, In, Dn, Ln) {
    if (Ln.length) {
      for (var $n = nr.getModel("minorSplitLine"), Nn = $n.getModel("lineStyle"), Rn = [], Fn = 0; Fn < Ln.length; Fn++)
        for (var Pn = 0; Pn < Ln[Fn].length; Pn++)
          Rn.push(new Circle$1({
            shape: {
              cx: Cn.cx,
              cy: Cn.cy,
              r: Ln[Fn][Pn].coord
            }
          }));
      _n.add(mergePath(Rn, {
        style: defaults({
          fill: null
        }, Nn.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(_n, nr, Cn, Bn, In, Dn) {
    if (Dn.length) {
      var Ln = nr.getModel("splitArea"), $n = Ln.getModel("areaStyle"), Nn = $n.get("color"), Rn = 0;
      Nn = Nn instanceof Array ? Nn : [Nn];
      for (var Fn = [], Pn = Dn[0].coord, Un = 1; Un < Dn.length; Un++) {
        var Hn = Rn++ % Nn.length;
        Fn[Hn] = Fn[Hn] || [], Fn[Hn].push(new Sector$1({
          shape: {
            cx: Cn.cx,
            cy: Cn.cy,
            r0: Pn,
            r: Dn[Un].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), Pn = Dn[Un].coord;
      }
      for (var Un = 0; Un < Fn.length; Un++)
        _n.add(mergePath(Fn[Un], {
          style: defaults({
            fill: Nn[Un % Nn.length]
          }, $n.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function layoutAxis(_n, nr, Cn) {
  return {
    position: [_n.cx, _n.cy],
    rotation: Cn / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: nr.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
const RadiusAxisView$1 = RadiusAxisView;
function getSeriesStackId(_n) {
  return _n.get("stack") || "__ec_stack_" + _n.seriesIndex;
}
function getAxisKey(_n, nr) {
  return nr.dim + _n.model.componentIndex;
}
function barLayoutPolar(_n, nr, Cn) {
  var Bn = {}, In = calRadialBar(filter(nr.getSeriesByType(_n), function(Dn) {
    return !nr.isSeriesFiltered(Dn) && Dn.coordinateSystem && Dn.coordinateSystem.type === "polar";
  }));
  nr.eachSeriesByType(_n, function(Dn) {
    if (Dn.coordinateSystem.type === "polar") {
      var Ln = Dn.getData(), $n = Dn.coordinateSystem, Nn = $n.getBaseAxis(), Rn = getAxisKey($n, Nn), Fn = getSeriesStackId(Dn), Pn = In[Rn][Fn], Un = Pn.offset, Hn = Pn.width, zn = $n.getOtherAxis(Nn), Gn = Dn.coordinateSystem.cx, Yn = Dn.coordinateSystem.cy, Wn = Dn.get("barMinHeight") || 0, Xn = Dn.get("barMinAngle") || 0;
      Bn[Fn] = Bn[Fn] || [];
      for (var ea = Ln.mapDimension(zn.dim), ta = Ln.mapDimension(Nn.dim), na = isDimensionStacked(
        Ln,
        ea
        /* , baseDim */
      ), ra = Nn.dim !== "radius" || !Dn.get("roundCap", !0), aa = zn.model, ia = aa.get("startValue"), Aa = zn.dataToCoord(ia || 0), sa = 0, oa = Ln.count(); sa < oa; sa++) {
        var la = Ln.get(ea, sa), ua = Ln.get(ta, sa), ca = la >= 0 ? "p" : "n", fa = Aa;
        na && (Bn[Fn][ua] || (Bn[Fn][ua] = {
          p: Aa,
          n: Aa
          // Negative stack
        }), fa = Bn[Fn][ua][ca]);
        var ha = void 0, pa = void 0, ya = void 0, da = void 0;
        if (zn.dim === "radius") {
          var Ca = zn.dataToCoord(la) - Aa, ma = Nn.dataToCoord(ua);
          Math.abs(Ca) < Wn && (Ca = (Ca < 0 ? -1 : 1) * Wn), ha = fa, pa = fa + Ca, ya = ma - Un, da = ya - Hn, na && (Bn[Fn][ua][ca] = pa);
        } else {
          var va = zn.dataToCoord(la, ra) - Aa, ga = Nn.dataToCoord(ua);
          Math.abs(va) < Xn && (va = (va < 0 ? -1 : 1) * Xn), ha = ga + Un, pa = ha + Hn, ya = fa, da = fa + va, na && (Bn[Fn][ua][ca] = da);
        }
        Ln.setItemLayout(sa, {
          cx: Gn,
          cy: Yn,
          r0: ha,
          r: pa,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -ya * Math.PI / 180,
          endAngle: -da * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: ya >= da
        });
      }
    }
  });
}
function calRadialBar(_n) {
  var nr = {};
  each$f(_n, function(Bn, In) {
    var Dn = Bn.getData(), Ln = Bn.coordinateSystem, $n = Ln.getBaseAxis(), Nn = getAxisKey(Ln, $n), Rn = $n.getExtent(), Fn = $n.type === "category" ? $n.getBandWidth() : Math.abs(Rn[1] - Rn[0]) / Dn.count(), Pn = nr[Nn] || {
      bandWidth: Fn,
      remainedWidth: Fn,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, Un = Pn.stacks;
    nr[Nn] = Pn;
    var Hn = getSeriesStackId(Bn);
    Un[Hn] || Pn.autoWidthCount++, Un[Hn] = Un[Hn] || {
      width: 0,
      maxWidth: 0
    };
    var zn = parsePercent(Bn.get("barWidth"), Fn), Gn = parsePercent(Bn.get("barMaxWidth"), Fn), Yn = Bn.get("barGap"), Wn = Bn.get("barCategoryGap");
    zn && !Un[Hn].width && (zn = Math.min(Pn.remainedWidth, zn), Un[Hn].width = zn, Pn.remainedWidth -= zn), Gn && (Un[Hn].maxWidth = Gn), Yn != null && (Pn.gap = Yn), Wn != null && (Pn.categoryGap = Wn);
  });
  var Cn = {};
  return each$f(nr, function(Bn, In) {
    Cn[In] = {};
    var Dn = Bn.stacks, Ln = Bn.bandWidth, $n = parsePercent(Bn.categoryGap, Ln), Nn = parsePercent(Bn.gap, 1), Rn = Bn.remainedWidth, Fn = Bn.autoWidthCount, Pn = (Rn - $n) / (Fn + (Fn - 1) * Nn);
    Pn = Math.max(Pn, 0), each$f(Dn, function(Gn, Yn) {
      var Wn = Gn.maxWidth;
      Wn && Wn < Pn && (Wn = Math.min(Wn, Rn), Gn.width && (Wn = Math.min(Wn, Gn.width)), Rn -= Wn, Gn.width = Wn, Fn--);
    }), Pn = (Rn - $n) / (Fn + (Fn - 1) * Nn), Pn = Math.max(Pn, 0);
    var Un = 0, Hn;
    each$f(Dn, function(Gn, Yn) {
      Gn.width || (Gn.width = Pn), Hn = Gn, Un += Gn.width * (1 + Nn);
    }), Hn && (Un -= Hn.width * Nn);
    var zn = -Un / 2;
    each$f(Dn, function(Gn, Yn) {
      Cn[In][Yn] = Cn[In][Yn] || {
        offset: zn,
        width: Gn.width
      }, zn += Gn.width * (1 + Nn);
    });
  }), Cn;
}
var angleAxisExtraOption = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, radiusAxisExtraOption = {
  splitNumber: 5
}, PolarView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "polar", nr;
  }(ComponentView$1)
);
function install$o(_n) {
  use(install$q), AxisView$1.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer$1), _n.registerCoordinateSystem("polar", polarCreator$1), _n.registerComponentModel(PolarModel$1), _n.registerComponentView(PolarView), axisModelCreator(_n, "angle", AngleAxisModel, angleAxisExtraOption), axisModelCreator(_n, "radius", RadiusAxisModel, radiusAxisExtraOption), _n.registerComponentView(AngleAxisView$1), _n.registerComponentView(RadiusAxisView$1), _n.registerLayout(curry$1(barLayoutPolar, "bar"));
}
function layout$1(_n, nr) {
  nr = nr || {};
  var Cn = _n.coordinateSystem, Bn = _n.axis, In = {}, Dn = Bn.position, Ln = Bn.orient, $n = Cn.getRect(), Nn = [$n.x, $n.x + $n.width, $n.y, $n.y + $n.height], Rn = {
    horizontal: {
      top: Nn[2],
      bottom: Nn[3]
    },
    vertical: {
      left: Nn[0],
      right: Nn[1]
    }
  };
  In.position = [Ln === "vertical" ? Rn.vertical[Dn] : Nn[0], Ln === "horizontal" ? Rn.horizontal[Dn] : Nn[3]];
  var Fn = {
    horizontal: 0,
    vertical: 1
  };
  In.rotation = Math.PI / 2 * Fn[Ln];
  var Pn = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  In.labelDirection = In.tickDirection = In.nameDirection = Pn[Dn], _n.get(["axisTick", "inside"]) && (In.tickDirection = -In.tickDirection), retrieve(nr.labelInside, _n.get(["axisLabel", "inside"])) && (In.labelDirection = -In.labelDirection);
  var Un = nr.rotate;
  return Un == null && (Un = _n.get(["axisLabel", "rotate"])), In.labelRotation = Dn === "top" ? -Un : Un, In.z2 = 1, In;
}
var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"], selfBuilderAttrs = ["splitArea", "splitLine"], SingleAxisView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.axisPointerClass = "SingleAxisPointer", Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      var Ln = this.group;
      Ln.removeAll();
      var $n = this._axisGroup;
      this._axisGroup = new Group$4();
      var Nn = layout$1(Cn), Rn = new AxisBuilder$1(Cn, Nn);
      each$f(axisBuilderAttrs, Rn.add, Rn), Ln.add(this._axisGroup), Ln.add(Rn.getGroup()), each$f(selfBuilderAttrs, function(Fn) {
        Cn.get([Fn, "show"]) && axisElementBuilders[Fn](this, this.group, this._axisGroup, Cn);
      }, this), groupTransition($n, this._axisGroup, Cn), _n.prototype.render.call(this, Cn, Bn, In, Dn);
    }, nr.prototype.remove = function() {
      rectCoordAxisHandleRemove(this);
    }, nr.type = "singleAxis", nr;
  }(AxisView$1)
), axisElementBuilders = {
  splitLine: function(_n, nr, Cn, Bn) {
    var In = Bn.axis;
    if (!In.scale.isBlank()) {
      var Dn = Bn.getModel("splitLine"), Ln = Dn.getModel("lineStyle"), $n = Ln.get("color");
      $n = $n instanceof Array ? $n : [$n];
      for (var Nn = Ln.get("width"), Rn = Bn.coordinateSystem.getRect(), Fn = In.isHorizontal(), Pn = [], Un = 0, Hn = In.getTicksCoords({
        tickModel: Dn
      }), zn = [], Gn = [], Yn = 0; Yn < Hn.length; ++Yn) {
        var Wn = In.toGlobalCoord(Hn[Yn].coord);
        Fn ? (zn[0] = Wn, zn[1] = Rn.y, Gn[0] = Wn, Gn[1] = Rn.y + Rn.height) : (zn[0] = Rn.x, zn[1] = Wn, Gn[0] = Rn.x + Rn.width, Gn[1] = Wn);
        var Xn = new Line$3({
          shape: {
            x1: zn[0],
            y1: zn[1],
            x2: Gn[0],
            y2: Gn[1]
          },
          silent: !0
        });
        subPixelOptimizeLine(Xn.shape, Nn);
        var ea = Un++ % $n.length;
        Pn[ea] = Pn[ea] || [], Pn[ea].push(Xn);
      }
      for (var ta = Ln.getLineStyle(["color"]), Yn = 0; Yn < Pn.length; ++Yn)
        nr.add(mergePath(Pn[Yn], {
          style: defaults({
            stroke: $n[Yn % $n.length]
          }, ta),
          silent: !0
        }));
    }
  },
  splitArea: function(_n, nr, Cn, Bn) {
    rectCoordAxisBuildSplitArea(_n, Cn, Bn, Bn);
  }
};
const SingleAxisView$1 = SingleAxisView;
var SingleAxisModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.getCoordSysModel = function() {
      return this;
    }, nr.type = "singleAxis", nr.layoutMode = "box", nr.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, nr;
  }(ComponentModel$1)
);
mixin(SingleAxisModel, AxisModelCommonMixin.prototype);
const SingleAxisModel$1 = SingleAxisModel;
var SingleAxis = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In, Dn, Ln) {
      var $n = _n.call(this, Cn, Bn, In) || this;
      return $n.type = Dn || "value", $n.position = Ln || "bottom", $n;
    }
    return nr.prototype.isHorizontal = function() {
      var Cn = this.position;
      return Cn === "top" || Cn === "bottom";
    }, nr.prototype.pointToData = function(Cn, Bn) {
      return this.coordinateSystem.pointToData(Cn)[0];
    }, nr;
  }(Axis$1)
);
const SingleAxis$1 = SingleAxis;
var singleDimensions = ["single"], Single = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.type = "single", this.dimension = "single", this.dimensions = singleDimensions, this.axisPointerEnabled = !0, this.model = nr, this._init(nr, Cn, Bn);
    }
    return _n.prototype._init = function(nr, Cn, Bn) {
      var In = this.dimension, Dn = new SingleAxis$1(In, createScaleByModel$1(nr), [0, 0], nr.get("type"), nr.get("position")), Ln = Dn.type === "category";
      Dn.onBand = Ln && nr.get("boundaryGap"), Dn.inverse = nr.get("inverse"), Dn.orient = nr.get("orient"), nr.axis = Dn, Dn.model = nr, Dn.coordinateSystem = this, this._axis = Dn;
    }, _n.prototype.update = function(nr, Cn) {
      nr.eachSeries(function(Bn) {
        if (Bn.coordinateSystem === this) {
          var In = Bn.getData();
          each$f(In.mapDimensionsAll(this.dimension), function(Dn) {
            this._axis.scale.unionExtentFromData(In, Dn);
          }, this), niceScaleExtent(this._axis.scale, this._axis.model);
        }
      }, this);
    }, _n.prototype.resize = function(nr, Cn) {
      this._rect = getLayoutRect$1({
        left: nr.get("left"),
        top: nr.get("top"),
        right: nr.get("right"),
        bottom: nr.get("bottom"),
        width: nr.get("width"),
        height: nr.get("height")
      }, {
        width: Cn.getWidth(),
        height: Cn.getHeight()
      }), this._adjustAxis();
    }, _n.prototype.getRect = function() {
      return this._rect;
    }, _n.prototype._adjustAxis = function() {
      var nr = this._rect, Cn = this._axis, Bn = Cn.isHorizontal(), In = Bn ? [0, nr.width] : [0, nr.height], Dn = Cn.inverse ? 1 : 0;
      Cn.setExtent(In[Dn], In[1 - Dn]), this._updateAxisTransform(Cn, Bn ? nr.x : nr.y);
    }, _n.prototype._updateAxisTransform = function(nr, Cn) {
      var Bn = nr.getExtent(), In = Bn[0] + Bn[1], Dn = nr.isHorizontal();
      nr.toGlobalCoord = Dn ? function(Ln) {
        return Ln + Cn;
      } : function(Ln) {
        return In - Ln + Cn;
      }, nr.toLocalCoord = Dn ? function(Ln) {
        return Ln - Cn;
      } : function(Ln) {
        return In - Ln + Cn;
      };
    }, _n.prototype.getAxis = function() {
      return this._axis;
    }, _n.prototype.getBaseAxis = function() {
      return this._axis;
    }, _n.prototype.getAxes = function() {
      return [this._axis];
    }, _n.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, _n.prototype.containPoint = function(nr) {
      var Cn = this.getRect(), Bn = this.getAxis(), In = Bn.orient;
      return In === "horizontal" ? Bn.contain(Bn.toLocalCoord(nr[0])) && nr[1] >= Cn.y && nr[1] <= Cn.y + Cn.height : Bn.contain(Bn.toLocalCoord(nr[1])) && nr[0] >= Cn.y && nr[0] <= Cn.y + Cn.height;
    }, _n.prototype.pointToData = function(nr) {
      var Cn = this.getAxis();
      return [Cn.coordToData(Cn.toLocalCoord(nr[Cn.orient === "horizontal" ? 0 : 1]))];
    }, _n.prototype.dataToPoint = function(nr) {
      var Cn = this.getAxis(), Bn = this.getRect(), In = [], Dn = Cn.orient === "horizontal" ? 0 : 1;
      return nr instanceof Array && (nr = nr[0]), In[Dn] = Cn.toGlobalCoord(Cn.dataToCoord(+nr)), In[1 - Dn] = Dn === 0 ? Bn.y + Bn.height / 2 : Bn.x + Bn.width / 2, In;
    }, _n.prototype.convertToPixel = function(nr, Cn, Bn) {
      var In = getCoordSys$1(Cn);
      return In === this ? this.dataToPoint(Bn) : null;
    }, _n.prototype.convertFromPixel = function(nr, Cn, Bn) {
      var In = getCoordSys$1(Cn);
      return In === this ? this.pointToData(Bn) : null;
    }, _n;
  }()
);
function getCoordSys$1(_n) {
  var nr = _n.seriesModel, Cn = _n.singleAxisModel;
  return Cn && Cn.coordinateSystem || nr && nr.coordinateSystem;
}
function create(_n, nr) {
  var Cn = [];
  return _n.eachComponent("singleAxis", function(Bn, In) {
    var Dn = new Single(Bn, _n, nr);
    Dn.name = "single_" + In, Dn.resize(Bn, nr), Bn.coordinateSystem = Dn, Cn.push(Dn);
  }), _n.eachSeries(function(Bn) {
    if (Bn.get("coordinateSystem") === "singleAxis") {
      var In = Bn.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      Bn.coordinateSystem = In && In.coordinateSystem;
    }
  }), Cn;
}
var singleCreator = {
  create,
  dimensions: singleDimensions
};
const singleCreator$1 = singleCreator;
var XY$1 = ["x", "y"], WH$1 = ["width", "height"], SingleAxisPointer = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.makeElOption = function(Cn, Bn, In, Dn, Ln) {
      var $n = In.axis, Nn = $n.coordinateSystem, Rn = getGlobalExtent(Nn, 1 - getPointDimIndex($n)), Fn = Nn.dataToPoint(Bn)[0], Pn = Dn.get("type");
      if (Pn && Pn !== "none") {
        var Un = buildElStyle(Dn), Hn = pointerShapeBuilder[Pn]($n, Fn, Rn);
        Hn.style = Un, Cn.graphicKey = Hn.type, Cn.pointer = Hn;
      }
      var zn = layout$1(In);
      buildCartesianSingleLabelElOption(
        // @ts-ignore
        Bn,
        Cn,
        zn,
        In,
        Dn,
        Ln
      );
    }, nr.prototype.getHandleTransform = function(Cn, Bn, In) {
      var Dn = layout$1(Bn, {
        labelInside: !1
      });
      Dn.labelMargin = In.get(["handle", "margin"]);
      var Ln = getTransformedPosition(Bn.axis, Cn, Dn);
      return {
        x: Ln[0],
        y: Ln[1],
        rotation: Dn.rotation + (Dn.labelDirection < 0 ? Math.PI : 0)
      };
    }, nr.prototype.updateHandleTransform = function(Cn, Bn, In, Dn) {
      var Ln = In.axis, $n = Ln.coordinateSystem, Nn = getPointDimIndex(Ln), Rn = getGlobalExtent($n, Nn), Fn = [Cn.x, Cn.y];
      Fn[Nn] += Bn[Nn], Fn[Nn] = Math.min(Rn[1], Fn[Nn]), Fn[Nn] = Math.max(Rn[0], Fn[Nn]);
      var Pn = getGlobalExtent($n, 1 - Nn), Un = (Pn[1] + Pn[0]) / 2, Hn = [Un, Un];
      return Hn[Nn] = Fn[Nn], {
        x: Fn[0],
        y: Fn[1],
        rotation: Cn.rotation,
        cursorPoint: Hn,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, nr;
  }(BaseAxisPointer$1)
), pointerShapeBuilder = {
  line: function(_n, nr, Cn) {
    var Bn = makeLineShape([nr, Cn[0]], [nr, Cn[1]], getPointDimIndex(_n));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: Bn
    };
  },
  shadow: function(_n, nr, Cn) {
    var Bn = _n.getBandWidth(), In = Cn[1] - Cn[0];
    return {
      type: "Rect",
      shape: makeRectShape([nr - Bn / 2, Cn[0]], [Bn, In], getPointDimIndex(_n))
    };
  }
};
function getPointDimIndex(_n) {
  return _n.isHorizontal() ? 0 : 1;
}
function getGlobalExtent(_n, nr) {
  var Cn = _n.getRect();
  return [Cn[XY$1[nr]], Cn[XY$1[nr]] + Cn[WH$1[nr]]];
}
const SingleAxisPointer$1 = SingleAxisPointer;
var SingleView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "single", nr;
  }(ComponentView$1)
);
function install$n(_n) {
  use(install$q), AxisView$1.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer$1), _n.registerComponentView(SingleView), _n.registerComponentView(SingleAxisView$1), _n.registerComponentModel(SingleAxisModel$1), axisModelCreator(_n, "single", SingleAxisModel$1, SingleAxisModel$1.defaultOption), _n.registerCoordinateSystem("single", singleCreator$1);
}
var CalendarModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      var Dn = getLayoutParams(Cn);
      _n.prototype.init.apply(this, arguments), mergeAndNormalizeLayoutParams$1(Cn, Dn);
    }, nr.prototype.mergeOption = function(Cn) {
      _n.prototype.mergeOption.apply(this, arguments), mergeAndNormalizeLayoutParams$1(this.option, Cn);
    }, nr.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, nr.type = "calendar", nr.defaultOption = {
      // zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: "50%",
        color: "#000"
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: 5,
        // center or left
        align: "center",
        formatter: null,
        color: "#000"
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, nr;
  }(ComponentModel$1)
);
function mergeAndNormalizeLayoutParams$1(_n, nr) {
  var Cn = _n.cellSize, Bn;
  isArray$4(Cn) ? Bn = Cn : Bn = _n.cellSize = [Cn, Cn], Bn.length === 1 && (Bn[1] = Bn[0]);
  var In = map$1([0, 1], function(Dn) {
    return sizeCalculable(nr, Dn) && (Bn[Dn] = "auto"), Bn[Dn] != null && Bn[Dn] !== "auto";
  });
  mergeLayoutParam(_n, nr, {
    type: "box",
    ignoreSize: In
  });
}
const CalendarModel$1 = CalendarModel;
var CalendarView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn = this.group;
      Dn.removeAll();
      var Ln = Cn.coordinateSystem, $n = Ln.getRangeInfo(), Nn = Ln.getOrient(), Rn = Bn.getLocaleModel();
      this._renderDayRect(Cn, $n, Dn), this._renderLines(Cn, $n, Nn, Dn), this._renderYearText(Cn, $n, Nn, Dn), this._renderMonthText(Cn, Rn, Nn, Dn), this._renderWeekText(Cn, Rn, $n, Nn, Dn);
    }, nr.prototype._renderDayRect = function(Cn, Bn, In) {
      for (var Dn = Cn.coordinateSystem, Ln = Cn.getModel("itemStyle").getItemStyle(), $n = Dn.getCellWidth(), Nn = Dn.getCellHeight(), Rn = Bn.start.time; Rn <= Bn.end.time; Rn = Dn.getNextNDay(Rn, 1).time) {
        var Fn = Dn.dataToRect([Rn], !1).tl, Pn = new Rect$3({
          shape: {
            x: Fn[0],
            y: Fn[1],
            width: $n,
            height: Nn
          },
          cursor: "default",
          style: Ln
        });
        In.add(Pn);
      }
    }, nr.prototype._renderLines = function(Cn, Bn, In, Dn) {
      var Ln = this, $n = Cn.coordinateSystem, Nn = Cn.getModel(["splitLine", "lineStyle"]).getLineStyle(), Rn = Cn.get(["splitLine", "show"]), Fn = Nn.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var Pn = Bn.start, Un = 0; Pn.time <= Bn.end.time; Un++) {
        zn(Pn.formatedDate), Un === 0 && (Pn = $n.getDateInfo(Bn.start.y + "-" + Bn.start.m));
        var Hn = Pn.date;
        Hn.setMonth(Hn.getMonth() + 1), Pn = $n.getDateInfo(Hn);
      }
      zn($n.getNextNDay(Bn.end.time, 1).formatedDate);
      function zn(Gn) {
        Ln._firstDayOfMonth.push($n.getDateInfo(Gn)), Ln._firstDayPoints.push($n.dataToRect([Gn], !1).tl);
        var Yn = Ln._getLinePointsOfOneWeek(Cn, Gn, In);
        Ln._tlpoints.push(Yn[0]), Ln._blpoints.push(Yn[Yn.length - 1]), Rn && Ln._drawSplitline(Yn, Nn, Dn);
      }
      Rn && this._drawSplitline(Ln._getEdgesPoints(Ln._tlpoints, Fn, In), Nn, Dn), Rn && this._drawSplitline(Ln._getEdgesPoints(Ln._blpoints, Fn, In), Nn, Dn);
    }, nr.prototype._getEdgesPoints = function(Cn, Bn, In) {
      var Dn = [Cn[0].slice(), Cn[Cn.length - 1].slice()], Ln = In === "horizontal" ? 0 : 1;
      return Dn[0][Ln] = Dn[0][Ln] - Bn / 2, Dn[1][Ln] = Dn[1][Ln] + Bn / 2, Dn;
    }, nr.prototype._drawSplitline = function(Cn, Bn, In) {
      var Dn = new Polyline$3({
        z2: 20,
        shape: {
          points: Cn
        },
        style: Bn
      });
      In.add(Dn);
    }, nr.prototype._getLinePointsOfOneWeek = function(Cn, Bn, In) {
      for (var Dn = Cn.coordinateSystem, Ln = Dn.getDateInfo(Bn), $n = [], Nn = 0; Nn < 7; Nn++) {
        var Rn = Dn.getNextNDay(Ln.time, Nn), Fn = Dn.dataToRect([Rn.time], !1);
        $n[2 * Rn.day] = Fn.tl, $n[2 * Rn.day + 1] = Fn[In === "horizontal" ? "bl" : "tr"];
      }
      return $n;
    }, nr.prototype._formatterLabel = function(Cn, Bn) {
      return isString$1(Cn) && Cn ? formatTplSimple(Cn, Bn) : isFunction$1(Cn) ? Cn(Bn) : Bn.nameMap;
    }, nr.prototype._yearTextPositionControl = function(Cn, Bn, In, Dn, Ln) {
      var $n = Bn[0], Nn = Bn[1], Rn = ["center", "bottom"];
      Dn === "bottom" ? (Nn += Ln, Rn = ["center", "top"]) : Dn === "left" ? $n -= Ln : Dn === "right" ? ($n += Ln, Rn = ["center", "top"]) : Nn -= Ln;
      var Fn = 0;
      return (Dn === "left" || Dn === "right") && (Fn = Math.PI / 2), {
        rotation: Fn,
        x: $n,
        y: Nn,
        style: {
          align: Rn[0],
          verticalAlign: Rn[1]
        }
      };
    }, nr.prototype._renderYearText = function(Cn, Bn, In, Dn) {
      var Ln = Cn.getModel("yearLabel");
      if (Ln.get("show")) {
        var $n = Ln.get("margin"), Nn = Ln.get("position");
        Nn || (Nn = In !== "horizontal" ? "top" : "left");
        var Rn = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], Fn = (Rn[0][0] + Rn[1][0]) / 2, Pn = (Rn[0][1] + Rn[1][1]) / 2, Un = In === "horizontal" ? 0 : 1, Hn = {
          top: [Fn, Rn[Un][1]],
          bottom: [Fn, Rn[1 - Un][1]],
          left: [Rn[1 - Un][0], Pn],
          right: [Rn[Un][0], Pn]
        }, zn = Bn.start.y;
        +Bn.end.y > +Bn.start.y && (zn = zn + "-" + Bn.end.y);
        var Gn = Ln.get("formatter"), Yn = {
          start: Bn.start.y,
          end: Bn.end.y,
          nameMap: zn
        }, Wn = this._formatterLabel(Gn, Yn), Xn = new ZRText$1({
          z2: 30,
          style: createTextStyle$1(Ln, {
            text: Wn
          }),
          silent: Ln.get("silent")
        });
        Xn.attr(this._yearTextPositionControl(Xn, Hn[Nn], In, Nn, $n)), Dn.add(Xn);
      }
    }, nr.prototype._monthTextPositionControl = function(Cn, Bn, In, Dn, Ln) {
      var $n = "left", Nn = "top", Rn = Cn[0], Fn = Cn[1];
      return In === "horizontal" ? (Fn = Fn + Ln, Bn && ($n = "center"), Dn === "start" && (Nn = "bottom")) : (Rn = Rn + Ln, Bn && (Nn = "middle"), Dn === "start" && ($n = "right")), {
        x: Rn,
        y: Fn,
        align: $n,
        verticalAlign: Nn
      };
    }, nr.prototype._renderMonthText = function(Cn, Bn, In, Dn) {
      var Ln = Cn.getModel("monthLabel");
      if (Ln.get("show")) {
        var $n = Ln.get("nameMap"), Nn = Ln.get("margin"), Rn = Ln.get("position"), Fn = Ln.get("align"), Pn = [this._tlpoints, this._blpoints];
        (!$n || isString$1($n)) && ($n && (Bn = getLocaleModel($n) || Bn), $n = Bn.get(["time", "monthAbbr"]) || []);
        var Un = Rn === "start" ? 0 : 1, Hn = In === "horizontal" ? 0 : 1;
        Nn = Rn === "start" ? -Nn : Nn;
        for (var zn = Fn === "center", Gn = Ln.get("silent"), Yn = 0; Yn < Pn[Un].length - 1; Yn++) {
          var Wn = Pn[Un][Yn].slice(), Xn = this._firstDayOfMonth[Yn];
          if (zn) {
            var ea = this._firstDayPoints[Yn];
            Wn[Hn] = (ea[Hn] + Pn[0][Yn + 1][Hn]) / 2;
          }
          var ta = Ln.get("formatter"), na = $n[+Xn.m - 1], ra = {
            yyyy: Xn.y,
            yy: (Xn.y + "").slice(2),
            MM: Xn.m,
            M: +Xn.m,
            nameMap: na
          }, aa = this._formatterLabel(ta, ra), ia = new ZRText$1({
            z2: 30,
            style: extend(createTextStyle$1(Ln, {
              text: aa
            }), this._monthTextPositionControl(Wn, zn, In, Rn, Nn)),
            silent: Gn
          });
          Dn.add(ia);
        }
      }
    }, nr.prototype._weekTextPositionControl = function(Cn, Bn, In, Dn, Ln) {
      var $n = "center", Nn = "middle", Rn = Cn[0], Fn = Cn[1], Pn = In === "start";
      return Bn === "horizontal" ? (Rn = Rn + Dn + (Pn ? 1 : -1) * Ln[0] / 2, $n = Pn ? "right" : "left") : (Fn = Fn + Dn + (Pn ? 1 : -1) * Ln[1] / 2, Nn = Pn ? "bottom" : "top"), {
        x: Rn,
        y: Fn,
        align: $n,
        verticalAlign: Nn
      };
    }, nr.prototype._renderWeekText = function(Cn, Bn, In, Dn, Ln) {
      var $n = Cn.getModel("dayLabel");
      if ($n.get("show")) {
        var Nn = Cn.coordinateSystem, Rn = $n.get("position"), Fn = $n.get("nameMap"), Pn = $n.get("margin"), Un = Nn.getFirstDayOfWeek();
        if (!Fn || isString$1(Fn)) {
          Fn && (Bn = getLocaleModel(Fn) || Bn);
          var Hn = Bn.get(["time", "dayOfWeekShort"]);
          Fn = Hn || map$1(Bn.get(["time", "dayOfWeekAbbr"]), function(ra) {
            return ra[0];
          });
        }
        var zn = Nn.getNextNDay(In.end.time, 7 - In.lweek).time, Gn = [Nn.getCellWidth(), Nn.getCellHeight()];
        Pn = parsePercent(Pn, Math.min(Gn[1], Gn[0])), Rn === "start" && (zn = Nn.getNextNDay(In.start.time, -(7 + In.fweek)).time, Pn = -Pn);
        for (var Yn = $n.get("silent"), Wn = 0; Wn < 7; Wn++) {
          var Xn = Nn.getNextNDay(zn, Wn), ea = Nn.dataToRect([Xn.time], !1).center, ta = Wn;
          ta = Math.abs((Wn + Un) % 7);
          var na = new ZRText$1({
            z2: 30,
            style: extend(createTextStyle$1($n, {
              text: Fn[ta]
            }), this._weekTextPositionControl(ea, Dn, Rn, Pn, Gn)),
            silent: Yn
          });
          Ln.add(na);
        }
      }
    }, nr.type = "calendar", nr;
  }(ComponentView$1)
);
const CalendarView$1 = CalendarView;
var PROXIMATE_ONE_DAY = 864e5, Calendar = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      this.type = "calendar", this.dimensions = _n.dimensions, this.getDimensionsInfo = _n.getDimensionsInfo, this._model = nr;
    }
    return _n.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, _n.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, _n.prototype.getModel = function() {
      return this._model;
    }, _n.prototype.getRect = function() {
      return this._rect;
    }, _n.prototype.getCellWidth = function() {
      return this._sw;
    }, _n.prototype.getCellHeight = function() {
      return this._sh;
    }, _n.prototype.getOrient = function() {
      return this._orient;
    }, _n.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, _n.prototype.getDateInfo = function(nr) {
      nr = parseDate(nr);
      var Cn = nr.getFullYear(), Bn = nr.getMonth() + 1, In = Bn < 10 ? "0" + Bn : "" + Bn, Dn = nr.getDate(), Ln = Dn < 10 ? "0" + Dn : "" + Dn, $n = nr.getDay();
      return $n = Math.abs(($n + 7 - this.getFirstDayOfWeek()) % 7), {
        y: Cn + "",
        m: In,
        d: Ln,
        day: $n,
        time: nr.getTime(),
        formatedDate: Cn + "-" + In + "-" + Ln,
        date: nr
      };
    }, _n.prototype.getNextNDay = function(nr, Cn) {
      return Cn = Cn || 0, Cn === 0 ? this.getDateInfo(nr) : (nr = new Date(this.getDateInfo(nr).time), nr.setDate(nr.getDate() + Cn), this.getDateInfo(nr));
    }, _n.prototype.update = function(nr, Cn) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var Bn = this._rangeInfo.weeks || 1, In = ["width", "height"], Dn = this._model.getCellSize().slice(), Ln = this._model.getBoxLayoutParams(), $n = this._orient === "horizontal" ? [Bn, 7] : [7, Bn];
      each$f([0, 1], function(Pn) {
        Fn(Dn, Pn) && (Ln[In[Pn]] = Dn[Pn] * $n[Pn]);
      });
      var Nn = {
        width: Cn.getWidth(),
        height: Cn.getHeight()
      }, Rn = this._rect = getLayoutRect$1(Ln, Nn);
      each$f([0, 1], function(Pn) {
        Fn(Dn, Pn) || (Dn[Pn] = Rn[In[Pn]] / $n[Pn]);
      });
      function Fn(Pn, Un) {
        return Pn[Un] != null && Pn[Un] !== "auto";
      }
      this._sw = Dn[0], this._sh = Dn[1];
    }, _n.prototype.dataToPoint = function(nr, Cn) {
      isArray$4(nr) && (nr = nr[0]), Cn == null && (Cn = !0);
      var Bn = this.getDateInfo(nr), In = this._rangeInfo, Dn = Bn.formatedDate;
      if (Cn && !(Bn.time >= In.start.time && Bn.time < In.end.time + PROXIMATE_ONE_DAY))
        return [NaN, NaN];
      var Ln = Bn.day, $n = this._getRangeInfo([In.start.time, Dn]).nthWeek;
      return this._orient === "vertical" ? [this._rect.x + Ln * this._sw + this._sw / 2, this._rect.y + $n * this._sh + this._sh / 2] : [this._rect.x + $n * this._sw + this._sw / 2, this._rect.y + Ln * this._sh + this._sh / 2];
    }, _n.prototype.pointToData = function(nr) {
      var Cn = this.pointToDate(nr);
      return Cn && Cn.time;
    }, _n.prototype.dataToRect = function(nr, Cn) {
      var Bn = this.dataToPoint(nr, Cn);
      return {
        contentShape: {
          x: Bn[0] - (this._sw - this._lineWidth) / 2,
          y: Bn[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: Bn,
        tl: [Bn[0] - this._sw / 2, Bn[1] - this._sh / 2],
        tr: [Bn[0] + this._sw / 2, Bn[1] - this._sh / 2],
        br: [Bn[0] + this._sw / 2, Bn[1] + this._sh / 2],
        bl: [Bn[0] - this._sw / 2, Bn[1] + this._sh / 2]
      };
    }, _n.prototype.pointToDate = function(nr) {
      var Cn = Math.floor((nr[0] - this._rect.x) / this._sw) + 1, Bn = Math.floor((nr[1] - this._rect.y) / this._sh) + 1, In = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(Bn, Cn - 1, In) : this._getDateByWeeksAndDay(Cn, Bn - 1, In);
    }, _n.prototype.convertToPixel = function(nr, Cn, Bn) {
      var In = getCoordSys(Cn);
      return In === this ? In.dataToPoint(Bn) : null;
    }, _n.prototype.convertFromPixel = function(nr, Cn, Bn) {
      var In = getCoordSys(Cn);
      return In === this ? In.pointToData(Bn) : null;
    }, _n.prototype.containPoint = function(nr) {
      return console.warn("Not implemented."), !1;
    }, _n.prototype._initRangeOption = function() {
      var nr = this._model.get("range"), Cn;
      if (isArray$4(nr) && nr.length === 1 && (nr = nr[0]), isArray$4(nr))
        Cn = nr;
      else {
        var Bn = nr.toString();
        if (/^\d{4}$/.test(Bn) && (Cn = [Bn + "-01-01", Bn + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(Bn)) {
          var In = this.getDateInfo(Bn), Dn = In.date;
          Dn.setMonth(Dn.getMonth() + 1);
          var Ln = this.getNextNDay(Dn, -1);
          Cn = [In.formatedDate, Ln.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(Bn) && (Cn = [Bn, Bn]);
      }
      if (!Cn)
        return process.env.NODE_ENV !== "production" && logError("Invalid date range."), nr;
      var $n = this._getRangeInfo(Cn);
      return $n.start.time > $n.end.time && Cn.reverse(), Cn;
    }, _n.prototype._getRangeInfo = function(nr) {
      var Cn = [this.getDateInfo(nr[0]), this.getDateInfo(nr[1])], Bn;
      Cn[0].time > Cn[1].time && (Bn = !0, Cn.reverse());
      var In = Math.floor(Cn[1].time / PROXIMATE_ONE_DAY) - Math.floor(Cn[0].time / PROXIMATE_ONE_DAY) + 1, Dn = new Date(Cn[0].time), Ln = Dn.getDate(), $n = Cn[1].date.getDate();
      Dn.setDate(Ln + In - 1);
      var Nn = Dn.getDate();
      if (Nn !== $n)
        for (var Rn = Dn.getTime() - Cn[1].time > 0 ? 1 : -1; (Nn = Dn.getDate()) !== $n && (Dn.getTime() - Cn[1].time) * Rn > 0; )
          In -= Rn, Dn.setDate(Nn - Rn);
      var Fn = Math.floor((In + Cn[0].day + 6) / 7), Pn = Bn ? -Fn + 1 : Fn - 1;
      return Bn && Cn.reverse(), {
        range: [Cn[0].formatedDate, Cn[1].formatedDate],
        start: Cn[0],
        end: Cn[1],
        allDay: In,
        weeks: Fn,
        // From 0.
        nthWeek: Pn,
        fweek: Cn[0].day,
        lweek: Cn[1].day
      };
    }, _n.prototype._getDateByWeeksAndDay = function(nr, Cn, Bn) {
      var In = this._getRangeInfo(Bn);
      if (nr > In.weeks || nr === 0 && Cn < In.fweek || nr === In.weeks && Cn > In.lweek)
        return null;
      var Dn = (nr - 1) * 7 - In.fweek + Cn, Ln = new Date(In.start.time);
      return Ln.setDate(+In.start.d + Dn), this.getDateInfo(Ln);
    }, _n.create = function(nr, Cn) {
      var Bn = [];
      return nr.eachComponent("calendar", function(In) {
        var Dn = new _n(In);
        Bn.push(Dn), In.coordinateSystem = Dn;
      }), nr.eachSeries(function(In) {
        In.get("coordinateSystem") === "calendar" && (In.coordinateSystem = Bn[In.get("calendarIndex") || 0]);
      }), Bn;
    }, _n.dimensions = ["time", "value"], _n;
  }()
);
function getCoordSys(_n) {
  var nr = _n.calendarModel, Cn = _n.seriesModel, Bn = nr ? nr.coordinateSystem : Cn ? Cn.coordinateSystem : null;
  return Bn;
}
const Calendar$1 = Calendar;
function install$m(_n) {
  _n.registerComponentModel(CalendarModel$1), _n.registerComponentView(CalendarView$1), _n.registerCoordinateSystem("calendar", Calendar$1);
}
function setKeyInfoToNewElOption(_n, nr) {
  var Cn = _n.existing;
  if (nr.id = _n.keyInfo.id, !nr.type && Cn && (nr.type = Cn.type), nr.parentId == null) {
    var Bn = nr.parentOption;
    Bn ? nr.parentId = Bn.id : Cn && (nr.parentId = Cn.parentId);
  }
  nr.parentOption = null;
}
function isSetLoc(_n, nr) {
  var Cn;
  return each$f(nr, function(Bn) {
    _n[Bn] != null && _n[Bn] !== "auto" && (Cn = !0);
  }), Cn;
}
function mergeNewElOptionToExist(_n, nr, Cn) {
  var Bn = extend({}, Cn), In = _n[nr], Dn = Cn.$action || "merge";
  if (Dn === "merge")
    if (In) {
      if (process.env.NODE_ENV !== "production") {
        var Ln = Cn.type;
        assert(!Ln || In.type === Ln, 'Please set $action: "replace" to change `type`');
      }
      merge$1(In, Bn, !0), mergeLayoutParam(In, Bn, {
        ignoreSize: !0
      }), copyLayoutParams(Cn, In), copyTransitionInfo(Cn, In), copyTransitionInfo(Cn, In, "shape"), copyTransitionInfo(Cn, In, "style"), copyTransitionInfo(Cn, In, "extra"), Cn.clipPath = In.clipPath;
    } else
      _n[nr] = Bn;
  else
    Dn === "replace" ? _n[nr] = Bn : Dn === "remove" && In && (_n[nr] = null);
}
var TRANSITION_PROPS_TO_COPY = ["transition", "enterFrom", "leaveTo"], ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function copyTransitionInfo(_n, nr, Cn) {
  if (Cn && (!_n[Cn] && nr[Cn] && (_n[Cn] = {}), _n = _n[Cn], nr = nr[Cn]), !(!_n || !nr))
    for (var Bn = Cn ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY, In = 0; In < Bn.length; In++) {
      var Dn = Bn[In];
      _n[Dn] == null && nr[Dn] != null && (_n[Dn] = nr[Dn]);
    }
}
function setLayoutInfoToExist(_n, nr) {
  if (_n && (_n.hv = nr.hv = [
    // Rigid body, don't care about `width`.
    isSetLoc(nr, ["left", "right"]),
    // Rigid body, don't care about `height`.
    isSetLoc(nr, ["top", "bottom"])
  ], _n.type === "group")) {
    var Cn = _n, Bn = nr;
    Cn.width == null && (Cn.width = Bn.width = 0), Cn.height == null && (Cn.height = Bn.height = 0);
  }
}
var GraphicComponentModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.preventAutoZ = !0, Cn;
    }
    return nr.prototype.mergeOption = function(Cn, Bn) {
      var In = this.option.elements;
      this.option.elements = null, _n.prototype.mergeOption.call(this, Cn, Bn), this.option.elements = In;
    }, nr.prototype.optionUpdated = function(Cn, Bn) {
      var In = this.option, Dn = (Bn ? In : Cn).elements, Ln = In.elements = Bn ? [] : In.elements, $n = [];
      this._flatten(Dn, $n, null);
      var Nn = mappingToExists(Ln, $n, "normalMerge"), Rn = this._elOptionsToUpdate = [];
      each$f(Nn, function(Fn, Pn) {
        var Un = Fn.newOption;
        process.env.NODE_ENV !== "production" && assert(isObject$6(Un) || Fn.existing, "Empty graphic option definition"), Un && (Rn.push(Un), setKeyInfoToNewElOption(Fn, Un), mergeNewElOptionToExist(Ln, Pn, Un), setLayoutInfoToExist(Ln[Pn], Un));
      }, this), In.elements = filter(Ln, function(Fn) {
        return Fn && delete Fn.$action, Fn != null;
      });
    }, nr.prototype._flatten = function(Cn, Bn, In) {
      each$f(Cn, function(Dn) {
        if (Dn) {
          In && (Dn.parentOption = In), Bn.push(Dn);
          var Ln = Dn.children;
          Ln && Ln.length && this._flatten(Ln, Bn, Dn), delete Dn.children;
        }
      }, this);
    }, nr.prototype.useElOptionsToUpdate = function() {
      var Cn = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, Cn;
    }, nr.type = "graphic", nr.defaultOption = {
      elements: []
      // parentId: null
    }, nr;
  }(ComponentModel$1)
), nonShapeGraphicElements = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: Group$4,
  image: ZRImage$1,
  text: ZRText$1
}, inner$7 = makeInner(), GraphicComponentView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function() {
      this._elMap = createHashMap();
    }, nr.prototype.render = function(Cn, Bn, In) {
      Cn !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = Cn, this._updateElements(Cn), this._relocate(Cn, In);
    }, nr.prototype._updateElements = function(Cn) {
      var Bn = Cn.useElOptionsToUpdate();
      if (Bn) {
        var In = this._elMap, Dn = this.group, Ln = Cn.get("z"), $n = Cn.get("zlevel");
        each$f(Bn, function(Nn) {
          var Rn = convertOptionIdName(Nn.id, null), Fn = Rn != null ? In.get(Rn) : null, Pn = convertOptionIdName(Nn.parentId, null), Un = Pn != null ? In.get(Pn) : Dn, Hn = Nn.type, zn = Nn.style;
          Hn === "text" && zn && Nn.hv && Nn.hv[1] && (zn.textVerticalAlign = zn.textBaseline = zn.verticalAlign = zn.align = null);
          var Gn = Nn.textContent, Yn = Nn.textConfig;
          if (zn && isEC4CompatibleStyle(zn, Hn, !!Yn, !!Gn)) {
            var Wn = convertFromEC4CompatibleStyle(zn, Hn, !0);
            !Yn && Wn.textConfig && (Yn = Nn.textConfig = Wn.textConfig), !Gn && Wn.textContent && (Gn = Wn.textContent);
          }
          var Xn = getCleanedElOption(Nn);
          process.env.NODE_ENV !== "production" && Fn && assert(Un === Fn.parent, "Changing parent is not supported.");
          var ea = Nn.$action || "merge", ta = ea === "merge", na = ea === "replace";
          if (ta) {
            var ra = !Fn, aa = Fn;
            ra ? aa = createEl(Rn, Un, Nn.type, In) : (aa && (inner$7(aa).isNew = !1), stopPreviousKeyframeAnimationAndRestore(aa)), aa && (applyUpdateTransition(aa, Xn, Cn, {
              isInit: ra
            }), updateCommonAttrs(aa, Nn, Ln, $n));
          } else if (na) {
            removeEl$1(Fn, Nn, In, Cn);
            var ia = createEl(Rn, Un, Nn.type, In);
            ia && (applyUpdateTransition(ia, Xn, Cn, {
              isInit: !0
            }), updateCommonAttrs(ia, Nn, Ln, $n));
          } else
            ea === "remove" && (updateLeaveTo(Fn, Nn), removeEl$1(Fn, Nn, In, Cn));
          var Aa = In.get(Rn);
          if (Aa && Gn)
            if (ta) {
              var sa = Aa.getTextContent();
              sa ? sa.attr(Gn) : Aa.setTextContent(new ZRText$1(Gn));
            } else
              na && Aa.setTextContent(new ZRText$1(Gn));
          if (Aa) {
            var oa = Nn.clipPath;
            if (oa) {
              var la = oa.type, ua = void 0, ra = !1;
              if (ta) {
                var ca = Aa.getClipPath();
                ra = !ca || inner$7(ca).type !== la, ua = ra ? newEl(la) : ca;
              } else
                na && (ra = !0, ua = newEl(la));
              Aa.setClipPath(ua), applyUpdateTransition(ua, oa, Cn, {
                isInit: ra
              }), applyKeyframeAnimation(ua, oa.keyframeAnimation, Cn);
            }
            var fa = inner$7(Aa);
            Aa.setTextConfig(Yn), fa.option = Nn, setEventData(Aa, Cn, Nn), setTooltipConfig({
              el: Aa,
              componentModel: Cn,
              itemName: Aa.name,
              itemTooltipOption: Nn.tooltip
            }), applyKeyframeAnimation(Aa, Nn.keyframeAnimation, Cn);
          }
        });
      }
    }, nr.prototype._relocate = function(Cn, Bn) {
      for (var In = Cn.option.elements, Dn = this.group, Ln = this._elMap, $n = Bn.getWidth(), Nn = Bn.getHeight(), Rn = ["x", "y"], Fn = 0; Fn < In.length; Fn++) {
        var Pn = In[Fn], Un = convertOptionIdName(Pn.id, null), Hn = Un != null ? Ln.get(Un) : null;
        if (!(!Hn || !Hn.isGroup)) {
          var zn = Hn.parent, Gn = zn === Dn, Yn = inner$7(Hn), Wn = inner$7(zn);
          Yn.width = parsePercent(Yn.option.width, Gn ? $n : Wn.width) || 0, Yn.height = parsePercent(Yn.option.height, Gn ? Nn : Wn.height) || 0;
        }
      }
      for (var Fn = In.length - 1; Fn >= 0; Fn--) {
        var Pn = In[Fn], Un = convertOptionIdName(Pn.id, null), Hn = Un != null ? Ln.get(Un) : null;
        if (Hn) {
          var zn = Hn.parent, Wn = inner$7(zn), Xn = zn === Dn ? {
            width: $n,
            height: Nn
          } : {
            width: Wn.width,
            height: Wn.height
          }, ea = {}, ta = positionElement(Hn, Pn, Xn, null, {
            hv: Pn.hv,
            boundingMode: Pn.bounding
          }, ea);
          if (!inner$7(Hn).isNew && ta) {
            for (var na = Pn.transition, ra = {}, aa = 0; aa < Rn.length; aa++) {
              var ia = Rn[aa], Aa = ea[ia];
              na && (isTransitionAll(na) || indexOf(na, ia) >= 0) ? ra[ia] = Aa : Hn[ia] = Aa;
            }
            updateProps$1(Hn, ra, Cn, 0);
          } else
            Hn.attr(ea);
        }
      }
    }, nr.prototype._clear = function() {
      var Cn = this, Bn = this._elMap;
      Bn.each(function(In) {
        removeEl$1(In, inner$7(In).option, Bn, Cn._lastGraphicModel);
      }), this._elMap = createHashMap();
    }, nr.prototype.dispose = function() {
      this._clear();
    }, nr.type = "graphic", nr;
  }(ComponentView$1)
);
function newEl(_n) {
  process.env.NODE_ENV !== "production" && assert(_n, "graphic type MUST be set");
  var nr = hasOwn(nonShapeGraphicElements, _n) ? nonShapeGraphicElements[_n] : getShapeClass(_n);
  process.env.NODE_ENV !== "production" && assert(nr, "graphic type " + _n + " can not be found");
  var Cn = new nr({});
  return inner$7(Cn).type = _n, Cn;
}
function createEl(_n, nr, Cn, Bn) {
  var In = newEl(Cn);
  return nr.add(In), Bn.set(_n, In), inner$7(In).id = _n, inner$7(In).isNew = !0, In;
}
function removeEl$1(_n, nr, Cn, Bn) {
  var In = _n && _n.parent;
  In && (_n.type === "group" && _n.traverse(function(Dn) {
    removeEl$1(Dn, nr, Cn, Bn);
  }), applyLeaveTransition(_n, nr, Bn), Cn.removeKey(inner$7(_n).id));
}
function updateCommonAttrs(_n, nr, Cn, Bn) {
  _n.isGroup || each$f([
    ["cursor", Displayable$1.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", Bn || 0],
    ["z", Cn || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(In) {
    var Dn = In[0];
    hasOwn(nr, Dn) ? _n[Dn] = retrieve2(nr[Dn], In[1]) : _n[Dn] == null && (_n[Dn] = In[1]);
  }), each$f(keys(nr), function(In) {
    if (In.indexOf("on") === 0) {
      var Dn = nr[In];
      _n[In] = isFunction$1(Dn) ? Dn : null;
    }
  }), hasOwn(nr, "draggable") && (_n.draggable = nr.draggable), nr.name != null && (_n.name = nr.name), nr.id != null && (_n.id = nr.id);
}
function getCleanedElOption(_n) {
  return _n = extend({}, _n), each$f(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(LOCATION_PARAMS), function(nr) {
    delete _n[nr];
  }), _n;
}
function setEventData(_n, nr, Cn) {
  var Bn = getECData(_n).eventData;
  !_n.silent && !_n.ignore && !Bn && (Bn = getECData(_n).eventData = {
    componentType: "graphic",
    componentIndex: nr.componentIndex,
    name: _n.name
  }), Bn && (Bn.info = Cn.info);
}
function install$l(_n) {
  _n.registerComponentModel(GraphicComponentModel), _n.registerComponentView(GraphicComponentView), _n.registerPreprocessor(function(nr) {
    var Cn = nr.graphic;
    isArray$4(Cn) ? !Cn[0] || !Cn[0].elements ? nr.graphic = [{
      elements: Cn
    }] : nr.graphic = [nr.graphic[0]] : Cn && !Cn.elements && (nr.graphic = [{
      elements: [Cn]
    }]);
  });
}
var DATA_ZOOM_AXIS_DIMENSIONS = ["x", "y", "radius", "angle", "single"], SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
function isCoordSupported(_n) {
  var nr = _n.get("coordinateSystem");
  return indexOf(SERIES_COORDS, nr) >= 0;
}
function getAxisMainType(_n) {
  return process.env.NODE_ENV !== "production" && assert(_n), _n + "Axis";
}
function findEffectedDataZooms(_n, nr) {
  var Cn = createHashMap(), Bn = [], In = createHashMap();
  _n.eachComponent({
    mainType: "dataZoom",
    query: nr
  }, function(Fn) {
    In.get(Fn.uid) || $n(Fn);
  });
  var Dn;
  do
    Dn = !1, _n.eachComponent("dataZoom", Ln);
  while (Dn);
  function Ln(Fn) {
    !In.get(Fn.uid) && Nn(Fn) && ($n(Fn), Dn = !0);
  }
  function $n(Fn) {
    In.set(Fn.uid, !0), Bn.push(Fn), Rn(Fn);
  }
  function Nn(Fn) {
    var Pn = !1;
    return Fn.eachTargetAxis(function(Un, Hn) {
      var zn = Cn.get(Un);
      zn && zn[Hn] && (Pn = !0);
    }), Pn;
  }
  function Rn(Fn) {
    Fn.eachTargetAxis(function(Pn, Un) {
      (Cn.get(Pn) || Cn.set(Pn, []))[Un] = !0;
    });
  }
  return Bn;
}
function collectReferCoordSysModelInfo(_n) {
  var nr = _n.ecModel, Cn = {
    infoList: [],
    infoMap: createHashMap()
  };
  return _n.eachTargetAxis(function(Bn, In) {
    var Dn = nr.getComponent(getAxisMainType(Bn), In);
    if (Dn) {
      var Ln = Dn.getCoordSysModel();
      if (Ln) {
        var $n = Ln.uid, Nn = Cn.infoMap.get($n);
        Nn || (Nn = {
          model: Ln,
          axisModels: []
        }, Cn.infoList.push(Nn), Cn.infoMap.set($n, Nn)), Nn.axisModels.push(Dn);
      }
    }
  }), Cn;
}
var DataZoomAxisInfo = (
  /** @class */
  function() {
    function _n() {
      this.indexList = [], this.indexMap = [];
    }
    return _n.prototype.add = function(nr) {
      this.indexMap[nr] || (this.indexList.push(nr), this.indexMap[nr] = !0);
    }, _n;
  }()
), DataZoomModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn._autoThrottle = !0, Cn._noTarget = !0, Cn._rangePropMode = ["percent", "percent"], Cn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      var Dn = retrieveRawOption(Cn);
      this.settledOption = Dn, this.mergeDefaultAndTheme(Cn, In), this._doInit(Dn);
    }, nr.prototype.mergeOption = function(Cn) {
      var Bn = retrieveRawOption(Cn);
      merge$1(this.option, Cn, !0), merge$1(this.settledOption, Bn, !0), this._doInit(Bn);
    }, nr.prototype._doInit = function(Cn) {
      var Bn = this.option;
      this._setDefaultThrottle(Cn), this._updateRangeUse(Cn);
      var In = this.settledOption;
      each$f([["start", "startValue"], ["end", "endValue"]], function(Dn, Ln) {
        this._rangePropMode[Ln] === "value" && (Bn[Dn[0]] = In[Dn[0]] = null);
      }, this), this._resetTarget();
    }, nr.prototype._resetTarget = function() {
      var Cn = this.get("orient", !0), Bn = this._targetAxisInfoMap = createHashMap(), In = this._fillSpecifiedTargetAxis(Bn);
      In ? this._orient = Cn || this._makeAutoOrientByTargetAxis() : (this._orient = Cn || "horizontal", this._fillAutoTargetAxisByOrient(Bn, this._orient)), this._noTarget = !0, Bn.each(function(Dn) {
        Dn.indexList.length && (this._noTarget = !1);
      }, this);
    }, nr.prototype._fillSpecifiedTargetAxis = function(Cn) {
      var Bn = !1;
      return each$f(DATA_ZOOM_AXIS_DIMENSIONS, function(In) {
        var Dn = this.getReferringComponents(getAxisMainType(In), MULTIPLE_REFERRING);
        if (Dn.specified) {
          Bn = !0;
          var Ln = new DataZoomAxisInfo();
          each$f(Dn.models, function($n) {
            Ln.add($n.componentIndex);
          }), Cn.set(In, Ln);
        }
      }, this), Bn;
    }, nr.prototype._fillAutoTargetAxisByOrient = function(Cn, Bn) {
      var In = this.ecModel, Dn = !0;
      if (Dn) {
        var Ln = Bn === "vertical" ? "y" : "x", $n = In.findComponents({
          mainType: Ln + "Axis"
        });
        Nn($n, Ln);
      }
      if (Dn) {
        var $n = In.findComponents({
          mainType: "singleAxis",
          filter: function(Fn) {
            return Fn.get("orient", !0) === Bn;
          }
        });
        Nn($n, "single");
      }
      function Nn(Rn, Fn) {
        var Pn = Rn[0];
        if (Pn) {
          var Un = new DataZoomAxisInfo();
          if (Un.add(Pn.componentIndex), Cn.set(Fn, Un), Dn = !1, Fn === "x" || Fn === "y") {
            var Hn = Pn.getReferringComponents("grid", SINGLE_REFERRING).models[0];
            Hn && each$f(Rn, function(zn) {
              Pn.componentIndex !== zn.componentIndex && Hn === zn.getReferringComponents("grid", SINGLE_REFERRING).models[0] && Un.add(zn.componentIndex);
            });
          }
        }
      }
      Dn && each$f(DATA_ZOOM_AXIS_DIMENSIONS, function(Rn) {
        if (Dn) {
          var Fn = In.findComponents({
            mainType: getAxisMainType(Rn),
            filter: function(Un) {
              return Un.get("type", !0) === "category";
            }
          });
          if (Fn[0]) {
            var Pn = new DataZoomAxisInfo();
            Pn.add(Fn[0].componentIndex), Cn.set(Rn, Pn), Dn = !1;
          }
        }
      }, this);
    }, nr.prototype._makeAutoOrientByTargetAxis = function() {
      var Cn;
      return this.eachTargetAxis(function(Bn) {
        !Cn && (Cn = Bn);
      }, this), Cn === "y" ? "vertical" : "horizontal";
    }, nr.prototype._setDefaultThrottle = function(Cn) {
      if (Cn.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var Bn = this.ecModel.option;
        this.option.throttle = Bn.animation && Bn.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, nr.prototype._updateRangeUse = function(Cn) {
      var Bn = this._rangePropMode, In = this.get("rangeMode");
      each$f([["start", "startValue"], ["end", "endValue"]], function(Dn, Ln) {
        var $n = Cn[Dn[0]] != null, Nn = Cn[Dn[1]] != null;
        $n && !Nn ? Bn[Ln] = "percent" : !$n && Nn ? Bn[Ln] = "value" : In ? Bn[Ln] = In[Ln] : $n && (Bn[Ln] = "percent");
      });
    }, nr.prototype.noTarget = function() {
      return this._noTarget;
    }, nr.prototype.getFirstTargetAxisModel = function() {
      var Cn;
      return this.eachTargetAxis(function(Bn, In) {
        Cn == null && (Cn = this.ecModel.getComponent(getAxisMainType(Bn), In));
      }, this), Cn;
    }, nr.prototype.eachTargetAxis = function(Cn, Bn) {
      this._targetAxisInfoMap.each(function(In, Dn) {
        each$f(In.indexList, function(Ln) {
          Cn.call(Bn, Dn, Ln);
        });
      });
    }, nr.prototype.getAxisProxy = function(Cn, Bn) {
      var In = this.getAxisModel(Cn, Bn);
      if (In)
        return In.__dzAxisProxy;
    }, nr.prototype.getAxisModel = function(Cn, Bn) {
      process.env.NODE_ENV !== "production" && assert(Cn && Bn != null);
      var In = this._targetAxisInfoMap.get(Cn);
      if (In && In.indexMap[Bn])
        return this.ecModel.getComponent(getAxisMainType(Cn), Bn);
    }, nr.prototype.setRawRange = function(Cn) {
      var Bn = this.option, In = this.settledOption;
      each$f([["start", "startValue"], ["end", "endValue"]], function(Dn) {
        (Cn[Dn[0]] != null || Cn[Dn[1]] != null) && (Bn[Dn[0]] = In[Dn[0]] = Cn[Dn[0]], Bn[Dn[1]] = In[Dn[1]] = Cn[Dn[1]]);
      }, this), this._updateRangeUse(Cn);
    }, nr.prototype.setCalculatedRange = function(Cn) {
      var Bn = this.option;
      each$f(["start", "startValue", "end", "endValue"], function(In) {
        Bn[In] = Cn[In];
      });
    }, nr.prototype.getPercentRange = function() {
      var Cn = this.findRepresentativeAxisProxy();
      if (Cn)
        return Cn.getDataPercentWindow();
    }, nr.prototype.getValueRange = function(Cn, Bn) {
      if (Cn == null && Bn == null) {
        var In = this.findRepresentativeAxisProxy();
        if (In)
          return In.getDataValueWindow();
      } else
        return this.getAxisProxy(Cn, Bn).getDataValueWindow();
    }, nr.prototype.findRepresentativeAxisProxy = function(Cn) {
      if (Cn)
        return Cn.__dzAxisProxy;
      for (var Bn, In = this._targetAxisInfoMap.keys(), Dn = 0; Dn < In.length; Dn++)
        for (var Ln = In[Dn], $n = this._targetAxisInfoMap.get(Ln), Nn = 0; Nn < $n.indexList.length; Nn++) {
          var Rn = this.getAxisProxy(Ln, $n.indexList[Nn]);
          if (Rn.hostedBy(this))
            return Rn;
          Bn || (Bn = Rn);
        }
      return Bn;
    }, nr.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, nr.prototype.getOrient = function() {
      return process.env.NODE_ENV !== "production" && assert(this._orient), this._orient;
    }, nr.type = "dataZoom", nr.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], nr.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, nr;
  }(ComponentModel$1)
);
function retrieveRawOption(_n) {
  var nr = {};
  return each$f(["start", "end", "startValue", "endValue", "throttle"], function(Cn) {
    _n.hasOwnProperty(Cn) && (nr[Cn] = _n[Cn]);
  }), nr;
}
const DataZoomModel$1 = DataZoomModel;
var SelectDataZoomModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "dataZoom.select", nr;
  }(DataZoomModel$1)
);
const SelectZoomModel = SelectDataZoomModel;
var DataZoomView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      this.dataZoomModel = Cn, this.ecModel = Bn, this.api = In;
    }, nr.type = "dataZoom", nr;
  }(ComponentView$1)
);
const DataZoomView$1 = DataZoomView;
var SelectDataZoomView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "dataZoom.select", nr;
  }(DataZoomView$1)
);
const SelectZoomView = SelectDataZoomView;
var each$7 = each$f, asc$1 = asc$2, AxisProxy = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn, In) {
      this._dimName = nr, this._axisIndex = Cn, this.ecModel = In, this._dataZoomModel = Bn;
    }
    return _n.prototype.hostedBy = function(nr) {
      return this._dataZoomModel === nr;
    }, _n.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, _n.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, _n.prototype.getTargetSeriesModels = function() {
      var nr = [];
      return this.ecModel.eachSeries(function(Cn) {
        if (isCoordSupported(Cn)) {
          var Bn = getAxisMainType(this._dimName), In = Cn.getReferringComponents(Bn, SINGLE_REFERRING).models[0];
          In && this._axisIndex === In.componentIndex && nr.push(Cn);
        }
      }, this), nr;
    }, _n.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, _n.prototype.getMinMaxSpan = function() {
      return clone$4(this._minMaxSpan);
    }, _n.prototype.calculateDataWindow = function(nr) {
      var Cn = this._dataExtent, Bn = this.getAxisModel(), In = Bn.axis.scale, Dn = this._dataZoomModel.getRangePropMode(), Ln = [0, 100], $n = [], Nn = [], Rn;
      each$7(["start", "end"], function(Un, Hn) {
        var zn = nr[Un], Gn = nr[Un + "Value"];
        Dn[Hn] === "percent" ? (zn == null && (zn = Ln[Hn]), Gn = In.parse(linearMap$2(zn, Ln, Cn))) : (Rn = !0, Gn = Gn == null ? Cn[Hn] : In.parse(Gn), zn = linearMap$2(Gn, Cn, Ln)), Nn[Hn] = Gn == null || isNaN(Gn) ? Cn[Hn] : Gn, $n[Hn] = zn == null || isNaN(zn) ? Ln[Hn] : zn;
      }), asc$1(Nn), asc$1($n);
      var Fn = this._minMaxSpan;
      Rn ? Pn(Nn, $n, Cn, Ln, !1) : Pn($n, Nn, Ln, Cn, !0);
      function Pn(Un, Hn, zn, Gn, Yn) {
        var Wn = Yn ? "Span" : "ValueSpan";
        sliderMove(0, Un, zn, "all", Fn["min" + Wn], Fn["max" + Wn]);
        for (var Xn = 0; Xn < 2; Xn++)
          Hn[Xn] = linearMap$2(Un[Xn], zn, Gn, !0), Yn && (Hn[Xn] = In.parse(Hn[Xn]));
      }
      return {
        valueWindow: Nn,
        percentWindow: $n
      };
    }, _n.prototype.reset = function(nr) {
      if (nr === this._dataZoomModel) {
        var Cn = this.getTargetSeriesModels();
        this._dataExtent = calculateDataExtent(this, this._dimName, Cn), this._updateMinMaxSpan();
        var Bn = this.calculateDataWindow(nr.settledOption);
        this._valueWindow = Bn.valueWindow, this._percentWindow = Bn.percentWindow, this._setAxisModel();
      }
    }, _n.prototype.filterData = function(nr, Cn) {
      if (nr !== this._dataZoomModel)
        return;
      var Bn = this._dimName, In = this.getTargetSeriesModels(), Dn = nr.get("filterMode"), Ln = this._valueWindow;
      if (Dn === "none")
        return;
      each$7(In, function(Nn) {
        var Rn = Nn.getData(), Fn = Rn.mapDimensionsAll(Bn);
        if (Fn.length) {
          if (Dn === "weakFilter") {
            var Pn = Rn.getStore(), Un = map$1(Fn, function(Hn) {
              return Rn.getDimensionIndex(Hn);
            }, Rn);
            Rn.filterSelf(function(Hn) {
              for (var zn, Gn, Yn, Wn = 0; Wn < Fn.length; Wn++) {
                var Xn = Pn.get(Un[Wn], Hn), ea = !isNaN(Xn), ta = Xn < Ln[0], na = Xn > Ln[1];
                if (ea && !ta && !na)
                  return !0;
                ea && (Yn = !0), ta && (zn = !0), na && (Gn = !0);
              }
              return Yn && zn && Gn;
            });
          } else
            each$7(Fn, function(Hn) {
              if (Dn === "empty")
                Nn.setData(Rn = Rn.map(Hn, function(Gn) {
                  return $n(Gn) ? Gn : NaN;
                }));
              else {
                var zn = {};
                zn[Hn] = Ln, Rn.selectRange(zn);
              }
            });
          each$7(Fn, function(Hn) {
            Rn.setApproximateExtent(Ln, Hn);
          });
        }
      });
      function $n(Nn) {
        return Nn >= Ln[0] && Nn <= Ln[1];
      }
    }, _n.prototype._updateMinMaxSpan = function() {
      var nr = this._minMaxSpan = {}, Cn = this._dataZoomModel, Bn = this._dataExtent;
      each$7(["min", "max"], function(In) {
        var Dn = Cn.get(In + "Span"), Ln = Cn.get(In + "ValueSpan");
        Ln != null && (Ln = this.getAxisModel().axis.scale.parse(Ln)), Ln != null ? Dn = linearMap$2(Bn[0] + Ln, Bn, [0, 100], !0) : Dn != null && (Ln = linearMap$2(Dn, [0, 100], Bn, !0) - Bn[0]), nr[In + "Span"] = Dn, nr[In + "ValueSpan"] = Ln;
      }, this);
    }, _n.prototype._setAxisModel = function() {
      var nr = this.getAxisModel(), Cn = this._percentWindow, Bn = this._valueWindow;
      if (Cn) {
        var In = getPixelPrecision(Bn, [0, 500]);
        In = Math.min(In, 20);
        var Dn = nr.axis.scale.rawExtentInfo;
        Cn[0] !== 0 && Dn.setDeterminedMinMax("min", +Bn[0].toFixed(In)), Cn[1] !== 100 && Dn.setDeterminedMinMax("max", +Bn[1].toFixed(In)), Dn.freeze();
      }
    }, _n;
  }()
);
function calculateDataExtent(_n, nr, Cn) {
  var Bn = [1 / 0, -1 / 0];
  each$7(Cn, function(Ln) {
    unionAxisExtentFromData(Bn, Ln.getData(), nr);
  });
  var In = _n.getAxisModel(), Dn = ensureScaleRawExtentInfo(In.axis.scale, In, Bn).calculate();
  return [Dn.min, Dn.max];
}
const AxisProxy$1 = AxisProxy;
var dataZoomProcessor = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(_n) {
    function nr(In) {
      _n.eachComponent("dataZoom", function(Dn) {
        Dn.eachTargetAxis(function(Ln, $n) {
          var Nn = _n.getComponent(getAxisMainType(Ln), $n);
          In(Ln, $n, Nn, Dn);
        });
      });
    }
    nr(function(In, Dn, Ln, $n) {
      Ln.__dzAxisProxy = null;
    });
    var Cn = [];
    nr(function(In, Dn, Ln, $n) {
      Ln.__dzAxisProxy || (Ln.__dzAxisProxy = new AxisProxy$1(In, Dn, $n, _n), Cn.push(Ln.__dzAxisProxy));
    });
    var Bn = createHashMap();
    return each$f(Cn, function(In) {
      each$f(In.getTargetSeriesModels(), function(Dn) {
        Bn.set(Dn.uid, Dn);
      });
    }), Bn;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(_n, nr) {
    _n.eachComponent("dataZoom", function(Cn) {
      Cn.eachTargetAxis(function(Bn, In) {
        Cn.getAxisProxy(Bn, In).reset(Cn);
      }), Cn.eachTargetAxis(function(Bn, In) {
        Cn.getAxisProxy(Bn, In).filterData(Cn, nr);
      });
    }), _n.eachComponent("dataZoom", function(Cn) {
      var Bn = Cn.findRepresentativeAxisProxy();
      if (Bn) {
        var In = Bn.getDataPercentWindow(), Dn = Bn.getDataValueWindow();
        Cn.setCalculatedRange({
          start: In[0],
          end: In[1],
          startValue: Dn[0],
          endValue: Dn[1]
        });
      }
    });
  }
};
const dataZoomProcessor$1 = dataZoomProcessor;
function installDataZoomAction(_n) {
  _n.registerAction("dataZoom", function(nr, Cn) {
    var Bn = findEffectedDataZooms(Cn, nr);
    each$f(Bn, function(In) {
      In.setRawRange({
        start: nr.start,
        end: nr.end,
        startValue: nr.startValue,
        endValue: nr.endValue
      });
    });
  });
}
var installed$1 = !1;
function installCommon$1(_n) {
  installed$1 || (installed$1 = !0, _n.registerProcessor(_n.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor$1), installDataZoomAction(_n), _n.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function install$k(_n) {
  _n.registerComponentModel(SelectZoomModel), _n.registerComponentView(SelectZoomView), installCommon$1(_n);
}
var ToolboxFeature = (
  /** @class */
  function() {
    function _n() {
    }
    return _n;
  }()
), features = {};
function registerFeature(_n, nr) {
  features[_n] = nr;
}
function getFeature(_n) {
  return features[_n];
}
var ToolboxModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.optionUpdated = function() {
      _n.prototype.optionUpdated.apply(this, arguments);
      var Cn = this.ecModel;
      each$f(this.option.feature, function(Bn, In) {
        var Dn = getFeature(In);
        Dn && (Dn.getDefaultOption && (Dn.defaultOption = Dn.getDefaultOption(Cn)), merge$1(Bn, Dn.defaultOption));
      });
    }, nr.type = "toolbox", nr.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, nr.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, nr;
  }(ComponentModel$1)
);
const ToolboxModel$1 = ToolboxModel;
function layout(_n, nr, Cn) {
  var Bn = nr.getBoxLayoutParams(), In = nr.get("padding"), Dn = {
    width: Cn.getWidth(),
    height: Cn.getHeight()
  }, Ln = getLayoutRect$1(Bn, Dn, In);
  box(nr.get("orient"), _n, nr.get("itemGap"), Ln.width, Ln.height), positionElement(_n, Bn, Dn, In);
}
function makeBackground(_n, nr) {
  var Cn = normalizeCssArray(nr.get("padding")), Bn = nr.getItemStyle(["color", "opacity"]);
  return Bn.fill = nr.get("backgroundColor"), _n = new Rect$3({
    shape: {
      x: _n.x - Cn[3],
      y: _n.y - Cn[0],
      width: _n.width + Cn[1] + Cn[3],
      height: _n.height + Cn[0] + Cn[2],
      r: nr.get("borderRadius")
    },
    style: Bn,
    silent: !0,
    z2: -1
  }), _n;
}
var ToolboxView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      var Ln = this.group;
      if (Ln.removeAll(), !Cn.get("show"))
        return;
      var $n = +Cn.get("itemSize"), Nn = Cn.get("orient") === "vertical", Rn = Cn.get("feature") || {}, Fn = this._features || (this._features = {}), Pn = [];
      each$f(Rn, function(zn, Gn) {
        Pn.push(Gn);
      }), new DataDiffer$1(this._featureNames || [], Pn).add(Un).update(Un).remove(curry$1(Un, null)).execute(), this._featureNames = Pn;
      function Un(zn, Gn) {
        var Yn = Pn[zn], Wn = Pn[Gn], Xn = Rn[Yn], ea = new Model$1(Xn, Cn, Cn.ecModel), ta;
        if (Dn && Dn.newTitle != null && Dn.featureName === Yn && (Xn.title = Dn.newTitle), Yn && !Wn) {
          if (isUserFeatureName(Yn))
            ta = {
              onclick: ea.option.onclick,
              featureName: Yn
            };
          else {
            var na = getFeature(Yn);
            if (!na)
              return;
            ta = new na();
          }
          Fn[Yn] = ta;
        } else if (ta = Fn[Wn], !ta)
          return;
        ta.uid = getUID("toolbox-feature"), ta.model = ea, ta.ecModel = Bn, ta.api = In;
        var ra = ta instanceof ToolboxFeature;
        if (!Yn && Wn) {
          ra && ta.dispose && ta.dispose(Bn, In);
          return;
        }
        if (!ea.get("show") || ra && ta.unusable) {
          ra && ta.remove && ta.remove(Bn, In);
          return;
        }
        Hn(ea, ta, Yn), ea.setIconStatus = function(aa, ia) {
          var Aa = this.option, sa = this.iconPaths;
          Aa.iconStatus = Aa.iconStatus || {}, Aa.iconStatus[aa] = ia, sa[aa] && (ia === "emphasis" ? enterEmphasis : leaveEmphasis)(sa[aa]);
        }, ta instanceof ToolboxFeature && ta.render && ta.render(ea, Bn, In, Dn);
      }
      function Hn(zn, Gn, Yn) {
        var Wn = zn.getModel("iconStyle"), Xn = zn.getModel(["emphasis", "iconStyle"]), ea = Gn instanceof ToolboxFeature && Gn.getIcons ? Gn.getIcons() : zn.get("icon"), ta = zn.get("title") || {}, na, ra;
        isString$1(ea) ? (na = {}, na[Yn] = ea) : na = ea, isString$1(ta) ? (ra = {}, ra[Yn] = ta) : ra = ta;
        var aa = zn.iconPaths = {};
        each$f(na, function(ia, Aa) {
          var sa = createIcon(ia, {}, {
            x: -$n / 2,
            y: -$n / 2,
            width: $n,
            height: $n
          });
          sa.setStyle(Wn.getItemStyle());
          var oa = sa.ensureState("emphasis");
          oa.style = Xn.getItemStyle();
          var la = new ZRText$1({
            style: {
              text: ra[Aa],
              align: Xn.get("textAlign"),
              borderRadius: Xn.get("textBorderRadius"),
              padding: Xn.get("textPadding"),
              fill: null,
              font: getFont({
                fontStyle: Xn.get("textFontStyle"),
                fontFamily: Xn.get("textFontFamily"),
                fontSize: Xn.get("textFontSize"),
                fontWeight: Xn.get("textFontWeight")
              }, Bn)
            },
            ignore: !0
          });
          sa.setTextContent(la), setTooltipConfig({
            el: sa,
            componentModel: Cn,
            itemName: Aa,
            formatterParamsExtra: {
              title: ra[Aa]
            }
          }), sa.__title = ra[Aa], sa.on("mouseover", function() {
            var ua = Xn.getItemStyle(), ca = Nn ? Cn.get("right") == null && Cn.get("left") !== "right" ? "right" : "left" : Cn.get("bottom") == null && Cn.get("top") !== "bottom" ? "bottom" : "top";
            la.setStyle({
              fill: Xn.get("textFill") || ua.fill || ua.stroke || "#000",
              backgroundColor: Xn.get("textBackgroundColor")
            }), sa.setTextConfig({
              position: Xn.get("textPosition") || ca
            }), la.ignore = !Cn.get("showTitle"), In.enterEmphasis(this);
          }).on("mouseout", function() {
            zn.get(["iconStatus", Aa]) !== "emphasis" && In.leaveEmphasis(this), la.hide();
          }), (zn.get(["iconStatus", Aa]) === "emphasis" ? enterEmphasis : leaveEmphasis)(sa), Ln.add(sa), sa.on("click", bind$1(Gn.onclick, Gn, Bn, In, Aa)), aa[Aa] = sa;
        });
      }
      layout(Ln, Cn, In), Ln.add(makeBackground(Ln.getBoundingRect(), Cn)), Nn || Ln.eachChild(function(zn) {
        var Gn = zn.__title, Yn = zn.ensureState("emphasis"), Wn = Yn.textConfig || (Yn.textConfig = {}), Xn = zn.getTextContent(), ea = Xn && Xn.ensureState("emphasis");
        if (ea && !isFunction$1(ea) && Gn) {
          var ta = ea.style || (ea.style = {}), na = getBoundingRect(Gn, ZRText$1.makeFont(ta)), ra = zn.x + Ln.x, aa = zn.y + Ln.y + $n, ia = !1;
          aa + na.height > In.getHeight() && (Wn.position = "top", ia = !0);
          var Aa = ia ? -5 - na.height : $n + 10;
          ra + na.width / 2 > In.getWidth() ? (Wn.position = ["100%", Aa], ta.align = "right") : ra - na.width / 2 < 0 && (Wn.position = [0, Aa], ta.align = "left");
        }
      });
    }, nr.prototype.updateView = function(Cn, Bn, In, Dn) {
      each$f(this._features, function(Ln) {
        Ln instanceof ToolboxFeature && Ln.updateView && Ln.updateView(Ln.model, Bn, In, Dn);
      });
    }, nr.prototype.remove = function(Cn, Bn) {
      each$f(this._features, function(In) {
        In instanceof ToolboxFeature && In.remove && In.remove(Cn, Bn);
      }), this.group.removeAll();
    }, nr.prototype.dispose = function(Cn, Bn) {
      each$f(this._features, function(In) {
        In instanceof ToolboxFeature && In.dispose && In.dispose(Cn, Bn);
      });
    }, nr.type = "toolbox", nr;
  }(ComponentView$1)
);
function isUserFeatureName(_n) {
  return _n.indexOf("my") === 0;
}
const ToolboxView$1 = ToolboxView;
var SaveAsImage = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.onclick = function(Cn, Bn) {
      var In = this.model, Dn = In.get("name") || Cn.get("title.0.text") || "echarts", Ln = Bn.getZr().painter.getType() === "svg", $n = Ln ? "svg" : In.get("type", !0) || "png", Nn = Bn.getConnectedDataURL({
        type: $n,
        backgroundColor: In.get("backgroundColor", !0) || Cn.get("backgroundColor") || "#fff",
        connectedBackgroundColor: In.get("connectedBackgroundColor"),
        excludeComponents: In.get("excludeComponents"),
        pixelRatio: In.get("pixelRatio")
      }), Rn = env$1.browser;
      if (typeof MouseEvent == "function" && (Rn.newEdge || !Rn.ie && !Rn.edge)) {
        var Fn = document.createElement("a");
        Fn.download = Dn + "." + $n, Fn.target = "_blank", Fn.href = Nn;
        var Pn = new MouseEvent("click", {
          // some micro front-end framework， window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        Fn.dispatchEvent(Pn);
      } else if (window.navigator.msSaveOrOpenBlob || Ln) {
        var Un = Nn.split(","), Hn = Un[0].indexOf("base64") > -1, zn = Ln ? decodeURIComponent(Un[1]) : Un[1];
        Hn && (zn = window.atob(zn));
        var Gn = Dn + "." + $n;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var Yn = zn.length, Wn = new Uint8Array(Yn); Yn--; )
            Wn[Yn] = zn.charCodeAt(Yn);
          var Xn = new Blob([Wn]);
          window.navigator.msSaveOrOpenBlob(Xn, Gn);
        } else {
          var ea = document.createElement("iframe");
          document.body.appendChild(ea);
          var ta = ea.contentWindow, na = ta.document;
          na.open("image/svg+xml", "replace"), na.write(zn), na.close(), ta.focus(), na.execCommand("SaveAs", !0, Gn), document.body.removeChild(ea);
        }
      } else {
        var ra = In.get("lang"), aa = '<body style="margin:0;"><img src="' + Nn + '" style="max-width:100%;" title="' + (ra && ra[0] || "") + '" /></body>', ia = window.open();
        ia.document.write(aa), ia.document.title = Dn;
      }
    }, nr.getDefaultOption = function(Cn) {
      var Bn = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: Cn.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: Cn.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return Bn;
    }, nr;
  }(ToolboxFeature)
);
const SaveAsImage$1 = SaveAsImage;
var INNER_STACK_KEYWORD = "__ec_magicType_stack__", radioTypes = [["line", "bar"], ["stack"]], MagicType = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.getIcons = function() {
      var Cn = this.model, Bn = Cn.get("icon"), In = {};
      return each$f(Cn.get("type"), function(Dn) {
        Bn[Dn] && (In[Dn] = Bn[Dn]);
      }), In;
    }, nr.getDefaultOption = function(Cn) {
      var Bn = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: Cn.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return Bn;
    }, nr.prototype.onclick = function(Cn, Bn, In) {
      var Dn = this.model, Ln = Dn.get(["seriesIndex", In]);
      if (seriesOptGenreator[In]) {
        var $n = {
          series: []
        }, Nn = function(Pn) {
          var Un = Pn.subType, Hn = Pn.id, zn = seriesOptGenreator[In](Un, Hn, Pn, Dn);
          zn && (defaults(zn, Pn.option), $n.series.push(zn));
          var Gn = Pn.coordinateSystem;
          if (Gn && Gn.type === "cartesian2d" && (In === "line" || In === "bar")) {
            var Yn = Gn.getAxesByScale("ordinal")[0];
            if (Yn) {
              var Wn = Yn.dim, Xn = Wn + "Axis", ea = Pn.getReferringComponents(Xn, SINGLE_REFERRING).models[0], ta = ea.componentIndex;
              $n[Xn] = $n[Xn] || [];
              for (var na = 0; na <= ta; na++)
                $n[Xn][ta] = $n[Xn][ta] || {};
              $n[Xn][ta].boundaryGap = In === "bar";
            }
          }
        };
        each$f(radioTypes, function(Pn) {
          indexOf(Pn, In) >= 0 && each$f(Pn, function(Un) {
            Dn.setIconStatus(Un, "normal");
          });
        }), Dn.setIconStatus(In, "emphasis"), Cn.eachComponent({
          mainType: "series",
          query: Ln == null ? null : {
            seriesIndex: Ln
          }
        }, Nn);
        var Rn, Fn = In;
        In === "stack" && (Rn = merge$1({
          stack: Dn.option.title.tiled,
          tiled: Dn.option.title.stack
        }, Dn.option.title), Dn.get(["iconStatus", In]) !== "emphasis" && (Fn = "tiled")), Bn.dispatchAction({
          type: "changeMagicType",
          currentType: Fn,
          newOption: $n,
          newTitle: Rn,
          featureName: "magicType"
        });
      }
    }, nr;
  }(ToolboxFeature)
), seriesOptGenreator = {
  line: function(_n, nr, Cn, Bn) {
    if (_n === "bar")
      return merge$1({
        id: nr,
        type: "line",
        // Preserve data related option
        data: Cn.get("data"),
        stack: Cn.get("stack"),
        markPoint: Cn.get("markPoint"),
        markLine: Cn.get("markLine")
      }, Bn.get(["option", "line"]) || {}, !0);
  },
  bar: function(_n, nr, Cn, Bn) {
    if (_n === "line")
      return merge$1({
        id: nr,
        type: "bar",
        // Preserve data related option
        data: Cn.get("data"),
        stack: Cn.get("stack"),
        markPoint: Cn.get("markPoint"),
        markLine: Cn.get("markLine")
      }, Bn.get(["option", "bar"]) || {}, !0);
  },
  stack: function(_n, nr, Cn, Bn) {
    var In = Cn.get("stack") === INNER_STACK_KEYWORD;
    if (_n === "line" || _n === "bar")
      return Bn.setIconStatus("stack", In ? "normal" : "emphasis"), merge$1({
        id: nr,
        stack: In ? "" : INNER_STACK_KEYWORD
      }, Bn.get(["option", "stack"]) || {}, !0);
  }
};
registerAction({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(_n, nr) {
  nr.mergeOption(_n.newOption);
});
const MagicType$1 = MagicType;
var BLOCK_SPLITER = new Array(60).join("-"), ITEM_SPLITER = "	";
function groupSeries(_n) {
  var nr = {}, Cn = [], Bn = [];
  return _n.eachRawSeries(function(In) {
    var Dn = In.coordinateSystem;
    if (Dn && (Dn.type === "cartesian2d" || Dn.type === "polar")) {
      var Ln = Dn.getBaseAxis();
      if (Ln.type === "category") {
        var $n = Ln.dim + "_" + Ln.index;
        nr[$n] || (nr[$n] = {
          categoryAxis: Ln,
          valueAxis: Dn.getOtherAxis(Ln),
          series: []
        }, Bn.push({
          axisDim: Ln.dim,
          axisIndex: Ln.index
        })), nr[$n].series.push(In);
      } else
        Cn.push(In);
    } else
      Cn.push(In);
  }), {
    seriesGroupByCategoryAxis: nr,
    other: Cn,
    meta: Bn
  };
}
function assembleSeriesWithCategoryAxis(_n) {
  var nr = [];
  return each$f(_n, function(Cn, Bn) {
    var In = Cn.categoryAxis, Dn = Cn.valueAxis, Ln = Dn.dim, $n = [" "].concat(map$1(Cn.series, function(Hn) {
      return Hn.name;
    })), Nn = [In.model.getCategories()];
    each$f(Cn.series, function(Hn) {
      var zn = Hn.getRawData();
      Nn.push(Hn.getRawData().mapArray(zn.mapDimension(Ln), function(Gn) {
        return Gn;
      }));
    });
    for (var Rn = [$n.join(ITEM_SPLITER)], Fn = 0; Fn < Nn[0].length; Fn++) {
      for (var Pn = [], Un = 0; Un < Nn.length; Un++)
        Pn.push(Nn[Un][Fn]);
      Rn.push(Pn.join(ITEM_SPLITER));
    }
    nr.push(Rn.join(`
`));
  }), nr.join(`

` + BLOCK_SPLITER + `

`);
}
function assembleOtherSeries(_n) {
  return map$1(_n, function(nr) {
    var Cn = nr.getRawData(), Bn = [nr.name], In = [];
    return Cn.each(Cn.dimensions, function() {
      for (var Dn = arguments.length, Ln = arguments[Dn - 1], $n = Cn.getName(Ln), Nn = 0; Nn < Dn - 1; Nn++)
        In[Nn] = arguments[Nn];
      Bn.push(($n ? $n + ITEM_SPLITER : "") + In.join(ITEM_SPLITER));
    }), Bn.join(`
`);
  }).join(`

` + BLOCK_SPLITER + `

`);
}
function getContentFromModel(_n) {
  var nr = groupSeries(_n);
  return {
    value: filter([assembleSeriesWithCategoryAxis(nr.seriesGroupByCategoryAxis), assembleOtherSeries(nr.other)], function(Cn) {
      return !!Cn.replace(/[\n\t\s]/g, "");
    }).join(`

` + BLOCK_SPLITER + `

`),
    meta: nr.meta
  };
}
function trim(_n) {
  return _n.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function isTSVFormat(_n) {
  var nr = _n.slice(0, _n.indexOf(`
`));
  if (nr.indexOf(ITEM_SPLITER) >= 0)
    return !0;
}
var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
function parseTSVContents(_n) {
  for (var nr = _n.split(/\n+/g), Cn = trim(nr.shift()).split(itemSplitRegex), Bn = [], In = map$1(Cn, function(Nn) {
    return {
      name: Nn,
      data: []
    };
  }), Dn = 0; Dn < nr.length; Dn++) {
    var Ln = trim(nr[Dn]).split(itemSplitRegex);
    Bn.push(Ln.shift());
    for (var $n = 0; $n < Ln.length; $n++)
      In[$n] && (In[$n].data[Dn] = Ln[$n]);
  }
  return {
    series: In,
    categories: Bn
  };
}
function parseListContents(_n) {
  for (var nr = _n.split(/\n+/g), Cn = trim(nr.shift()), Bn = [], In = 0; In < nr.length; In++) {
    var Dn = trim(nr[In]);
    if (Dn) {
      var Ln = Dn.split(itemSplitRegex), $n = "", Nn = void 0, Rn = !1;
      isNaN(Ln[0]) ? (Rn = !0, $n = Ln[0], Ln = Ln.slice(1), Bn[In] = {
        name: $n,
        value: []
      }, Nn = Bn[In].value) : Nn = Bn[In] = [];
      for (var Fn = 0; Fn < Ln.length; Fn++)
        Nn.push(+Ln[Fn]);
      Nn.length === 1 && (Rn ? Bn[In].value = Nn[0] : Bn[In] = Nn[0]);
    }
  }
  return {
    name: Cn,
    data: Bn
  };
}
function parseContents(_n, nr) {
  var Cn = _n.split(new RegExp(`
*` + BLOCK_SPLITER + `
*`, "g")), Bn = {
    series: []
  };
  return each$f(Cn, function(In, Dn) {
    if (isTSVFormat(In)) {
      var Ln = parseTSVContents(In), $n = nr[Dn], Nn = $n.axisDim + "Axis";
      $n && (Bn[Nn] = Bn[Nn] || [], Bn[Nn][$n.axisIndex] = {
        data: Ln.categories
      }, Bn.series = Bn.series.concat(Ln.series));
    } else {
      var Ln = parseListContents(In);
      Bn.series.push(Ln);
    }
  }), Bn;
}
var DataView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.onclick = function(Cn, Bn) {
      setTimeout(function() {
        Bn.dispatchAction({
          type: "hideTip"
        });
      });
      var In = Bn.getDom(), Dn = this.model;
      this._dom && In.removeChild(this._dom);
      var Ln = document.createElement("div");
      Ln.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", Ln.style.backgroundColor = Dn.get("backgroundColor") || "#fff";
      var $n = document.createElement("h4"), Nn = Dn.get("lang") || [];
      $n.innerHTML = Nn[0] || Dn.get("title"), $n.style.cssText = "margin:10px 20px", $n.style.color = Dn.get("textColor");
      var Rn = document.createElement("div"), Fn = document.createElement("textarea");
      Rn.style.cssText = "overflow:auto";
      var Pn = Dn.get("optionToContent"), Un = Dn.get("contentToOption"), Hn = getContentFromModel(Cn);
      if (isFunction$1(Pn)) {
        var zn = Pn(Bn.getOption());
        isString$1(zn) ? Rn.innerHTML = zn : isDom(zn) && Rn.appendChild(zn);
      } else {
        Fn.readOnly = Dn.get("readOnly");
        var Gn = Fn.style;
        Gn.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", Gn.color = Dn.get("textColor"), Gn.borderColor = Dn.get("textareaBorderColor"), Gn.backgroundColor = Dn.get("textareaColor"), Fn.value = Hn.value, Rn.appendChild(Fn);
      }
      var Yn = Hn.meta, Wn = document.createElement("div");
      Wn.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var Xn = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", ea = document.createElement("div"), ta = document.createElement("div");
      Xn += ";background-color:" + Dn.get("buttonColor"), Xn += ";color:" + Dn.get("buttonTextColor");
      var na = this;
      function ra() {
        In.removeChild(Ln), na._dom = null;
      }
      addEventListener(ea, "click", ra), addEventListener(ta, "click", function() {
        if (Un == null && Pn != null || Un != null && Pn == null) {
          process.env.NODE_ENV !== "production" && warn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), ra();
          return;
        }
        var aa;
        try {
          isFunction$1(Un) ? aa = Un(Rn, Bn.getOption()) : aa = parseContents(Fn.value, Yn);
        } catch (ia) {
          throw ra(), new Error("Data view format error " + ia);
        }
        aa && Bn.dispatchAction({
          type: "changeDataView",
          newOption: aa
        }), ra();
      }), ea.innerHTML = Nn[1], ta.innerHTML = Nn[2], ta.style.cssText = ea.style.cssText = Xn, !Dn.get("readOnly") && Wn.appendChild(ta), Wn.appendChild(ea), Ln.appendChild($n), Ln.appendChild(Rn), Ln.appendChild(Wn), Rn.style.height = In.clientHeight - 80 + "px", In.appendChild(Ln), this._dom = Ln;
    }, nr.prototype.remove = function(Cn, Bn) {
      this._dom && Bn.getDom().removeChild(this._dom);
    }, nr.prototype.dispose = function(Cn, Bn) {
      this.remove(Cn, Bn);
    }, nr.getDefaultOption = function(Cn) {
      var Bn = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: Cn.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: Cn.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return Bn;
    }, nr;
  }(ToolboxFeature)
);
function tryMergeDataOption(_n, nr) {
  return map$1(_n, function(Cn, Bn) {
    var In = nr && nr[Bn];
    if (isObject$6(In) && !isArray$4(In)) {
      var Dn = isObject$6(Cn) && !isArray$4(Cn);
      Dn || (Cn = {
        value: Cn
      });
      var Ln = In.name != null && Cn.name == null;
      return Cn = defaults(Cn, In), Ln && delete Cn.name, Cn;
    } else
      return Cn;
  });
}
registerAction({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(_n, nr) {
  var Cn = [];
  each$f(_n.newOption.series, function(Bn) {
    var In = nr.getSeriesByName(Bn.name)[0];
    if (!In)
      Cn.push(extend({
        // Default is scatter
        type: "scatter"
      }, Bn));
    else {
      var Dn = In.get("data");
      Cn.push({
        name: Bn.name,
        data: tryMergeDataOption(Bn.data, Dn)
      });
    }
  }), nr.mergeOption(defaults({
    series: Cn
  }, _n.newOption));
});
const DataView$1 = DataView;
var each$6 = each$f, inner$6 = makeInner();
function push(_n, nr) {
  var Cn = getStoreSnapshots(_n);
  each$6(nr, function(Bn, In) {
    for (var Dn = Cn.length - 1; Dn >= 0; Dn--) {
      var Ln = Cn[Dn];
      if (Ln[In])
        break;
    }
    if (Dn < 0) {
      var $n = _n.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: In
      })[0];
      if ($n) {
        var Nn = $n.getPercentRange();
        Cn[0][In] = {
          dataZoomId: In,
          start: Nn[0],
          end: Nn[1]
        };
      }
    }
  }), Cn.push(nr);
}
function pop(_n) {
  var nr = getStoreSnapshots(_n), Cn = nr[nr.length - 1];
  nr.length > 1 && nr.pop();
  var Bn = {};
  return each$6(Cn, function(In, Dn) {
    for (var Ln = nr.length - 1; Ln >= 0; Ln--)
      if (In = nr[Ln][Dn], In) {
        Bn[Dn] = In;
        break;
      }
  }), Bn;
}
function clear(_n) {
  inner$6(_n).snapshots = null;
}
function count(_n) {
  return getStoreSnapshots(_n).length;
}
function getStoreSnapshots(_n) {
  var nr = inner$6(_n);
  return nr.snapshots || (nr.snapshots = [{}]), nr.snapshots;
}
var RestoreOption = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.onclick = function(Cn, Bn) {
      clear(Cn), Bn.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, nr.getDefaultOption = function(Cn) {
      var Bn = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: Cn.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return Bn;
    }, nr;
  }(ToolboxFeature)
);
registerAction({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(_n, nr) {
  nr.resetOption("recreate");
});
const Restore = RestoreOption;
var INCLUDE_FINDER_MAIN_TYPES = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], BrushTargetManager = (
  /** @class */
  function() {
    function _n(nr, Cn, Bn) {
      var In = this;
      this._targetInfoList = [];
      var Dn = parseFinder(Cn, nr);
      each$f(targetInfoBuilders, function(Ln, $n) {
        (!Bn || !Bn.include || indexOf(Bn.include, $n) >= 0) && Ln(Dn, In._targetInfoList);
      });
    }
    return _n.prototype.setOutputRanges = function(nr, Cn) {
      return this.matchOutputRanges(nr, Cn, function(Bn, In, Dn) {
        if ((Bn.coordRanges || (Bn.coordRanges = [])).push(In), !Bn.coordRange) {
          Bn.coordRange = In;
          var Ln = coordConvert[Bn.brushType](0, Dn, In);
          Bn.__rangeOffset = {
            offset: diffProcessor[Bn.brushType](Ln.values, Bn.range, [1, 1]),
            xyMinMax: Ln.xyMinMax
          };
        }
      }), nr;
    }, _n.prototype.matchOutputRanges = function(nr, Cn, Bn) {
      each$f(nr, function(In) {
        var Dn = this.findTargetInfo(In, Cn);
        Dn && Dn !== !0 && each$f(Dn.coordSyses, function(Ln) {
          var $n = coordConvert[In.brushType](1, Ln, In.range, !0);
          Bn(In, $n.values, Ln, Cn);
        });
      }, this);
    }, _n.prototype.setInputRanges = function(nr, Cn) {
      each$f(nr, function(Bn) {
        var In = this.findTargetInfo(Bn, Cn);
        if (process.env.NODE_ENV !== "production" && (assert(!In || In === !0 || Bn.coordRange, "coordRange must be specified when coord index specified."), assert(!In || In !== !0 || Bn.range, "range must be specified in global brush.")), Bn.range = Bn.range || [], In && In !== !0) {
          Bn.panelId = In.panelId;
          var Dn = coordConvert[Bn.brushType](0, In.coordSys, Bn.coordRange), Ln = Bn.__rangeOffset;
          Bn.range = Ln ? diffProcessor[Bn.brushType](Dn.values, Ln.offset, getScales(Dn.xyMinMax, Ln.xyMinMax)) : Dn.values;
        }
      }, this);
    }, _n.prototype.makePanelOpts = function(nr, Cn) {
      return map$1(this._targetInfoList, function(Bn) {
        var In = Bn.getPanelRect();
        return {
          panelId: Bn.panelId,
          defaultBrushType: Cn ? Cn(Bn) : null,
          clipPath: makeRectPanelClipPath(In),
          isTargetByCursor: makeRectIsTargetByCursor(In, nr, Bn.coordSysModel),
          getLinearBrushOtherExtent: makeLinearBrushOtherExtent(In)
        };
      });
    }, _n.prototype.controlSeries = function(nr, Cn, Bn) {
      var In = this.findTargetInfo(nr, Bn);
      return In === !0 || In && indexOf(In.coordSyses, Cn.coordinateSystem) >= 0;
    }, _n.prototype.findTargetInfo = function(nr, Cn) {
      for (var Bn = this._targetInfoList, In = parseFinder(Cn, nr), Dn = 0; Dn < Bn.length; Dn++) {
        var Ln = Bn[Dn], $n = nr.panelId;
        if ($n) {
          if (Ln.panelId === $n)
            return Ln;
        } else
          for (var Nn = 0; Nn < targetInfoMatchers.length; Nn++)
            if (targetInfoMatchers[Nn](In, Ln))
              return Ln;
      }
      return !0;
    }, _n;
  }()
);
function formatMinMax(_n) {
  return _n[0] > _n[1] && _n.reverse(), _n;
}
function parseFinder(_n, nr) {
  return parseFinder$1(_n, nr, {
    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
  });
}
var targetInfoBuilders = {
  grid: function(_n, nr) {
    var Cn = _n.xAxisModels, Bn = _n.yAxisModels, In = _n.gridModels, Dn = createHashMap(), Ln = {}, $n = {};
    !Cn && !Bn && !In || (each$f(Cn, function(Nn) {
      var Rn = Nn.axis.grid.model;
      Dn.set(Rn.id, Rn), Ln[Rn.id] = !0;
    }), each$f(Bn, function(Nn) {
      var Rn = Nn.axis.grid.model;
      Dn.set(Rn.id, Rn), $n[Rn.id] = !0;
    }), each$f(In, function(Nn) {
      Dn.set(Nn.id, Nn), Ln[Nn.id] = !0, $n[Nn.id] = !0;
    }), Dn.each(function(Nn) {
      var Rn = Nn.coordinateSystem, Fn = [];
      each$f(Rn.getCartesians(), function(Pn, Un) {
        (indexOf(Cn, Pn.getAxis("x").model) >= 0 || indexOf(Bn, Pn.getAxis("y").model) >= 0) && Fn.push(Pn);
      }), nr.push({
        panelId: "grid--" + Nn.id,
        gridModel: Nn,
        coordSysModel: Nn,
        // Use the first one as the representitive coordSys.
        coordSys: Fn[0],
        coordSyses: Fn,
        getPanelRect: panelRectBuilders.grid,
        xAxisDeclared: Ln[Nn.id],
        yAxisDeclared: $n[Nn.id]
      });
    }));
  },
  geo: function(_n, nr) {
    each$f(_n.geoModels, function(Cn) {
      var Bn = Cn.coordinateSystem;
      nr.push({
        panelId: "geo--" + Cn.id,
        geoModel: Cn,
        coordSysModel: Cn,
        coordSys: Bn,
        coordSyses: [Bn],
        getPanelRect: panelRectBuilders.geo
      });
    });
  }
}, targetInfoMatchers = [
  // grid
  function(_n, nr) {
    var Cn = _n.xAxisModel, Bn = _n.yAxisModel, In = _n.gridModel;
    return !In && Cn && (In = Cn.axis.grid.model), !In && Bn && (In = Bn.axis.grid.model), In && In === nr.gridModel;
  },
  // geo
  function(_n, nr) {
    var Cn = _n.geoModel;
    return Cn && Cn === nr.geoModel;
  }
], panelRectBuilders = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var _n = this.coordSys, nr = _n.getBoundingRect().clone();
    return nr.applyTransform(getTransform$1(_n)), nr;
  }
}, coordConvert = {
  lineX: curry$1(axisConvert, 0),
  lineY: curry$1(axisConvert, 1),
  rect: function(_n, nr, Cn, Bn) {
    var In = _n ? nr.pointToData([Cn[0][0], Cn[1][0]], Bn) : nr.dataToPoint([Cn[0][0], Cn[1][0]], Bn), Dn = _n ? nr.pointToData([Cn[0][1], Cn[1][1]], Bn) : nr.dataToPoint([Cn[0][1], Cn[1][1]], Bn), Ln = [formatMinMax([In[0], Dn[0]]), formatMinMax([In[1], Dn[1]])];
    return {
      values: Ln,
      xyMinMax: Ln
    };
  },
  polygon: function(_n, nr, Cn, Bn) {
    var In = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], Dn = map$1(Cn, function(Ln) {
      var $n = _n ? nr.pointToData(Ln, Bn) : nr.dataToPoint(Ln, Bn);
      return In[0][0] = Math.min(In[0][0], $n[0]), In[1][0] = Math.min(In[1][0], $n[1]), In[0][1] = Math.max(In[0][1], $n[0]), In[1][1] = Math.max(In[1][1], $n[1]), $n;
    });
    return {
      values: Dn,
      xyMinMax: In
    };
  }
};
function axisConvert(_n, nr, Cn, Bn) {
  process.env.NODE_ENV !== "production" && assert(Cn.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  var In = Cn.getAxis(["x", "y"][_n]), Dn = formatMinMax(map$1([0, 1], function($n) {
    return nr ? In.coordToData(In.toLocalCoord(Bn[$n]), !0) : In.toGlobalCoord(In.dataToCoord(Bn[$n]));
  })), Ln = [];
  return Ln[_n] = Dn, Ln[1 - _n] = [NaN, NaN], {
    values: Dn,
    xyMinMax: Ln
  };
}
var diffProcessor = {
  lineX: curry$1(axisDiffProcessor, 0),
  lineY: curry$1(axisDiffProcessor, 1),
  rect: function(_n, nr, Cn) {
    return [[_n[0][0] - Cn[0] * nr[0][0], _n[0][1] - Cn[0] * nr[0][1]], [_n[1][0] - Cn[1] * nr[1][0], _n[1][1] - Cn[1] * nr[1][1]]];
  },
  polygon: function(_n, nr, Cn) {
    return map$1(_n, function(Bn, In) {
      return [Bn[0] - Cn[0] * nr[In][0], Bn[1] - Cn[1] * nr[In][1]];
    });
  }
};
function axisDiffProcessor(_n, nr, Cn, Bn) {
  return [nr[0] - Bn[_n] * Cn[0], nr[1] - Bn[_n] * Cn[1]];
}
function getScales(_n, nr) {
  var Cn = getSize(_n), Bn = getSize(nr), In = [Cn[0] / Bn[0], Cn[1] / Bn[1]];
  return isNaN(In[0]) && (In[0] = 1), isNaN(In[1]) && (In[1] = 1), In;
}
function getSize(_n) {
  return _n ? [_n[0][1] - _n[0][0], _n[1][1] - _n[1][0]] : [NaN, NaN];
}
const BrushTargetManager$1 = BrushTargetManager;
var each$5 = each$f, DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_"), DataZoomFeature = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.render = function(Cn, Bn, In, Dn) {
      this._brushController || (this._brushController = new BrushController$1(In.getZr()), this._brushController.on("brush", bind$1(this._onBrush, this)).mount()), updateZoomBtnStatus(Cn, Bn, this, Dn, In), updateBackBtnStatus(Cn, Bn);
    }, nr.prototype.onclick = function(Cn, Bn, In) {
      handlers[In].call(this);
    }, nr.prototype.remove = function(Cn, Bn) {
      this._brushController && this._brushController.unmount();
    }, nr.prototype.dispose = function(Cn, Bn) {
      this._brushController && this._brushController.dispose();
    }, nr.prototype._onBrush = function(Cn) {
      var Bn = Cn.areas;
      if (!Cn.isEnd || !Bn.length)
        return;
      var In = {}, Dn = this.ecModel;
      this._brushController.updateCovers([]);
      var Ln = new BrushTargetManager$1(makeAxisFinder(this.model), Dn, {
        include: ["grid"]
      });
      Ln.matchOutputRanges(Bn, Dn, function(Rn, Fn, Pn) {
        if (Pn.type === "cartesian2d") {
          var Un = Rn.brushType;
          Un === "rect" ? ($n("x", Pn, Fn[0]), $n("y", Pn, Fn[1])) : $n({
            lineX: "x",
            lineY: "y"
          }[Un], Pn, Fn);
        }
      }), push(Dn, In), this._dispatchZoomAction(In);
      function $n(Rn, Fn, Pn) {
        var Un = Fn.getAxis(Rn), Hn = Un.model, zn = Nn(Rn, Hn, Dn), Gn = zn.findRepresentativeAxisProxy(Hn).getMinMaxSpan();
        (Gn.minValueSpan != null || Gn.maxValueSpan != null) && (Pn = sliderMove(0, Pn.slice(), Un.scale.getExtent(), 0, Gn.minValueSpan, Gn.maxValueSpan)), zn && (In[zn.id] = {
          dataZoomId: zn.id,
          startValue: Pn[0],
          endValue: Pn[1]
        });
      }
      function Nn(Rn, Fn, Pn) {
        var Un;
        return Pn.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(Hn) {
          var zn = Hn.getAxisModel(Rn, Fn.componentIndex);
          zn && (Un = Hn);
        }), Un;
      }
    }, nr.prototype._dispatchZoomAction = function(Cn) {
      var Bn = [];
      each$5(Cn, function(In, Dn) {
        Bn.push(clone$4(In));
      }), Bn.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: Bn
      });
    }, nr.getDefaultOption = function(Cn) {
      var Bn = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: Cn.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return Bn;
    }, nr;
  }(ToolboxFeature)
), handlers = {
  zoom: function() {
    var _n = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: _n
    });
  },
  back: function() {
    this._dispatchZoomAction(pop(this.ecModel));
  }
};
function makeAxisFinder(_n) {
  var nr = {
    xAxisIndex: _n.get("xAxisIndex", !0),
    yAxisIndex: _n.get("yAxisIndex", !0),
    xAxisId: _n.get("xAxisId", !0),
    yAxisId: _n.get("yAxisId", !0)
  };
  return nr.xAxisIndex == null && nr.xAxisId == null && (nr.xAxisIndex = "all"), nr.yAxisIndex == null && nr.yAxisId == null && (nr.yAxisIndex = "all"), nr;
}
function updateBackBtnStatus(_n, nr) {
  _n.setIconStatus("back", count(nr) > 1 ? "emphasis" : "normal");
}
function updateZoomBtnStatus(_n, nr, Cn, Bn, In) {
  var Dn = Cn._isZoomActive;
  Bn && Bn.type === "takeGlobalCursor" && (Dn = Bn.key === "dataZoomSelect" ? Bn.dataZoomSelectActive : !1), Cn._isZoomActive = Dn, _n.setIconStatus("zoom", Dn ? "emphasis" : "normal");
  var Ln = new BrushTargetManager$1(makeAxisFinder(_n), nr, {
    include: ["grid"]
  }), $n = Ln.makePanelOpts(In, function(Nn) {
    return Nn.xAxisDeclared && !Nn.yAxisDeclared ? "lineX" : !Nn.xAxisDeclared && Nn.yAxisDeclared ? "lineY" : "rect";
  });
  Cn._brushController.setPanels($n).enableBrush(Dn && $n.length ? {
    brushType: "auto",
    brushStyle: _n.getModel("brushStyle").getItemStyle()
  } : !1);
}
registerInternalOptionCreator("dataZoom", function(_n) {
  var nr = _n.getComponent("toolbox", 0), Cn = ["feature", "dataZoom"];
  if (!nr || nr.get(Cn) == null)
    return;
  var Bn = nr.getModel(Cn), In = [], Dn = makeAxisFinder(Bn), Ln = parseFinder$1(_n, Dn);
  each$5(Ln.xAxisModels, function(Nn) {
    return $n(Nn, "xAxis", "xAxisIndex");
  }), each$5(Ln.yAxisModels, function(Nn) {
    return $n(Nn, "yAxis", "yAxisIndex");
  });
  function $n(Nn, Rn, Fn) {
    var Pn = Nn.componentIndex, Un = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: Bn.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: DATA_ZOOM_ID_BASE + Rn + Pn
    };
    Un[Fn] = Pn, In.push(Un);
  }
  return In;
});
const DataZoom = DataZoomFeature;
function install$j(_n) {
  _n.registerComponentModel(ToolboxModel$1), _n.registerComponentView(ToolboxView$1), registerFeature("saveAsImage", SaveAsImage$1), registerFeature("magicType", MagicType$1), registerFeature("dataView", DataView$1), registerFeature("dataZoom", DataZoom), registerFeature("restore", Restore), use(install$k);
}
var TooltipModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "tooltip", nr.dependencies = ["axisPointer"], nr.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaut false (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "#fff",
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, nr;
  }(ComponentModel$1)
);
const TooltipModel$1 = TooltipModel;
function shouldTooltipConfine(_n) {
  var nr = _n.get("confine");
  return nr != null ? !!nr : _n.get("renderMode") === "richText";
}
function testStyle(_n) {
  if (env$1.domSupported) {
    for (var nr = document.documentElement.style, Cn = 0, Bn = _n.length; Cn < Bn; Cn++)
      if (_n[Cn] in nr)
        return _n[Cn];
  }
}
var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function toCSSVendorPrefix(_n, nr) {
  if (!_n)
    return nr;
  nr = toCamelCase(nr, !0);
  var Cn = _n.indexOf(nr);
  return _n = Cn === -1 ? nr : "-" + _n.slice(0, Cn) + "-" + nr, _n.toLowerCase();
}
function getComputedStyle$1(_n, nr) {
  var Cn = _n.currentStyle || document.defaultView && document.defaultView.getComputedStyle(_n);
  return Cn ? nr ? Cn[nr] : Cn : null;
}
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition"), CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform"), gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env$1.transform3dSupported ? "will-change:transform;" : "");
function mirrorPos(_n) {
  return _n = _n === "left" ? "right" : _n === "right" ? "left" : _n === "top" ? "bottom" : "top", _n;
}
function assembleArrow(_n, nr, Cn) {
  if (!isString$1(Cn) || Cn === "inside")
    return "";
  var Bn = _n.get("backgroundColor"), In = _n.get("borderWidth");
  nr = convertToColorString(nr);
  var Dn = mirrorPos(Cn), Ln = Math.max(Math.round(In) * 1.5, 6), $n = "", Nn = CSS_TRANSFORM_VENDOR + ":", Rn;
  indexOf(["left", "right"], Dn) > -1 ? ($n += "top:50%", Nn += "translateY(-50%) rotate(" + (Rn = Dn === "left" ? -225 : -45) + "deg)") : ($n += "left:50%", Nn += "translateX(-50%) rotate(" + (Rn = Dn === "top" ? 225 : 45) + "deg)");
  var Fn = Rn * Math.PI / 180, Pn = Ln + In, Un = Pn * Math.abs(Math.cos(Fn)) + Pn * Math.abs(Math.sin(Fn)), Hn = Math.round(((Un - Math.SQRT2 * In) / 2 + Math.SQRT2 * In - (Un - Pn) / 2) * 100) / 100;
  $n += ";" + Dn + ":-" + Hn + "px";
  var zn = nr + " solid " + In + "px;", Gn = ["position:absolute;width:" + Ln + "px;height:" + Ln + "px;z-index:-1;", $n + ";" + Nn + ";", "border-bottom:" + zn, "border-right:" + zn, "background-color:" + Bn + ";"];
  return '<div style="' + Gn.join("") + '"></div>';
}
function assembleTransition(_n, nr) {
  var Cn = "cubic-bezier(0.23,1,0.32,1)", Bn = " " + _n / 2 + "s " + Cn, In = "opacity" + Bn + ",visibility" + Bn;
  return nr || (Bn = " " + _n + "s " + Cn, In += env$1.transformSupported ? "," + CSS_TRANSFORM_VENDOR + Bn : ",left" + Bn + ",top" + Bn), CSS_TRANSITION_VENDOR + ":" + In;
}
function assembleTransform(_n, nr, Cn) {
  var Bn = _n.toFixed(0) + "px", In = nr.toFixed(0) + "px";
  if (!env$1.transformSupported)
    return Cn ? "top:" + In + ";left:" + Bn + ";" : [["top", In], ["left", Bn]];
  var Dn = env$1.transform3dSupported, Ln = "translate" + (Dn ? "3d" : "") + "(" + Bn + "," + In + (Dn ? ",0" : "") + ")";
  return Cn ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + Ln + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, Ln]];
}
function assembleFont(_n) {
  var nr = [], Cn = _n.get("fontSize"), Bn = _n.getTextColor();
  Bn && nr.push("color:" + Bn), nr.push("font:" + _n.getFont());
  var In = retrieve2(_n.get("lineHeight"), Math.round(Cn * 3 / 2));
  Cn && nr.push("line-height:" + In + "px");
  var Dn = _n.get("textShadowColor"), Ln = _n.get("textShadowBlur") || 0, $n = _n.get("textShadowOffsetX") || 0, Nn = _n.get("textShadowOffsetY") || 0;
  return Dn && Ln && nr.push("text-shadow:" + $n + "px " + Nn + "px " + Ln + "px " + Dn), each$f(["decoration", "align"], function(Rn) {
    var Fn = _n.get(Rn);
    Fn && nr.push("text-" + Rn + ":" + Fn);
  }), nr.join(";");
}
function assembleCssText(_n, nr, Cn) {
  var Bn = [], In = _n.get("transitionDuration"), Dn = _n.get("backgroundColor"), Ln = _n.get("shadowBlur"), $n = _n.get("shadowColor"), Nn = _n.get("shadowOffsetX"), Rn = _n.get("shadowOffsetY"), Fn = _n.getModel("textStyle"), Pn = getPaddingFromTooltipModel(_n, "html"), Un = Nn + "px " + Rn + "px " + Ln + "px " + $n;
  return Bn.push("box-shadow:" + Un), nr && In && Bn.push(assembleTransition(In, Cn)), Dn && Bn.push("background-color:" + Dn), each$f(["width", "color", "radius"], function(Hn) {
    var zn = "border-" + Hn, Gn = toCamelCase(zn), Yn = _n.get(Gn);
    Yn != null && Bn.push(zn + ":" + Yn + (Hn === "color" ? "" : "px"));
  }), Bn.push(assembleFont(Fn)), Pn != null && Bn.push("padding:" + normalizeCssArray(Pn).join("px ") + "px"), Bn.join(";") + ";";
}
function makeStyleCoord$1(_n, nr, Cn, Bn, In) {
  var Dn = nr && nr.painter;
  if (Cn) {
    var Ln = Dn && Dn.getViewportRoot();
    Ln && transformLocalCoord(_n, Ln, Cn, Bn, In);
  } else {
    _n[0] = Bn, _n[1] = In;
    var $n = Dn && Dn.getViewportRootOffset();
    $n && (_n[0] += $n.offsetLeft, _n[1] += $n.offsetTop);
  }
  _n[2] = _n[0] / nr.getWidth(), _n[3] = _n[1] / nr.getHeight();
}
var TooltipHTMLContent = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, env$1.wxa)
        return null;
      var Bn = document.createElement("div");
      Bn.domBelongToZr = !0, this.el = Bn;
      var In = this._zr = nr.getZr(), Dn = Cn.appendTo, Ln = Dn && (isString$1(Dn) ? document.querySelector(Dn) : isDom(Dn) ? Dn : isFunction$1(Dn) && Dn(nr.getDom()));
      makeStyleCoord$1(this._styleCoord, In, Ln, nr.getWidth() / 2, nr.getHeight() / 2), (Ln || nr.getDom()).appendChild(Bn), this._api = nr, this._container = Ln;
      var $n = this;
      Bn.onmouseenter = function() {
        $n._enterable && (clearTimeout($n._hideTimeout), $n._show = !0), $n._inContent = !0;
      }, Bn.onmousemove = function(Nn) {
        if (Nn = Nn || window.event, !$n._enterable) {
          var Rn = In.handler, Fn = In.painter.getViewportRoot();
          normalizeEvent(Fn, Nn, !0), Rn.dispatch("mousemove", Nn);
        }
      }, Bn.onmouseleave = function() {
        $n._inContent = !1, $n._enterable && $n._show && $n.hideLater($n._hideDelay);
      };
    }
    return _n.prototype.update = function(nr) {
      if (!this._container) {
        var Cn = this._api.getDom(), Bn = getComputedStyle$1(Cn, "position"), In = Cn.style;
        In.position !== "absolute" && Bn !== "absolute" && (In.position = "relative");
      }
      var Dn = nr.get("alwaysShowContent");
      Dn && this._moveIfResized(), this._alwaysShowContent = Dn, this.el.className = nr.get("className") || "";
    }, _n.prototype.show = function(nr, Cn) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var Bn = this.el, In = Bn.style, Dn = this._styleCoord;
      Bn.innerHTML ? In.cssText = gCssText + assembleCssText(nr, !this._firstShow, this._longHide) + assembleTransform(Dn[0], Dn[1], !0) + ("border-color:" + convertToColorString(Cn) + ";") + (nr.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : In.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, _n.prototype.setContent = function(nr, Cn, Bn, In, Dn) {
      var Ln = this.el;
      if (nr == null) {
        Ln.innerHTML = "";
        return;
      }
      var $n = "";
      if (isString$1(Dn) && Bn.get("trigger") === "item" && !shouldTooltipConfine(Bn) && ($n = assembleArrow(Bn, In, Dn)), isString$1(nr))
        Ln.innerHTML = nr + $n;
      else if (nr) {
        Ln.innerHTML = "", isArray$4(nr) || (nr = [nr]);
        for (var Nn = 0; Nn < nr.length; Nn++)
          isDom(nr[Nn]) && nr[Nn].parentNode !== Ln && Ln.appendChild(nr[Nn]);
        if ($n && Ln.childNodes.length) {
          var Rn = document.createElement("div");
          Rn.innerHTML = $n, Ln.appendChild(Rn);
        }
      }
    }, _n.prototype.setEnterable = function(nr) {
      this._enterable = nr;
    }, _n.prototype.getSize = function() {
      var nr = this.el;
      return nr ? [nr.offsetWidth, nr.offsetHeight] : [0, 0];
    }, _n.prototype.moveTo = function(nr, Cn) {
      if (this.el) {
        var Bn = this._styleCoord;
        if (makeStyleCoord$1(Bn, this._zr, this._container, nr, Cn), Bn[0] != null && Bn[1] != null) {
          var In = this.el.style, Dn = assembleTransform(Bn[0], Bn[1]);
          each$f(Dn, function(Ln) {
            In[Ln[0]] = Ln[1];
          });
        }
      }
    }, _n.prototype._moveIfResized = function() {
      var nr = this._styleCoord[2], Cn = this._styleCoord[3];
      this.moveTo(nr * this._zr.getWidth(), Cn * this._zr.getHeight());
    }, _n.prototype.hide = function() {
      var nr = this, Cn = this.el.style;
      Cn.visibility = "hidden", Cn.opacity = "0", env$1.transform3dSupported && (Cn.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return nr._longHide = !0;
      }, 500);
    }, _n.prototype.hideLater = function(nr) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (nr ? (this._hideDelay = nr, this._show = !1, this._hideTimeout = setTimeout(bind$1(this.hide, this), nr)) : this.hide());
    }, _n.prototype.isShow = function() {
      return this._show;
    }, _n.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var nr = this.el.parentNode;
      nr && nr.removeChild(this.el), this.el = this._container = null;
    }, _n;
  }()
);
const TooltipHTMLContent$1 = TooltipHTMLContent;
var TooltipRichContent = (
  /** @class */
  function() {
    function _n(nr) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = nr.getZr(), makeStyleCoord(this._styleCoord, this._zr, nr.getWidth() / 2, nr.getHeight() / 2);
    }
    return _n.prototype.update = function(nr) {
      var Cn = nr.get("alwaysShowContent");
      Cn && this._moveIfResized(), this._alwaysShowContent = Cn;
    }, _n.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, _n.prototype.setContent = function(nr, Cn, Bn, In, Dn) {
      var Ln = this;
      isObject$6(nr) && throwError(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var $n = Bn.getModel("textStyle");
      this.el = new ZRText$1({
        style: {
          rich: Cn.richTextStyles,
          text: nr,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: In,
          textShadowColor: $n.get("textShadowColor"),
          fill: Bn.get(["textStyle", "color"]),
          padding: getPaddingFromTooltipModel(Bn, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: Bn.get("z")
      }), each$f(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(Rn) {
        Ln.el.style[Rn] = Bn.get(Rn);
      }), each$f(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(Rn) {
        Ln.el.style[Rn] = $n.get(Rn) || 0;
      }), this._zr.add(this.el);
      var Nn = this;
      this.el.on("mouseover", function() {
        Nn._enterable && (clearTimeout(Nn._hideTimeout), Nn._show = !0), Nn._inContent = !0;
      }), this.el.on("mouseout", function() {
        Nn._enterable && Nn._show && Nn.hideLater(Nn._hideDelay), Nn._inContent = !1;
      });
    }, _n.prototype.setEnterable = function(nr) {
      this._enterable = nr;
    }, _n.prototype.getSize = function() {
      var nr = this.el, Cn = this.el.getBoundingRect(), Bn = calcShadowOuterSize(nr.style);
      return [Cn.width + Bn.left + Bn.right, Cn.height + Bn.top + Bn.bottom];
    }, _n.prototype.moveTo = function(nr, Cn) {
      var Bn = this.el;
      if (Bn) {
        var In = this._styleCoord;
        makeStyleCoord(In, this._zr, nr, Cn), nr = In[0], Cn = In[1];
        var Dn = Bn.style, Ln = mathMaxWith0(Dn.borderWidth || 0), $n = calcShadowOuterSize(Dn);
        Bn.x = nr + Ln + $n.left, Bn.y = Cn + Ln + $n.top, Bn.markRedraw();
      }
    }, _n.prototype._moveIfResized = function() {
      var nr = this._styleCoord[2], Cn = this._styleCoord[3];
      this.moveTo(nr * this._zr.getWidth(), Cn * this._zr.getHeight());
    }, _n.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, _n.prototype.hideLater = function(nr) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (nr ? (this._hideDelay = nr, this._show = !1, this._hideTimeout = setTimeout(bind$1(this.hide, this), nr)) : this.hide());
    }, _n.prototype.isShow = function() {
      return this._show;
    }, _n.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, _n;
  }()
);
function mathMaxWith0(_n) {
  return Math.max(0, _n);
}
function calcShadowOuterSize(_n) {
  var nr = mathMaxWith0(_n.shadowBlur || 0), Cn = mathMaxWith0(_n.shadowOffsetX || 0), Bn = mathMaxWith0(_n.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(nr - Cn),
    right: mathMaxWith0(nr + Cn),
    top: mathMaxWith0(nr - Bn),
    bottom: mathMaxWith0(nr + Bn)
  };
}
function makeStyleCoord(_n, nr, Cn, Bn) {
  _n[0] = Cn, _n[1] = Bn, _n[2] = _n[0] / nr.getWidth(), _n[3] = _n[1] / nr.getHeight();
}
const TooltipRichContent$1 = TooltipRichContent;
var proxyRect = new Rect$3({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), TooltipView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      if (!(env$1.node || !Bn.getDom())) {
        var In = Cn.getComponent("tooltip"), Dn = this._renderMode = getTooltipRenderMode(In.get("renderMode"));
        this._tooltipContent = Dn === "richText" ? new TooltipRichContent$1(Bn) : new TooltipHTMLContent$1(Bn, {
          appendTo: In.get("appendToBody", !0) ? "body" : In.get("appendTo", !0)
        });
      }
    }, nr.prototype.render = function(Cn, Bn, In) {
      if (!(env$1.node || !In.getDom())) {
        this.group.removeAll(), this._tooltipModel = Cn, this._ecModel = Bn, this._api = In;
        var Dn = this._tooltipContent;
        Dn.update(Cn), Dn.setEnterable(Cn.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && Cn.get("transitionDuration") ? createOrUpdate(this, "_updatePosition", 50, "fixRate") : clear$1(this, "_updatePosition");
      }
    }, nr.prototype._initGlobalListener = function() {
      var Cn = this._tooltipModel, Bn = Cn.get("triggerOn");
      register("itemTooltip", this._api, bind$1(function(In, Dn, Ln) {
        Bn !== "none" && (Bn.indexOf(In) >= 0 ? this._tryShow(Dn, Ln) : In === "leave" && this._hide(Ln));
      }, this));
    }, nr.prototype._keepShow = function() {
      var Cn = this._tooltipModel, Bn = this._ecModel, In = this._api, Dn = Cn.get("triggerOn");
      if (this._lastX != null && this._lastY != null && Dn !== "none" && Dn !== "click") {
        var Ln = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !In.isDisposed() && Ln.manuallyShowTip(Cn, Bn, In, {
            x: Ln._lastX,
            y: Ln._lastY,
            dataByCoordSys: Ln._lastDataByCoordSys
          });
        });
      }
    }, nr.prototype.manuallyShowTip = function(Cn, Bn, In, Dn) {
      if (!(Dn.from === this.uid || env$1.node || !In.getDom())) {
        var Ln = makeDispatchAction(Dn, In);
        this._ticket = "";
        var $n = Dn.dataByCoordSys, Nn = findComponentReference(Dn, Bn, In);
        if (Nn) {
          var Rn = Nn.el.getBoundingRect().clone();
          Rn.applyTransform(Nn.el.transform), this._tryShow({
            offsetX: Rn.x + Rn.width / 2,
            offsetY: Rn.y + Rn.height / 2,
            target: Nn.el,
            position: Dn.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, Ln);
        } else if (Dn.tooltip && Dn.x != null && Dn.y != null) {
          var Fn = proxyRect;
          Fn.x = Dn.x, Fn.y = Dn.y, Fn.update(), getECData(Fn).tooltipConfig = {
            name: null,
            option: Dn.tooltip
          }, this._tryShow({
            offsetX: Dn.x,
            offsetY: Dn.y,
            target: Fn
          }, Ln);
        } else if ($n)
          this._tryShow({
            offsetX: Dn.x,
            offsetY: Dn.y,
            position: Dn.position,
            dataByCoordSys: $n,
            tooltipOption: Dn.tooltipOption
          }, Ln);
        else if (Dn.seriesIndex != null) {
          if (this._manuallyAxisShowTip(Cn, Bn, In, Dn))
            return;
          var Pn = findPointFromSeries(Dn, Bn), Un = Pn.point[0], Hn = Pn.point[1];
          Un != null && Hn != null && this._tryShow({
            offsetX: Un,
            offsetY: Hn,
            target: Pn.el,
            position: Dn.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, Ln);
        } else
          Dn.x != null && Dn.y != null && (In.dispatchAction({
            type: "updateAxisPointer",
            x: Dn.x,
            y: Dn.y
          }), this._tryShow({
            offsetX: Dn.x,
            offsetY: Dn.y,
            position: Dn.position,
            target: In.getZr().findHover(Dn.x, Dn.y).target
          }, Ln));
      }
    }, nr.prototype.manuallyHideTip = function(Cn, Bn, In, Dn) {
      var Ln = this._tooltipContent;
      this._tooltipModel && Ln.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, Dn.from !== this.uid && this._hide(makeDispatchAction(Dn, In));
    }, nr.prototype._manuallyAxisShowTip = function(Cn, Bn, In, Dn) {
      var Ln = Dn.seriesIndex, $n = Dn.dataIndex, Nn = Bn.getComponent("axisPointer").coordSysAxesInfo;
      if (!(Ln == null || $n == null || Nn == null)) {
        var Rn = Bn.getSeriesByIndex(Ln);
        if (Rn) {
          var Fn = Rn.getData(), Pn = buildTooltipModel([Fn.getItemModel($n), Rn, (Rn.coordinateSystem || {}).model], this._tooltipModel);
          if (Pn.get("trigger") === "axis")
            return In.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: Ln,
              dataIndex: $n,
              position: Dn.position
            }), !0;
        }
      }
    }, nr.prototype._tryShow = function(Cn, Bn) {
      var In = Cn.target, Dn = this._tooltipModel;
      if (Dn) {
        this._lastX = Cn.offsetX, this._lastY = Cn.offsetY;
        var Ln = Cn.dataByCoordSys;
        if (Ln && Ln.length)
          this._showAxisTooltip(Ln, Cn);
        else if (In) {
          var $n = getECData(In);
          if ($n.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var Nn, Rn;
          findEventDispatcher(In, function(Fn) {
            if (getECData(Fn).dataIndex != null)
              return Nn = Fn, !0;
            if (getECData(Fn).tooltipConfig != null)
              return Rn = Fn, !0;
          }, !0), Nn ? this._showSeriesItemTooltip(Cn, Nn, Bn) : Rn ? this._showComponentItemTooltip(Cn, Rn, Bn) : this._hide(Bn);
        } else
          this._lastDataByCoordSys = null, this._hide(Bn);
      }
    }, nr.prototype._showOrMove = function(Cn, Bn) {
      var In = Cn.get("showDelay");
      Bn = bind$1(Bn, this), clearTimeout(this._showTimout), In > 0 ? this._showTimout = setTimeout(Bn, In) : Bn();
    }, nr.prototype._showAxisTooltip = function(Cn, Bn) {
      var In = this._ecModel, Dn = this._tooltipModel, Ln = [Bn.offsetX, Bn.offsetY], $n = buildTooltipModel([Bn.tooltipOption], Dn), Nn = this._renderMode, Rn = [], Fn = createTooltipMarkup("section", {
        blocks: [],
        noHeader: !0
      }), Pn = [], Un = new TooltipMarkupStyleCreator();
      each$f(Cn, function(Xn) {
        each$f(Xn.dataByAxis, function(ea) {
          var ta = In.getComponent(ea.axisDim + "Axis", ea.axisIndex), na = ea.value;
          if (!(!ta || na == null)) {
            var ra = getValueLabel(na, ta.axis, In, ea.seriesDataIndices, ea.valueLabelOpt), aa = createTooltipMarkup("section", {
              header: ra,
              noHeader: !trim$1(ra),
              sortBlocks: !0,
              blocks: []
            });
            Fn.blocks.push(aa), each$f(ea.seriesDataIndices, function(ia) {
              var Aa = In.getSeriesByIndex(ia.seriesIndex), sa = ia.dataIndexInside, oa = Aa.getDataParams(sa);
              if (!(oa.dataIndex < 0)) {
                oa.axisDim = ea.axisDim, oa.axisIndex = ea.axisIndex, oa.axisType = ea.axisType, oa.axisId = ea.axisId, oa.axisValue = getAxisRawValue(ta.axis, {
                  value: na
                }), oa.axisValueLabel = ra, oa.marker = Un.makeTooltipMarker("item", convertToColorString(oa.color), Nn);
                var la = normalizeTooltipFormatResult(Aa.formatTooltip(sa, !0, null)), ua = la.frag;
                if (ua) {
                  var ca = buildTooltipModel([Aa], Dn).get("valueFormatter");
                  aa.blocks.push(ca ? extend({
                    valueFormatter: ca
                  }, ua) : ua);
                }
                la.text && Pn.push(la.text), Rn.push(oa);
              }
            });
          }
        });
      }), Fn.blocks.reverse(), Pn.reverse();
      var Hn = Bn.position, zn = $n.get("order"), Gn = buildTooltipMarkup(Fn, Un, Nn, zn, In.get("useUTC"), $n.get("textStyle"));
      Gn && Pn.unshift(Gn);
      var Yn = Nn === "richText" ? `

` : "<br/>", Wn = Pn.join(Yn);
      this._showOrMove($n, function() {
        this._updateContentNotChangedOnAxis(Cn, Rn) ? this._updatePosition($n, Hn, Ln[0], Ln[1], this._tooltipContent, Rn) : this._showTooltipContent($n, Wn, Rn, Math.random() + "", Ln[0], Ln[1], Hn, null, Un);
      });
    }, nr.prototype._showSeriesItemTooltip = function(Cn, Bn, In) {
      var Dn = this._ecModel, Ln = getECData(Bn), $n = Ln.seriesIndex, Nn = Dn.getSeriesByIndex($n), Rn = Ln.dataModel || Nn, Fn = Ln.dataIndex, Pn = Ln.dataType, Un = Rn.getData(Pn), Hn = this._renderMode, zn = Cn.positionDefault, Gn = buildTooltipModel([Un.getItemModel(Fn), Rn, Nn && (Nn.coordinateSystem || {}).model], this._tooltipModel, zn ? {
        position: zn
      } : null), Yn = Gn.get("trigger");
      if (!(Yn != null && Yn !== "item")) {
        var Wn = Rn.getDataParams(Fn, Pn), Xn = new TooltipMarkupStyleCreator();
        Wn.marker = Xn.makeTooltipMarker("item", convertToColorString(Wn.color), Hn);
        var ea = normalizeTooltipFormatResult(Rn.formatTooltip(Fn, !1, Pn)), ta = Gn.get("order"), na = Gn.get("valueFormatter"), ra = ea.frag, aa = ra ? buildTooltipMarkup(na ? extend({
          valueFormatter: na
        }, ra) : ra, Xn, Hn, ta, Dn.get("useUTC"), Gn.get("textStyle")) : ea.text, ia = "item_" + Rn.name + "_" + Fn;
        this._showOrMove(Gn, function() {
          this._showTooltipContent(Gn, aa, Wn, ia, Cn.offsetX, Cn.offsetY, Cn.position, Cn.target, Xn);
        }), In({
          type: "showTip",
          dataIndexInside: Fn,
          dataIndex: Un.getRawIndex(Fn),
          seriesIndex: $n,
          from: this.uid
        });
      }
    }, nr.prototype._showComponentItemTooltip = function(Cn, Bn, In) {
      var Dn = this._renderMode === "html", Ln = getECData(Bn), $n = Ln.tooltipConfig, Nn = $n.option || {}, Rn = Nn.encodeHTMLContent;
      if (isString$1(Nn)) {
        var Fn = Nn;
        Nn = {
          content: Fn,
          // Fixed formatter
          formatter: Fn
        }, Rn = !0;
      }
      Rn && Dn && Nn.content && (Nn = clone$4(Nn), Nn.content = encodeHTML(Nn.content));
      var Pn = [Nn], Un = this._ecModel.getComponent(Ln.componentMainType, Ln.componentIndex);
      Un && Pn.push(Un), Pn.push({
        formatter: Nn.content
      });
      var Hn = Cn.positionDefault, zn = buildTooltipModel(Pn, this._tooltipModel, Hn ? {
        position: Hn
      } : null), Gn = zn.get("content"), Yn = Math.random() + "", Wn = new TooltipMarkupStyleCreator();
      this._showOrMove(zn, function() {
        var Xn = clone$4(zn.get("formatterParams") || {});
        this._showTooltipContent(zn, Gn, Xn, Yn, Cn.offsetX, Cn.offsetY, Cn.position, Bn, Wn);
      }), In({
        type: "showTip",
        from: this.uid
      });
    }, nr.prototype._showTooltipContent = function(Cn, Bn, In, Dn, Ln, $n, Nn, Rn, Fn) {
      if (this._ticket = "", !(!Cn.get("showContent") || !Cn.get("show"))) {
        var Pn = this._tooltipContent;
        Pn.setEnterable(Cn.get("enterable"));
        var Un = Cn.get("formatter");
        Nn = Nn || Cn.get("position");
        var Hn = Bn, zn = this._getNearestPoint([Ln, $n], In, Cn.get("trigger"), Cn.get("borderColor")), Gn = zn.color;
        if (Un)
          if (isString$1(Un)) {
            var Yn = Cn.ecModel.get("useUTC"), Wn = isArray$4(In) ? In[0] : In, Xn = Wn && Wn.axisType && Wn.axisType.indexOf("time") >= 0;
            Hn = Un, Xn && (Hn = format$1(Wn.axisValue, Hn, Yn)), Hn = formatTpl(Hn, In, !0);
          } else if (isFunction$1(Un)) {
            var ea = bind$1(function(ta, na) {
              ta === this._ticket && (Pn.setContent(na, Fn, Cn, Gn, Nn), this._updatePosition(Cn, Nn, Ln, $n, Pn, In, Rn));
            }, this);
            this._ticket = Dn, Hn = Un(In, Dn, ea);
          } else
            Hn = Un;
        Pn.setContent(Hn, Fn, Cn, Gn, Nn), Pn.show(Cn, Gn), this._updatePosition(Cn, Nn, Ln, $n, Pn, In, Rn);
      }
    }, nr.prototype._getNearestPoint = function(Cn, Bn, In, Dn) {
      if (In === "axis" || isArray$4(Bn))
        return {
          color: Dn || (this._renderMode === "html" ? "#fff" : "none")
        };
      if (!isArray$4(Bn))
        return {
          color: Dn || Bn.color || Bn.borderColor
        };
    }, nr.prototype._updatePosition = function(Cn, Bn, In, Dn, Ln, $n, Nn) {
      var Rn = this._api.getWidth(), Fn = this._api.getHeight();
      Bn = Bn || Cn.get("position");
      var Pn = Ln.getSize(), Un = Cn.get("align"), Hn = Cn.get("verticalAlign"), zn = Nn && Nn.getBoundingRect().clone();
      if (Nn && zn.applyTransform(Nn.transform), isFunction$1(Bn) && (Bn = Bn([In, Dn], $n, Ln.el, zn, {
        viewSize: [Rn, Fn],
        contentSize: Pn.slice()
      })), isArray$4(Bn))
        In = parsePercent(Bn[0], Rn), Dn = parsePercent(Bn[1], Fn);
      else if (isObject$6(Bn)) {
        var Gn = Bn;
        Gn.width = Pn[0], Gn.height = Pn[1];
        var Yn = getLayoutRect$1(Gn, {
          width: Rn,
          height: Fn
        });
        In = Yn.x, Dn = Yn.y, Un = null, Hn = null;
      } else if (isString$1(Bn) && Nn) {
        var Wn = calcTooltipPosition(Bn, zn, Pn, Cn.get("borderWidth"));
        In = Wn[0], Dn = Wn[1];
      } else {
        var Wn = refixTooltipPosition(In, Dn, Ln, Rn, Fn, Un ? null : 20, Hn ? null : 20);
        In = Wn[0], Dn = Wn[1];
      }
      if (Un && (In -= isCenterAlign(Un) ? Pn[0] / 2 : Un === "right" ? Pn[0] : 0), Hn && (Dn -= isCenterAlign(Hn) ? Pn[1] / 2 : Hn === "bottom" ? Pn[1] : 0), shouldTooltipConfine(Cn)) {
        var Wn = confineTooltipPosition(In, Dn, Ln, Rn, Fn);
        In = Wn[0], Dn = Wn[1];
      }
      Ln.moveTo(In, Dn);
    }, nr.prototype._updateContentNotChangedOnAxis = function(Cn, Bn) {
      var In = this._lastDataByCoordSys, Dn = this._cbParamsList, Ln = !!In && In.length === Cn.length;
      return Ln && each$f(In, function($n, Nn) {
        var Rn = $n.dataByAxis || [], Fn = Cn[Nn] || {}, Pn = Fn.dataByAxis || [];
        Ln = Ln && Rn.length === Pn.length, Ln && each$f(Rn, function(Un, Hn) {
          var zn = Pn[Hn] || {}, Gn = Un.seriesDataIndices || [], Yn = zn.seriesDataIndices || [];
          Ln = Ln && Un.value === zn.value && Un.axisType === zn.axisType && Un.axisId === zn.axisId && Gn.length === Yn.length, Ln && each$f(Gn, function(Wn, Xn) {
            var ea = Yn[Xn];
            Ln = Ln && Wn.seriesIndex === ea.seriesIndex && Wn.dataIndex === ea.dataIndex;
          }), Dn && each$f(Un.seriesDataIndices, function(Wn) {
            var Xn = Wn.seriesIndex, ea = Bn[Xn], ta = Dn[Xn];
            ea && ta && ta.data !== ea.data && (Ln = !1);
          });
        });
      }), this._lastDataByCoordSys = Cn, this._cbParamsList = Bn, !!Ln;
    }, nr.prototype._hide = function(Cn) {
      this._lastDataByCoordSys = null, Cn({
        type: "hideTip",
        from: this.uid
      });
    }, nr.prototype.dispose = function(Cn, Bn) {
      env$1.node || !Bn.getDom() || (clear$1(this, "_updatePosition"), this._tooltipContent.dispose(), unregister("itemTooltip", Bn));
    }, nr.type = "tooltip", nr;
  }(ComponentView$1)
);
function buildTooltipModel(_n, nr, Cn) {
  var Bn = nr.ecModel, In;
  Cn ? (In = new Model$1(Cn, Bn, Bn), In = new Model$1(nr.option, In, Bn)) : In = nr;
  for (var Dn = _n.length - 1; Dn >= 0; Dn--) {
    var Ln = _n[Dn];
    Ln && (Ln instanceof Model$1 && (Ln = Ln.get("tooltip", !0)), isString$1(Ln) && (Ln = {
      formatter: Ln
    }), Ln && (In = new Model$1(Ln, In, Bn)));
  }
  return In;
}
function makeDispatchAction(_n, nr) {
  return _n.dispatchAction || bind$1(nr.dispatchAction, nr);
}
function refixTooltipPosition(_n, nr, Cn, Bn, In, Dn, Ln) {
  var $n = Cn.getSize(), Nn = $n[0], Rn = $n[1];
  return Dn != null && (_n + Nn + Dn + 2 > Bn ? _n -= Nn + Dn : _n += Dn), Ln != null && (nr + Rn + Ln > In ? nr -= Rn + Ln : nr += Ln), [_n, nr];
}
function confineTooltipPosition(_n, nr, Cn, Bn, In) {
  var Dn = Cn.getSize(), Ln = Dn[0], $n = Dn[1];
  return _n = Math.min(_n + Ln, Bn) - Ln, nr = Math.min(nr + $n, In) - $n, _n = Math.max(_n, 0), nr = Math.max(nr, 0), [_n, nr];
}
function calcTooltipPosition(_n, nr, Cn, Bn) {
  var In = Cn[0], Dn = Cn[1], Ln = Math.ceil(Math.SQRT2 * Bn) + 8, $n = 0, Nn = 0, Rn = nr.width, Fn = nr.height;
  switch (_n) {
    case "inside":
      $n = nr.x + Rn / 2 - In / 2, Nn = nr.y + Fn / 2 - Dn / 2;
      break;
    case "top":
      $n = nr.x + Rn / 2 - In / 2, Nn = nr.y - Dn - Ln;
      break;
    case "bottom":
      $n = nr.x + Rn / 2 - In / 2, Nn = nr.y + Fn + Ln;
      break;
    case "left":
      $n = nr.x - In - Ln, Nn = nr.y + Fn / 2 - Dn / 2;
      break;
    case "right":
      $n = nr.x + Rn + Ln, Nn = nr.y + Fn / 2 - Dn / 2;
  }
  return [$n, Nn];
}
function isCenterAlign(_n) {
  return _n === "center" || _n === "middle";
}
function findComponentReference(_n, nr, Cn) {
  var Bn = preParseFinder(_n).queryOptionMap, In = Bn.keys()[0];
  if (!(!In || In === "series")) {
    var Dn = queryReferringComponents(nr, In, Bn.get(In), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), Ln = Dn.models[0];
    if (Ln) {
      var $n = Cn.getViewOfComponentModel(Ln), Nn;
      if ($n.group.traverse(function(Rn) {
        var Fn = getECData(Rn).tooltipConfig;
        if (Fn && Fn.name === _n.name)
          return Nn = Rn, !0;
      }), Nn)
        return {
          componentMainType: In,
          componentIndex: Ln.componentIndex,
          el: Nn
        };
    }
  }
}
const TooltipView$1 = TooltipView;
function install$i(_n) {
  use(install$q), _n.registerComponentModel(TooltipModel$1), _n.registerComponentView(TooltipView$1), _n.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, noop$1), _n.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, noop$1);
}
var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
function brushPreprocessor(_n, nr) {
  var Cn = normalizeToArray(_n ? _n.brush : []);
  if (Cn.length) {
    var Bn = [];
    each$f(Cn, function(Nn) {
      var Rn = Nn.hasOwnProperty("toolbox") ? Nn.toolbox : [];
      Rn instanceof Array && (Bn = Bn.concat(Rn));
    });
    var In = _n && _n.toolbox;
    isArray$4(In) && (In = In[0]), In || (In = {
      feature: {}
    }, _n.toolbox = [In]);
    var Dn = In.feature || (In.feature = {}), Ln = Dn.brush || (Dn.brush = {}), $n = Ln.type || (Ln.type = []);
    $n.push.apply($n, Bn), removeDuplicate($n), nr && !$n.length && $n.push.apply($n, DEFAULT_TOOLBOX_BTNS);
  }
}
function removeDuplicate(_n) {
  var nr = {};
  each$f(_n, function(Cn) {
    nr[Cn] = 1;
  }), _n.length = 0, each$f(nr, function(Cn, Bn) {
    _n.push(Bn);
  });
}
var each$4 = each$f;
function hasKeys(_n) {
  if (_n) {
    for (var nr in _n)
      if (_n.hasOwnProperty(nr))
        return !0;
  }
}
function createVisualMappings(_n, nr, Cn) {
  var Bn = {};
  return each$4(nr, function(Dn) {
    var Ln = Bn[Dn] = In();
    each$4(_n[Dn], function($n, Nn) {
      if (VisualMapping$1.isValidType(Nn)) {
        var Rn = {
          type: Nn,
          visual: $n
        };
        Cn && Cn(Rn, Dn), Ln[Nn] = new VisualMapping$1(Rn), Nn === "opacity" && (Rn = clone$4(Rn), Rn.type = "colorAlpha", Ln.__hidden.__alphaForOpacity = new VisualMapping$1(Rn));
      }
    });
  }), Bn;
  function In() {
    var Dn = function() {
    };
    Dn.prototype.__hidden = Dn.prototype;
    var Ln = new Dn();
    return Ln;
  }
}
function replaceVisualOption(_n, nr, Cn) {
  var Bn;
  each$f(Cn, function(In) {
    nr.hasOwnProperty(In) && hasKeys(nr[In]) && (Bn = !0);
  }), Bn && each$f(Cn, function(In) {
    nr.hasOwnProperty(In) && hasKeys(nr[In]) ? _n[In] = clone$4(nr[In]) : delete _n[In];
  });
}
function applyVisual(_n, nr, Cn, Bn, In, Dn) {
  var Ln = {};
  each$f(_n, function(Pn) {
    var Un = VisualMapping$1.prepareVisualTypes(nr[Pn]);
    Ln[Pn] = Un;
  });
  var $n;
  function Nn(Pn) {
    return getItemVisualFromData(Cn, $n, Pn);
  }
  function Rn(Pn, Un) {
    setItemVisualFromData(Cn, $n, Pn, Un);
  }
  Dn == null ? Cn.each(Fn) : Cn.each([Dn], Fn);
  function Fn(Pn, Un) {
    $n = Dn == null ? Pn : Un;
    var Hn = Cn.getRawDataItem($n);
    if (!(Hn && Hn.visualMap === !1))
      for (var zn = Bn.call(In, Pn), Gn = nr[zn], Yn = Ln[zn], Wn = 0, Xn = Yn.length; Wn < Xn; Wn++) {
        var ea = Yn[Wn];
        Gn[ea] && Gn[ea].applyVisual(Pn, Nn, Rn);
      }
  }
}
function incrementalApplyVisual(_n, nr, Cn, Bn) {
  var In = {};
  return each$f(_n, function(Dn) {
    var Ln = VisualMapping$1.prepareVisualTypes(nr[Dn]);
    In[Dn] = Ln;
  }), {
    progress: function(Ln, $n) {
      var Nn;
      Bn != null && (Nn = $n.getDimensionIndex(Bn));
      function Rn(na) {
        return getItemVisualFromData($n, Pn, na);
      }
      function Fn(na, ra) {
        setItemVisualFromData($n, Pn, na, ra);
      }
      for (var Pn, Un = $n.getStore(); (Pn = Ln.next()) != null; ) {
        var Hn = $n.getRawDataItem(Pn);
        if (!(Hn && Hn.visualMap === !1))
          for (var zn = Bn != null ? Un.get(Nn, Pn) : Pn, Gn = Cn(zn), Yn = nr[Gn], Wn = In[Gn], Xn = 0, ea = Wn.length; Xn < ea; Xn++) {
            var ta = Wn[Xn];
            Yn[ta] && Yn[ta].applyVisual(zn, Rn, Fn);
          }
      }
    }
  };
}
function makeBrushCommonSelectorForSeries(_n) {
  var nr = _n.brushType, Cn = {
    point: function(Bn) {
      return selector[nr].point(Bn, Cn, _n);
    },
    rect: function(Bn) {
      return selector[nr].rect(Bn, Cn, _n);
    }
  };
  return Cn;
}
var selector = {
  lineX: getLineSelectors(0),
  lineY: getLineSelectors(1),
  rect: {
    point: function(_n, nr, Cn) {
      return _n && Cn.boundingRect.contain(_n[0], _n[1]);
    },
    rect: function(_n, nr, Cn) {
      return _n && Cn.boundingRect.intersect(_n);
    }
  },
  polygon: {
    point: function(_n, nr, Cn) {
      return _n && Cn.boundingRect.contain(_n[0], _n[1]) && contain(Cn.range, _n[0], _n[1]);
    },
    rect: function(_n, nr, Cn) {
      var Bn = Cn.range;
      if (!_n || Bn.length <= 1)
        return !1;
      var In = _n.x, Dn = _n.y, Ln = _n.width, $n = _n.height, Nn = Bn[0];
      if (contain(Bn, In, Dn) || contain(Bn, In + Ln, Dn) || contain(Bn, In, Dn + $n) || contain(Bn, In + Ln, Dn + $n) || BoundingRect$1.create(_n).contain(Nn[0], Nn[1]) || linePolygonIntersect(In, Dn, In + Ln, Dn, Bn) || linePolygonIntersect(In, Dn, In, Dn + $n, Bn) || linePolygonIntersect(In + Ln, Dn, In + Ln, Dn + $n, Bn) || linePolygonIntersect(In, Dn + $n, In + Ln, Dn + $n, Bn))
        return !0;
    }
  }
};
function getLineSelectors(_n) {
  var nr = ["x", "y"], Cn = ["width", "height"];
  return {
    point: function(Bn, In, Dn) {
      if (Bn) {
        var Ln = Dn.range, $n = Bn[_n];
        return inLineRange($n, Ln);
      }
    },
    rect: function(Bn, In, Dn) {
      if (Bn) {
        var Ln = Dn.range, $n = [Bn[nr[_n]], Bn[nr[_n]] + Bn[Cn[_n]]];
        return $n[1] < $n[0] && $n.reverse(), inLineRange($n[0], Ln) || inLineRange($n[1], Ln) || inLineRange(Ln[0], $n) || inLineRange(Ln[1], $n);
      }
    }
  };
}
function inLineRange(_n, nr) {
  return nr[0] <= _n && _n <= nr[1];
}
var STATE_LIST = ["inBrush", "outOfBrush"], DISPATCH_METHOD = "__ecBrushSelect", DISPATCH_FLAG = "__ecInBrushSelectEvent";
function layoutCovers(_n) {
  _n.eachComponent({
    mainType: "brush"
  }, function(nr) {
    var Cn = nr.brushTargetManager = new BrushTargetManager$1(nr.option, _n);
    Cn.setInputRanges(nr.areas, _n);
  });
}
function brushVisual(_n, nr, Cn) {
  var Bn = [], In, Dn;
  _n.eachComponent({
    mainType: "brush"
  }, function(Ln) {
    Cn && Cn.type === "takeGlobalCursor" && Ln.setBrushOption(Cn.key === "brush" ? Cn.brushOption : {
      brushType: !1
    });
  }), layoutCovers(_n), _n.eachComponent({
    mainType: "brush"
  }, function(Ln, $n) {
    var Nn = {
      brushId: Ln.id,
      brushIndex: $n,
      brushName: Ln.name,
      areas: clone$4(Ln.areas),
      selected: []
    };
    Bn.push(Nn);
    var Rn = Ln.option, Fn = Rn.brushLink, Pn = [], Un = [], Hn = [], zn = !1;
    $n || (In = Rn.throttleType, Dn = Rn.throttleDelay);
    var Gn = map$1(Ln.areas, function(na) {
      var ra = boundingRectBuilders[na.brushType], aa = defaults({
        boundingRect: ra ? ra(na) : void 0
      }, na);
      return aa.selectors = makeBrushCommonSelectorForSeries(aa), aa;
    }), Yn = createVisualMappings(Ln.option, STATE_LIST, function(na) {
      na.mappingMethod = "fixed";
    });
    isArray$4(Fn) && each$f(Fn, function(na) {
      Pn[na] = 1;
    });
    function Wn(na) {
      return Fn === "all" || !!Pn[na];
    }
    function Xn(na) {
      return !!na.length;
    }
    _n.eachSeries(function(na, ra) {
      var aa = Hn[ra] = [];
      na.subType === "parallel" ? ea(na, ra) : ta(na, ra, aa);
    });
    function ea(na, ra) {
      var aa = na.coordinateSystem;
      zn = zn || aa.hasAxisBrushed(), Wn(ra) && aa.eachActiveState(na.getData(), function(ia, Aa) {
        ia === "active" && (Un[Aa] = 1);
      });
    }
    function ta(na, ra, aa) {
      if (!(!na.brushSelector || brushModelNotControll(Ln, ra)) && (each$f(Gn, function(Aa) {
        Ln.brushTargetManager.controlSeries(Aa, na, _n) && aa.push(Aa), zn = zn || Xn(aa);
      }), Wn(ra) && Xn(aa))) {
        var ia = na.getData();
        ia.each(function(Aa) {
          checkInRange(na, aa, ia, Aa) && (Un[Aa] = 1);
        });
      }
    }
    _n.eachSeries(function(na, ra) {
      var aa = {
        seriesId: na.id,
        seriesIndex: ra,
        seriesName: na.name,
        dataIndex: []
      };
      Nn.selected.push(aa);
      var ia = Hn[ra], Aa = na.getData(), sa = Wn(ra) ? function(oa) {
        return Un[oa] ? (aa.dataIndex.push(Aa.getRawIndex(oa)), "inBrush") : "outOfBrush";
      } : function(oa) {
        return checkInRange(na, ia, Aa, oa) ? (aa.dataIndex.push(Aa.getRawIndex(oa)), "inBrush") : "outOfBrush";
      };
      (Wn(ra) ? zn : Xn(ia)) && applyVisual(STATE_LIST, Yn, Aa, sa);
    });
  }), dispatchAction$1(nr, In, Dn, Bn, Cn);
}
function dispatchAction$1(_n, nr, Cn, Bn, In) {
  if (In) {
    var Dn = _n.getZr();
    if (!Dn[DISPATCH_FLAG]) {
      Dn[DISPATCH_METHOD] || (Dn[DISPATCH_METHOD] = doDispatch);
      var Ln = createOrUpdate(Dn, DISPATCH_METHOD, Cn, nr);
      Ln(_n, Bn);
    }
  }
}
function doDispatch(_n, nr) {
  if (!_n.isDisposed()) {
    var Cn = _n.getZr();
    Cn[DISPATCH_FLAG] = !0, _n.dispatchAction({
      type: "brushSelect",
      batch: nr
    }), Cn[DISPATCH_FLAG] = !1;
  }
}
function checkInRange(_n, nr, Cn, Bn) {
  for (var In = 0, Dn = nr.length; In < Dn; In++) {
    var Ln = nr[In];
    if (_n.brushSelector(Bn, Cn, Ln.selectors, Ln))
      return !0;
  }
}
function brushModelNotControll(_n, nr) {
  var Cn = _n.option.seriesIndex;
  return Cn != null && Cn !== "all" && (isArray$4(Cn) ? indexOf(Cn, nr) < 0 : nr !== Cn);
}
var boundingRectBuilders = {
  rect: function(_n) {
    return getBoundingRectFromMinMax(_n.range);
  },
  polygon: function(_n) {
    for (var nr, Cn = _n.range, Bn = 0, In = Cn.length; Bn < In; Bn++) {
      nr = nr || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var Dn = Cn[Bn];
      Dn[0] < nr[0][0] && (nr[0][0] = Dn[0]), Dn[0] > nr[0][1] && (nr[0][1] = Dn[0]), Dn[1] < nr[1][0] && (nr[1][0] = Dn[1]), Dn[1] > nr[1][1] && (nr[1][1] = Dn[1]);
    }
    return nr && getBoundingRectFromMinMax(nr);
  }
};
function getBoundingRectFromMinMax(_n) {
  return new BoundingRect$1(_n[0][0], _n[1][0], _n[0][1] - _n[0][0], _n[1][1] - _n[1][0]);
}
var BrushView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      this.ecModel = Cn, this.api = Bn, this.model, (this._brushController = new BrushController$1(Bn.getZr())).on("brush", bind$1(this._onBrush, this)).mount();
    }, nr.prototype.render = function(Cn, Bn, In, Dn) {
      this.model = Cn, this._updateController(Cn, Bn, In, Dn);
    }, nr.prototype.updateTransform = function(Cn, Bn, In, Dn) {
      layoutCovers(Bn), this._updateController(Cn, Bn, In, Dn);
    }, nr.prototype.updateVisual = function(Cn, Bn, In, Dn) {
      this.updateTransform(Cn, Bn, In, Dn);
    }, nr.prototype.updateView = function(Cn, Bn, In, Dn) {
      this._updateController(Cn, Bn, In, Dn);
    }, nr.prototype._updateController = function(Cn, Bn, In, Dn) {
      (!Dn || Dn.$from !== Cn.id) && this._brushController.setPanels(Cn.brushTargetManager.makePanelOpts(In)).enableBrush(Cn.brushOption).updateCovers(Cn.areas.slice());
    }, nr.prototype.dispose = function() {
      this._brushController.dispose();
    }, nr.prototype._onBrush = function(Cn) {
      var Bn = this.model.id, In = this.model.brushTargetManager.setOutputRanges(Cn.areas, this.ecModel);
      (!Cn.isEnd || Cn.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: Bn,
        areas: clone$4(In),
        $from: Bn
      }), Cn.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: Bn,
        areas: clone$4(In),
        $from: Bn
      });
    }, nr.type = "brush", nr;
  }(ComponentView$1)
);
const BrushView$1 = BrushView;
var DEFAULT_OUT_OF_BRUSH_COLOR = "#ddd", BrushModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.areas = [], Cn.brushOption = {}, Cn;
    }
    return nr.prototype.optionUpdated = function(Cn, Bn) {
      var In = this.option;
      !Bn && replaceVisualOption(In, Cn, ["inBrush", "outOfBrush"]);
      var Dn = In.inBrush = In.inBrush || {};
      In.outOfBrush = In.outOfBrush || {
        color: DEFAULT_OUT_OF_BRUSH_COLOR
      }, Dn.hasOwnProperty("liftZ") || (Dn.liftZ = 5);
    }, nr.prototype.setAreas = function(Cn) {
      process.env.NODE_ENV !== "production" && (assert(isArray$4(Cn)), each$f(Cn, function(Bn) {
        assert(Bn.brushType, "Illegal areas");
      })), Cn && (this.areas = map$1(Cn, function(Bn) {
        return generateBrushOption(this.option, Bn);
      }, this));
    }, nr.prototype.setBrushOption = function(Cn) {
      this.brushOption = generateBrushOption(this.option, Cn), this.brushType = this.brushOption.brushType;
    }, nr.type = "brush", nr.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], nr.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4
    }, nr;
  }(ComponentModel$1)
);
function generateBrushOption(_n, nr) {
  return merge$1({
    brushType: _n.brushType,
    brushMode: _n.brushMode,
    transformable: _n.transformable,
    brushStyle: new Model$1(_n.brushStyle).getItemStyle(),
    removeOnClick: _n.removeOnClick,
    z: _n.z
  }, nr, !0);
}
const BrushModel$1 = BrushModel;
var ICON_TYPES = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], BrushFeature = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      return _n !== null && _n.apply(this, arguments) || this;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      var Dn, Ln, $n;
      Bn.eachComponent({
        mainType: "brush"
      }, function(Nn) {
        Dn = Nn.brushType, Ln = Nn.brushOption.brushMode || "single", $n = $n || !!Nn.areas.length;
      }), this._brushType = Dn, this._brushMode = Ln, each$f(Cn.get("type", !0), function(Nn) {
        Cn.setIconStatus(Nn, (Nn === "keep" ? Ln === "multiple" : Nn === "clear" ? $n : Nn === Dn) ? "emphasis" : "normal");
      });
    }, nr.prototype.updateView = function(Cn, Bn, In) {
      this.render(Cn, Bn, In);
    }, nr.prototype.getIcons = function() {
      var Cn = this.model, Bn = Cn.get("icon", !0), In = {};
      return each$f(Cn.get("type", !0), function(Dn) {
        Bn[Dn] && (In[Dn] = Bn[Dn]);
      }), In;
    }, nr.prototype.onclick = function(Cn, Bn, In) {
      var Dn = this._brushType, Ln = this._brushMode;
      In === "clear" ? (Bn.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), Bn.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : Bn.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: In === "keep" ? Dn : Dn === In ? !1 : In,
          brushMode: In === "keep" ? Ln === "multiple" ? "single" : "multiple" : Ln
        }
      });
    }, nr.getDefaultOption = function(Cn) {
      var Bn = {
        show: !0,
        type: ICON_TYPES.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: Cn.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return Bn;
    }, nr;
  }(ToolboxFeature)
);
const BrushFeature$1 = BrushFeature;
function install$h(_n) {
  _n.registerComponentView(BrushView$1), _n.registerComponentModel(BrushModel$1), _n.registerPreprocessor(brushPreprocessor), _n.registerVisual(_n.PRIORITY.VISUAL.BRUSH, brushVisual), _n.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(nr, Cn) {
    Cn.eachComponent({
      mainType: "brush",
      query: nr
    }, function(Bn) {
      Bn.setAreas(nr.areas);
    });
  }), _n.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, noop$1), _n.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, noop$1), registerFeature("brush", BrushFeature$1);
}
var TitleModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, Cn;
    }
    return nr.type = "title", nr.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, nr;
  }(ComponentModel$1)
), TitleView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      if (this.group.removeAll(), !!Cn.get("show")) {
        var Dn = this.group, Ln = Cn.getModel("textStyle"), $n = Cn.getModel("subtextStyle"), Nn = Cn.get("textAlign"), Rn = retrieve2(Cn.get("textBaseline"), Cn.get("textVerticalAlign")), Fn = new ZRText$1({
          style: createTextStyle$1(Ln, {
            text: Cn.get("text"),
            fill: Ln.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), Pn = Fn.getBoundingRect(), Un = Cn.get("subtext"), Hn = new ZRText$1({
          style: createTextStyle$1($n, {
            text: Un,
            fill: $n.getTextColor(),
            y: Pn.height + Cn.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), zn = Cn.get("link"), Gn = Cn.get("sublink"), Yn = Cn.get("triggerEvent", !0);
        Fn.silent = !zn && !Yn, Hn.silent = !Gn && !Yn, zn && Fn.on("click", function() {
          windowOpen(zn, "_" + Cn.get("target"));
        }), Gn && Hn.on("click", function() {
          windowOpen(Gn, "_" + Cn.get("subtarget"));
        }), getECData(Fn).eventData = getECData(Hn).eventData = Yn ? {
          componentType: "title",
          componentIndex: Cn.componentIndex
        } : null, Dn.add(Fn), Un && Dn.add(Hn);
        var Wn = Dn.getBoundingRect(), Xn = Cn.getBoxLayoutParams();
        Xn.width = Wn.width, Xn.height = Wn.height;
        var ea = getLayoutRect$1(Xn, {
          width: In.getWidth(),
          height: In.getHeight()
        }, Cn.get("padding"));
        Nn || (Nn = Cn.get("left") || Cn.get("right"), Nn === "middle" && (Nn = "center"), Nn === "right" ? ea.x += ea.width : Nn === "center" && (ea.x += ea.width / 2)), Rn || (Rn = Cn.get("top") || Cn.get("bottom"), Rn === "center" && (Rn = "middle"), Rn === "bottom" ? ea.y += ea.height : Rn === "middle" && (ea.y += ea.height / 2), Rn = Rn || "top"), Dn.x = ea.x, Dn.y = ea.y, Dn.markRedraw();
        var ta = {
          align: Nn,
          verticalAlign: Rn
        };
        Fn.setStyle(ta), Hn.setStyle(ta), Wn = Dn.getBoundingRect();
        var na = ea.margin, ra = Cn.getItemStyle(["color", "opacity"]);
        ra.fill = Cn.get("backgroundColor");
        var aa = new Rect$3({
          shape: {
            x: Wn.x - na[3],
            y: Wn.y - na[0],
            width: Wn.width + na[1] + na[3],
            height: Wn.height + na[0] + na[2],
            r: Cn.get("borderRadius")
          },
          style: ra,
          subPixelOptimize: !0,
          silent: !0
        });
        Dn.add(aa);
      }
    }, nr.type = "title", nr;
  }(ComponentView$1)
);
function install$g(_n) {
  _n.registerComponentModel(TitleModel), _n.registerComponentView(TitleView);
}
var TimelineModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.layoutMode = "box", Cn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      this.mergeDefaultAndTheme(Cn, In), this._initData();
    }, nr.prototype.mergeOption = function(Cn) {
      _n.prototype.mergeOption.apply(this, arguments), this._initData();
    }, nr.prototype.setCurrentIndex = function(Cn) {
      Cn == null && (Cn = this.option.currentIndex);
      var Bn = this._data.count();
      this.option.loop ? Cn = (Cn % Bn + Bn) % Bn : (Cn >= Bn && (Cn = Bn - 1), Cn < 0 && (Cn = 0)), this.option.currentIndex = Cn;
    }, nr.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, nr.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, nr.prototype.setPlayState = function(Cn) {
      this.option.autoPlay = !!Cn;
    }, nr.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, nr.prototype._initData = function() {
      var Cn = this.option, Bn = Cn.data || [], In = Cn.axisType, Dn = this._names = [], Ln;
      In === "category" ? (Ln = [], each$f(Bn, function(Rn, Fn) {
        var Pn = convertOptionIdName(getDataItemValue(Rn), ""), Un;
        isObject$6(Rn) ? (Un = clone$4(Rn), Un.value = Fn) : Un = Fn, Ln.push(Un), Dn.push(Pn);
      })) : Ln = Bn;
      var $n = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[In] || "number", Nn = this._data = new SeriesData$1([{
        name: "value",
        type: $n
      }], this);
      Nn.initData(Ln, Dn);
    }, nr.prototype.getData = function() {
      return this._data;
    }, nr.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, nr.type = "timeline", nr.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, nr;
  }(ComponentModel$1)
);
const TimelineModel$1 = TimelineModel;
var SliderTimelineModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "timeline.slider", nr.defaultOption = inheritDefaultOption(TimelineModel$1.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        // eslint-disable-next-line max-len
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        // eslint-disable-next-line max-len
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), nr;
  }(TimelineModel$1)
);
mixin(SliderTimelineModel, DataFormatMixin.prototype);
const SliderTimelineModel$1 = SliderTimelineModel;
var TimelineView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "timeline", nr;
  }(ComponentView$1)
);
const TimelineView$1 = TimelineView;
var TimelineAxis = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr(Cn, Bn, In, Dn) {
      var Ln = _n.call(this, Cn, Bn, In) || this;
      return Ln.type = Dn || "value", Ln;
    }
    return nr.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, nr.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, nr;
  }(Axis$1)
);
const TimelineAxis$1 = TimelineAxis;
var PI = Math.PI, labelDataIndexStore = makeInner(), SliderTimelineView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      this.api = Bn;
    }, nr.prototype.render = function(Cn, Bn, In) {
      if (this.model = Cn, this.api = In, this.ecModel = Bn, this.group.removeAll(), Cn.get("show", !0)) {
        var Dn = this._layout(Cn, In), Ln = this._createGroup("_mainGroup"), $n = this._createGroup("_labelGroup"), Nn = this._axis = this._createAxis(Dn, Cn);
        Cn.formatTooltip = function(Rn) {
          var Fn = Nn.scale.getLabel({
            value: Rn
          });
          return createTooltipMarkup("nameValue", {
            noName: !0,
            value: Fn
          });
        }, each$f(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(Rn) {
          this["_render" + Rn](Dn, Ln, Nn, Cn);
        }, this), this._renderAxisLabel(Dn, $n, Nn, Cn), this._position(Dn, Cn);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, nr.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, nr.prototype.dispose = function() {
      this._clearTimer();
    }, nr.prototype._layout = function(Cn, Bn) {
      var In = Cn.get(["label", "position"]), Dn = Cn.get("orient"), Ln = getViewRect(Cn, Bn), $n;
      In == null || In === "auto" ? $n = Dn === "horizontal" ? Ln.y + Ln.height / 2 < Bn.getHeight() / 2 ? "-" : "+" : Ln.x + Ln.width / 2 < Bn.getWidth() / 2 ? "+" : "-" : isString$1(In) ? $n = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[Dn][In] : $n = In;
      var Nn = {
        horizontal: "center",
        vertical: $n >= 0 || $n === "+" ? "left" : "right"
      }, Rn = {
        horizontal: $n >= 0 || $n === "+" ? "top" : "bottom",
        vertical: "middle"
      }, Fn = {
        horizontal: 0,
        vertical: PI / 2
      }, Pn = Dn === "vertical" ? Ln.height : Ln.width, Un = Cn.getModel("controlStyle"), Hn = Un.get("show", !0), zn = Hn ? Un.get("itemSize") : 0, Gn = Hn ? Un.get("itemGap") : 0, Yn = zn + Gn, Wn = Cn.get(["label", "rotate"]) || 0;
      Wn = Wn * PI / 180;
      var Xn, ea, ta, na = Un.get("position", !0), ra = Hn && Un.get("showPlayBtn", !0), aa = Hn && Un.get("showPrevBtn", !0), ia = Hn && Un.get("showNextBtn", !0), Aa = 0, sa = Pn;
      na === "left" || na === "bottom" ? (ra && (Xn = [0, 0], Aa += Yn), aa && (ea = [Aa, 0], Aa += Yn), ia && (ta = [sa - zn, 0], sa -= Yn)) : (ra && (Xn = [sa - zn, 0], sa -= Yn), aa && (ea = [0, 0], Aa += Yn), ia && (ta = [sa - zn, 0], sa -= Yn));
      var oa = [Aa, sa];
      return Cn.get("inverse") && oa.reverse(), {
        viewRect: Ln,
        mainLength: Pn,
        orient: Dn,
        rotation: Fn[Dn],
        labelRotation: Wn,
        labelPosOpt: $n,
        labelAlign: Cn.get(["label", "align"]) || Nn[Dn],
        labelBaseline: Cn.get(["label", "verticalAlign"]) || Cn.get(["label", "baseline"]) || Rn[Dn],
        // Based on mainGroup.
        playPosition: Xn,
        prevBtnPosition: ea,
        nextBtnPosition: ta,
        axisExtent: oa,
        controlSize: zn,
        controlGap: Gn
      };
    }, nr.prototype._position = function(Cn, Bn) {
      var In = this._mainGroup, Dn = this._labelGroup, Ln = Cn.viewRect;
      if (Cn.orient === "vertical") {
        var $n = create$1(), Nn = Ln.x, Rn = Ln.y + Ln.height;
        translate($n, $n, [-Nn, -Rn]), rotate($n, $n, -PI / 2), translate($n, $n, [Nn, Rn]), Ln = Ln.clone(), Ln.applyTransform($n);
      }
      var Fn = Xn(Ln), Pn = Xn(In.getBoundingRect()), Un = Xn(Dn.getBoundingRect()), Hn = [In.x, In.y], zn = [Dn.x, Dn.y];
      zn[0] = Hn[0] = Fn[0][0];
      var Gn = Cn.labelPosOpt;
      if (Gn == null || isString$1(Gn)) {
        var Yn = Gn === "+" ? 0 : 1;
        ea(Hn, Pn, Fn, 1, Yn), ea(zn, Un, Fn, 1, 1 - Yn);
      } else {
        var Yn = Gn >= 0 ? 0 : 1;
        ea(Hn, Pn, Fn, 1, Yn), zn[1] = Hn[1] + Gn;
      }
      In.setPosition(Hn), Dn.setPosition(zn), In.rotation = Dn.rotation = Cn.rotation, Wn(In), Wn(Dn);
      function Wn(ta) {
        ta.originX = Fn[0][0] - ta.x, ta.originY = Fn[1][0] - ta.y;
      }
      function Xn(ta) {
        return [[ta.x, ta.x + ta.width], [ta.y, ta.y + ta.height]];
      }
      function ea(ta, na, ra, aa, ia) {
        ta[aa] += ra[aa][ia] - na[aa][ia];
      }
    }, nr.prototype._createAxis = function(Cn, Bn) {
      var In = Bn.getData(), Dn = Bn.get("axisType"), Ln = createScaleByModel(Bn, Dn);
      Ln.getTicks = function() {
        return In.mapArray(["value"], function(Rn) {
          return {
            value: Rn
          };
        });
      };
      var $n = In.getDataExtent("value");
      Ln.setExtent($n[0], $n[1]), Ln.calcNiceTicks();
      var Nn = new TimelineAxis$1("value", Ln, Cn.axisExtent, Dn);
      return Nn.model = Bn, Nn;
    }, nr.prototype._createGroup = function(Cn) {
      var Bn = this[Cn] = new Group$4();
      return this.group.add(Bn), Bn;
    }, nr.prototype._renderAxisLine = function(Cn, Bn, In, Dn) {
      var Ln = In.getExtent();
      if (Dn.get(["lineStyle", "show"])) {
        var $n = new Line$3({
          shape: {
            x1: Ln[0],
            y1: 0,
            x2: Ln[1],
            y2: 0
          },
          style: extend({
            lineCap: "round"
          }, Dn.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        Bn.add($n);
        var Nn = this._progressLine = new Line$3({
          shape: {
            x1: Ln[0],
            x2: this._currentPointer ? this._currentPointer.x : Ln[0],
            y1: 0,
            y2: 0
          },
          style: defaults({
            lineCap: "round",
            lineWidth: $n.style.lineWidth
          }, Dn.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        Bn.add(Nn);
      }
    }, nr.prototype._renderAxisTick = function(Cn, Bn, In, Dn) {
      var Ln = this, $n = Dn.getData(), Nn = In.scale.getTicks();
      this._tickSymbols = [], each$f(Nn, function(Rn) {
        var Fn = In.dataToCoord(Rn.value), Pn = $n.getItemModel(Rn.value), Un = Pn.getModel("itemStyle"), Hn = Pn.getModel(["emphasis", "itemStyle"]), zn = Pn.getModel(["progress", "itemStyle"]), Gn = {
          x: Fn,
          y: 0,
          onclick: bind$1(Ln._changeTimeline, Ln, Rn.value)
        }, Yn = giveSymbol(Pn, Un, Bn, Gn);
        Yn.ensureState("emphasis").style = Hn.getItemStyle(), Yn.ensureState("progress").style = zn.getItemStyle(), enableHoverEmphasis(Yn);
        var Wn = getECData(Yn);
        Pn.get("tooltip") ? (Wn.dataIndex = Rn.value, Wn.dataModel = Dn) : Wn.dataIndex = Wn.dataModel = null, Ln._tickSymbols.push(Yn);
      });
    }, nr.prototype._renderAxisLabel = function(Cn, Bn, In, Dn) {
      var Ln = this, $n = In.getLabelModel();
      if ($n.get("show")) {
        var Nn = Dn.getData(), Rn = In.getViewLabels();
        this._tickLabels = [], each$f(Rn, function(Fn) {
          var Pn = Fn.tickValue, Un = Nn.getItemModel(Pn), Hn = Un.getModel("label"), zn = Un.getModel(["emphasis", "label"]), Gn = Un.getModel(["progress", "label"]), Yn = In.dataToCoord(Fn.tickValue), Wn = new ZRText$1({
            x: Yn,
            y: 0,
            rotation: Cn.labelRotation - Cn.rotation,
            onclick: bind$1(Ln._changeTimeline, Ln, Pn),
            silent: !1,
            style: createTextStyle$1(Hn, {
              text: Fn.formattedLabel,
              align: Cn.labelAlign,
              verticalAlign: Cn.labelBaseline
            })
          });
          Wn.ensureState("emphasis").style = createTextStyle$1(zn), Wn.ensureState("progress").style = createTextStyle$1(Gn), Bn.add(Wn), enableHoverEmphasis(Wn), labelDataIndexStore(Wn).dataIndex = Pn, Ln._tickLabels.push(Wn);
        });
      }
    }, nr.prototype._renderControl = function(Cn, Bn, In, Dn) {
      var Ln = Cn.controlSize, $n = Cn.rotation, Nn = Dn.getModel("controlStyle").getItemStyle(), Rn = Dn.getModel(["emphasis", "controlStyle"]).getItemStyle(), Fn = Dn.getPlayState(), Pn = Dn.get("inverse", !0);
      Un(Cn.nextBtnPosition, "next", bind$1(this._changeTimeline, this, Pn ? "-" : "+")), Un(Cn.prevBtnPosition, "prev", bind$1(this._changeTimeline, this, Pn ? "+" : "-")), Un(Cn.playPosition, Fn ? "stop" : "play", bind$1(this._handlePlayClick, this, !Fn), !0);
      function Un(Hn, zn, Gn, Yn) {
        if (Hn) {
          var Wn = parsePercent$1(retrieve2(Dn.get(["controlStyle", zn + "BtnSize"]), Ln), Ln), Xn = [0, -Wn / 2, Wn, Wn], ea = makeControlIcon(Dn, zn + "Icon", Xn, {
            x: Hn[0],
            y: Hn[1],
            originX: Ln / 2,
            originY: 0,
            rotation: Yn ? -$n : 0,
            rectHover: !0,
            style: Nn,
            onclick: Gn
          });
          ea.ensureState("emphasis").style = Rn, Bn.add(ea), enableHoverEmphasis(ea);
        }
      }
    }, nr.prototype._renderCurrentPointer = function(Cn, Bn, In, Dn) {
      var Ln = Dn.getData(), $n = Dn.getCurrentIndex(), Nn = Ln.getItemModel($n).getModel("checkpointStyle"), Rn = this, Fn = {
        onCreate: function(Pn) {
          Pn.draggable = !0, Pn.drift = bind$1(Rn._handlePointerDrag, Rn), Pn.ondragend = bind$1(Rn._handlePointerDragend, Rn), pointerMoveTo(Pn, Rn._progressLine, $n, In, Dn, !0);
        },
        onUpdate: function(Pn) {
          pointerMoveTo(Pn, Rn._progressLine, $n, In, Dn);
        }
      };
      this._currentPointer = giveSymbol(Nn, Nn, this._mainGroup, {}, this._currentPointer, Fn);
    }, nr.prototype._handlePlayClick = function(Cn) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: Cn,
        from: this.uid
      });
    }, nr.prototype._handlePointerDrag = function(Cn, Bn, In) {
      this._clearTimer(), this._pointerChangeTimeline([In.offsetX, In.offsetY]);
    }, nr.prototype._handlePointerDragend = function(Cn) {
      this._pointerChangeTimeline([Cn.offsetX, Cn.offsetY], !0);
    }, nr.prototype._pointerChangeTimeline = function(Cn, Bn) {
      var In = this._toAxisCoord(Cn)[0], Dn = this._axis, Ln = asc$2(Dn.getExtent().slice());
      In > Ln[1] && (In = Ln[1]), In < Ln[0] && (In = Ln[0]), this._currentPointer.x = In, this._currentPointer.markRedraw();
      var $n = this._progressLine;
      $n && ($n.shape.x2 = In, $n.dirty());
      var Nn = this._findNearestTick(In), Rn = this.model;
      (Bn || Nn !== Rn.getCurrentIndex() && Rn.get("realtime")) && this._changeTimeline(Nn);
    }, nr.prototype._doPlayStop = function() {
      var Cn = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var Bn = Cn.model;
        Cn._changeTimeline(Bn.getCurrentIndex() + (Bn.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, nr.prototype._toAxisCoord = function(Cn) {
      var Bn = this._mainGroup.getLocalTransform();
      return applyTransform(Cn, Bn, !0);
    }, nr.prototype._findNearestTick = function(Cn) {
      var Bn = this.model.getData(), In = 1 / 0, Dn, Ln = this._axis;
      return Bn.each(["value"], function($n, Nn) {
        var Rn = Ln.dataToCoord($n), Fn = Math.abs(Rn - Cn);
        Fn < In && (In = Fn, Dn = Nn);
      }), Dn;
    }, nr.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, nr.prototype._changeTimeline = function(Cn) {
      var Bn = this.model.getCurrentIndex();
      Cn === "+" ? Cn = Bn + 1 : Cn === "-" && (Cn = Bn - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: Cn,
        from: this.uid
      });
    }, nr.prototype._updateTicksStatus = function() {
      var Cn = this.model.getCurrentIndex(), Bn = this._tickSymbols, In = this._tickLabels;
      if (Bn)
        for (var Dn = 0; Dn < Bn.length; Dn++)
          Bn && Bn[Dn] && Bn[Dn].toggleState("progress", Dn < Cn);
      if (In)
        for (var Dn = 0; Dn < In.length; Dn++)
          In && In[Dn] && In[Dn].toggleState("progress", labelDataIndexStore(In[Dn]).dataIndex <= Cn);
    }, nr.type = "timeline.slider", nr;
  }(TimelineView$1)
);
function createScaleByModel(_n, nr) {
  if (nr = nr || _n.get("type"), nr)
    switch (nr) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: _n.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new TimeScale$1({
          locale: _n.ecModel.getLocaleModel(),
          useUTC: _n.ecModel.get("useUTC")
        });
      default:
        return new IntervalScale$1();
    }
}
function getViewRect(_n, nr) {
  return getLayoutRect$1(_n.getBoxLayoutParams(), {
    width: nr.getWidth(),
    height: nr.getHeight()
  }, _n.get("padding"));
}
function makeControlIcon(_n, nr, Cn, Bn) {
  var In = Bn.style, Dn = createIcon(_n.get(["controlStyle", nr]), Bn || {}, new BoundingRect$1(Cn[0], Cn[1], Cn[2], Cn[3]));
  return In && Dn.setStyle(In), Dn;
}
function giveSymbol(_n, nr, Cn, Bn, In, Dn) {
  var Ln = nr.get("color");
  if (In)
    In.setColor(Ln), Cn.add(In), Dn && Dn.onUpdate(In);
  else {
    var $n = _n.get("symbol");
    In = createSymbol$1($n, -1, -1, 2, 2, Ln), In.setStyle("strokeNoScale", !0), Cn.add(In), Dn && Dn.onCreate(In);
  }
  var Nn = nr.getItemStyle(["color"]);
  In.setStyle(Nn), Bn = merge$1({
    rectHover: !0,
    z2: 100
  }, Bn, !0);
  var Rn = normalizeSymbolSize(_n.get("symbolSize"));
  Bn.scaleX = Rn[0] / 2, Bn.scaleY = Rn[1] / 2;
  var Fn = normalizeSymbolOffset(_n.get("symbolOffset"), Rn);
  Fn && (Bn.x = (Bn.x || 0) + Fn[0], Bn.y = (Bn.y || 0) + Fn[1]);
  var Pn = _n.get("symbolRotate");
  return Bn.rotation = (Pn || 0) * Math.PI / 180 || 0, In.attr(Bn), In.updateTransform(), In;
}
function pointerMoveTo(_n, nr, Cn, Bn, In, Dn) {
  if (!_n.dragging) {
    var Ln = In.getModel("checkpointStyle"), $n = Bn.dataToCoord(In.getData().get("value", Cn));
    if (Dn || !Ln.get("animation", !0))
      _n.attr({
        x: $n,
        y: 0
      }), nr && nr.attr({
        shape: {
          x2: $n
        }
      });
    else {
      var Nn = {
        duration: Ln.get("animationDuration", !0),
        easing: Ln.get("animationEasing", !0)
      };
      _n.stopAnimation(null, !0), _n.animateTo({
        x: $n,
        y: 0
      }, Nn), nr && nr.animateTo({
        shape: {
          x2: $n
        }
      }, Nn);
    }
  }
}
const SliderTimelineView$1 = SliderTimelineView;
function installTimelineAction(_n) {
  _n.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(nr, Cn, Bn) {
    var In = Cn.getComponent("timeline");
    return In && nr.currentIndex != null && (In.setCurrentIndex(nr.currentIndex), !In.get("loop", !0) && In.isIndexMax() && In.getPlayState() && (In.setPlayState(!1), Bn.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: nr.from
    }))), Cn.resetOption("timeline", {
      replaceMerge: In.get("replaceMerge", !0)
    }), defaults({
      currentIndex: In.option.currentIndex
    }, nr);
  }), _n.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(nr, Cn) {
    var Bn = Cn.getComponent("timeline");
    Bn && nr.playState != null && Bn.setPlayState(nr.playState);
  });
}
function timelinePreprocessor(_n) {
  var nr = _n && _n.timeline;
  isArray$4(nr) || (nr = nr ? [nr] : []), each$f(nr, function(Cn) {
    Cn && compatibleEC2(Cn);
  });
}
function compatibleEC2(_n) {
  var nr = _n.type, Cn = {
    number: "value",
    time: "time"
  };
  if (Cn[nr] && (_n.axisType = Cn[nr], delete _n.type), transferItem(_n), has$1(_n, "controlPosition")) {
    var Bn = _n.controlStyle || (_n.controlStyle = {});
    has$1(Bn, "position") || (Bn.position = _n.controlPosition), Bn.position === "none" && !has$1(Bn, "show") && (Bn.show = !1, delete Bn.position), delete _n.controlPosition;
  }
  each$f(_n.data || [], function(In) {
    isObject$6(In) && !isArray$4(In) && (!has$1(In, "value") && has$1(In, "name") && (In.value = In.name), transferItem(In));
  });
}
function transferItem(_n) {
  var nr = _n.itemStyle || (_n.itemStyle = {}), Cn = nr.emphasis || (nr.emphasis = {}), Bn = _n.label || _n.label || {}, In = Bn.normal || (Bn.normal = {}), Dn = {
    normal: 1,
    emphasis: 1
  };
  each$f(Bn, function(Ln, $n) {
    !Dn[$n] && !has$1(In, $n) && (In[$n] = Ln);
  }), Cn.label && !has$1(Bn, "emphasis") && (Bn.emphasis = Cn.label, delete Cn.label);
}
function has$1(_n, nr) {
  return _n.hasOwnProperty(nr);
}
function install$f(_n) {
  _n.registerComponentModel(SliderTimelineModel$1), _n.registerComponentView(SliderTimelineView$1), _n.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), installTimelineAction(_n), _n.registerPreprocessor(timelinePreprocessor);
}
function checkMarkerInSeries(_n, nr) {
  if (!_n)
    return !1;
  for (var Cn = isArray$4(_n) ? _n : [_n], Bn = 0; Bn < Cn.length; Bn++)
    if (Cn[Bn] && Cn[Bn][nr])
      return !0;
  return !1;
}
function fillLabel(_n) {
  defaultEmphasis(_n, "label", ["show"]);
}
var inner$5 = makeInner(), MarkerModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.createdBySelf = !1, Cn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      if (process.env.NODE_ENV !== "production" && this.type === "marker")
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      this.mergeDefaultAndTheme(Cn, In), this._mergeOption(Cn, In, !1, !0);
    }, nr.prototype.isAnimationEnabled = function() {
      if (env$1.node)
        return !1;
      var Cn = this.__hostSeries;
      return this.getShallow("animation") && Cn && Cn.isAnimationEnabled();
    }, nr.prototype.mergeOption = function(Cn, Bn) {
      this._mergeOption(Cn, Bn, !1, !1);
    }, nr.prototype._mergeOption = function(Cn, Bn, In, Dn) {
      var Ln = this.mainType;
      In || Bn.eachSeries(function($n) {
        var Nn = $n.get(this.mainType, !0), Rn = inner$5($n)[Ln];
        if (!Nn || !Nn.data) {
          inner$5($n)[Ln] = null;
          return;
        }
        Rn ? Rn._mergeOption(Nn, Bn, !0) : (Dn && fillLabel(Nn), each$f(Nn.data, function(Fn) {
          Fn instanceof Array ? (fillLabel(Fn[0]), fillLabel(Fn[1])) : fillLabel(Fn);
        }), Rn = this.createMarkerModelFromSeries(Nn, this, Bn), extend(Rn, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: $n.seriesIndex,
          name: $n.name,
          createdBySelf: !0
        }), Rn.__hostSeries = $n), inner$5($n)[Ln] = Rn;
      }, this);
    }, nr.prototype.formatTooltip = function(Cn, Bn, In) {
      var Dn = this.getData(), Ln = this.getRawValue(Cn), $n = Dn.getName(Cn);
      return createTooltipMarkup("section", {
        header: this.name,
        blocks: [createTooltipMarkup("nameValue", {
          name: $n,
          value: Ln,
          noName: !$n,
          noValue: Ln == null
        })]
      });
    }, nr.prototype.getData = function() {
      return this._data;
    }, nr.prototype.setData = function(Cn) {
      this._data = Cn;
    }, nr.prototype.getDataParams = function(Cn, Bn) {
      var In = DataFormatMixin.prototype.getDataParams.call(this, Cn, Bn), Dn = this.__hostSeries;
      return Dn && (In.seriesId = Dn.id, In.seriesName = Dn.name, In.seriesType = Dn.subType), In;
    }, nr.getMarkerModelFromSeries = function(Cn, Bn) {
      return inner$5(Cn)[Bn];
    }, nr.type = "marker", nr.dependencies = ["series", "grid", "polar", "geo"], nr;
  }(ComponentModel$1)
);
mixin(MarkerModel, DataFormatMixin.prototype);
const MarkerModel$1 = MarkerModel;
var MarkPointModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.createMarkerModelFromSeries = function(Cn, Bn, In) {
      return new nr(Cn, Bn, In);
    }, nr.type = "markPoint", nr.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, nr;
  }(MarkerModel$1)
);
const MarkPointModel$1 = MarkPointModel;
function hasXOrY(_n) {
  return !(isNaN(parseFloat(_n.x)) && isNaN(parseFloat(_n.y)));
}
function hasXAndY(_n) {
  return !isNaN(parseFloat(_n.x)) && !isNaN(parseFloat(_n.y));
}
function markerTypeCalculatorWithExtent(_n, nr, Cn, Bn, In, Dn) {
  var Ln = [], $n = isDimensionStacked(
    nr,
    Bn
    /* , otherDataDim */
  ), Nn = $n ? nr.getCalculationInfo("stackResultDimension") : Bn, Rn = numCalculate(nr, Nn, _n), Fn = nr.indicesOfNearest(Nn, Rn)[0];
  Ln[In] = nr.get(Cn, Fn), Ln[Dn] = nr.get(Nn, Fn);
  var Pn = nr.get(Bn, Fn), Un = getPrecision(nr.get(Bn, Fn));
  return Un = Math.min(Un, 20), Un >= 0 && (Ln[Dn] = +Ln[Dn].toFixed(Un)), [Ln, Pn];
}
var markerTypeCalculator = {
  min: curry$1(markerTypeCalculatorWithExtent, "min"),
  max: curry$1(markerTypeCalculatorWithExtent, "max"),
  average: curry$1(markerTypeCalculatorWithExtent, "average"),
  median: curry$1(markerTypeCalculatorWithExtent, "median")
};
function dataTransform(_n, nr) {
  if (nr) {
    var Cn = _n.getData(), Bn = _n.coordinateSystem, In = Bn && Bn.dimensions;
    if (!hasXAndY(nr) && !isArray$4(nr.coord) && isArray$4(In)) {
      var Dn = getAxisInfo(nr, Cn, Bn, _n);
      if (nr = clone$4(nr), nr.type && markerTypeCalculator[nr.type] && Dn.baseAxis && Dn.valueAxis) {
        var Ln = indexOf(In, Dn.baseAxis.dim), $n = indexOf(In, Dn.valueAxis.dim), Nn = markerTypeCalculator[nr.type](Cn, Dn.baseDataDim, Dn.valueDataDim, Ln, $n);
        nr.coord = Nn[0], nr.value = Nn[1];
      } else
        nr.coord = [nr.xAxis != null ? nr.xAxis : nr.radiusAxis, nr.yAxis != null ? nr.yAxis : nr.angleAxis];
    }
    if (nr.coord == null || !isArray$4(In))
      nr.coord = [];
    else
      for (var Rn = nr.coord, Fn = 0; Fn < 2; Fn++)
        markerTypeCalculator[Rn[Fn]] && (Rn[Fn] = numCalculate(Cn, Cn.mapDimension(In[Fn]), Rn[Fn]));
    return nr;
  }
}
function getAxisInfo(_n, nr, Cn, Bn) {
  var In = {};
  return _n.valueIndex != null || _n.valueDim != null ? (In.valueDataDim = _n.valueIndex != null ? nr.getDimension(_n.valueIndex) : _n.valueDim, In.valueAxis = Cn.getAxis(dataDimToCoordDim(Bn, In.valueDataDim)), In.baseAxis = Cn.getOtherAxis(In.valueAxis), In.baseDataDim = nr.mapDimension(In.baseAxis.dim)) : (In.baseAxis = Bn.getBaseAxis(), In.valueAxis = Cn.getOtherAxis(In.baseAxis), In.baseDataDim = nr.mapDimension(In.baseAxis.dim), In.valueDataDim = nr.mapDimension(In.valueAxis.dim)), In;
}
function dataDimToCoordDim(_n, nr) {
  var Cn = _n.getData().getDimensionInfo(nr);
  return Cn && Cn.coordDim;
}
function dataFilter(_n, nr) {
  return _n && _n.containData && nr.coord && !hasXOrY(nr) ? _n.containData(nr.coord) : !0;
}
function zoneFilter(_n, nr, Cn) {
  return _n && _n.containZone && nr.coord && Cn.coord && !hasXOrY(nr) && !hasXOrY(Cn) ? _n.containZone(nr.coord, Cn.coord) : !0;
}
function createMarkerDimValueGetter(_n, nr) {
  return _n ? function(Cn, Bn, In, Dn) {
    var Ln = Dn < 2 ? Cn.coord && Cn.coord[Dn] : Cn.value;
    return parseDataValue(Ln, nr[Dn]);
  } : function(Cn, Bn, In, Dn) {
    return parseDataValue(Cn.value, nr[Dn]);
  };
}
function numCalculate(_n, nr, Cn) {
  if (Cn === "average") {
    var Bn = 0, In = 0;
    return _n.each(nr, function(Dn, Ln) {
      isNaN(Dn) || (Bn += Dn, In++);
    }), Bn / In;
  } else
    return Cn === "median" ? _n.getMedian(nr) : _n.getDataExtent(nr)[Cn === "max" ? 1 : 0];
}
var inner$4 = makeInner(), MarkerView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.init = function() {
      this.markerGroupMap = createHashMap();
    }, nr.prototype.render = function(Cn, Bn, In) {
      var Dn = this, Ln = this.markerGroupMap;
      Ln.each(function($n) {
        inner$4($n).keep = !1;
      }), Bn.eachSeries(function($n) {
        var Nn = MarkerModel$1.getMarkerModelFromSeries($n, Dn.type);
        Nn && Dn.renderSeries($n, Nn, Bn, In);
      }), Ln.each(function($n) {
        !inner$4($n).keep && Dn.group.remove($n.group);
      });
    }, nr.prototype.markKeep = function(Cn) {
      inner$4(Cn).keep = !0;
    }, nr.prototype.toggleBlurSeries = function(Cn, Bn) {
      var In = this;
      each$f(Cn, function(Dn) {
        var Ln = MarkerModel$1.getMarkerModelFromSeries(Dn, In.type);
        if (Ln) {
          var $n = Ln.getData();
          $n.eachItemGraphicEl(function(Nn) {
            Nn && (Bn ? enterBlur(Nn) : leaveBlur(Nn));
          });
        }
      });
    }, nr.type = "marker", nr;
  }(ComponentView$1)
);
const MarkerView$1 = MarkerView;
function updateMarkerLayout(_n, nr, Cn) {
  var Bn = nr.coordinateSystem;
  _n.each(function(In) {
    var Dn = _n.getItemModel(In), Ln, $n = parsePercent(Dn.get("x"), Cn.getWidth()), Nn = parsePercent(Dn.get("y"), Cn.getHeight());
    if (!isNaN($n) && !isNaN(Nn))
      Ln = [$n, Nn];
    else if (nr.getMarkerPosition)
      Ln = nr.getMarkerPosition(_n.getValues(_n.dimensions, In));
    else if (Bn) {
      var Rn = _n.get(Bn.dimensions[0], In), Fn = _n.get(Bn.dimensions[1], In);
      Ln = Bn.dataToPoint([Rn, Fn]);
    }
    isNaN($n) || (Ln[0] = $n), isNaN(Nn) || (Ln[1] = Nn), _n.setItemLayout(In, Ln);
  });
}
var MarkPointView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.updateTransform = function(Cn, Bn, In) {
      Bn.eachSeries(function(Dn) {
        var Ln = MarkerModel$1.getMarkerModelFromSeries(Dn, "markPoint");
        Ln && (updateMarkerLayout(Ln.getData(), Dn, In), this.markerGroupMap.get(Dn.id).updateLayout());
      }, this);
    }, nr.prototype.renderSeries = function(Cn, Bn, In, Dn) {
      var Ln = Cn.coordinateSystem, $n = Cn.id, Nn = Cn.getData(), Rn = this.markerGroupMap, Fn = Rn.get($n) || Rn.set($n, new SymbolDraw$1()), Pn = createData(Ln, Cn, Bn);
      Bn.setData(Pn), updateMarkerLayout(Bn.getData(), Cn, Dn), Pn.each(function(Un) {
        var Hn = Pn.getItemModel(Un), zn = Hn.getShallow("symbol"), Gn = Hn.getShallow("symbolSize"), Yn = Hn.getShallow("symbolRotate"), Wn = Hn.getShallow("symbolOffset"), Xn = Hn.getShallow("symbolKeepAspect");
        if (isFunction$1(zn) || isFunction$1(Gn) || isFunction$1(Yn) || isFunction$1(Wn)) {
          var ea = Bn.getRawValue(Un), ta = Bn.getDataParams(Un);
          isFunction$1(zn) && (zn = zn(ea, ta)), isFunction$1(Gn) && (Gn = Gn(ea, ta)), isFunction$1(Yn) && (Yn = Yn(ea, ta)), isFunction$1(Wn) && (Wn = Wn(ea, ta));
        }
        var na = Hn.getModel("itemStyle").getItemStyle(), ra = getVisualFromData(Nn, "color");
        na.fill || (na.fill = ra), Pn.setItemVisual(Un, {
          symbol: zn,
          symbolSize: Gn,
          symbolRotate: Yn,
          symbolOffset: Wn,
          symbolKeepAspect: Xn,
          style: na
        });
      }), Fn.updateData(Pn), this.group.add(Fn.group), Pn.eachItemGraphicEl(function(Un) {
        Un.traverse(function(Hn) {
          getECData(Hn).dataModel = Bn;
        });
      }), this.markKeep(Fn), Fn.group.silent = Bn.get("silent") || Cn.get("silent");
    }, nr.type = "markPoint", nr;
  }(MarkerView$1)
);
function createData(_n, nr, Cn) {
  var Bn;
  _n ? Bn = map$1(_n && _n.dimensions, function($n) {
    var Nn = nr.getData().getDimensionInfo(nr.getData().mapDimension($n)) || {};
    return extend(extend({}, Nn), {
      name: $n,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : Bn = [{
    name: "value",
    type: "float"
  }];
  var In = new SeriesData$1(Bn, Cn), Dn = map$1(Cn.get("data"), curry$1(dataTransform, nr));
  _n && (Dn = filter(Dn, curry$1(dataFilter, _n)));
  var Ln = createMarkerDimValueGetter(!!_n, Bn);
  return In.initData(Dn, null, Ln), In;
}
const MarkPointView$1 = MarkPointView;
function install$e(_n) {
  _n.registerComponentModel(MarkPointModel$1), _n.registerComponentView(MarkPointView$1), _n.registerPreprocessor(function(nr) {
    checkMarkerInSeries(nr.series, "markPoint") && (nr.markPoint = nr.markPoint || {});
  });
}
var MarkLineModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.createMarkerModelFromSeries = function(Cn, Bn, In) {
      return new nr(Cn, Bn, In);
    }, nr.type = "markLine", nr.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, nr;
  }(MarkerModel$1)
);
const MarkLineModel$1 = MarkLineModel;
var inner$3 = makeInner(), markLineTransform = function(_n, nr, Cn, Bn) {
  var In = _n.getData(), Dn;
  if (isArray$4(Bn))
    Dn = Bn;
  else {
    var Ln = Bn.type;
    if (Ln === "min" || Ln === "max" || Ln === "average" || Ln === "median" || Bn.xAxis != null || Bn.yAxis != null) {
      var $n = void 0, Nn = void 0;
      if (Bn.yAxis != null || Bn.xAxis != null)
        $n = nr.getAxis(Bn.yAxis != null ? "y" : "x"), Nn = retrieve(Bn.yAxis, Bn.xAxis);
      else {
        var Rn = getAxisInfo(Bn, In, nr, _n);
        $n = Rn.valueAxis;
        var Fn = getStackedDimension(In, Rn.valueDataDim);
        Nn = numCalculate(In, Fn, Ln);
      }
      var Pn = $n.dim === "x" ? 0 : 1, Un = 1 - Pn, Hn = clone$4(Bn), zn = {
        coord: []
      };
      Hn.type = null, Hn.coord = [], Hn.coord[Un] = -1 / 0, zn.coord[Un] = 1 / 0;
      var Gn = Cn.get("precision");
      Gn >= 0 && isNumber(Nn) && (Nn = +Nn.toFixed(Math.min(Gn, 20))), Hn.coord[Pn] = zn.coord[Pn] = Nn, Dn = [Hn, zn, {
        type: Ln,
        valueIndex: Bn.valueIndex,
        // Force to use the value of calculated value.
        value: Nn
      }];
    } else
      process.env.NODE_ENV !== "production" && logError("Invalid markLine data."), Dn = [];
  }
  var Yn = [dataTransform(_n, Dn[0]), dataTransform(_n, Dn[1]), extend({}, Dn[2])];
  return Yn[2].type = Yn[2].type || null, merge$1(Yn[2], Yn[0]), merge$1(Yn[2], Yn[1]), Yn;
};
function isInfinity$1(_n) {
  return !isNaN(_n) && !isFinite(_n);
}
function ifMarkLineHasOnlyDim(_n, nr, Cn, Bn) {
  var In = 1 - _n, Dn = Bn.dimensions[_n];
  return isInfinity$1(nr[In]) && isInfinity$1(Cn[In]) && nr[_n] === Cn[_n] && Bn.getAxis(Dn).containData(nr[_n]);
}
function markLineFilter(_n, nr) {
  if (_n.type === "cartesian2d") {
    var Cn = nr[0].coord, Bn = nr[1].coord;
    if (Cn && Bn && (ifMarkLineHasOnlyDim(1, Cn, Bn, _n) || ifMarkLineHasOnlyDim(0, Cn, Bn, _n)))
      return !0;
  }
  return dataFilter(_n, nr[0]) && dataFilter(_n, nr[1]);
}
function updateSingleMarkerEndLayout(_n, nr, Cn, Bn, In) {
  var Dn = Bn.coordinateSystem, Ln = _n.getItemModel(nr), $n, Nn = parsePercent(Ln.get("x"), In.getWidth()), Rn = parsePercent(Ln.get("y"), In.getHeight());
  if (!isNaN(Nn) && !isNaN(Rn))
    $n = [Nn, Rn];
  else {
    if (Bn.getMarkerPosition)
      $n = Bn.getMarkerPosition(_n.getValues(_n.dimensions, nr));
    else {
      var Fn = Dn.dimensions, Pn = _n.get(Fn[0], nr), Un = _n.get(Fn[1], nr);
      $n = Dn.dataToPoint([Pn, Un]);
    }
    if (isCoordinateSystemType(Dn, "cartesian2d")) {
      var Hn = Dn.getAxis("x"), zn = Dn.getAxis("y"), Fn = Dn.dimensions;
      isInfinity$1(_n.get(Fn[0], nr)) ? $n[0] = Hn.toGlobalCoord(Hn.getExtent()[Cn ? 0 : 1]) : isInfinity$1(_n.get(Fn[1], nr)) && ($n[1] = zn.toGlobalCoord(zn.getExtent()[Cn ? 0 : 1]));
    }
    isNaN(Nn) || ($n[0] = Nn), isNaN(Rn) || ($n[1] = Rn);
  }
  _n.setItemLayout(nr, $n);
}
var MarkLineView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.updateTransform = function(Cn, Bn, In) {
      Bn.eachSeries(function(Dn) {
        var Ln = MarkerModel$1.getMarkerModelFromSeries(Dn, "markLine");
        if (Ln) {
          var $n = Ln.getData(), Nn = inner$3(Ln).from, Rn = inner$3(Ln).to;
          Nn.each(function(Fn) {
            updateSingleMarkerEndLayout(Nn, Fn, !0, Dn, In), updateSingleMarkerEndLayout(Rn, Fn, !1, Dn, In);
          }), $n.each(function(Fn) {
            $n.setItemLayout(Fn, [Nn.getItemLayout(Fn), Rn.getItemLayout(Fn)]);
          }), this.markerGroupMap.get(Dn.id).updateLayout();
        }
      }, this);
    }, nr.prototype.renderSeries = function(Cn, Bn, In, Dn) {
      var Ln = Cn.coordinateSystem, $n = Cn.id, Nn = Cn.getData(), Rn = this.markerGroupMap, Fn = Rn.get($n) || Rn.set($n, new LineDraw$1());
      this.group.add(Fn.group);
      var Pn = createList$1(Ln, Cn, Bn), Un = Pn.from, Hn = Pn.to, zn = Pn.line;
      inner$3(Bn).from = Un, inner$3(Bn).to = Hn, Bn.setData(zn);
      var Gn = Bn.get("symbol"), Yn = Bn.get("symbolSize"), Wn = Bn.get("symbolRotate"), Xn = Bn.get("symbolOffset");
      isArray$4(Gn) || (Gn = [Gn, Gn]), isArray$4(Yn) || (Yn = [Yn, Yn]), isArray$4(Wn) || (Wn = [Wn, Wn]), isArray$4(Xn) || (Xn = [Xn, Xn]), Pn.from.each(function(ta) {
        ea(Un, ta, !0), ea(Hn, ta, !1);
      }), zn.each(function(ta) {
        var na = zn.getItemModel(ta).getModel("lineStyle").getLineStyle();
        zn.setItemLayout(ta, [Un.getItemLayout(ta), Hn.getItemLayout(ta)]), na.stroke == null && (na.stroke = Un.getItemVisual(ta, "style").fill), zn.setItemVisual(ta, {
          fromSymbolKeepAspect: Un.getItemVisual(ta, "symbolKeepAspect"),
          fromSymbolOffset: Un.getItemVisual(ta, "symbolOffset"),
          fromSymbolRotate: Un.getItemVisual(ta, "symbolRotate"),
          fromSymbolSize: Un.getItemVisual(ta, "symbolSize"),
          fromSymbol: Un.getItemVisual(ta, "symbol"),
          toSymbolKeepAspect: Hn.getItemVisual(ta, "symbolKeepAspect"),
          toSymbolOffset: Hn.getItemVisual(ta, "symbolOffset"),
          toSymbolRotate: Hn.getItemVisual(ta, "symbolRotate"),
          toSymbolSize: Hn.getItemVisual(ta, "symbolSize"),
          toSymbol: Hn.getItemVisual(ta, "symbol"),
          style: na
        });
      }), Fn.updateData(zn), Pn.line.eachItemGraphicEl(function(ta) {
        getECData(ta).dataModel = Bn, ta.traverse(function(na) {
          getECData(na).dataModel = Bn;
        });
      });
      function ea(ta, na, ra) {
        var aa = ta.getItemModel(na);
        updateSingleMarkerEndLayout(ta, na, ra, Cn, Dn);
        var ia = aa.getModel("itemStyle").getItemStyle();
        ia.fill == null && (ia.fill = getVisualFromData(Nn, "color")), ta.setItemVisual(na, {
          symbolKeepAspect: aa.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: retrieve2(aa.get("symbolOffset", !0), Xn[ra ? 0 : 1]),
          symbolRotate: retrieve2(aa.get("symbolRotate", !0), Wn[ra ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: retrieve2(aa.get("symbolSize"), Yn[ra ? 0 : 1]),
          symbol: retrieve2(aa.get("symbol", !0), Gn[ra ? 0 : 1]),
          style: ia
        });
      }
      this.markKeep(Fn), Fn.group.silent = Bn.get("silent") || Cn.get("silent");
    }, nr.type = "markLine", nr;
  }(MarkerView$1)
);
function createList$1(_n, nr, Cn) {
  var Bn;
  _n ? Bn = map$1(_n && _n.dimensions, function(Rn) {
    var Fn = nr.getData().getDimensionInfo(nr.getData().mapDimension(Rn)) || {};
    return extend(extend({}, Fn), {
      name: Rn,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : Bn = [{
    name: "value",
    type: "float"
  }];
  var In = new SeriesData$1(Bn, Cn), Dn = new SeriesData$1(Bn, Cn), Ln = new SeriesData$1([], Cn), $n = map$1(Cn.get("data"), curry$1(markLineTransform, nr, _n, Cn));
  _n && ($n = filter($n, curry$1(markLineFilter, _n)));
  var Nn = createMarkerDimValueGetter(!!_n, Bn);
  return In.initData(map$1($n, function(Rn) {
    return Rn[0];
  }), null, Nn), Dn.initData(map$1($n, function(Rn) {
    return Rn[1];
  }), null, Nn), Ln.initData(map$1($n, function(Rn) {
    return Rn[2];
  })), Ln.hasItemOption = !0, {
    from: In,
    to: Dn,
    line: Ln
  };
}
const MarkLineView$1 = MarkLineView;
function install$d(_n) {
  _n.registerComponentModel(MarkLineModel$1), _n.registerComponentView(MarkLineView$1), _n.registerPreprocessor(function(nr) {
    checkMarkerInSeries(nr.series, "markLine") && (nr.markLine = nr.markLine || {});
  });
}
var MarkAreaModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.createMarkerModelFromSeries = function(Cn, Bn, In) {
      return new nr(Cn, Bn, In);
    }, nr.type = "markArea", nr.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, nr;
  }(MarkerModel$1)
);
const MarkAreaModel$1 = MarkAreaModel;
var inner$2 = makeInner(), markAreaTransform = function(_n, nr, Cn, Bn) {
  var In = Bn[0], Dn = Bn[1];
  if (!(!In || !Dn)) {
    var Ln = dataTransform(_n, In), $n = dataTransform(_n, Dn), Nn = Ln.coord, Rn = $n.coord;
    Nn[0] = retrieve(Nn[0], -1 / 0), Nn[1] = retrieve(Nn[1], -1 / 0), Rn[0] = retrieve(Rn[0], 1 / 0), Rn[1] = retrieve(Rn[1], 1 / 0);
    var Fn = mergeAll([{}, Ln, $n]);
    return Fn.coord = [Ln.coord, $n.coord], Fn.x0 = Ln.x, Fn.y0 = Ln.y, Fn.x1 = $n.x, Fn.y1 = $n.y, Fn;
  }
};
function isInfinity(_n) {
  return !isNaN(_n) && !isFinite(_n);
}
function ifMarkAreaHasOnlyDim(_n, nr, Cn, Bn) {
  var In = 1 - _n;
  return isInfinity(nr[In]) && isInfinity(Cn[In]);
}
function markAreaFilter(_n, nr) {
  var Cn = nr.coord[0], Bn = nr.coord[1], In = {
    coord: Cn,
    x: nr.x0,
    y: nr.y0
  }, Dn = {
    coord: Bn,
    x: nr.x1,
    y: nr.y1
  };
  return isCoordinateSystemType(_n, "cartesian2d") ? Cn && Bn && (ifMarkAreaHasOnlyDim(1, Cn, Bn) || ifMarkAreaHasOnlyDim(0, Cn, Bn)) ? !0 : zoneFilter(_n, In, Dn) : dataFilter(_n, In) || dataFilter(_n, Dn);
}
function getSingleMarkerEndPoint(_n, nr, Cn, Bn, In) {
  var Dn = Bn.coordinateSystem, Ln = _n.getItemModel(nr), $n, Nn = parsePercent(Ln.get(Cn[0]), In.getWidth()), Rn = parsePercent(Ln.get(Cn[1]), In.getHeight());
  if (!isNaN(Nn) && !isNaN(Rn))
    $n = [Nn, Rn];
  else {
    if (Bn.getMarkerPosition) {
      var Fn = _n.getValues(["x0", "y0"], nr), Pn = _n.getValues(["x1", "y1"], nr), Un = Dn.clampData(Fn), Hn = Dn.clampData(Pn), zn = [];
      Cn[0] === "x0" ? zn[0] = Un[0] > Hn[0] ? Pn[0] : Fn[0] : zn[0] = Un[0] > Hn[0] ? Fn[0] : Pn[0], Cn[1] === "y0" ? zn[1] = Un[1] > Hn[1] ? Pn[1] : Fn[1] : zn[1] = Un[1] > Hn[1] ? Fn[1] : Pn[1], $n = Bn.getMarkerPosition(zn, Cn, !0);
    } else {
      var Gn = _n.get(Cn[0], nr), Yn = _n.get(Cn[1], nr), Wn = [Gn, Yn];
      Dn.clampData && Dn.clampData(Wn, Wn), $n = Dn.dataToPoint(Wn, !0);
    }
    if (isCoordinateSystemType(Dn, "cartesian2d")) {
      var Xn = Dn.getAxis("x"), ea = Dn.getAxis("y"), Gn = _n.get(Cn[0], nr), Yn = _n.get(Cn[1], nr);
      isInfinity(Gn) ? $n[0] = Xn.toGlobalCoord(Xn.getExtent()[Cn[0] === "x0" ? 0 : 1]) : isInfinity(Yn) && ($n[1] = ea.toGlobalCoord(ea.getExtent()[Cn[1] === "y0" ? 0 : 1]));
    }
    isNaN(Nn) || ($n[0] = Nn), isNaN(Rn) || ($n[1] = Rn);
  }
  return $n;
}
var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], MarkAreaView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.updateTransform = function(Cn, Bn, In) {
      Bn.eachSeries(function(Dn) {
        var Ln = MarkerModel$1.getMarkerModelFromSeries(Dn, "markArea");
        if (Ln) {
          var $n = Ln.getData();
          $n.each(function(Nn) {
            var Rn = map$1(dimPermutations, function(Pn) {
              return getSingleMarkerEndPoint($n, Nn, Pn, Dn, In);
            });
            $n.setItemLayout(Nn, Rn);
            var Fn = $n.getItemGraphicEl(Nn);
            Fn.setShape("points", Rn);
          });
        }
      }, this);
    }, nr.prototype.renderSeries = function(Cn, Bn, In, Dn) {
      var Ln = Cn.coordinateSystem, $n = Cn.id, Nn = Cn.getData(), Rn = this.markerGroupMap, Fn = Rn.get($n) || Rn.set($n, {
        group: new Group$4()
      });
      this.group.add(Fn.group), this.markKeep(Fn);
      var Pn = createList(Ln, Cn, Bn);
      Bn.setData(Pn), Pn.each(function(Un) {
        var Hn = map$1(dimPermutations, function(ia) {
          return getSingleMarkerEndPoint(Pn, Un, ia, Cn, Dn);
        }), zn = Ln.getAxis("x").scale, Gn = Ln.getAxis("y").scale, Yn = zn.getExtent(), Wn = Gn.getExtent(), Xn = [zn.parse(Pn.get("x0", Un)), zn.parse(Pn.get("x1", Un))], ea = [Gn.parse(Pn.get("y0", Un)), Gn.parse(Pn.get("y1", Un))];
        asc$2(Xn), asc$2(ea);
        var ta = !(Yn[0] > Xn[1] || Yn[1] < Xn[0] || Wn[0] > ea[1] || Wn[1] < ea[0]), na = !ta;
        Pn.setItemLayout(Un, {
          points: Hn,
          allClipped: na
        });
        var ra = Pn.getItemModel(Un).getModel("itemStyle").getItemStyle(), aa = getVisualFromData(Nn, "color");
        ra.fill || (ra.fill = aa, isString$1(ra.fill) && (ra.fill = modifyAlpha(ra.fill, 0.4))), ra.stroke || (ra.stroke = aa), Pn.setItemVisual(Un, "style", ra);
      }), Pn.diff(inner$2(Fn).data).add(function(Un) {
        var Hn = Pn.getItemLayout(Un);
        if (!Hn.allClipped) {
          var zn = new Polygon$1({
            shape: {
              points: Hn.points
            }
          });
          Pn.setItemGraphicEl(Un, zn), Fn.group.add(zn);
        }
      }).update(function(Un, Hn) {
        var zn = inner$2(Fn).data.getItemGraphicEl(Hn), Gn = Pn.getItemLayout(Un);
        Gn.allClipped ? zn && Fn.group.remove(zn) : (zn ? updateProps$1(zn, {
          shape: {
            points: Gn.points
          }
        }, Bn, Un) : zn = new Polygon$1({
          shape: {
            points: Gn.points
          }
        }), Pn.setItemGraphicEl(Un, zn), Fn.group.add(zn));
      }).remove(function(Un) {
        var Hn = inner$2(Fn).data.getItemGraphicEl(Un);
        Fn.group.remove(Hn);
      }).execute(), Pn.eachItemGraphicEl(function(Un, Hn) {
        var zn = Pn.getItemModel(Hn), Gn = Pn.getItemVisual(Hn, "style");
        Un.useStyle(Pn.getItemVisual(Hn, "style")), setLabelStyle(Un, getLabelStatesModels(zn), {
          labelFetcher: Bn,
          labelDataIndex: Hn,
          defaultText: Pn.getName(Hn) || "",
          inheritColor: isString$1(Gn.fill) ? modifyAlpha(Gn.fill, 1) : "#000"
        }), setStatesStylesFromModel(Un, zn), toggleHoverEmphasis(Un, null, null, zn.get(["emphasis", "disabled"])), getECData(Un).dataModel = Bn;
      }), inner$2(Fn).data = Pn, Fn.group.silent = Bn.get("silent") || Cn.get("silent");
    }, nr.type = "markArea", nr;
  }(MarkerView$1)
);
function createList(_n, nr, Cn) {
  var Bn, In, Dn = ["x0", "y0", "x1", "y1"];
  if (_n) {
    var Ln = map$1(_n && _n.dimensions, function(Rn) {
      var Fn = nr.getData(), Pn = Fn.getDimensionInfo(Fn.mapDimension(Rn)) || {};
      return extend(extend({}, Pn), {
        name: Rn,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    In = map$1(Dn, function(Rn, Fn) {
      return {
        name: Rn,
        type: Ln[Fn % 2].type
      };
    }), Bn = new SeriesData$1(In, Cn);
  } else
    In = [{
      name: "value",
      type: "float"
    }], Bn = new SeriesData$1(In, Cn);
  var $n = map$1(Cn.get("data"), curry$1(markAreaTransform, nr, _n, Cn));
  _n && ($n = filter($n, curry$1(markAreaFilter, _n)));
  var Nn = _n ? function(Rn, Fn, Pn, Un) {
    var Hn = Rn.coord[Math.floor(Un / 2)][Un % 2];
    return parseDataValue(Hn, In[Un]);
  } : function(Rn, Fn, Pn, Un) {
    return parseDataValue(Rn.value, In[Un]);
  };
  return Bn.initData($n, null, Nn), Bn.hasItemOption = !0, Bn;
}
const MarkAreaView$1 = MarkAreaView;
function install$c(_n) {
  _n.registerComponentModel(MarkAreaModel$1), _n.registerComponentView(MarkAreaView$1), _n.registerPreprocessor(function(nr) {
    checkMarkerInSeries(nr.series, "markArea") && (nr.markArea = nr.markArea || {});
  });
}
var getDefaultSelectorOptions = function(_n, nr) {
  if (nr === "all")
    return {
      type: "all",
      title: _n.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (nr === "inverse")
    return {
      type: "inverse",
      title: _n.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, LegendModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, Cn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      this.mergeDefaultAndTheme(Cn, In), Cn.selected = Cn.selected || {}, this._updateSelector(Cn);
    }, nr.prototype.mergeOption = function(Cn, Bn) {
      _n.prototype.mergeOption.call(this, Cn, Bn), this._updateSelector(Cn);
    }, nr.prototype._updateSelector = function(Cn) {
      var Bn = Cn.selector, In = this.ecModel;
      Bn === !0 && (Bn = Cn.selector = ["all", "inverse"]), isArray$4(Bn) && each$f(Bn, function(Dn, Ln) {
        isString$1(Dn) && (Dn = {
          type: Dn
        }), Bn[Ln] = merge$1(Dn, getDefaultSelectorOptions(In, Dn.type));
      });
    }, nr.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var Cn = this._data;
      if (Cn[0] && this.get("selectedMode") === "single") {
        for (var Bn = !1, In = 0; In < Cn.length; In++) {
          var Dn = Cn[In].get("name");
          if (this.isSelected(Dn)) {
            this.select(Dn), Bn = !0;
            break;
          }
        }
        !Bn && this.select(Cn[0].get("name"));
      }
    }, nr.prototype._updateData = function(Cn) {
      var Bn = [], In = [];
      Cn.eachRawSeries(function(Nn) {
        var Rn = Nn.name;
        In.push(Rn);
        var Fn;
        if (Nn.legendVisualProvider) {
          var Pn = Nn.legendVisualProvider, Un = Pn.getAllNames();
          Cn.isSeriesFiltered(Nn) || (In = In.concat(Un)), Un.length ? Bn = Bn.concat(Un) : Fn = !0;
        } else
          Fn = !0;
        Fn && isNameSpecified(Nn) && Bn.push(Nn.name);
      }), this._availableNames = In;
      var Dn = this.get("data") || Bn, Ln = createHashMap(), $n = map$1(Dn, function(Nn) {
        return (isString$1(Nn) || isNumber(Nn)) && (Nn = {
          name: Nn
        }), Ln.get(Nn.name) ? null : (Ln.set(Nn.name, !0), new Model$1(Nn, this, this.ecModel));
      }, this);
      this._data = filter($n, function(Nn) {
        return !!Nn;
      });
    }, nr.prototype.getData = function() {
      return this._data;
    }, nr.prototype.select = function(Cn) {
      var Bn = this.option.selected, In = this.get("selectedMode");
      if (In === "single") {
        var Dn = this._data;
        each$f(Dn, function(Ln) {
          Bn[Ln.get("name")] = !1;
        });
      }
      Bn[Cn] = !0;
    }, nr.prototype.unSelect = function(Cn) {
      this.get("selectedMode") !== "single" && (this.option.selected[Cn] = !1);
    }, nr.prototype.toggleSelected = function(Cn) {
      var Bn = this.option.selected;
      Bn.hasOwnProperty(Cn) || (Bn[Cn] = !0), this[Bn[Cn] ? "unSelect" : "select"](Cn);
    }, nr.prototype.allSelect = function() {
      var Cn = this._data, Bn = this.option.selected;
      each$f(Cn, function(In) {
        Bn[In.get("name", !0)] = !0;
      });
    }, nr.prototype.inverseSelect = function() {
      var Cn = this._data, Bn = this.option.selected;
      each$f(Cn, function(In) {
        var Dn = In.get("name", !0);
        Bn.hasOwnProperty(Dn) || (Bn[Dn] = !0), Bn[Dn] = !Bn[Dn];
      });
    }, nr.prototype.isSelected = function(Cn) {
      var Bn = this.option.selected;
      return !(Bn.hasOwnProperty(Cn) && !Bn[Cn]) && indexOf(this._availableNames, Cn) >= 0;
    }, nr.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, nr.type = "legend.plain", nr.dependencies = ["series"], nr.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      }
    }, nr;
  }(ComponentModel$1)
);
const LegendModel$1 = LegendModel;
var curry = curry$1, each$3 = each$f, Group$1 = Group$4, LegendView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.newlineDisabled = !1, Cn;
    }
    return nr.prototype.init = function() {
      this.group.add(this._contentGroup = new Group$1()), this.group.add(this._selectorGroup = new Group$1()), this._isFirstRender = !0;
    }, nr.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, nr.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, nr.prototype.render = function(Cn, Bn, In) {
      var Dn = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!Cn.get("show", !0)) {
        var Ln = Cn.get("align"), $n = Cn.get("orient");
        (!Ln || Ln === "auto") && (Ln = Cn.get("left") === "right" && $n === "vertical" ? "right" : "left");
        var Nn = Cn.get("selector", !0), Rn = Cn.get("selectorPosition", !0);
        Nn && (!Rn || Rn === "auto") && (Rn = $n === "horizontal" ? "end" : "start"), this.renderInner(Ln, Cn, Bn, In, Nn, $n, Rn);
        var Fn = Cn.getBoxLayoutParams(), Pn = {
          width: In.getWidth(),
          height: In.getHeight()
        }, Un = Cn.get("padding"), Hn = getLayoutRect$1(Fn, Pn, Un), zn = this.layoutInner(Cn, Ln, Hn, Dn, Nn, Rn), Gn = getLayoutRect$1(defaults({
          width: zn.width,
          height: zn.height
        }, Fn), Pn, Un);
        this.group.x = Gn.x - zn.x, this.group.y = Gn.y - zn.y, this.group.markRedraw(), this.group.add(this._backgroundEl = makeBackground(zn, Cn));
      }
    }, nr.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, nr.prototype.renderInner = function(Cn, Bn, In, Dn, Ln, $n, Nn) {
      var Rn = this.getContentGroup(), Fn = createHashMap(), Pn = Bn.get("selectedMode"), Un = [];
      In.eachRawSeries(function(Hn) {
        !Hn.get("legendHoverLink") && Un.push(Hn.id);
      }), each$3(Bn.getData(), function(Hn, zn) {
        var Gn = Hn.get("name");
        if (!this.newlineDisabled && (Gn === "" || Gn === `
`)) {
          var Yn = new Group$1();
          Yn.newline = !0, Rn.add(Yn);
          return;
        }
        var Wn = In.getSeriesByName(Gn)[0];
        if (!Fn.get(Gn)) {
          if (Wn) {
            var Xn = Wn.getData(), ea = Xn.getVisual("legendLineStyle") || {}, ta = Xn.getVisual("legendIcon"), na = Xn.getVisual("style"), ra = this._createItem(Wn, Gn, zn, Hn, Bn, Cn, ea, na, ta, Pn, Dn);
            ra.on("click", curry(dispatchSelectAction, Gn, null, Dn, Un)).on("mouseover", curry(dispatchHighlightAction, Wn.name, null, Dn, Un)).on("mouseout", curry(dispatchDownplayAction, Wn.name, null, Dn, Un)), In.ssr && ra.eachChild(function(aa) {
              var ia = getECData(aa);
              ia.seriesIndex = Wn.seriesIndex, ia.dataIndex = zn, ia.ssrType = "legend";
            }), Fn.set(Gn, !0);
          } else
            In.eachRawSeries(function(aa) {
              if (!Fn.get(Gn) && aa.legendVisualProvider) {
                var ia = aa.legendVisualProvider;
                if (!ia.containName(Gn))
                  return;
                var Aa = ia.indexOfName(Gn), sa = ia.getItemVisual(Aa, "style"), oa = ia.getItemVisual(Aa, "legendIcon"), la = parse$2(sa.fill);
                la && la[3] === 0 && (la[3] = 0.2, sa = extend(extend({}, sa), {
                  fill: stringify$1(la, "rgba")
                }));
                var ua = this._createItem(aa, Gn, zn, Hn, Bn, Cn, {}, sa, oa, Pn, Dn);
                ua.on("click", curry(dispatchSelectAction, null, Gn, Dn, Un)).on("mouseover", curry(dispatchHighlightAction, null, Gn, Dn, Un)).on("mouseout", curry(dispatchDownplayAction, null, Gn, Dn, Un)), In.ssr && ua.eachChild(function(ca) {
                  var fa = getECData(ca);
                  fa.seriesIndex = aa.seriesIndex, fa.dataIndex = zn, fa.ssrType = "legend";
                }), Fn.set(Gn, !0);
              }
            }, this);
          process.env.NODE_ENV !== "production" && (Fn.get(Gn) || console.warn(Gn + " series not exists. Legend data should be same with series name or data name."));
        }
      }, this), Ln && this._createSelector(Ln, Bn, Dn, $n, Nn);
    }, nr.prototype._createSelector = function(Cn, Bn, In, Dn, Ln) {
      var $n = this.getSelectorGroup();
      each$3(Cn, function(Rn) {
        var Fn = Rn.type, Pn = new ZRText$1({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            In.dispatchAction({
              type: Fn === "all" ? "legendAllSelect" : "legendInverseSelect",
              legendId: Bn.id
            });
          }
        });
        $n.add(Pn);
        var Un = Bn.getModel("selectorLabel"), Hn = Bn.getModel(["emphasis", "selectorLabel"]);
        setLabelStyle(Pn, {
          normal: Un,
          emphasis: Hn
        }, {
          defaultText: Rn.title
        }), enableHoverEmphasis(Pn);
      });
    }, nr.prototype._createItem = function(Cn, Bn, In, Dn, Ln, $n, Nn, Rn, Fn, Pn, Un) {
      var Hn = Cn.visualDrawType, zn = Ln.get("itemWidth"), Gn = Ln.get("itemHeight"), Yn = Ln.isSelected(Bn), Wn = Dn.get("symbolRotate"), Xn = Dn.get("symbolKeepAspect"), ea = Dn.get("icon");
      Fn = ea || Fn || "roundRect";
      var ta = getLegendStyle(Fn, Dn, Nn, Rn, Hn, Yn, Un), na = new Group$1(), ra = Dn.getModel("textStyle");
      if (isFunction$1(Cn.getLegendIcon) && (!ea || ea === "inherit"))
        na.add(Cn.getLegendIcon({
          itemWidth: zn,
          itemHeight: Gn,
          icon: Fn,
          iconRotate: Wn,
          itemStyle: ta.itemStyle,
          lineStyle: ta.lineStyle,
          symbolKeepAspect: Xn
        }));
      else {
        var aa = ea === "inherit" && Cn.getData().getVisual("symbol") ? Wn === "inherit" ? Cn.getData().getVisual("symbolRotate") : Wn : 0;
        na.add(getDefaultLegendIcon({
          itemWidth: zn,
          itemHeight: Gn,
          icon: Fn,
          iconRotate: aa,
          itemStyle: ta.itemStyle,
          lineStyle: ta.lineStyle,
          symbolKeepAspect: Xn
        }));
      }
      var ia = $n === "left" ? zn + 5 : -5, Aa = $n, sa = Ln.get("formatter"), oa = Bn;
      isString$1(sa) && sa ? oa = sa.replace("{name}", Bn ?? "") : isFunction$1(sa) && (oa = sa(Bn));
      var la = Yn ? ra.getTextColor() : Dn.get("inactiveColor");
      na.add(new ZRText$1({
        style: createTextStyle$1(ra, {
          text: oa,
          x: ia,
          y: Gn / 2,
          fill: la,
          align: Aa,
          verticalAlign: "middle"
        }, {
          inheritColor: la
        })
      }));
      var ua = new Rect$3({
        shape: na.getBoundingRect(),
        style: {
          // Cannot use 'invisible' because SVG SSR will miss the node
          fill: "transparent"
        }
      }), ca = Dn.getModel("tooltip");
      return ca.get("show") && setTooltipConfig({
        el: ua,
        componentModel: Ln,
        itemName: Bn,
        itemTooltipOption: ca.option
      }), na.add(ua), na.eachChild(function(fa) {
        fa.silent = !0;
      }), ua.silent = !Pn, this.getContentGroup().add(na), enableHoverEmphasis(na), na.__legendDataIndex = In, na;
    }, nr.prototype.layoutInner = function(Cn, Bn, In, Dn, Ln, $n) {
      var Nn = this.getContentGroup(), Rn = this.getSelectorGroup();
      box(Cn.get("orient"), Nn, Cn.get("itemGap"), In.width, In.height);
      var Fn = Nn.getBoundingRect(), Pn = [-Fn.x, -Fn.y];
      if (Rn.markRedraw(), Nn.markRedraw(), Ln) {
        box(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          Rn,
          Cn.get("selectorItemGap", !0)
        );
        var Un = Rn.getBoundingRect(), Hn = [-Un.x, -Un.y], zn = Cn.get("selectorButtonGap", !0), Gn = Cn.getOrient().index, Yn = Gn === 0 ? "width" : "height", Wn = Gn === 0 ? "height" : "width", Xn = Gn === 0 ? "y" : "x";
        $n === "end" ? Hn[Gn] += Fn[Yn] + zn : Pn[Gn] += Un[Yn] + zn, Hn[1 - Gn] += Fn[Wn] / 2 - Un[Wn] / 2, Rn.x = Hn[0], Rn.y = Hn[1], Nn.x = Pn[0], Nn.y = Pn[1];
        var ea = {
          x: 0,
          y: 0
        };
        return ea[Yn] = Fn[Yn] + zn + Un[Yn], ea[Wn] = Math.max(Fn[Wn], Un[Wn]), ea[Xn] = Math.min(0, Un[Xn] + Hn[1 - Gn]), ea;
      } else
        return Nn.x = Pn[0], Nn.y = Pn[1], this.group.getBoundingRect();
    }, nr.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, nr.type = "legend.plain", nr;
  }(ComponentView$1)
);
function getLegendStyle(_n, nr, Cn, Bn, In, Dn, Ln) {
  function $n(Yn, Wn) {
    Yn.lineWidth === "auto" && (Yn.lineWidth = Wn.lineWidth > 0 ? 2 : 0), each$3(Yn, function(Xn, ea) {
      Yn[ea] === "inherit" && (Yn[ea] = Wn[ea]);
    });
  }
  var Nn = nr.getModel("itemStyle"), Rn = Nn.getItemStyle(), Fn = _n.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", Pn = Nn.getShallow("decal");
  Rn.decal = !Pn || Pn === "inherit" ? Bn.decal : createOrUpdatePatternFromDecal(Pn, Ln), Rn.fill === "inherit" && (Rn.fill = Bn[In]), Rn.stroke === "inherit" && (Rn.stroke = Bn[Fn]), Rn.opacity === "inherit" && (Rn.opacity = (In === "fill" ? Bn : Cn).opacity), $n(Rn, Bn);
  var Un = nr.getModel("lineStyle"), Hn = Un.getLineStyle();
  if ($n(Hn, Cn), Rn.fill === "auto" && (Rn.fill = Bn.fill), Rn.stroke === "auto" && (Rn.stroke = Bn.fill), Hn.stroke === "auto" && (Hn.stroke = Bn.fill), !Dn) {
    var zn = nr.get("inactiveBorderWidth"), Gn = Rn[Fn];
    Rn.lineWidth = zn === "auto" ? Bn.lineWidth > 0 && Gn ? 2 : 0 : Rn.lineWidth, Rn.fill = nr.get("inactiveColor"), Rn.stroke = nr.get("inactiveBorderColor"), Hn.stroke = Un.get("inactiveColor"), Hn.lineWidth = Un.get("inactiveWidth");
  }
  return {
    itemStyle: Rn,
    lineStyle: Hn
  };
}
function getDefaultLegendIcon(_n) {
  var nr = _n.icon || "roundRect", Cn = createSymbol$1(nr, 0, 0, _n.itemWidth, _n.itemHeight, _n.itemStyle.fill, _n.symbolKeepAspect);
  return Cn.setStyle(_n.itemStyle), Cn.rotation = (_n.iconRotate || 0) * Math.PI / 180, Cn.setOrigin([_n.itemWidth / 2, _n.itemHeight / 2]), nr.indexOf("empty") > -1 && (Cn.style.stroke = Cn.style.fill, Cn.style.fill = "#fff", Cn.style.lineWidth = 2), Cn;
}
function dispatchSelectAction(_n, nr, Cn, Bn) {
  dispatchDownplayAction(_n, nr, Cn, Bn), Cn.dispatchAction({
    type: "legendToggleSelect",
    name: _n ?? nr
  }), dispatchHighlightAction(_n, nr, Cn, Bn);
}
function isUseHoverLayer(_n) {
  for (var nr = _n.getZr().storage.getDisplayList(), Cn, Bn = 0, In = nr.length; Bn < In && !(Cn = nr[Bn].states.emphasis); )
    Bn++;
  return Cn && Cn.hoverLayer;
}
function dispatchHighlightAction(_n, nr, Cn, Bn) {
  isUseHoverLayer(Cn) || Cn.dispatchAction({
    type: "highlight",
    seriesName: _n,
    name: nr,
    excludeSeriesId: Bn
  });
}
function dispatchDownplayAction(_n, nr, Cn, Bn) {
  isUseHoverLayer(Cn) || Cn.dispatchAction({
    type: "downplay",
    seriesName: _n,
    name: nr,
    excludeSeriesId: Bn
  });
}
const LegendView$1 = LegendView;
function legendFilter(_n) {
  var nr = _n.findComponents({
    mainType: "legend"
  });
  nr && nr.length && _n.filterSeries(function(Cn) {
    for (var Bn = 0; Bn < nr.length; Bn++)
      if (!nr[Bn].isSelected(Cn.name))
        return !1;
    return !0;
  });
}
function legendSelectActionHandler(_n, nr, Cn) {
  var Bn = _n === "allSelect" || _n === "inverseSelect", In = {}, Dn = [];
  Cn.eachComponent({
    mainType: "legend",
    query: nr
  }, function($n) {
    Bn ? $n[_n]() : $n[_n](nr.name), makeSelectedMap($n, In), Dn.push($n.componentIndex);
  });
  var Ln = {};
  return Cn.eachComponent("legend", function($n) {
    each$f(In, function(Nn, Rn) {
      $n[Nn ? "select" : "unSelect"](Rn);
    }), makeSelectedMap($n, Ln);
  }), Bn ? {
    selected: Ln,
    // return legendIndex array to tell the developers which legends are allSelect / inverseSelect
    legendIndex: Dn
  } : {
    name: nr.name,
    selected: Ln
  };
}
function makeSelectedMap(_n, nr) {
  var Cn = nr || {};
  return each$f(_n.getData(), function(Bn) {
    var In = Bn.get("name");
    if (!(In === `
` || In === "")) {
      var Dn = _n.isSelected(In);
      hasOwn(Cn, In) ? Cn[In] = Cn[In] && Dn : Cn[In] = Dn;
    }
  }), Cn;
}
function installLegendAction(_n) {
  _n.registerAction("legendToggleSelect", "legendselectchanged", curry$1(legendSelectActionHandler, "toggleSelected")), _n.registerAction("legendAllSelect", "legendselectall", curry$1(legendSelectActionHandler, "allSelect")), _n.registerAction("legendInverseSelect", "legendinverseselect", curry$1(legendSelectActionHandler, "inverseSelect")), _n.registerAction("legendSelect", "legendselected", curry$1(legendSelectActionHandler, "select")), _n.registerAction("legendUnSelect", "legendunselected", curry$1(legendSelectActionHandler, "unSelect"));
}
function install$b(_n) {
  _n.registerComponentModel(LegendModel$1), _n.registerComponentView(LegendView$1), _n.registerProcessor(_n.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter), _n.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), installLegendAction(_n);
}
var ScrollableLegendModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.setScrollDataIndex = function(Cn) {
      this.option.scrollDataIndex = Cn;
    }, nr.prototype.init = function(Cn, Bn, In) {
      var Dn = getLayoutParams(Cn);
      _n.prototype.init.call(this, Cn, Bn, In), mergeAndNormalizeLayoutParams(this, Cn, Dn);
    }, nr.prototype.mergeOption = function(Cn, Bn) {
      _n.prototype.mergeOption.call(this, Cn, Bn), mergeAndNormalizeLayoutParams(this, this.option, Cn);
    }, nr.type = "legend.scroll", nr.defaultOption = inheritDefaultOption(LegendModel$1.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), nr;
  }(LegendModel$1)
);
function mergeAndNormalizeLayoutParams(_n, nr, Cn) {
  var Bn = _n.getOrient(), In = [1, 1];
  In[Bn.index] = 0, mergeLayoutParam(nr, Cn, {
    type: "box",
    ignoreSize: !!In
  });
}
const ScrollableLegendModel$1 = ScrollableLegendModel;
var Group = Group$4, WH = ["width", "height"], XY = ["x", "y"], ScrollableLegendView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.newlineDisabled = !0, Cn._currentIndex = 0, Cn;
    }
    return nr.prototype.init = function() {
      _n.prototype.init.call(this), this.group.add(this._containerGroup = new Group()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new Group());
    }, nr.prototype.resetInner = function() {
      _n.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, nr.prototype.renderInner = function(Cn, Bn, In, Dn, Ln, $n, Nn) {
      var Rn = this;
      _n.prototype.renderInner.call(this, Cn, Bn, In, Dn, Ln, $n, Nn);
      var Fn = this._controllerGroup, Pn = Bn.get("pageIconSize", !0), Un = isArray$4(Pn) ? Pn : [Pn, Pn];
      zn("pagePrev", 0);
      var Hn = Bn.getModel("pageTextStyle");
      Fn.add(new ZRText$1({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: Hn.getTextColor(),
          font: Hn.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), zn("pageNext", 1);
      function zn(Gn, Yn) {
        var Wn = Gn + "DataIndex", Xn = createIcon(Bn.get("pageIcons", !0)[Bn.getOrient().name][Yn], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: bind$1(Rn._pageGo, Rn, Wn, Bn, Dn)
        }, {
          x: -Un[0] / 2,
          y: -Un[1] / 2,
          width: Un[0],
          height: Un[1]
        });
        Xn.name = Gn, Fn.add(Xn);
      }
    }, nr.prototype.layoutInner = function(Cn, Bn, In, Dn, Ln, $n) {
      var Nn = this.getSelectorGroup(), Rn = Cn.getOrient().index, Fn = WH[Rn], Pn = XY[Rn], Un = WH[1 - Rn], Hn = XY[1 - Rn];
      Ln && box(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        Nn,
        Cn.get("selectorItemGap", !0)
      );
      var zn = Cn.get("selectorButtonGap", !0), Gn = Nn.getBoundingRect(), Yn = [-Gn.x, -Gn.y], Wn = clone$4(In);
      Ln && (Wn[Fn] = In[Fn] - Gn[Fn] - zn);
      var Xn = this._layoutContentAndController(Cn, Dn, Wn, Rn, Fn, Un, Hn, Pn);
      if (Ln) {
        if ($n === "end")
          Yn[Rn] += Xn[Fn] + zn;
        else {
          var ea = Gn[Fn] + zn;
          Yn[Rn] -= ea, Xn[Pn] -= ea;
        }
        Xn[Fn] += Gn[Fn] + zn, Yn[1 - Rn] += Xn[Hn] + Xn[Un] / 2 - Gn[Un] / 2, Xn[Un] = Math.max(Xn[Un], Gn[Un]), Xn[Hn] = Math.min(Xn[Hn], Gn[Hn] + Yn[1 - Rn]), Nn.x = Yn[0], Nn.y = Yn[1], Nn.markRedraw();
      }
      return Xn;
    }, nr.prototype._layoutContentAndController = function(Cn, Bn, In, Dn, Ln, $n, Nn, Rn) {
      var Fn = this.getContentGroup(), Pn = this._containerGroup, Un = this._controllerGroup;
      box(Cn.get("orient"), Fn, Cn.get("itemGap"), Dn ? In.width : null, Dn ? null : In.height), box(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        Un,
        Cn.get("pageButtonItemGap", !0)
      );
      var Hn = Fn.getBoundingRect(), zn = Un.getBoundingRect(), Gn = this._showController = Hn[Ln] > In[Ln], Yn = [-Hn.x, -Hn.y];
      Bn || (Yn[Dn] = Fn[Rn]);
      var Wn = [0, 0], Xn = [-zn.x, -zn.y], ea = retrieve2(Cn.get("pageButtonGap", !0), Cn.get("itemGap", !0));
      if (Gn) {
        var ta = Cn.get("pageButtonPosition", !0);
        ta === "end" ? Xn[Dn] += In[Ln] - zn[Ln] : Wn[Dn] += zn[Ln] + ea;
      }
      Xn[1 - Dn] += Hn[$n] / 2 - zn[$n] / 2, Fn.setPosition(Yn), Pn.setPosition(Wn), Un.setPosition(Xn);
      var na = {
        x: 0,
        y: 0
      };
      if (na[Ln] = Gn ? In[Ln] : Hn[Ln], na[$n] = Math.max(Hn[$n], zn[$n]), na[Nn] = Math.min(0, zn[Nn] + Xn[1 - Dn]), Pn.__rectSize = In[Ln], Gn) {
        var ra = {
          x: 0,
          y: 0
        };
        ra[Ln] = Math.max(In[Ln] - zn[Ln] - ea, 0), ra[$n] = na[$n], Pn.setClipPath(new Rect$3({
          shape: ra
        })), Pn.__rectSize = ra[Ln];
      } else
        Un.eachChild(function(ia) {
          ia.attr({
            invisible: !0,
            silent: !0
          });
        });
      var aa = this._getPageInfo(Cn);
      return aa.pageIndex != null && updateProps$1(
        Fn,
        {
          x: aa.contentPosition[0],
          y: aa.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        Gn ? Cn : null
      ), this._updatePageInfoView(Cn, aa), na;
    }, nr.prototype._pageGo = function(Cn, Bn, In) {
      var Dn = this._getPageInfo(Bn)[Cn];
      Dn != null && In.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: Dn,
        legendId: Bn.id
      });
    }, nr.prototype._updatePageInfoView = function(Cn, Bn) {
      var In = this._controllerGroup;
      each$f(["pagePrev", "pageNext"], function(Fn) {
        var Pn = Fn + "DataIndex", Un = Bn[Pn] != null, Hn = In.childOfName(Fn);
        Hn && (Hn.setStyle("fill", Un ? Cn.get("pageIconColor", !0) : Cn.get("pageIconInactiveColor", !0)), Hn.cursor = Un ? "pointer" : "default");
      });
      var Dn = In.childOfName("pageText"), Ln = Cn.get("pageFormatter"), $n = Bn.pageIndex, Nn = $n != null ? $n + 1 : 0, Rn = Bn.pageCount;
      Dn && Ln && Dn.setStyle("text", isString$1(Ln) ? Ln.replace("{current}", Nn == null ? "" : Nn + "").replace("{total}", Rn == null ? "" : Rn + "") : Ln({
        current: Nn,
        total: Rn
      }));
    }, nr.prototype._getPageInfo = function(Cn) {
      var Bn = Cn.get("scrollDataIndex", !0), In = this.getContentGroup(), Dn = this._containerGroup.__rectSize, Ln = Cn.getOrient().index, $n = WH[Ln], Nn = XY[Ln], Rn = this._findTargetItemIndex(Bn), Fn = In.children(), Pn = Fn[Rn], Un = Fn.length, Hn = Un ? 1 : 0, zn = {
        contentPosition: [In.x, In.y],
        pageCount: Hn,
        pageIndex: Hn - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!Pn)
        return zn;
      var Gn = ta(Pn);
      zn.contentPosition[Ln] = -Gn.s;
      for (var Yn = Rn + 1, Wn = Gn, Xn = Gn, ea = null; Yn <= Un; ++Yn)
        ea = ta(Fn[Yn]), // Half of the last item is out of the window.
        (!ea && Xn.e > Wn.s + Dn || ea && !na(ea, Wn.s)) && (Xn.i > Wn.i ? Wn = Xn : Wn = ea, Wn && (zn.pageNextDataIndex == null && (zn.pageNextDataIndex = Wn.i), ++zn.pageCount)), Xn = ea;
      for (var Yn = Rn - 1, Wn = Gn, Xn = Gn, ea = null; Yn >= -1; --Yn)
        ea = ta(Fn[Yn]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!ea || !na(Xn, ea.s)) && Wn.i < Xn.i && (Xn = Wn, zn.pagePrevDataIndex == null && (zn.pagePrevDataIndex = Wn.i), ++zn.pageCount, ++zn.pageIndex), Wn = ea;
      return zn;
      function ta(ra) {
        if (ra) {
          var aa = ra.getBoundingRect(), ia = aa[Nn] + ra[Nn];
          return {
            s: ia,
            e: ia + aa[$n],
            i: ra.__legendDataIndex
          };
        }
      }
      function na(ra, aa) {
        return ra.e >= aa && ra.s <= aa + Dn;
      }
    }, nr.prototype._findTargetItemIndex = function(Cn) {
      if (!this._showController)
        return 0;
      var Bn, In = this.getContentGroup(), Dn;
      return In.eachChild(function(Ln, $n) {
        var Nn = Ln.__legendDataIndex;
        Dn == null && Nn != null && (Dn = $n), Nn === Cn && (Bn = $n);
      }), Bn ?? Dn;
    }, nr.type = "legend.scroll", nr;
  }(LegendView$1)
);
const ScrollableLegendView$1 = ScrollableLegendView;
function installScrollableLegendAction(_n) {
  _n.registerAction("legendScroll", "legendscroll", function(nr, Cn) {
    var Bn = nr.scrollDataIndex;
    Bn != null && Cn.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: nr
    }, function(In) {
      In.setScrollDataIndex(Bn);
    });
  });
}
function install$a(_n) {
  use(install$b), _n.registerComponentModel(ScrollableLegendModel$1), _n.registerComponentView(ScrollableLegendView$1), installScrollableLegendAction(_n);
}
function install$9(_n) {
  use(install$b), use(install$a);
}
var InsideZoomModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "dataZoom.inside", nr.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), nr;
  }(DataZoomModel$1)
);
const InsideZoomModel$1 = InsideZoomModel;
var inner$1 = makeInner();
function setViewInfoToCoordSysRecord(_n, nr, Cn) {
  inner$1(_n).coordSysRecordMap.each(function(Bn) {
    var In = Bn.dataZoomInfoMap.get(nr.uid);
    In && (In.getRange = Cn);
  });
}
function disposeCoordSysRecordIfNeeded(_n, nr) {
  for (var Cn = inner$1(_n).coordSysRecordMap, Bn = Cn.keys(), In = 0; In < Bn.length; In++) {
    var Dn = Bn[In], Ln = Cn.get(Dn), $n = Ln.dataZoomInfoMap;
    if ($n) {
      var Nn = nr.uid, Rn = $n.get(Nn);
      Rn && ($n.removeKey(Nn), $n.keys().length || disposeCoordSysRecord(Cn, Ln));
    }
  }
}
function disposeCoordSysRecord(_n, nr) {
  if (nr) {
    _n.removeKey(nr.model.uid);
    var Cn = nr.controller;
    Cn && Cn.dispose();
  }
}
function createCoordSysRecord(_n, nr) {
  var Cn = {
    model: nr,
    containsPoint: curry$1(containsPoint, nr),
    dispatchAction: curry$1(dispatchAction, _n),
    dataZoomInfoMap: null,
    controller: null
  }, Bn = Cn.controller = new RoamController$1(_n.getZr());
  return each$f(["pan", "zoom", "scrollMove"], function(In) {
    Bn.on(In, function(Dn) {
      var Ln = [];
      Cn.dataZoomInfoMap.each(function($n) {
        if (Dn.isAvailableBehavior($n.model.option)) {
          var Nn = ($n.getRange || {})[In], Rn = Nn && Nn($n.dzReferCoordSysInfo, Cn.model.mainType, Cn.controller, Dn);
          !$n.model.get("disabled", !0) && Rn && Ln.push({
            dataZoomId: $n.model.id,
            start: Rn[0],
            end: Rn[1]
          });
        }
      }), Ln.length && Cn.dispatchAction(Ln);
    });
  }), Cn;
}
function dispatchAction(_n, nr) {
  _n.isDisposed() || _n.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: nr
  });
}
function containsPoint(_n, nr, Cn, Bn) {
  return _n.coordinateSystem.containPoint([Cn, Bn]);
}
function mergeControllerParams(_n) {
  var nr, Cn = "type_", Bn = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, In = !0;
  return _n.each(function(Dn) {
    var Ln = Dn.model, $n = Ln.get("disabled", !0) ? !1 : Ln.get("zoomLock", !0) ? "move" : !0;
    Bn[Cn + $n] > Bn[Cn + nr] && (nr = $n), In = In && Ln.get("preventDefaultMouseMove", !0);
  }), {
    controlType: nr,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!In
    }
  };
}
function installDataZoomRoamProcessor(_n) {
  _n.registerProcessor(_n.PRIORITY.PROCESSOR.FILTER, function(nr, Cn) {
    var Bn = inner$1(Cn), In = Bn.coordSysRecordMap || (Bn.coordSysRecordMap = createHashMap());
    In.each(function(Dn) {
      Dn.dataZoomInfoMap = null;
    }), nr.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(Dn) {
      var Ln = collectReferCoordSysModelInfo(Dn);
      each$f(Ln.infoList, function($n) {
        var Nn = $n.model.uid, Rn = In.get(Nn) || In.set(Nn, createCoordSysRecord(Cn, $n.model)), Fn = Rn.dataZoomInfoMap || (Rn.dataZoomInfoMap = createHashMap());
        Fn.set(Dn.uid, {
          dzReferCoordSysInfo: $n,
          model: Dn,
          getRange: null
        });
      });
    }), In.each(function(Dn) {
      var Ln = Dn.controller, $n, Nn = Dn.dataZoomInfoMap;
      if (Nn) {
        var Rn = Nn.keys()[0];
        Rn != null && ($n = Nn.get(Rn));
      }
      if (!$n) {
        disposeCoordSysRecord(In, Dn);
        return;
      }
      var Fn = mergeControllerParams(Nn);
      Ln.enable(Fn.controlType, Fn.opt), Ln.setPointerChecker(Dn.containsPoint), createOrUpdate(Dn, "dispatchAction", $n.model.get("throttle", !0), "fixRate");
    });
  });
}
var InsideZoomView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = "dataZoom.inside", Cn;
    }
    return nr.prototype.render = function(Cn, Bn, In) {
      if (_n.prototype.render.apply(this, arguments), Cn.noTarget()) {
        this._clear();
        return;
      }
      this.range = Cn.getPercentRange(), setViewInfoToCoordSysRecord(In, Cn, {
        pan: bind$1(getRangeHandlers.pan, this),
        zoom: bind$1(getRangeHandlers.zoom, this),
        scrollMove: bind$1(getRangeHandlers.scrollMove, this)
      });
    }, nr.prototype.dispose = function() {
      this._clear(), _n.prototype.dispose.apply(this, arguments);
    }, nr.prototype._clear = function() {
      disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel), this.range = null;
    }, nr.type = "dataZoom.inside", nr;
  }(DataZoomView$1)
), getRangeHandlers = {
  zoom: function(_n, nr, Cn, Bn) {
    var In = this.range, Dn = In.slice(), Ln = _n.axisModels[0];
    if (Ln) {
      var $n = getDirectionInfo[nr](null, [Bn.originX, Bn.originY], Ln, Cn, _n), Nn = ($n.signal > 0 ? $n.pixelStart + $n.pixelLength - $n.pixel : $n.pixel - $n.pixelStart) / $n.pixelLength * (Dn[1] - Dn[0]) + Dn[0], Rn = Math.max(1 / Bn.scale, 0);
      Dn[0] = (Dn[0] - Nn) * Rn + Nn, Dn[1] = (Dn[1] - Nn) * Rn + Nn;
      var Fn = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (sliderMove(0, Dn, [0, 100], 0, Fn.minSpan, Fn.maxSpan), this.range = Dn, In[0] !== Dn[0] || In[1] !== Dn[1])
        return Dn;
    }
  },
  pan: makeMover(function(_n, nr, Cn, Bn, In, Dn) {
    var Ln = getDirectionInfo[Bn]([Dn.oldX, Dn.oldY], [Dn.newX, Dn.newY], nr, In, Cn);
    return Ln.signal * (_n[1] - _n[0]) * Ln.pixel / Ln.pixelLength;
  }),
  scrollMove: makeMover(function(_n, nr, Cn, Bn, In, Dn) {
    var Ln = getDirectionInfo[Bn]([0, 0], [Dn.scrollDelta, Dn.scrollDelta], nr, In, Cn);
    return Ln.signal * (_n[1] - _n[0]) * Dn.scrollDelta;
  })
};
function makeMover(_n) {
  return function(nr, Cn, Bn, In) {
    var Dn = this.range, Ln = Dn.slice(), $n = nr.axisModels[0];
    if ($n) {
      var Nn = _n(Ln, $n, nr, Cn, Bn, In);
      if (sliderMove(Nn, Ln, [0, 100], "all"), this.range = Ln, Dn[0] !== Ln[0] || Dn[1] !== Ln[1])
        return Ln;
    }
  };
}
var getDirectionInfo = {
  grid: function(_n, nr, Cn, Bn, In) {
    var Dn = Cn.axis, Ln = {}, $n = In.model.coordinateSystem.getRect();
    return _n = _n || [0, 0], Dn.dim === "x" ? (Ln.pixel = nr[0] - _n[0], Ln.pixelLength = $n.width, Ln.pixelStart = $n.x, Ln.signal = Dn.inverse ? 1 : -1) : (Ln.pixel = nr[1] - _n[1], Ln.pixelLength = $n.height, Ln.pixelStart = $n.y, Ln.signal = Dn.inverse ? -1 : 1), Ln;
  },
  polar: function(_n, nr, Cn, Bn, In) {
    var Dn = Cn.axis, Ln = {}, $n = In.model.coordinateSystem, Nn = $n.getRadiusAxis().getExtent(), Rn = $n.getAngleAxis().getExtent();
    return _n = _n ? $n.pointToCoord(_n) : [0, 0], nr = $n.pointToCoord(nr), Cn.mainType === "radiusAxis" ? (Ln.pixel = nr[0] - _n[0], Ln.pixelLength = Nn[1] - Nn[0], Ln.pixelStart = Nn[0], Ln.signal = Dn.inverse ? 1 : -1) : (Ln.pixel = nr[1] - _n[1], Ln.pixelLength = Rn[1] - Rn[0], Ln.pixelStart = Rn[0], Ln.signal = Dn.inverse ? -1 : 1), Ln;
  },
  singleAxis: function(_n, nr, Cn, Bn, In) {
    var Dn = Cn.axis, Ln = In.model.coordinateSystem.getRect(), $n = {};
    return _n = _n || [0, 0], Dn.orient === "horizontal" ? ($n.pixel = nr[0] - _n[0], $n.pixelLength = Ln.width, $n.pixelStart = Ln.x, $n.signal = Dn.inverse ? 1 : -1) : ($n.pixel = nr[1] - _n[1], $n.pixelLength = Ln.height, $n.pixelStart = Ln.y, $n.signal = Dn.inverse ? -1 : 1), $n;
  }
};
const InsideZoomView$1 = InsideZoomView;
function install$8(_n) {
  installCommon$1(_n), _n.registerComponentModel(InsideZoomModel$1), _n.registerComponentView(InsideZoomView$1), installDataZoomRoamProcessor(_n);
}
var SliderZoomModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.type = "dataZoom.slider", nr.layoutMode = "box", nr.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: !0,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleLabel: {
          show: !0
        },
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), nr;
  }(DataZoomModel$1)
);
const SliderZoomModel$1 = SliderZoomModel;
var Rect = Rect$3, DEFAULT_LOCATION_EDGE_GAP = 7, DEFAULT_FRAME_BORDER_WIDTH = 1, DEFAULT_FILLER_SIZE = 30, DEFAULT_MOVE_HANDLE_SIZE = 7, HORIZONTAL = "horizontal", VERTICAL = "vertical", LABEL_GAP = 5, SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"], REALTIME_ANIMATION_CONFIG = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, SliderZoomView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn._displayables = {}, Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      this.api = Bn, this._onBrush = bind$1(this._onBrush, this), this._onBrushEnd = bind$1(this._onBrushEnd, this);
    }, nr.prototype.render = function(Cn, Bn, In, Dn) {
      if (_n.prototype.render.apply(this, arguments), createOrUpdate(this, "_dispatchZoomAction", Cn.get("throttle"), "fixRate"), this._orient = Cn.getOrient(), Cn.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (Cn.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!Dn || Dn.type !== "dataZoom" || Dn.from !== this.uid) && this._buildView(), this._updateView();
    }, nr.prototype.dispose = function() {
      this._clear(), _n.prototype.dispose.apply(this, arguments);
    }, nr.prototype._clear = function() {
      clear$1(this, "_dispatchZoomAction");
      var Cn = this.api.getZr();
      Cn.off("mousemove", this._onBrush), Cn.off("mouseup", this._onBrushEnd);
    }, nr.prototype._buildView = function() {
      var Cn = this.group;
      Cn.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var Bn = this._displayables.sliderGroup = new Group$4();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), Cn.add(Bn), this._positionGroup();
    }, nr.prototype._resetLocation = function() {
      var Cn = this.dataZoomModel, Bn = this.api, In = Cn.get("brushSelect"), Dn = In ? DEFAULT_MOVE_HANDLE_SIZE : 0, Ln = this._findCoordRect(), $n = {
        width: Bn.getWidth(),
        height: Bn.getHeight()
      }, Nn = this._orient === HORIZONTAL ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: $n.width - Ln.x - Ln.width,
        top: $n.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - Dn,
        width: Ln.width,
        height: DEFAULT_FILLER_SIZE
      } : {
        right: DEFAULT_LOCATION_EDGE_GAP,
        top: Ln.y,
        width: DEFAULT_FILLER_SIZE,
        height: Ln.height
      }, Rn = getLayoutParams(Cn.option);
      each$f(["right", "top", "width", "height"], function(Pn) {
        Rn[Pn] === "ph" && (Rn[Pn] = Nn[Pn]);
      });
      var Fn = getLayoutRect$1(Rn, $n);
      this._location = {
        x: Fn.x,
        y: Fn.y
      }, this._size = [Fn.width, Fn.height], this._orient === VERTICAL && this._size.reverse();
    }, nr.prototype._positionGroup = function() {
      var Cn = this.group, Bn = this._location, In = this._orient, Dn = this.dataZoomModel.getFirstTargetAxisModel(), Ln = Dn && Dn.get("inverse"), $n = this._displayables.sliderGroup, Nn = (this._dataShadowInfo || {}).otherAxisInverse;
      $n.attr(In === HORIZONTAL && !Ln ? {
        scaleY: Nn ? 1 : -1,
        scaleX: 1
      } : In === HORIZONTAL && Ln ? {
        scaleY: Nn ? 1 : -1,
        scaleX: -1
      } : In === VERTICAL && !Ln ? {
        scaleY: Nn ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: Nn ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var Rn = Cn.getBoundingRect([$n]);
      Cn.x = Bn.x - Rn.x, Cn.y = Bn.y - Rn.y, Cn.markRedraw();
    }, nr.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, nr.prototype._renderBackground = function() {
      var Cn = this.dataZoomModel, Bn = this._size, In = this._displayables.sliderGroup, Dn = Cn.get("brushSelect");
      In.add(new Rect({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: Bn[0],
          height: Bn[1]
        },
        style: {
          fill: Cn.get("backgroundColor")
        },
        z2: -40
      }));
      var Ln = new Rect({
        shape: {
          x: 0,
          y: 0,
          width: Bn[0],
          height: Bn[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: bind$1(this._onClickPanel, this)
      }), $n = this.api.getZr();
      Dn ? (Ln.on("mousedown", this._onBrushStart, this), Ln.cursor = "crosshair", $n.on("mousemove", this._onBrush), $n.on("mouseup", this._onBrushEnd)) : ($n.off("mousemove", this._onBrush), $n.off("mouseup", this._onBrushEnd)), In.add(Ln);
    }, nr.prototype._renderDataShadow = function() {
      var Cn = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !Cn)
        return;
      var Bn = this._size, In = this._shadowSize || [], Dn = Cn.series, Ln = Dn.getRawData(), $n = Dn.getShadowDim && Dn.getShadowDim(), Nn = $n && Ln.getDimensionInfo($n) ? Dn.getShadowDim() : Cn.otherDim;
      if (Nn == null)
        return;
      var Rn = this._shadowPolygonPts, Fn = this._shadowPolylinePts;
      if (Ln !== this._shadowData || Nn !== this._shadowDim || Bn[0] !== In[0] || Bn[1] !== In[1]) {
        var Pn = Ln.getDataExtent(Nn), Un = (Pn[1] - Pn[0]) * 0.3;
        Pn = [Pn[0] - Un, Pn[1] + Un];
        var Hn = [0, Bn[1]], zn = [0, Bn[0]], Gn = [[Bn[0], 0], [0, 0]], Yn = [], Wn = zn[1] / (Ln.count() - 1), Xn = 0, ea = Math.round(Ln.count() / Bn[0]), ta;
        Ln.each([Nn], function(Aa, sa) {
          if (ea > 0 && sa % ea) {
            Xn += Wn;
            return;
          }
          var oa = Aa == null || isNaN(Aa) || Aa === "", la = oa ? 0 : linearMap$2(Aa, Pn, Hn, !0);
          oa && !ta && sa ? (Gn.push([Gn[Gn.length - 1][0], 0]), Yn.push([Yn[Yn.length - 1][0], 0])) : !oa && ta && (Gn.push([Xn, 0]), Yn.push([Xn, 0])), Gn.push([Xn, la]), Yn.push([Xn, la]), Xn += Wn, ta = oa;
        }), Rn = this._shadowPolygonPts = Gn, Fn = this._shadowPolylinePts = Yn;
      }
      this._shadowData = Ln, this._shadowDim = Nn, this._shadowSize = [Bn[0], Bn[1]];
      var na = this.dataZoomModel;
      function ra(Aa) {
        var sa = na.getModel(Aa ? "selectedDataBackground" : "dataBackground"), oa = new Group$4(), la = new Polygon$1({
          shape: {
            points: Rn
          },
          segmentIgnoreThreshold: 1,
          style: sa.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), ua = new Polyline$3({
          shape: {
            points: Fn
          },
          segmentIgnoreThreshold: 1,
          style: sa.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return oa.add(la), oa.add(ua), oa;
      }
      for (var aa = 0; aa < 3; aa++) {
        var ia = ra(aa === 1);
        this._displayables.sliderGroup.add(ia), this._displayables.dataShadowSegs.push(ia);
      }
    }, nr.prototype._prepareDataShadowInfo = function() {
      var Cn = this.dataZoomModel, Bn = Cn.get("showDataShadow");
      if (Bn !== !1) {
        var In, Dn = this.ecModel;
        return Cn.eachTargetAxis(function(Ln, $n) {
          var Nn = Cn.getAxisProxy(Ln, $n).getTargetSeriesModels();
          each$f(Nn, function(Rn) {
            if (!In && !(Bn !== !0 && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, Rn.get("type")) < 0)) {
              var Fn = Dn.getComponent(getAxisMainType(Ln), $n).axis, Pn = getOtherDim(Ln), Un, Hn = Rn.coordinateSystem;
              Pn != null && Hn.getOtherAxis && (Un = Hn.getOtherAxis(Fn).inverse), Pn = Rn.getData().mapDimension(Pn), In = {
                thisAxis: Fn,
                series: Rn,
                thisDim: Ln,
                otherDim: Pn,
                otherAxisInverse: Un
              };
            }
          }, this);
        }, this), In;
      }
    }, nr.prototype._renderHandle = function() {
      var Cn = this.group, Bn = this._displayables, In = Bn.handles = [null, null], Dn = Bn.handleLabels = [null, null], Ln = this._displayables.sliderGroup, $n = this._size, Nn = this.dataZoomModel, Rn = this.api, Fn = Nn.get("borderRadius") || 0, Pn = Nn.get("brushSelect"), Un = Bn.filler = new Rect({
        silent: Pn,
        style: {
          fill: Nn.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      Ln.add(Un), Ln.add(new Rect({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: $n[0],
          height: $n[1],
          r: Fn
        },
        style: {
          // deprecated option
          stroke: Nn.get("dataBackgroundColor") || Nn.get("borderColor"),
          lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
          fill: "rgba(0,0,0,0)"
        }
      })), each$f([0, 1], function(ea) {
        var ta = Nn.get("handleIcon");
        !symbolBuildProxies[ta] && ta.indexOf("path://") < 0 && ta.indexOf("image://") < 0 && (ta = "path://" + ta, process.env.NODE_ENV !== "production" && deprecateLog("handleIcon now needs 'path://' prefix when using a path string"));
        var na = createSymbol$1(ta, -1, 0, 2, 2, null, !0);
        na.attr({
          cursor: getCursor$1(this._orient),
          draggable: !0,
          drift: bind$1(this._onDragMove, this, ea),
          ondragend: bind$1(this._onDragEnd, this),
          onmouseover: bind$1(this._showDataInfo, this, !0),
          onmouseout: bind$1(this._showDataInfo, this, !1),
          z2: 5
        });
        var ra = na.getBoundingRect(), aa = Nn.get("handleSize");
        this._handleHeight = parsePercent(aa, this._size[1]), this._handleWidth = ra.width / ra.height * this._handleHeight, na.setStyle(Nn.getModel("handleStyle").getItemStyle()), na.style.strokeNoScale = !0, na.rectHover = !0, na.ensureState("emphasis").style = Nn.getModel(["emphasis", "handleStyle"]).getItemStyle(), enableHoverEmphasis(na);
        var ia = Nn.get("handleColor");
        ia != null && (na.style.fill = ia), Ln.add(In[ea] = na);
        var Aa = Nn.getModel("textStyle"), sa = Nn.get("handleLabel") || {}, oa = sa.show || !1;
        Cn.add(Dn[ea] = new ZRText$1({
          silent: !0,
          invisible: !oa,
          style: createTextStyle$1(Aa, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: Aa.getTextColor(),
            font: Aa.getFont()
          }),
          z2: 10
        }));
      }, this);
      var Hn = Un;
      if (Pn) {
        var zn = parsePercent(Nn.get("moveHandleSize"), $n[1]), Gn = Bn.moveHandle = new Rect$3({
          style: Nn.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: $n[1] - 0.5,
            height: zn
          }
        }), Yn = zn * 0.8, Wn = Bn.moveHandleIcon = createSymbol$1(Nn.get("moveHandleIcon"), -Yn / 2, -Yn / 2, Yn, Yn, "#fff", !0);
        Wn.silent = !0, Wn.y = $n[1] + zn / 2 - 0.5, Gn.ensureState("emphasis").style = Nn.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var Xn = Math.min($n[1] / 2, Math.max(zn, 10));
        Hn = Bn.moveZone = new Rect$3({
          invisible: !0,
          shape: {
            y: $n[1] - Xn,
            height: zn + Xn
          }
        }), Hn.on("mouseover", function() {
          Rn.enterEmphasis(Gn);
        }).on("mouseout", function() {
          Rn.leaveEmphasis(Gn);
        }), Ln.add(Gn), Ln.add(Wn), Ln.add(Hn);
      }
      Hn.attr({
        draggable: !0,
        cursor: getCursor$1(this._orient),
        drift: bind$1(this._onDragMove, this, "all"),
        ondragstart: bind$1(this._showDataInfo, this, !0),
        ondragend: bind$1(this._onDragEnd, this),
        onmouseover: bind$1(this._showDataInfo, this, !0),
        onmouseout: bind$1(this._showDataInfo, this, !1)
      });
    }, nr.prototype._resetInterval = function() {
      var Cn = this._range = this.dataZoomModel.getPercentRange(), Bn = this._getViewExtent();
      this._handleEnds = [linearMap$2(Cn[0], [0, 100], Bn, !0), linearMap$2(Cn[1], [0, 100], Bn, !0)];
    }, nr.prototype._updateInterval = function(Cn, Bn) {
      var In = this.dataZoomModel, Dn = this._handleEnds, Ln = this._getViewExtent(), $n = In.findRepresentativeAxisProxy().getMinMaxSpan(), Nn = [0, 100];
      sliderMove(Bn, Dn, Ln, In.get("zoomLock") ? "all" : Cn, $n.minSpan != null ? linearMap$2($n.minSpan, Nn, Ln, !0) : null, $n.maxSpan != null ? linearMap$2($n.maxSpan, Nn, Ln, !0) : null);
      var Rn = this._range, Fn = this._range = asc$2([linearMap$2(Dn[0], Ln, Nn, !0), linearMap$2(Dn[1], Ln, Nn, !0)]);
      return !Rn || Rn[0] !== Fn[0] || Rn[1] !== Fn[1];
    }, nr.prototype._updateView = function(Cn) {
      var Bn = this._displayables, In = this._handleEnds, Dn = asc$2(In.slice()), Ln = this._size;
      each$f([0, 1], function(Hn) {
        var zn = Bn.handles[Hn], Gn = this._handleHeight;
        zn.attr({
          scaleX: Gn / 2,
          scaleY: Gn / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: In[Hn] + (Hn ? -1 : 1),
          y: Ln[1] / 2 - Gn / 2
        });
      }, this), Bn.filler.setShape({
        x: Dn[0],
        y: 0,
        width: Dn[1] - Dn[0],
        height: Ln[1]
      });
      var $n = {
        x: Dn[0],
        width: Dn[1] - Dn[0]
      };
      Bn.moveHandle && (Bn.moveHandle.setShape($n), Bn.moveZone.setShape($n), Bn.moveZone.getBoundingRect(), Bn.moveHandleIcon && Bn.moveHandleIcon.attr("x", $n.x + $n.width / 2));
      for (var Nn = Bn.dataShadowSegs, Rn = [0, Dn[0], Dn[1], Ln[0]], Fn = 0; Fn < Nn.length; Fn++) {
        var Pn = Nn[Fn], Un = Pn.getClipPath();
        Un || (Un = new Rect$3(), Pn.setClipPath(Un)), Un.setShape({
          x: Rn[Fn],
          y: 0,
          width: Rn[Fn + 1] - Rn[Fn],
          height: Ln[1]
        });
      }
      this._updateDataInfo(Cn);
    }, nr.prototype._updateDataInfo = function(Cn) {
      var Bn = this.dataZoomModel, In = this._displayables, Dn = In.handleLabels, Ln = this._orient, $n = ["", ""];
      if (Bn.get("showDetail")) {
        var Nn = Bn.findRepresentativeAxisProxy();
        if (Nn) {
          var Rn = Nn.getAxisModel().axis, Fn = this._range, Pn = Cn ? Nn.calculateDataWindow({
            start: Fn[0],
            end: Fn[1]
          }).valueWindow : Nn.getDataValueWindow();
          $n = [this._formatLabel(Pn[0], Rn), this._formatLabel(Pn[1], Rn)];
        }
      }
      var Un = asc$2(this._handleEnds.slice());
      Hn.call(this, 0), Hn.call(this, 1);
      function Hn(zn) {
        var Gn = getTransform$1(In.handles[zn].parent, this.group), Yn = transformDirection(zn === 0 ? "right" : "left", Gn), Wn = this._handleWidth / 2 + LABEL_GAP, Xn = applyTransform([Un[zn] + (zn === 0 ? -Wn : Wn), this._size[1] / 2], Gn);
        Dn[zn].setStyle({
          x: Xn[0],
          y: Xn[1],
          verticalAlign: Ln === HORIZONTAL ? "middle" : Yn,
          align: Ln === HORIZONTAL ? Yn : "center",
          text: $n[zn]
        });
      }
    }, nr.prototype._formatLabel = function(Cn, Bn) {
      var In = this.dataZoomModel, Dn = In.get("labelFormatter"), Ln = In.get("labelPrecision");
      (Ln == null || Ln === "auto") && (Ln = Bn.getPixelPrecision());
      var $n = Cn == null || isNaN(Cn) ? "" : Bn.type === "category" || Bn.type === "time" ? Bn.scale.getLabel({
        value: Math.round(Cn)
      }) : Cn.toFixed(Math.min(Ln, 20));
      return isFunction$1(Dn) ? Dn(Cn, $n) : isString$1(Dn) ? Dn.replace("{value}", $n) : $n;
    }, nr.prototype._showDataInfo = function(Cn) {
      var Bn = this.dataZoomModel.get("handleLabel") || {}, In = Bn.show || !1, Dn = this.dataZoomModel.getModel(["emphasis", "handleLabel"]), Ln = Dn.get("show") || !1, $n = Cn || this._dragging ? Ln : In, Nn = this._displayables, Rn = Nn.handleLabels;
      Rn[0].attr("invisible", !$n), Rn[1].attr("invisible", !$n), Nn.moveHandle && this.api[$n ? "enterEmphasis" : "leaveEmphasis"](Nn.moveHandle, 1);
    }, nr.prototype._onDragMove = function(Cn, Bn, In, Dn) {
      this._dragging = !0, stop(Dn.event);
      var Ln = this._displayables.sliderGroup.getLocalTransform(), $n = applyTransform([Bn, In], Ln, !0), Nn = this._updateInterval(Cn, $n[0]), Rn = this.dataZoomModel.get("realtime");
      this._updateView(!Rn), Nn && Rn && this._dispatchZoomAction(!0);
    }, nr.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var Cn = this.dataZoomModel.get("realtime");
      !Cn && this._dispatchZoomAction(!1);
    }, nr.prototype._onClickPanel = function(Cn) {
      var Bn = this._size, In = this._displayables.sliderGroup.transformCoordToLocal(Cn.offsetX, Cn.offsetY);
      if (!(In[0] < 0 || In[0] > Bn[0] || In[1] < 0 || In[1] > Bn[1])) {
        var Dn = this._handleEnds, Ln = (Dn[0] + Dn[1]) / 2, $n = this._updateInterval("all", In[0] - Ln);
        this._updateView(), $n && this._dispatchZoomAction(!1);
      }
    }, nr.prototype._onBrushStart = function(Cn) {
      var Bn = Cn.offsetX, In = Cn.offsetY;
      this._brushStart = new Point$1(Bn, In), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, nr.prototype._onBrushEnd = function(Cn) {
      if (this._brushing) {
        var Bn = this._displayables.brushRect;
        if (this._brushing = !1, !!Bn) {
          Bn.attr("ignore", !0);
          var In = Bn.shape, Dn = +/* @__PURE__ */ new Date();
          if (!(Dn - this._brushStartTime < 200 && Math.abs(In.width) < 5)) {
            var Ln = this._getViewExtent(), $n = [0, 100];
            this._range = asc$2([linearMap$2(In.x, Ln, $n, !0), linearMap$2(In.x + In.width, Ln, $n, !0)]), this._handleEnds = [In.x, In.x + In.width], this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, nr.prototype._onBrush = function(Cn) {
      this._brushing && (stop(Cn.event), this._updateBrushRect(Cn.offsetX, Cn.offsetY));
    }, nr.prototype._updateBrushRect = function(Cn, Bn) {
      var In = this._displayables, Dn = this.dataZoomModel, Ln = In.brushRect;
      Ln || (Ln = In.brushRect = new Rect({
        silent: !0,
        style: Dn.getModel("brushStyle").getItemStyle()
      }), In.sliderGroup.add(Ln)), Ln.attr("ignore", !1);
      var $n = this._brushStart, Nn = this._displayables.sliderGroup, Rn = Nn.transformCoordToLocal(Cn, Bn), Fn = Nn.transformCoordToLocal($n.x, $n.y), Pn = this._size;
      Rn[0] = Math.max(Math.min(Pn[0], Rn[0]), 0), Ln.setShape({
        x: Fn[0],
        y: 0,
        width: Rn[0] - Fn[0],
        height: Pn[1]
      });
    }, nr.prototype._dispatchZoomAction = function(Cn) {
      var Bn = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: Cn ? REALTIME_ANIMATION_CONFIG : null,
        start: Bn[0],
        end: Bn[1]
      });
    }, nr.prototype._findCoordRect = function() {
      var Cn, Bn = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
      if (!Cn && Bn.length) {
        var In = Bn[0].model.coordinateSystem;
        Cn = In.getRect && In.getRect();
      }
      if (!Cn) {
        var Dn = this.api.getWidth(), Ln = this.api.getHeight();
        Cn = {
          x: Dn * 0.2,
          y: Ln * 0.2,
          width: Dn * 0.6,
          height: Ln * 0.6
        };
      }
      return Cn;
    }, nr.type = "dataZoom.slider", nr;
  }(DataZoomView$1)
);
function getOtherDim(_n) {
  var nr = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return nr[_n];
}
function getCursor$1(_n) {
  return _n === "vertical" ? "ns-resize" : "ew-resize";
}
const SliderZoomView$1 = SliderZoomView;
function install$7(_n) {
  _n.registerComponentModel(SliderZoomModel$1), _n.registerComponentView(SliderZoomView$1), installCommon$1(_n);
}
function install$6(_n) {
  use(install$8), use(install$7);
}
var visualDefault = {
  /**
   * @public
   */
  get: function(_n, nr, Cn) {
    var Bn = clone$4((defaultOption[_n] || {})[nr]);
    return Cn && isArray$4(Bn) ? Bn[Bn.length - 1] : Bn;
  }
}, defaultOption = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
const visualDefault$1 = visualDefault;
var mapVisual = VisualMapping$1.mapVisual, eachVisual = VisualMapping$1.eachVisual, isArray = isArray$4, each$2 = each$f, asc = asc$2, linearMap$1 = linearMap$2, VisualMapModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.stateList = ["inRange", "outOfRange"], Cn.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], Cn.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, Cn.dataBound = [-1 / 0, 1 / 0], Cn.targetVisuals = {}, Cn.controllerVisuals = {}, Cn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      this.mergeDefaultAndTheme(Cn, In);
    }, nr.prototype.optionUpdated = function(Cn, Bn) {
      var In = this.option;
      !Bn && replaceVisualOption(In, Cn, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, nr.prototype.resetVisual = function(Cn) {
      var Bn = this.stateList;
      Cn = bind$1(Cn, this), this.controllerVisuals = createVisualMappings(this.option.controller, Bn, Cn), this.targetVisuals = createVisualMappings(this.option.target, Bn, Cn);
    }, nr.prototype.getItemSymbol = function() {
      return null;
    }, nr.prototype.getTargetSeriesIndices = function() {
      var Cn = this.option.seriesIndex, Bn = [];
      return Cn == null || Cn === "all" ? this.ecModel.eachSeries(function(In, Dn) {
        Bn.push(Dn);
      }) : Bn = normalizeToArray(Cn), Bn;
    }, nr.prototype.eachTargetSeries = function(Cn, Bn) {
      each$f(this.getTargetSeriesIndices(), function(In) {
        var Dn = this.ecModel.getSeriesByIndex(In);
        Dn && Cn.call(Bn, Dn);
      }, this);
    }, nr.prototype.isTargetSeries = function(Cn) {
      var Bn = !1;
      return this.eachTargetSeries(function(In) {
        In === Cn && (Bn = !0);
      }), Bn;
    }, nr.prototype.formatValueText = function(Cn, Bn, In) {
      var Dn = this.option, Ln = Dn.precision, $n = this.dataBound, Nn = Dn.formatter, Rn;
      In = In || ["<", ">"], isArray$4(Cn) && (Cn = Cn.slice(), Rn = !0);
      var Fn = Bn ? Cn : Rn ? [Pn(Cn[0]), Pn(Cn[1])] : Pn(Cn);
      if (isString$1(Nn))
        return Nn.replace("{value}", Rn ? Fn[0] : Fn).replace("{value2}", Rn ? Fn[1] : Fn);
      if (isFunction$1(Nn))
        return Rn ? Nn(Cn[0], Cn[1]) : Nn(Cn);
      if (Rn)
        return Cn[0] === $n[0] ? In[0] + " " + Fn[1] : Cn[1] === $n[1] ? In[1] + " " + Fn[0] : Fn[0] + " - " + Fn[1];
      return Fn;
      function Pn(Un) {
        return Un === $n[0] ? "min" : Un === $n[1] ? "max" : (+Un).toFixed(Math.min(Ln, 20));
      }
    }, nr.prototype.resetExtent = function() {
      var Cn = this.option, Bn = asc([Cn.min, Cn.max]);
      this._dataExtent = Bn;
    }, nr.prototype.getDataDimensionIndex = function(Cn) {
      var Bn = this.option.dimension;
      if (Bn != null)
        return Cn.getDimensionIndex(Bn);
      for (var In = Cn.dimensions, Dn = In.length - 1; Dn >= 0; Dn--) {
        var Ln = In[Dn], $n = Cn.getDimensionInfo(Ln);
        if (!$n.isCalculationCoord)
          return $n.storeDimIndex;
      }
    }, nr.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, nr.prototype.completeVisualOption = function() {
      var Cn = this.ecModel, Bn = this.option, In = {
        inRange: Bn.inRange,
        outOfRange: Bn.outOfRange
      }, Dn = Bn.target || (Bn.target = {}), Ln = Bn.controller || (Bn.controller = {});
      merge$1(Dn, In), merge$1(Ln, In);
      var $n = this.isCategory();
      Nn.call(this, Dn), Nn.call(this, Ln), Rn.call(this, Dn, "inRange", "outOfRange"), Fn.call(this, Ln);
      function Nn(Pn) {
        isArray(Bn.color) && !Pn.inRange && (Pn.inRange = {
          color: Bn.color.slice().reverse()
        }), Pn.inRange = Pn.inRange || {
          color: Cn.get("gradientColor")
        };
      }
      function Rn(Pn, Un, Hn) {
        var zn = Pn[Un], Gn = Pn[Hn];
        zn && !Gn && (Gn = Pn[Hn] = {}, each$2(zn, function(Yn, Wn) {
          if (VisualMapping$1.isValidType(Wn)) {
            var Xn = visualDefault$1.get(Wn, "inactive", $n);
            Xn != null && (Gn[Wn] = Xn, Wn === "color" && !Gn.hasOwnProperty("opacity") && !Gn.hasOwnProperty("colorAlpha") && (Gn.opacity = [0, 0]));
          }
        }));
      }
      function Fn(Pn) {
        var Un = (Pn.inRange || {}).symbol || (Pn.outOfRange || {}).symbol, Hn = (Pn.inRange || {}).symbolSize || (Pn.outOfRange || {}).symbolSize, zn = this.get("inactiveColor"), Gn = this.getItemSymbol(), Yn = Gn || "roundRect";
        each$2(this.stateList, function(Wn) {
          var Xn = this.itemSize, ea = Pn[Wn];
          ea || (ea = Pn[Wn] = {
            color: $n ? zn : [zn]
          }), ea.symbol == null && (ea.symbol = Un && clone$4(Un) || ($n ? Yn : [Yn])), ea.symbolSize == null && (ea.symbolSize = Hn && clone$4(Hn) || ($n ? Xn[0] : [Xn[0], Xn[0]])), ea.symbol = mapVisual(ea.symbol, function(ra) {
            return ra === "none" ? Yn : ra;
          });
          var ta = ea.symbolSize;
          if (ta != null) {
            var na = -1 / 0;
            eachVisual(ta, function(ra) {
              ra > na && (na = ra);
            }), ea.symbolSize = mapVisual(ta, function(ra) {
              return linearMap$1(ra, [0, na], [0, Xn[0]], !0);
            });
          }
        }, this);
      }
    }, nr.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, nr.prototype.isCategory = function() {
      return !!this.option.categories;
    }, nr.prototype.setSelected = function(Cn) {
    }, nr.prototype.getSelected = function() {
      return null;
    }, nr.prototype.getValueState = function(Cn) {
      return null;
    }, nr.prototype.getVisualMeta = function(Cn) {
      return null;
    }, nr.type = "visualMap", nr.dependencies = ["series"], nr.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      // 接受数组分别设定上右下左边距，同css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
        // 值域文字颜色
      }
    }, nr;
  }(ComponentModel$1)
);
const VisualMapModel$1 = VisualMapModel;
var DEFAULT_BAR_BOUND = [20, 140], ContinuousModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.optionUpdated = function(Cn, Bn) {
      _n.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(In) {
        In.mappingMethod = "linear", In.dataExtent = this.getExtent();
      }), this._resetRange();
    }, nr.prototype.resetItemSize = function() {
      _n.prototype.resetItemSize.apply(this, arguments);
      var Cn = this.itemSize;
      (Cn[0] == null || isNaN(Cn[0])) && (Cn[0] = DEFAULT_BAR_BOUND[0]), (Cn[1] == null || isNaN(Cn[1])) && (Cn[1] = DEFAULT_BAR_BOUND[1]);
    }, nr.prototype._resetRange = function() {
      var Cn = this.getExtent(), Bn = this.option.range;
      !Bn || Bn.auto ? (Cn.auto = 1, this.option.range = Cn) : isArray$4(Bn) && (Bn[0] > Bn[1] && Bn.reverse(), Bn[0] = Math.max(Bn[0], Cn[0]), Bn[1] = Math.min(Bn[1], Cn[1]));
    }, nr.prototype.completeVisualOption = function() {
      _n.prototype.completeVisualOption.apply(this, arguments), each$f(this.stateList, function(Cn) {
        var Bn = this.option.controller[Cn].symbolSize;
        Bn && Bn[0] !== Bn[1] && (Bn[0] = Bn[1] / 3);
      }, this);
    }, nr.prototype.setSelected = function(Cn) {
      this.option.range = Cn.slice(), this._resetRange();
    }, nr.prototype.getSelected = function() {
      var Cn = this.getExtent(), Bn = asc$2((this.get("range") || []).slice());
      return Bn[0] > Cn[1] && (Bn[0] = Cn[1]), Bn[1] > Cn[1] && (Bn[1] = Cn[1]), Bn[0] < Cn[0] && (Bn[0] = Cn[0]), Bn[1] < Cn[0] && (Bn[1] = Cn[0]), Bn;
    }, nr.prototype.getValueState = function(Cn) {
      var Bn = this.option.range, In = this.getExtent();
      return (Bn[0] <= In[0] || Bn[0] <= Cn) && (Bn[1] >= In[1] || Cn <= Bn[1]) ? "inRange" : "outOfRange";
    }, nr.prototype.findTargetDataIndices = function(Cn) {
      var Bn = [];
      return this.eachTargetSeries(function(In) {
        var Dn = [], Ln = In.getData();
        Ln.each(this.getDataDimensionIndex(Ln), function($n, Nn) {
          Cn[0] <= $n && $n <= Cn[1] && Dn.push(Nn);
        }, this), Bn.push({
          seriesId: In.id,
          dataIndex: Dn
        });
      }, this), Bn;
    }, nr.prototype.getVisualMeta = function(Cn) {
      var Bn = getColorStopValues(this, "outOfRange", this.getExtent()), In = getColorStopValues(this, "inRange", this.option.range.slice()), Dn = [];
      function Ln(Hn, zn) {
        Dn.push({
          value: Hn,
          color: Cn(Hn, zn)
        });
      }
      for (var $n = 0, Nn = 0, Rn = In.length, Fn = Bn.length; Nn < Fn && (!In.length || Bn[Nn] <= In[0]); Nn++)
        Bn[Nn] < In[$n] && Ln(Bn[Nn], "outOfRange");
      for (var Pn = 1; $n < Rn; $n++, Pn = 0)
        Pn && Dn.length && Ln(In[$n], "outOfRange"), Ln(In[$n], "inRange");
      for (var Pn = 1; Nn < Fn; Nn++)
        (!In.length || In[In.length - 1] < Bn[Nn]) && (Pn && (Dn.length && Ln(Dn[Dn.length - 1].value, "outOfRange"), Pn = 0), Ln(Bn[Nn], "outOfRange"));
      var Un = Dn.length;
      return {
        stops: Dn,
        outerColors: [Un ? Dn[0].color : "transparent", Un ? Dn[Un - 1].color : "transparent"]
      };
    }, nr.type = "visualMap.continuous", nr.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: 'rgba(0,0,0,0.2)'
      //     }
      // }
    }), nr;
  }(VisualMapModel$1)
);
function getColorStopValues(_n, nr, Cn) {
  if (Cn[0] === Cn[1])
    return Cn.slice();
  for (var Bn = 200, In = (Cn[1] - Cn[0]) / Bn, Dn = Cn[0], Ln = [], $n = 0; $n <= Bn && Dn < Cn[1]; $n++)
    Ln.push(Dn), Dn += In;
  return Ln.push(Cn[1]), Ln;
}
const ContinuousModel$1 = ContinuousModel;
var VisualMapView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      this.ecModel = Cn, this.api = Bn;
    }, nr.prototype.render = function(Cn, Bn, In, Dn) {
      if (this.visualMapModel = Cn, Cn.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(Cn, Bn, In, Dn);
    }, nr.prototype.renderBackground = function(Cn) {
      var Bn = this.visualMapModel, In = normalizeCssArray(Bn.get("padding") || 0), Dn = Cn.getBoundingRect();
      Cn.add(new Rect$3({
        z2: -1,
        silent: !0,
        shape: {
          x: Dn.x - In[3],
          y: Dn.y - In[0],
          width: Dn.width + In[3] + In[1],
          height: Dn.height + In[0] + In[2]
        },
        style: {
          fill: Bn.get("backgroundColor"),
          stroke: Bn.get("borderColor"),
          lineWidth: Bn.get("borderWidth")
        }
      }));
    }, nr.prototype.getControllerVisual = function(Cn, Bn, In) {
      In = In || {};
      var Dn = In.forceState, Ln = this.visualMapModel, $n = {};
      if (Bn === "color") {
        var Nn = Ln.get("contentColor");
        $n.color = Nn;
      }
      function Rn(Hn) {
        return $n[Hn];
      }
      function Fn(Hn, zn) {
        $n[Hn] = zn;
      }
      var Pn = Ln.controllerVisuals[Dn || Ln.getValueState(Cn)], Un = VisualMapping$1.prepareVisualTypes(Pn);
      return each$f(Un, function(Hn) {
        var zn = Pn[Hn];
        In.convertOpacityToAlpha && Hn === "opacity" && (Hn = "colorAlpha", zn = Pn.__alphaForOpacity), VisualMapping$1.dependsOn(Hn, Bn) && zn && zn.applyVisual(Cn, Rn, Fn);
      }), $n[Bn];
    }, nr.prototype.positionGroup = function(Cn) {
      var Bn = this.visualMapModel, In = this.api;
      positionElement(Cn, Bn.getBoxLayoutParams(), {
        width: In.getWidth(),
        height: In.getHeight()
      });
    }, nr.prototype.doRender = function(Cn, Bn, In, Dn) {
    }, nr.type = "visualMap", nr;
  }(ComponentView$1)
);
const VisualMapView$1 = VisualMapView;
var paramsSet = [["left", "right", "width"], ["top", "bottom", "height"]];
function getItemAlign(_n, nr, Cn) {
  var Bn = _n.option, In = Bn.align;
  if (In != null && In !== "auto")
    return In;
  for (var Dn = {
    width: nr.getWidth(),
    height: nr.getHeight()
  }, Ln = Bn.orient === "horizontal" ? 1 : 0, $n = paramsSet[Ln], Nn = [0, null, 10], Rn = {}, Fn = 0; Fn < 3; Fn++)
    Rn[paramsSet[1 - Ln][Fn]] = Nn[Fn], Rn[$n[Fn]] = Fn === 2 ? Cn[0] : Bn[$n[Fn]];
  var Pn = [["x", "width", 3], ["y", "height", 0]][Ln], Un = getLayoutRect$1(Rn, Dn, Bn.padding);
  return $n[(Un.margin[Pn[2]] || 0) + Un[Pn[0]] + Un[Pn[1]] * 0.5 < Dn[Pn[1]] * 0.5 ? 0 : 1];
}
function makeHighDownBatch(_n, nr) {
  return each$f(_n || [], function(Cn) {
    Cn.dataIndex != null && (Cn.dataIndexInside = Cn.dataIndex, Cn.dataIndex = null), Cn.highlightKey = "visualMap" + (nr ? nr.componentIndex : "");
  }), _n;
}
var linearMap = linearMap$2, each$1 = each$f, mathMin = Math.min, mathMax = Math.max, HOVER_LINK_SIZE = 12, HOVER_LINK_OUT = 6, ContinuousView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn._shapes = {}, Cn._dataInterval = [], Cn._handleEnds = [], Cn._hoverLinkDataIndices = [], Cn;
    }
    return nr.prototype.init = function(Cn, Bn) {
      _n.prototype.init.call(this, Cn, Bn), this._hoverLinkFromSeriesMouseOver = bind$1(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = bind$1(this._hideIndicator, this);
    }, nr.prototype.doRender = function(Cn, Bn, In, Dn) {
      (!Dn || Dn.type !== "selectDataRange" || Dn.from !== this.uid) && this._buildView();
    }, nr.prototype._buildView = function() {
      this.group.removeAll();
      var Cn = this.visualMapModel, Bn = this.group;
      this._orient = Cn.get("orient"), this._useHandle = Cn.get("calculable"), this._resetInterval(), this._renderBar(Bn);
      var In = Cn.get("text");
      this._renderEndsText(Bn, In, 0), this._renderEndsText(Bn, In, 1), this._updateView(!0), this.renderBackground(Bn), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(Bn);
    }, nr.prototype._renderEndsText = function(Cn, Bn, In) {
      if (Bn) {
        var Dn = Bn[1 - In];
        Dn = Dn != null ? Dn + "" : "";
        var Ln = this.visualMapModel, $n = Ln.get("textGap"), Nn = Ln.itemSize, Rn = this._shapes.mainGroup, Fn = this._applyTransform([Nn[0] / 2, In === 0 ? -$n : Nn[1] + $n], Rn), Pn = this._applyTransform(In === 0 ? "bottom" : "top", Rn), Un = this._orient, Hn = this.visualMapModel.textStyleModel;
        this.group.add(new ZRText$1({
          style: createTextStyle$1(Hn, {
            x: Fn[0],
            y: Fn[1],
            verticalAlign: Un === "horizontal" ? "middle" : Pn,
            align: Un === "horizontal" ? Pn : "center",
            text: Dn
          })
        }));
      }
    }, nr.prototype._renderBar = function(Cn) {
      var Bn = this.visualMapModel, In = this._shapes, Dn = Bn.itemSize, Ln = this._orient, $n = this._useHandle, Nn = getItemAlign(Bn, this.api, Dn), Rn = In.mainGroup = this._createBarGroup(Nn), Fn = new Group$4();
      Rn.add(Fn), Fn.add(In.outOfRange = createPolygon()), Fn.add(In.inRange = createPolygon(null, $n ? getCursor(this._orient) : null, bind$1(this._dragHandle, this, "all", !1), bind$1(this._dragHandle, this, "all", !0))), Fn.setClipPath(new Rect$3({
        shape: {
          x: 0,
          y: 0,
          width: Dn[0],
          height: Dn[1],
          r: 3
        }
      }));
      var Pn = Bn.textStyleModel.getTextRect("国"), Un = mathMax(Pn.width, Pn.height);
      $n && (In.handleThumbs = [], In.handleLabels = [], In.handleLabelPoints = [], this._createHandle(Bn, Rn, 0, Dn, Un, Ln), this._createHandle(Bn, Rn, 1, Dn, Un, Ln)), this._createIndicator(Bn, Rn, Dn, Un, Ln), Cn.add(Rn);
    }, nr.prototype._createHandle = function(Cn, Bn, In, Dn, Ln, $n) {
      var Nn = bind$1(this._dragHandle, this, In, !1), Rn = bind$1(this._dragHandle, this, In, !0), Fn = parsePercent$1(Cn.get("handleSize"), Dn[0]), Pn = createSymbol$1(Cn.get("handleIcon"), -Fn / 2, -Fn / 2, Fn, Fn, null, !0), Un = getCursor(this._orient);
      Pn.attr({
        cursor: Un,
        draggable: !0,
        drift: Nn,
        ondragend: Rn,
        onmousemove: function(Wn) {
          stop(Wn.event);
        }
      }), Pn.x = Dn[0] / 2, Pn.useStyle(Cn.getModel("handleStyle").getItemStyle()), Pn.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), Pn.style.lineWidth *= 2, Pn.ensureState("emphasis").style = Cn.getModel(["emphasis", "handleStyle"]).getItemStyle(), setAsHighDownDispatcher(Pn, !0), Bn.add(Pn);
      var Hn = this.visualMapModel.textStyleModel, zn = new ZRText$1({
        cursor: Un,
        draggable: !0,
        drift: Nn,
        onmousemove: function(Wn) {
          stop(Wn.event);
        },
        ondragend: Rn,
        style: createTextStyle$1(Hn, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      zn.ensureState("blur").style = {
        opacity: 0.1
      }, zn.stateTransition = {
        duration: 200
      }, this.group.add(zn);
      var Gn = [Fn, 0], Yn = this._shapes;
      Yn.handleThumbs[In] = Pn, Yn.handleLabelPoints[In] = Gn, Yn.handleLabels[In] = zn;
    }, nr.prototype._createIndicator = function(Cn, Bn, In, Dn, Ln) {
      var $n = parsePercent$1(Cn.get("indicatorSize"), In[0]), Nn = createSymbol$1(Cn.get("indicatorIcon"), -$n / 2, -$n / 2, $n, $n, null, !0);
      Nn.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: In[0] / 2
      });
      var Rn = Cn.getModel("indicatorStyle").getItemStyle();
      if (Nn instanceof ZRImage$1) {
        var Fn = Nn.style;
        Nn.useStyle(extend({
          // TODO other properties like x, y ?
          image: Fn.image,
          x: Fn.x,
          y: Fn.y,
          width: Fn.width,
          height: Fn.height
        }, Rn));
      } else
        Nn.useStyle(Rn);
      Bn.add(Nn);
      var Pn = this.visualMapModel.textStyleModel, Un = new ZRText$1({
        silent: !0,
        invisible: !0,
        style: createTextStyle$1(Pn, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(Un);
      var Hn = [(Ln === "horizontal" ? Dn / 2 : HOVER_LINK_OUT) + In[0] / 2, 0], zn = this._shapes;
      zn.indicator = Nn, zn.indicatorLabel = Un, zn.indicatorLabelPoint = Hn, this._firstShowIndicator = !0;
    }, nr.prototype._dragHandle = function(Cn, Bn, In, Dn) {
      if (this._useHandle) {
        if (this._dragging = !Bn, !Bn) {
          var Ln = this._applyTransform([In, Dn], this._shapes.mainGroup, !0);
          this._updateInterval(Cn, Ln[1]), this._hideIndicator(), this._updateView();
        }
        Bn === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), Bn ? !this._hovering && this._clearHoverLinkToSeries() : useHoverLinkOnHandle(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[Cn], !1);
      }
    }, nr.prototype._resetInterval = function() {
      var Cn = this.visualMapModel, Bn = this._dataInterval = Cn.getSelected(), In = Cn.getExtent(), Dn = [0, Cn.itemSize[1]];
      this._handleEnds = [linearMap(Bn[0], In, Dn, !0), linearMap(Bn[1], In, Dn, !0)];
    }, nr.prototype._updateInterval = function(Cn, Bn) {
      Bn = Bn || 0;
      var In = this.visualMapModel, Dn = this._handleEnds, Ln = [0, In.itemSize[1]];
      sliderMove(
        Bn,
        Dn,
        Ln,
        Cn,
        // cross is forbidden
        0
      );
      var $n = In.getExtent();
      this._dataInterval = [linearMap(Dn[0], Ln, $n, !0), linearMap(Dn[1], Ln, $n, !0)];
    }, nr.prototype._updateView = function(Cn) {
      var Bn = this.visualMapModel, In = Bn.getExtent(), Dn = this._shapes, Ln = [0, Bn.itemSize[1]], $n = Cn ? Ln : this._handleEnds, Nn = this._createBarVisual(this._dataInterval, In, $n, "inRange"), Rn = this._createBarVisual(In, In, Ln, "outOfRange");
      Dn.inRange.setStyle({
        fill: Nn.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", Nn.barPoints), Dn.outOfRange.setStyle({
        fill: Rn.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", Rn.barPoints), this._updateHandle($n, Nn);
    }, nr.prototype._createBarVisual = function(Cn, Bn, In, Dn) {
      var Ln = {
        forceState: Dn,
        convertOpacityToAlpha: !0
      }, $n = this._makeColorGradient(Cn, Ln), Nn = [this.getControllerVisual(Cn[0], "symbolSize", Ln), this.getControllerVisual(Cn[1], "symbolSize", Ln)], Rn = this._createBarPoints(In, Nn);
      return {
        barColor: new LinearGradient$1(0, 0, 0, 1, $n),
        barPoints: Rn,
        handlesColor: [$n[0].color, $n[$n.length - 1].color]
      };
    }, nr.prototype._makeColorGradient = function(Cn, Bn) {
      var In = 100, Dn = [], Ln = (Cn[1] - Cn[0]) / In;
      Dn.push({
        color: this.getControllerVisual(Cn[0], "color", Bn),
        offset: 0
      });
      for (var $n = 1; $n < In; $n++) {
        var Nn = Cn[0] + Ln * $n;
        if (Nn > Cn[1])
          break;
        Dn.push({
          color: this.getControllerVisual(Nn, "color", Bn),
          offset: $n / In
        });
      }
      return Dn.push({
        color: this.getControllerVisual(Cn[1], "color", Bn),
        offset: 1
      }), Dn;
    }, nr.prototype._createBarPoints = function(Cn, Bn) {
      var In = this.visualMapModel.itemSize;
      return [[In[0] - Bn[0], Cn[0]], [In[0], Cn[0]], [In[0], Cn[1]], [In[0] - Bn[1], Cn[1]]];
    }, nr.prototype._createBarGroup = function(Cn) {
      var Bn = this._orient, In = this.visualMapModel.get("inverse");
      return new Group$4(Bn === "horizontal" && !In ? {
        scaleX: Cn === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : Bn === "horizontal" && In ? {
        scaleX: Cn === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : Bn === "vertical" && !In ? {
        scaleX: Cn === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: Cn === "left" ? 1 : -1
      });
    }, nr.prototype._updateHandle = function(Cn, Bn) {
      if (this._useHandle) {
        var In = this._shapes, Dn = this.visualMapModel, Ln = In.handleThumbs, $n = In.handleLabels, Nn = Dn.itemSize, Rn = Dn.getExtent(), Fn = this._applyTransform("left", In.mainGroup);
        each$1([0, 1], function(Pn) {
          var Un = Ln[Pn];
          Un.setStyle("fill", Bn.handlesColor[Pn]), Un.y = Cn[Pn];
          var Hn = linearMap(Cn[Pn], [0, Nn[1]], Rn, !0), zn = this.getControllerVisual(Hn, "symbolSize");
          Un.scaleX = Un.scaleY = zn / Nn[0], Un.x = Nn[0] - zn / 2;
          var Gn = applyTransform(In.handleLabelPoints[Pn], getTransform$1(Un, this.group));
          if (this._orient === "horizontal") {
            var Yn = Fn === "left" || Fn === "top" ? (Nn[0] - zn) / 2 : (Nn[0] - zn) / -2;
            Gn[1] += Yn;
          }
          $n[Pn].setStyle({
            x: Gn[0],
            y: Gn[1],
            text: Dn.formatValueText(this._dataInterval[Pn]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", In.mainGroup) : "center"
          });
        }, this);
      }
    }, nr.prototype._showIndicator = function(Cn, Bn, In, Dn) {
      var Ln = this.visualMapModel, $n = Ln.getExtent(), Nn = Ln.itemSize, Rn = [0, Nn[1]], Fn = this._shapes, Pn = Fn.indicator;
      if (Pn) {
        Pn.attr("invisible", !1);
        var Un = {
          convertOpacityToAlpha: !0
        }, Hn = this.getControllerVisual(Cn, "color", Un), zn = this.getControllerVisual(Cn, "symbolSize"), Gn = linearMap(Cn, $n, Rn, !0), Yn = Nn[0] - zn / 2, Wn = {
          x: Pn.x,
          y: Pn.y
        };
        Pn.y = Gn, Pn.x = Yn;
        var Xn = applyTransform(Fn.indicatorLabelPoint, getTransform$1(Pn, this.group)), ea = Fn.indicatorLabel;
        ea.attr("invisible", !1);
        var ta = this._applyTransform("left", Fn.mainGroup), na = this._orient, ra = na === "horizontal";
        ea.setStyle({
          text: (In || "") + Ln.formatValueText(Bn),
          verticalAlign: ra ? ta : "middle",
          align: ra ? "center" : ta
        });
        var aa = {
          x: Yn,
          y: Gn,
          style: {
            fill: Hn
          }
        }, ia = {
          style: {
            x: Xn[0],
            y: Xn[1]
          }
        };
        if (Ln.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var Aa = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          Pn.x = Wn.x, Pn.y = Wn.y, Pn.animateTo(aa, Aa), ea.animateTo(ia, Aa);
        } else
          Pn.attr(aa), ea.attr(ia);
        this._firstShowIndicator = !1;
        var sa = this._shapes.handleLabels;
        if (sa)
          for (var oa = 0; oa < sa.length; oa++)
            this.api.enterBlur(sa[oa]);
      }
    }, nr.prototype._enableHoverLinkToSeries = function() {
      var Cn = this;
      this._shapes.mainGroup.on("mousemove", function(Bn) {
        if (Cn._hovering = !0, !Cn._dragging) {
          var In = Cn.visualMapModel.itemSize, Dn = Cn._applyTransform([Bn.offsetX, Bn.offsetY], Cn._shapes.mainGroup, !0, !0);
          Dn[1] = mathMin(mathMax(0, Dn[1]), In[1]), Cn._doHoverLinkToSeries(Dn[1], 0 <= Dn[0] && Dn[0] <= In[0]);
        }
      }).on("mouseout", function() {
        Cn._hovering = !1, !Cn._dragging && Cn._clearHoverLinkToSeries();
      });
    }, nr.prototype._enableHoverLinkFromSeries = function() {
      var Cn = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (Cn.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), Cn.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, nr.prototype._doHoverLinkToSeries = function(Cn, Bn) {
      var In = this.visualMapModel, Dn = In.itemSize;
      if (In.option.hoverLink) {
        var Ln = [0, Dn[1]], $n = In.getExtent();
        Cn = mathMin(mathMax(Ln[0], Cn), Ln[1]);
        var Nn = getHalfHoverLinkSize(In, $n, Ln), Rn = [Cn - Nn, Cn + Nn], Fn = linearMap(Cn, Ln, $n, !0), Pn = [linearMap(Rn[0], Ln, $n, !0), linearMap(Rn[1], Ln, $n, !0)];
        Rn[0] < Ln[0] && (Pn[0] = -1 / 0), Rn[1] > Ln[1] && (Pn[1] = 1 / 0), Bn && (Pn[0] === -1 / 0 ? this._showIndicator(Fn, Pn[1], "< ", Nn) : Pn[1] === 1 / 0 ? this._showIndicator(Fn, Pn[0], "> ", Nn) : this._showIndicator(Fn, Fn, "≈ ", Nn));
        var Un = this._hoverLinkDataIndices, Hn = [];
        (Bn || useHoverLinkOnHandle(In)) && (Hn = this._hoverLinkDataIndices = In.findTargetDataIndices(Pn));
        var zn = compressBatches(Un, Hn);
        this._dispatchHighDown("downplay", makeHighDownBatch(zn[0], In)), this._dispatchHighDown("highlight", makeHighDownBatch(zn[1], In));
      }
    }, nr.prototype._hoverLinkFromSeriesMouseOver = function(Cn) {
      var Bn;
      if (findEventDispatcher(Cn.target, function(Nn) {
        var Rn = getECData(Nn);
        if (Rn.dataIndex != null)
          return Bn = Rn, !0;
      }, !0), !!Bn) {
        var In = this.ecModel.getSeriesByIndex(Bn.seriesIndex), Dn = this.visualMapModel;
        if (Dn.isTargetSeries(In)) {
          var Ln = In.getData(Bn.dataType), $n = Ln.getStore().get(Dn.getDataDimensionIndex(Ln), Bn.dataIndex);
          isNaN($n) || this._showIndicator($n, $n);
        }
      }
    }, nr.prototype._hideIndicator = function() {
      var Cn = this._shapes;
      Cn.indicator && Cn.indicator.attr("invisible", !0), Cn.indicatorLabel && Cn.indicatorLabel.attr("invisible", !0);
      var Bn = this._shapes.handleLabels;
      if (Bn)
        for (var In = 0; In < Bn.length; In++)
          this.api.leaveBlur(Bn[In]);
    }, nr.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var Cn = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", makeHighDownBatch(Cn, this.visualMapModel)), Cn.length = 0;
    }, nr.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var Cn = this.api.getZr();
      Cn.off("mouseover", this._hoverLinkFromSeriesMouseOver), Cn.off("mouseout", this._hideIndicator);
    }, nr.prototype._applyTransform = function(Cn, Bn, In, Dn) {
      var Ln = getTransform$1(Bn, Dn ? null : this.group);
      return isArray$4(Cn) ? applyTransform(Cn, Ln, In) : transformDirection(Cn, Ln, In);
    }, nr.prototype._dispatchHighDown = function(Cn, Bn) {
      Bn && Bn.length && this.api.dispatchAction({
        type: Cn,
        batch: Bn
      });
    }, nr.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, nr.type = "visualMap.continuous", nr;
  }(VisualMapView$1)
);
function createPolygon(_n, nr, Cn, Bn) {
  return new Polygon$1({
    shape: {
      points: _n
    },
    draggable: !!Cn,
    cursor: nr,
    drift: Cn,
    onmousemove: function(In) {
      stop(In.event);
    },
    ondragend: Bn
  });
}
function getHalfHoverLinkSize(_n, nr, Cn) {
  var Bn = HOVER_LINK_SIZE / 2, In = _n.get("hoverLinkDataSize");
  return In && (Bn = linearMap(In, nr, Cn, !0) / 2), Bn;
}
function useHoverLinkOnHandle(_n) {
  var nr = _n.get("hoverLinkOnHandle");
  return !!(nr ?? _n.get("realtime"));
}
function getCursor(_n) {
  return _n === "vertical" ? "ns-resize" : "ew-resize";
}
const ContinuousView$1 = ContinuousView;
var visualMapActionInfo = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, visualMapActionHander = function(_n, nr) {
  nr.eachComponent({
    mainType: "visualMap",
    query: _n
  }, function(Cn) {
    Cn.setSelected(_n.selected);
  });
}, visualMapEncodingHandlers = [
  {
    createOnAllSeries: !0,
    reset: function(_n, nr) {
      var Cn = [];
      return nr.eachComponent("visualMap", function(Bn) {
        var In = _n.pipelineContext;
        !Bn.isTargetSeries(_n) || In && In.large || Cn.push(incrementalApplyVisual(Bn.stateList, Bn.targetVisuals, bind$1(Bn.getValueState, Bn), Bn.getDataDimensionIndex(_n.getData())));
      }), Cn;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(_n, nr) {
      var Cn = _n.getData(), Bn = [];
      nr.eachComponent("visualMap", function(In) {
        if (In.isTargetSeries(_n)) {
          var Dn = In.getVisualMeta(bind$1(getColorVisual, null, _n, In)) || {
            stops: [],
            outerColors: []
          }, Ln = In.getDataDimensionIndex(Cn);
          Ln >= 0 && (Dn.dimension = Ln, Bn.push(Dn));
        }
      }), _n.getData().setVisual("visualMeta", Bn);
    }
  }
];
function getColorVisual(_n, nr, Cn, Bn) {
  for (var In = nr.targetVisuals[Bn], Dn = VisualMapping$1.prepareVisualTypes(In), Ln = {
    color: getVisualFromData(_n.getData(), "color")
    // default color.
  }, $n = 0, Nn = Dn.length; $n < Nn; $n++) {
    var Rn = Dn[$n], Fn = In[Rn === "opacity" ? "__alphaForOpacity" : Rn];
    Fn && Fn.applyVisual(Cn, Pn, Un);
  }
  return Ln.color;
  function Pn(Hn) {
    return Ln[Hn];
  }
  function Un(Hn, zn) {
    Ln[Hn] = zn;
  }
}
var each = each$f;
function visualMapPreprocessor(_n) {
  var nr = _n && _n.visualMap;
  isArray$4(nr) || (nr = nr ? [nr] : []), each(nr, function(Cn) {
    if (Cn) {
      has(Cn, "splitList") && !has(Cn, "pieces") && (Cn.pieces = Cn.splitList, delete Cn.splitList);
      var Bn = Cn.pieces;
      Bn && isArray$4(Bn) && each(Bn, function(In) {
        isObject$6(In) && (has(In, "start") && !has(In, "min") && (In.min = In.start), has(In, "end") && !has(In, "max") && (In.max = In.end));
      });
    }
  });
}
function has(_n, nr) {
  return _n && _n.hasOwnProperty && _n.hasOwnProperty(nr);
}
var installed = !1;
function installCommon(_n) {
  installed || (installed = !0, _n.registerSubTypeDefaulter("visualMap", function(nr) {
    return !nr.categories && (!(nr.pieces ? nr.pieces.length > 0 : nr.splitNumber > 0) || nr.calculable) ? "continuous" : "piecewise";
  }), _n.registerAction(visualMapActionInfo, visualMapActionHander), each$f(visualMapEncodingHandlers, function(nr) {
    _n.registerVisual(_n.PRIORITY.VISUAL.COMPONENT, nr);
  }), _n.registerPreprocessor(visualMapPreprocessor));
}
function install$5(_n) {
  _n.registerComponentModel(ContinuousModel$1), _n.registerComponentView(ContinuousView$1), installCommon(_n);
}
var PiecewiseModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn._pieceList = [], Cn;
    }
    return nr.prototype.optionUpdated = function(Cn, Bn) {
      _n.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var In = this._mode = this._determineMode();
      this._pieceList = [], resetMethods[this._mode].call(this, this._pieceList), this._resetSelected(Cn, Bn);
      var Dn = this.option.categories;
      this.resetVisual(function(Ln, $n) {
        In === "categories" ? (Ln.mappingMethod = "category", Ln.categories = clone$4(Dn)) : (Ln.dataExtent = this.getExtent(), Ln.mappingMethod = "piecewise", Ln.pieceList = map$1(this._pieceList, function(Nn) {
          return Nn = clone$4(Nn), $n !== "inRange" && (Nn.visual = null), Nn;
        }));
      });
    }, nr.prototype.completeVisualOption = function() {
      var Cn = this.option, Bn = {}, In = VisualMapping$1.listVisualTypes(), Dn = this.isCategory();
      each$f(Cn.pieces, function($n) {
        each$f(In, function(Nn) {
          $n.hasOwnProperty(Nn) && (Bn[Nn] = 1);
        });
      }), each$f(Bn, function($n, Nn) {
        var Rn = !1;
        each$f(this.stateList, function(Fn) {
          Rn = Rn || Ln(Cn, Fn, Nn) || Ln(Cn.target, Fn, Nn);
        }, this), !Rn && each$f(this.stateList, function(Fn) {
          (Cn[Fn] || (Cn[Fn] = {}))[Nn] = visualDefault$1.get(Nn, Fn === "inRange" ? "active" : "inactive", Dn);
        });
      }, this);
      function Ln($n, Nn, Rn) {
        return $n && $n[Nn] && $n[Nn].hasOwnProperty(Rn);
      }
      _n.prototype.completeVisualOption.apply(this, arguments);
    }, nr.prototype._resetSelected = function(Cn, Bn) {
      var In = this.option, Dn = this._pieceList, Ln = (Bn ? In : Cn).selected || {};
      if (In.selected = Ln, each$f(Dn, function(Nn, Rn) {
        var Fn = this.getSelectedMapKey(Nn);
        Ln.hasOwnProperty(Fn) || (Ln[Fn] = !0);
      }, this), In.selectedMode === "single") {
        var $n = !1;
        each$f(Dn, function(Nn, Rn) {
          var Fn = this.getSelectedMapKey(Nn);
          Ln[Fn] && ($n ? Ln[Fn] = !1 : $n = !0);
        }, this);
      }
    }, nr.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, nr.prototype.getSelectedMapKey = function(Cn) {
      return this._mode === "categories" ? Cn.value + "" : Cn.index + "";
    }, nr.prototype.getPieceList = function() {
      return this._pieceList;
    }, nr.prototype._determineMode = function() {
      var Cn = this.option;
      return Cn.pieces && Cn.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, nr.prototype.setSelected = function(Cn) {
      this.option.selected = clone$4(Cn);
    }, nr.prototype.getValueState = function(Cn) {
      var Bn = VisualMapping$1.findPieceIndex(Cn, this._pieceList);
      return Bn != null && this.option.selected[this.getSelectedMapKey(this._pieceList[Bn])] ? "inRange" : "outOfRange";
    }, nr.prototype.findTargetDataIndices = function(Cn) {
      var Bn = [], In = this._pieceList;
      return this.eachTargetSeries(function(Dn) {
        var Ln = [], $n = Dn.getData();
        $n.each(this.getDataDimensionIndex($n), function(Nn, Rn) {
          var Fn = VisualMapping$1.findPieceIndex(Nn, In);
          Fn === Cn && Ln.push(Rn);
        }, this), Bn.push({
          seriesId: Dn.id,
          dataIndex: Ln
        });
      }, this), Bn;
    }, nr.prototype.getRepresentValue = function(Cn) {
      var Bn;
      if (this.isCategory())
        Bn = Cn.value;
      else if (Cn.value != null)
        Bn = Cn.value;
      else {
        var In = Cn.interval || [];
        Bn = In[0] === -1 / 0 && In[1] === 1 / 0 ? 0 : (In[0] + In[1]) / 2;
      }
      return Bn;
    }, nr.prototype.getVisualMeta = function(Cn) {
      if (this.isCategory())
        return;
      var Bn = [], In = ["", ""], Dn = this;
      function Ln(Fn, Pn) {
        var Un = Dn.getRepresentValue({
          interval: Fn
        });
        Pn || (Pn = Dn.getValueState(Un));
        var Hn = Cn(Un, Pn);
        Fn[0] === -1 / 0 ? In[0] = Hn : Fn[1] === 1 / 0 ? In[1] = Hn : Bn.push({
          value: Fn[0],
          color: Hn
        }, {
          value: Fn[1],
          color: Hn
        });
      }
      var $n = this._pieceList.slice();
      if (!$n.length)
        $n.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var Nn = $n[0].interval[0];
        Nn !== -1 / 0 && $n.unshift({
          interval: [-1 / 0, Nn]
        }), Nn = $n[$n.length - 1].interval[1], Nn !== 1 / 0 && $n.push({
          interval: [Nn, 1 / 0]
        });
      }
      var Rn = -1 / 0;
      return each$f($n, function(Fn) {
        var Pn = Fn.interval;
        Pn && (Pn[0] > Rn && Ln([Rn, Pn[0]], "outOfRange"), Ln(Pn.slice()), Rn = Pn[1]);
      }, this), {
        stops: Bn,
        outerColors: In
      };
    }, nr.type = "visualMap.piecewise", nr.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), nr;
  }(VisualMapModel$1)
), resetMethods = {
  splitNumber: function(_n) {
    var nr = this.option, Cn = Math.min(nr.precision, 20), Bn = this.getExtent(), In = nr.splitNumber;
    In = Math.max(parseInt(In, 10), 1), nr.splitNumber = In;
    for (var Dn = (Bn[1] - Bn[0]) / In; +Dn.toFixed(Cn) !== Dn && Cn < 5; )
      Cn++;
    nr.precision = Cn, Dn = +Dn.toFixed(Cn), nr.minOpen && _n.push({
      interval: [-1 / 0, Bn[0]],
      close: [0, 0]
    });
    for (var Ln = 0, $n = Bn[0]; Ln < In; $n += Dn, Ln++) {
      var Nn = Ln === In - 1 ? Bn[1] : $n + Dn;
      _n.push({
        interval: [$n, Nn],
        close: [1, 1]
      });
    }
    nr.maxOpen && _n.push({
      interval: [Bn[1], 1 / 0],
      close: [0, 0]
    }), reformIntervals(_n), each$f(_n, function(Rn, Fn) {
      Rn.index = Fn, Rn.text = this.formatValueText(Rn.interval);
    }, this);
  },
  categories: function(_n) {
    var nr = this.option;
    each$f(nr.categories, function(Cn) {
      _n.push({
        text: this.formatValueText(Cn, !0),
        value: Cn
      });
    }, this), normalizeReverse(nr, _n);
  },
  pieces: function(_n) {
    var nr = this.option;
    each$f(nr.pieces, function(Cn, Bn) {
      isObject$6(Cn) || (Cn = {
        value: Cn
      });
      var In = {
        text: "",
        index: Bn
      };
      if (Cn.label != null && (In.text = Cn.label), Cn.hasOwnProperty("value")) {
        var Dn = In.value = Cn.value;
        In.interval = [Dn, Dn], In.close = [1, 1];
      } else {
        for (var Ln = In.interval = [], $n = In.close = [0, 0], Nn = [1, 0, 1], Rn = [-1 / 0, 1 / 0], Fn = [], Pn = 0; Pn < 2; Pn++) {
          for (var Un = [["gte", "gt", "min"], ["lte", "lt", "max"]][Pn], Hn = 0; Hn < 3 && Ln[Pn] == null; Hn++)
            Ln[Pn] = Cn[Un[Hn]], $n[Pn] = Nn[Hn], Fn[Pn] = Hn === 2;
          Ln[Pn] == null && (Ln[Pn] = Rn[Pn]);
        }
        Fn[0] && Ln[1] === 1 / 0 && ($n[0] = 0), Fn[1] && Ln[0] === -1 / 0 && ($n[1] = 0), process.env.NODE_ENV !== "production" && Ln[0] > Ln[1] && console.warn("Piece " + Bn + "is illegal: " + Ln + " lower bound should not greater then uppper bound."), Ln[0] === Ln[1] && $n[0] && $n[1] && (In.value = Ln[0]);
      }
      In.visual = VisualMapping$1.retrieveVisuals(Cn), _n.push(In);
    }, this), normalizeReverse(nr, _n), reformIntervals(_n), each$f(_n, function(Cn) {
      var Bn = Cn.close, In = [["<", "≤"][Bn[1]], [">", "≥"][Bn[0]]];
      Cn.text = Cn.text || this.formatValueText(Cn.value != null ? Cn.value : Cn.interval, !1, In);
    }, this);
  }
};
function normalizeReverse(_n, nr) {
  var Cn = _n.inverse;
  (_n.orient === "vertical" ? !Cn : Cn) && nr.reverse();
}
const PiecewiseModel$1 = PiecewiseModel;
var PiecewiseVisualMapView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = nr.type, Cn;
    }
    return nr.prototype.doRender = function() {
      var Cn = this.group;
      Cn.removeAll();
      var Bn = this.visualMapModel, In = Bn.get("textGap"), Dn = Bn.textStyleModel, Ln = Dn.getFont(), $n = Dn.getTextColor(), Nn = this._getItemAlign(), Rn = Bn.itemSize, Fn = this._getViewData(), Pn = Fn.endsText, Un = retrieve(Bn.get("showLabel", !0), !Pn), Hn = !Bn.get("selectedMode");
      Pn && this._renderEndsText(Cn, Pn[0], Rn, Un, Nn), each$f(Fn.viewPieceList, function(zn) {
        var Gn = zn.piece, Yn = new Group$4();
        Yn.onclick = bind$1(this._onItemClick, this, Gn), this._enableHoverLink(Yn, zn.indexInModelPieceList);
        var Wn = Bn.getRepresentValue(Gn);
        if (this._createItemSymbol(Yn, Wn, [0, 0, Rn[0], Rn[1]], Hn), Un) {
          var Xn = this.visualMapModel.getValueState(Wn);
          Yn.add(new ZRText$1({
            style: {
              x: Nn === "right" ? -In : Rn[0] + In,
              y: Rn[1] / 2,
              text: Gn.text,
              verticalAlign: "middle",
              align: Nn,
              font: Ln,
              fill: $n,
              opacity: Xn === "outOfRange" ? 0.5 : 1
            },
            silent: Hn
          }));
        }
        Cn.add(Yn);
      }, this), Pn && this._renderEndsText(Cn, Pn[1], Rn, Un, Nn), box(Bn.get("orient"), Cn, Bn.get("itemGap")), this.renderBackground(Cn), this.positionGroup(Cn);
    }, nr.prototype._enableHoverLink = function(Cn, Bn) {
      var In = this;
      Cn.on("mouseover", function() {
        return Dn("highlight");
      }).on("mouseout", function() {
        return Dn("downplay");
      });
      var Dn = function(Ln) {
        var $n = In.visualMapModel;
        $n.option.hoverLink && In.api.dispatchAction({
          type: Ln,
          batch: makeHighDownBatch($n.findTargetDataIndices(Bn), $n)
        });
      };
    }, nr.prototype._getItemAlign = function() {
      var Cn = this.visualMapModel, Bn = Cn.option;
      if (Bn.orient === "vertical")
        return getItemAlign(Cn, this.api, Cn.itemSize);
      var In = Bn.align;
      return (!In || In === "auto") && (In = "left"), In;
    }, nr.prototype._renderEndsText = function(Cn, Bn, In, Dn, Ln) {
      if (Bn) {
        var $n = new Group$4(), Nn = this.visualMapModel.textStyleModel;
        $n.add(new ZRText$1({
          style: createTextStyle$1(Nn, {
            x: Dn ? Ln === "right" ? In[0] : 0 : In[0] / 2,
            y: In[1] / 2,
            verticalAlign: "middle",
            align: Dn ? Ln : "center",
            text: Bn
          })
        })), Cn.add($n);
      }
    }, nr.prototype._getViewData = function() {
      var Cn = this.visualMapModel, Bn = map$1(Cn.getPieceList(), function($n, Nn) {
        return {
          piece: $n,
          indexInModelPieceList: Nn
        };
      }), In = Cn.get("text"), Dn = Cn.get("orient"), Ln = Cn.get("inverse");
      return (Dn === "horizontal" ? Ln : !Ln) ? Bn.reverse() : In && (In = In.slice().reverse()), {
        viewPieceList: Bn,
        endsText: In
      };
    }, nr.prototype._createItemSymbol = function(Cn, Bn, In, Dn) {
      var Ln = createSymbol$1(
        // symbol will be string
        this.getControllerVisual(Bn, "symbol"),
        In[0],
        In[1],
        In[2],
        In[3],
        // color will be string
        this.getControllerVisual(Bn, "color")
      );
      Ln.silent = Dn, Cn.add(Ln);
    }, nr.prototype._onItemClick = function(Cn) {
      var Bn = this.visualMapModel, In = Bn.option, Dn = In.selectedMode;
      if (Dn) {
        var Ln = clone$4(In.selected), $n = Bn.getSelectedMapKey(Cn);
        Dn === "single" || Dn === !0 ? (Ln[$n] = !0, each$f(Ln, function(Nn, Rn) {
          Ln[Rn] = Rn === $n;
        })) : Ln[$n] = !Ln[$n], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: Ln
        });
      }
    }, nr.type = "visualMap.piecewise", nr;
  }(VisualMapView$1)
);
const PiecewiseView = PiecewiseVisualMapView;
function install$4(_n) {
  _n.registerComponentModel(PiecewiseModel$1), _n.registerComponentView(PiecewiseView), installCommon(_n);
}
function install$3(_n) {
  use(install$5), use(install$4);
}
var DEFAULT_OPTION = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, inner = makeInner(), decalPaletteScope = {};
function ariaVisual(_n, nr) {
  var Cn = _n.getModel("aria");
  if (!Cn.get("enabled"))
    return;
  var Bn = clone$4(DEFAULT_OPTION);
  merge$1(Bn.label, _n.getLocaleModel().get("aria"), !1), merge$1(Cn.option, Bn, !1), In(), Dn();
  function In() {
    var Rn = Cn.getModel("decal"), Fn = Rn.get("show");
    if (Fn) {
      var Pn = createHashMap();
      _n.eachSeries(function(Un) {
        if (!Un.isColorBySeries()) {
          var Hn = Pn.get(Un.type);
          Hn || (Hn = {}, Pn.set(Un.type, Hn)), inner(Un).scope = Hn;
        }
      }), _n.eachRawSeries(function(Un) {
        if (_n.isSeriesFiltered(Un))
          return;
        if (isFunction$1(Un.enableAriaDecal)) {
          Un.enableAriaDecal();
          return;
        }
        var Hn = Un.getData();
        if (Un.isColorBySeries()) {
          var Xn = getDecalFromPalette(Un.ecModel, Un.name, decalPaletteScope, _n.getSeriesCount()), ea = Hn.getVisual("decal");
          Hn.setVisual("decal", ta(ea, Xn));
        } else {
          var zn = Un.getRawData(), Gn = {}, Yn = inner(Un).scope;
          Hn.each(function(na) {
            var ra = Hn.getRawIndex(na);
            Gn[ra] = na;
          });
          var Wn = zn.count();
          zn.each(function(na) {
            var ra = Gn[na], aa = zn.getName(na) || na + "", ia = getDecalFromPalette(Un.ecModel, aa, Yn, Wn), Aa = Hn.getItemVisual(ra, "decal");
            Hn.setItemVisual(ra, "decal", ta(Aa, ia));
          });
        }
        function ta(na, ra) {
          var aa = na ? extend(extend({}, ra), na) : ra;
          return aa.dirty = !0, aa;
        }
      });
    }
  }
  function Dn() {
    var Rn = nr.getZr().dom;
    if (Rn) {
      var Fn = _n.getLocaleModel().get("aria"), Pn = Cn.getModel("label");
      if (Pn.option = defaults(Pn.option, Fn), !!Pn.get("enabled")) {
        if (Rn.setAttribute("role", "img"), Pn.get("description")) {
          Rn.setAttribute("aria-label", Pn.get("description"));
          return;
        }
        var Un = _n.getSeriesCount(), Hn = Pn.get(["data", "maxCount"]) || 10, zn = Pn.get(["series", "maxCount"]) || 10, Gn = Math.min(Un, zn), Yn;
        if (!(Un < 1)) {
          var Wn = $n();
          if (Wn) {
            var Xn = Pn.get(["general", "withTitle"]);
            Yn = Ln(Xn, {
              title: Wn
            });
          } else
            Yn = Pn.get(["general", "withoutTitle"]);
          var ea = [], ta = Un > 1 ? Pn.get(["series", "multiple", "prefix"]) : Pn.get(["series", "single", "prefix"]);
          Yn += Ln(ta, {
            seriesCount: Un
          }), _n.eachSeries(function(ia, Aa) {
            if (Aa < Gn) {
              var sa = void 0, oa = ia.get("name"), la = oa ? "withName" : "withoutName";
              sa = Un > 1 ? Pn.get(["series", "multiple", la]) : Pn.get(["series", "single", la]), sa = Ln(sa, {
                seriesId: ia.seriesIndex,
                seriesName: ia.get("name"),
                seriesType: Nn(ia.subType)
              });
              var ua = ia.getData();
              if (ua.count() > Hn) {
                var ca = Pn.get(["data", "partialData"]);
                sa += Ln(ca, {
                  displayCnt: Hn
                });
              } else
                sa += Pn.get(["data", "allData"]);
              for (var fa = Pn.get(["data", "separator", "middle"]), ha = Pn.get(["data", "separator", "end"]), pa = Pn.get(["data", "excludeDimensionId"]), ya = [], da = 0; da < ua.count(); da++)
                if (da < Hn) {
                  var Ca = ua.getName(da), ma = pa ? filter(ua.getValues(da), function(ga, xa) {
                    return indexOf(pa, xa) === -1;
                  }) : ua.getValues(da), va = Pn.get(["data", Ca ? "withName" : "withoutName"]);
                  ya.push(Ln(va, {
                    name: Ca,
                    value: ma.join(fa)
                  }));
                }
              sa += ya.join(fa) + ha, ea.push(sa);
            }
          });
          var na = Pn.getModel(["series", "multiple", "separator"]), ra = na.get("middle"), aa = na.get("end");
          Yn += ea.join(ra) + aa, Rn.setAttribute("aria-label", Yn);
        }
      }
    }
  }
  function Ln(Rn, Fn) {
    if (!isString$1(Rn))
      return Rn;
    var Pn = Rn;
    return each$f(Fn, function(Un, Hn) {
      Pn = Pn.replace(new RegExp("\\{\\s*" + Hn + "\\s*\\}", "g"), Un);
    }), Pn;
  }
  function $n() {
    var Rn = _n.get("title");
    return Rn && Rn.length && (Rn = Rn[0]), Rn && Rn.text;
  }
  function Nn(Rn) {
    var Fn = _n.getLocaleModel().get(["series", "typeNames"]);
    return Fn[Rn] || Fn.chart;
  }
}
function ariaPreprocessor(_n) {
  if (!(!_n || !_n.aria)) {
    var nr = _n.aria;
    nr.show != null && (nr.enabled = nr.show), nr.label = nr.label || {}, each$f(["description", "general", "series", "data"], function(Cn) {
      nr[Cn] != null && (nr.label[Cn] = nr[Cn]);
    });
  }
}
function install$2(_n) {
  _n.registerPreprocessor(ariaPreprocessor), _n.registerVisual(_n.PRIORITY.VISUAL.ARIA, ariaVisual);
}
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, RegExpEvaluator = (
  /** @class */
  function() {
    function _n(nr) {
      var Cn = this._condVal = isString$1(nr) ? new RegExp(nr) : isRegExp(nr) ? nr : null;
      if (Cn == null) {
        var Bn = "";
        process.env.NODE_ENV !== "production" && (Bn = makePrintable("Illegal regexp", nr, "in")), throwError(Bn);
      }
    }
    return _n.prototype.evaluate = function(nr) {
      var Cn = typeof nr;
      return isString$1(Cn) ? this._condVal.test(nr) : isNumber(Cn) ? this._condVal.test(nr + "") : !1;
    }, _n;
  }()
), ConstConditionInternal = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.evaluate = function() {
      return this.value;
    }, _n;
  }()
), AndConditionInternal = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.evaluate = function() {
      for (var nr = this.children, Cn = 0; Cn < nr.length; Cn++)
        if (!nr[Cn].evaluate())
          return !1;
      return !0;
    }, _n;
  }()
), OrConditionInternal = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.evaluate = function() {
      for (var nr = this.children, Cn = 0; Cn < nr.length; Cn++)
        if (nr[Cn].evaluate())
          return !0;
      return !1;
    }, _n;
  }()
), NotConditionInternal = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, _n;
  }()
), RelationalConditionInternal = (
  /** @class */
  function() {
    function _n() {
    }
    return _n.prototype.evaluate = function() {
      for (var nr = !!this.valueParser, Cn = this.getValue, Bn = Cn(this.valueGetterParam), In = nr ? this.valueParser(Bn) : null, Dn = 0; Dn < this.subCondList.length; Dn++)
        if (!this.subCondList[Dn].evaluate(nr ? In : Bn))
          return !1;
      return !0;
    }, _n;
  }()
);
function parseOption(_n, nr) {
  if (_n === !0 || _n === !1) {
    var Cn = new ConstConditionInternal();
    return Cn.value = _n, Cn;
  }
  var Bn = "";
  return isObjectNotArray(_n) || (process.env.NODE_ENV !== "production" && (Bn = makePrintable("Illegal config. Expect a plain object but actually", _n)), throwError(Bn)), _n.and ? parseAndOrOption("and", _n, nr) : _n.or ? parseAndOrOption("or", _n, nr) : _n.not ? parseNotOption(_n, nr) : parseRelationalOption(_n, nr);
}
function parseAndOrOption(_n, nr, Cn) {
  var Bn = nr[_n], In = "";
  process.env.NODE_ENV !== "production" && (In = makePrintable('"and"/"or" condition should only be `' + _n + ": [...]` and must not be empty array.", "Illegal condition:", nr)), isArray$4(Bn) || throwError(In), Bn.length || throwError(In);
  var Dn = _n === "and" ? new AndConditionInternal() : new OrConditionInternal();
  return Dn.children = map$1(Bn, function(Ln) {
    return parseOption(Ln, Cn);
  }), Dn.children.length || throwError(In), Dn;
}
function parseNotOption(_n, nr) {
  var Cn = _n.not, Bn = "";
  process.env.NODE_ENV !== "production" && (Bn = makePrintable('"not" condition should only be `not: {}`.', "Illegal condition:", _n)), isObjectNotArray(Cn) || throwError(Bn);
  var In = new NotConditionInternal();
  return In.child = parseOption(Cn, nr), In.child || throwError(Bn), In;
}
function parseRelationalOption(_n, nr) {
  for (var Cn = "", Bn = nr.prepareGetValue(_n), In = [], Dn = keys(_n), Ln = _n.parser, $n = Ln ? getRawValueParser(Ln) : null, Nn = 0; Nn < Dn.length; Nn++) {
    var Rn = Dn[Nn];
    if (!(Rn === "parser" || nr.valueGetterAttrMap.get(Rn))) {
      var Fn = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, Rn) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[Rn] : Rn, Pn = _n[Rn], Un = $n ? $n(Pn) : Pn, Hn = createFilterComparator(Fn, Un) || Fn === "reg" && new RegExpEvaluator(Un);
      Hn || (process.env.NODE_ENV !== "production" && (Cn = makePrintable('Illegal relational operation: "' + Rn + '" in condition:', _n)), throwError(Cn)), In.push(Hn);
    }
  }
  In.length || (process.env.NODE_ENV !== "production" && (Cn = makePrintable("Relational condition must have at least one operator.", "Illegal condition:", _n)), throwError(Cn));
  var zn = new RelationalConditionInternal();
  return zn.valueGetterParam = Bn, zn.valueParser = $n, zn.getValue = nr.getValue, zn.subCondList = In, zn;
}
function isObjectNotArray(_n) {
  return isObject$6(_n) && !isArrayLike$1(_n);
}
var ConditionalExpressionParsed = (
  /** @class */
  function() {
    function _n(nr, Cn) {
      this._cond = parseOption(nr, Cn);
    }
    return _n.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, _n;
  }()
);
function parseConditionalExpression(_n, nr) {
  return new ConditionalExpressionParsed(_n, nr);
}
var filterTransform = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(_n) {
    for (var nr = _n.upstream, Cn, Bn = parseConditionalExpression(_n.config, {
      valueGetterAttrMap: createHashMap({
        dimension: !0
      }),
      prepareGetValue: function($n) {
        var Nn = "", Rn = $n.dimension;
        hasOwn($n, "dimension") || (process.env.NODE_ENV !== "production" && (Nn = makePrintable('Relation condition must has prop "dimension" specified.', "Illegal condition:", $n)), throwError(Nn));
        var Fn = nr.getDimensionInfo(Rn);
        return Fn || (process.env.NODE_ENV !== "production" && (Nn = makePrintable("Can not find dimension info via: " + Rn + `.
`, "Existing dimensions: ", nr.cloneAllDimensionInfo(), `.
`, "Illegal condition:", $n, `.
`)), throwError(Nn)), {
          dimIdx: Fn.index
        };
      },
      getValue: function($n) {
        return nr.retrieveValueFromItem(Cn, $n.dimIdx);
      }
    }), In = [], Dn = 0, Ln = nr.count(); Dn < Ln; Dn++)
      Cn = nr.getRawDataItem(Dn), Bn.evaluate() && In.push(Cn);
    return {
      data: In
    };
  }
}, sampleLog = "";
process.env.NODE_ENV !== "production" && (sampleLog = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" "));
var sortTransform = {
  type: "echarts:sort",
  transform: function(_n) {
    var nr = _n.upstream, Cn = _n.config, Bn = "", In = normalizeToArray(Cn);
    In.length || (process.env.NODE_ENV !== "production" && (Bn = "Empty `config` in sort transform."), throwError(Bn));
    var Dn = [];
    each$f(In, function(Fn) {
      var Pn = Fn.dimension, Un = Fn.order, Hn = Fn.parser, zn = Fn.incomparable;
      if (Pn == null && (process.env.NODE_ENV !== "production" && (Bn = 'Sort transform config must has "dimension" specified.' + sampleLog), throwError(Bn)), Un !== "asc" && Un !== "desc" && (process.env.NODE_ENV !== "production" && (Bn = 'Sort transform config must has "order" specified.' + sampleLog), throwError(Bn)), zn && zn !== "min" && zn !== "max") {
        var Gn = "";
        process.env.NODE_ENV !== "production" && (Gn = 'incomparable must be "min" or "max" rather than "' + zn + '".'), throwError(Gn);
      }
      if (Un !== "asc" && Un !== "desc") {
        var Yn = "";
        process.env.NODE_ENV !== "production" && (Yn = 'order must be "asc" or "desc" rather than "' + Un + '".'), throwError(Yn);
      }
      var Wn = nr.getDimensionInfo(Pn);
      Wn || (process.env.NODE_ENV !== "production" && (Bn = makePrintable("Can not find dimension info via: " + Pn + `.
`, "Existing dimensions: ", nr.cloneAllDimensionInfo(), `.
`, "Illegal config:", Fn, `.
`)), throwError(Bn));
      var Xn = Hn ? getRawValueParser(Hn) : null;
      Hn && !Xn && (process.env.NODE_ENV !== "production" && (Bn = makePrintable("Invalid parser name " + Hn + `.
`, "Illegal config:", Fn, `.
`)), throwError(Bn)), Dn.push({
        dimIdx: Wn.index,
        parser: Xn,
        comparator: new SortOrderComparator(Un, zn)
      });
    });
    var Ln = nr.sourceFormat;
    Ln !== SOURCE_FORMAT_ARRAY_ROWS && Ln !== SOURCE_FORMAT_OBJECT_ROWS && (process.env.NODE_ENV !== "production" && (Bn = 'sourceFormat "' + Ln + '" is not supported yet'), throwError(Bn));
    for (var $n = [], Nn = 0, Rn = nr.count(); Nn < Rn; Nn++)
      $n.push(nr.getRawDataItem(Nn));
    return $n.sort(function(Fn, Pn) {
      for (var Un = 0; Un < Dn.length; Un++) {
        var Hn = Dn[Un], zn = nr.retrieveValueFromItem(Fn, Hn.dimIdx), Gn = nr.retrieveValueFromItem(Pn, Hn.dimIdx);
        Hn.parser && (zn = Hn.parser(zn), Gn = Hn.parser(Gn));
        var Yn = Hn.comparator.evaluate(zn, Gn);
        if (Yn !== 0)
          return Yn;
      }
      return 0;
    }), {
      data: $n
    };
  }
};
function install$1(_n) {
  _n.registerTransform(filterTransform), _n.registerTransform(sortTransform);
}
var DatasetModel = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = "dataset", Cn;
    }
    return nr.prototype.init = function(Cn, Bn, In) {
      _n.prototype.init.call(this, Cn, Bn, In), this._sourceManager = new SourceManager(this), disableTransformOptionMerge(this);
    }, nr.prototype.mergeOption = function(Cn, Bn) {
      _n.prototype.mergeOption.call(this, Cn, Bn), disableTransformOptionMerge(this);
    }, nr.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, nr.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, nr.type = "dataset", nr.defaultOption = {
      seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
    }, nr;
  }(ComponentModel$1)
), DatasetView = (
  /** @class */
  function(_n) {
    __extends$2(nr, _n);
    function nr() {
      var Cn = _n !== null && _n.apply(this, arguments) || this;
      return Cn.type = "dataset", Cn;
    }
    return nr.type = "dataset", nr;
  }(ComponentView$1)
);
function install(_n) {
  _n.registerComponentModel(DatasetModel), _n.registerComponentView(DatasetView);
}
var CMD = PathProxy$1.CMD;
function aroundEqual(_n, nr) {
  return Math.abs(_n - nr) < 1e-5;
}
function pathToBezierCurves(_n) {
  var nr = _n.data, Cn = _n.len(), Bn = [], In, Dn = 0, Ln = 0, $n = 0, Nn = 0;
  function Rn(ua, ca) {
    In && In.length > 2 && Bn.push(In), In = [ua, ca];
  }
  function Fn(ua, ca, fa, ha) {
    aroundEqual(ua, fa) && aroundEqual(ca, ha) || In.push(ua, ca, fa, ha, fa, ha);
  }
  function Pn(ua, ca, fa, ha, pa, ya) {
    var da = Math.abs(ca - ua), Ca = Math.tan(da / 4) * 4 / 3, ma = ca < ua ? -1 : 1, va = Math.cos(ua), ga = Math.sin(ua), xa = Math.cos(ca), wa = Math.sin(ca), ba = va * pa + fa, Ta = ga * ya + ha, Sa = xa * pa + fa, Ea = wa * ya + ha, Ia = pa * Ca * ma, Ba = ya * Ca * ma;
    In.push(ba - Ia * ga, Ta + Ba * va, Sa + Ia * wa, Ea - Ba * xa, Sa, Ea);
  }
  for (var Un, Hn, zn, Gn, Yn = 0; Yn < Cn; ) {
    var Wn = nr[Yn++], Xn = Yn === 1;
    switch (Xn && (Dn = nr[Yn], Ln = nr[Yn + 1], $n = Dn, Nn = Ln, (Wn === CMD.L || Wn === CMD.C || Wn === CMD.Q) && (In = [$n, Nn])), Wn) {
      case CMD.M:
        Dn = $n = nr[Yn++], Ln = Nn = nr[Yn++], Rn($n, Nn);
        break;
      case CMD.L:
        Un = nr[Yn++], Hn = nr[Yn++], Fn(Dn, Ln, Un, Hn), Dn = Un, Ln = Hn;
        break;
      case CMD.C:
        In.push(nr[Yn++], nr[Yn++], nr[Yn++], nr[Yn++], Dn = nr[Yn++], Ln = nr[Yn++]);
        break;
      case CMD.Q:
        Un = nr[Yn++], Hn = nr[Yn++], zn = nr[Yn++], Gn = nr[Yn++], In.push(Dn + 2 / 3 * (Un - Dn), Ln + 2 / 3 * (Hn - Ln), zn + 2 / 3 * (Un - zn), Gn + 2 / 3 * (Hn - Gn), zn, Gn), Dn = zn, Ln = Gn;
        break;
      case CMD.A:
        var ea = nr[Yn++], ta = nr[Yn++], na = nr[Yn++], ra = nr[Yn++], aa = nr[Yn++], ia = nr[Yn++] + aa;
        Yn += 1;
        var Aa = !nr[Yn++];
        Un = Math.cos(aa) * na + ea, Hn = Math.sin(aa) * ra + ta, Xn ? ($n = Un, Nn = Hn, Rn($n, Nn)) : Fn(Dn, Ln, Un, Hn), Dn = Math.cos(ia) * na + ea, Ln = Math.sin(ia) * ra + ta;
        for (var sa = (Aa ? -1 : 1) * Math.PI / 2, oa = aa; Aa ? oa > ia : oa < ia; oa += sa) {
          var la = Aa ? Math.max(oa + sa, ia) : Math.min(oa + sa, ia);
          Pn(oa, la, ea, ta, na, ra);
        }
        break;
      case CMD.R:
        $n = Dn = nr[Yn++], Nn = Ln = nr[Yn++], Un = $n + nr[Yn++], Hn = Nn + nr[Yn++], Rn(Un, Nn), Fn(Un, Nn, Un, Hn), Fn(Un, Hn, $n, Hn), Fn($n, Hn, $n, Nn), Fn($n, Nn, Un, Nn);
        break;
      case CMD.Z:
        In && Fn(Dn, Ln, $n, Nn), Dn = $n, Ln = Nn;
        break;
    }
  }
  return In && In.length > 2 && Bn.push(In), Bn;
}
function adpativeBezier(_n, nr, Cn, Bn, In, Dn, Ln, $n, Nn, Rn) {
  if (aroundEqual(_n, Cn) && aroundEqual(nr, Bn) && aroundEqual(In, Ln) && aroundEqual(Dn, $n)) {
    Nn.push(Ln, $n);
    return;
  }
  var Fn = 2 / Rn, Pn = Fn * Fn, Un = Ln - _n, Hn = $n - nr, zn = Math.sqrt(Un * Un + Hn * Hn);
  Un /= zn, Hn /= zn;
  var Gn = Cn - _n, Yn = Bn - nr, Wn = In - Ln, Xn = Dn - $n, ea = Gn * Gn + Yn * Yn, ta = Wn * Wn + Xn * Xn;
  if (ea < Pn && ta < Pn) {
    Nn.push(Ln, $n);
    return;
  }
  var na = Un * Gn + Hn * Yn, ra = -Un * Wn - Hn * Xn, aa = ea - na * na, ia = ta - ra * ra;
  if (aa < Pn && na >= 0 && ia < Pn && ra >= 0) {
    Nn.push(Ln, $n);
    return;
  }
  var Aa = [], sa = [];
  cubicSubdivide(_n, Cn, In, Ln, 0.5, Aa), cubicSubdivide(nr, Bn, Dn, $n, 0.5, sa), adpativeBezier(Aa[0], sa[0], Aa[1], sa[1], Aa[2], sa[2], Aa[3], sa[3], Nn, Rn), adpativeBezier(Aa[4], sa[4], Aa[5], sa[5], Aa[6], sa[6], Aa[7], sa[7], Nn, Rn);
}
function pathToPolygons(_n, nr) {
  var Cn = pathToBezierCurves(_n), Bn = [];
  nr = nr || 1;
  for (var In = 0; In < Cn.length; In++) {
    var Dn = Cn[In], Ln = [], $n = Dn[0], Nn = Dn[1];
    Ln.push($n, Nn);
    for (var Rn = 2; Rn < Dn.length; ) {
      var Fn = Dn[Rn++], Pn = Dn[Rn++], Un = Dn[Rn++], Hn = Dn[Rn++], zn = Dn[Rn++], Gn = Dn[Rn++];
      adpativeBezier($n, Nn, Fn, Pn, Un, Hn, zn, Gn, Ln, nr), $n = zn, Nn = Gn;
    }
    Bn.push(Ln);
  }
  return Bn;
}
function getDividingGrids(_n, nr, Cn) {
  var Bn = _n[nr], In = _n[1 - nr], Dn = Math.abs(Bn / In), Ln = Math.ceil(Math.sqrt(Dn * Cn)), $n = Math.floor(Cn / Ln);
  $n === 0 && ($n = 1, Ln = Cn);
  for (var Nn = [], Rn = 0; Rn < Ln; Rn++)
    Nn.push($n);
  var Fn = Ln * $n, Pn = Cn - Fn;
  if (Pn > 0)
    for (var Rn = 0; Rn < Pn; Rn++)
      Nn[Rn % Ln] += 1;
  return Nn;
}
function divideSector(_n, nr, Cn) {
  for (var Bn = _n.r0, In = _n.r, Dn = _n.startAngle, Ln = _n.endAngle, $n = Math.abs(Ln - Dn), Nn = $n * In, Rn = In - Bn, Fn = Nn > Math.abs(Rn), Pn = getDividingGrids([Nn, Rn], Fn ? 0 : 1, nr), Un = (Fn ? $n : Rn) / Pn.length, Hn = 0; Hn < Pn.length; Hn++)
    for (var zn = (Fn ? Rn : $n) / Pn[Hn], Gn = 0; Gn < Pn[Hn]; Gn++) {
      var Yn = {};
      Fn ? (Yn.startAngle = Dn + Un * Hn, Yn.endAngle = Dn + Un * (Hn + 1), Yn.r0 = Bn + zn * Gn, Yn.r = Bn + zn * (Gn + 1)) : (Yn.startAngle = Dn + zn * Gn, Yn.endAngle = Dn + zn * (Gn + 1), Yn.r0 = Bn + Un * Hn, Yn.r = Bn + Un * (Hn + 1)), Yn.clockwise = _n.clockwise, Yn.cx = _n.cx, Yn.cy = _n.cy, Cn.push(Yn);
    }
}
function divideRect(_n, nr, Cn) {
  for (var Bn = _n.width, In = _n.height, Dn = Bn > In, Ln = getDividingGrids([Bn, In], Dn ? 0 : 1, nr), $n = Dn ? "width" : "height", Nn = Dn ? "height" : "width", Rn = Dn ? "x" : "y", Fn = Dn ? "y" : "x", Pn = _n[$n] / Ln.length, Un = 0; Un < Ln.length; Un++)
    for (var Hn = _n[Nn] / Ln[Un], zn = 0; zn < Ln[Un]; zn++) {
      var Gn = {};
      Gn[Rn] = Un * Pn, Gn[Fn] = zn * Hn, Gn[$n] = Pn, Gn[Nn] = Hn, Gn.x += _n.x, Gn.y += _n.y, Cn.push(Gn);
    }
}
function crossProduct2d(_n, nr, Cn, Bn) {
  return _n * Bn - Cn * nr;
}
function lineLineIntersect(_n, nr, Cn, Bn, In, Dn, Ln, $n) {
  var Nn = Cn - _n, Rn = Bn - nr, Fn = Ln - In, Pn = $n - Dn, Un = crossProduct2d(Fn, Pn, Nn, Rn);
  if (Math.abs(Un) < 1e-6)
    return null;
  var Hn = _n - In, zn = nr - Dn, Gn = crossProduct2d(Hn, zn, Fn, Pn) / Un;
  return Gn < 0 || Gn > 1 ? null : new Point$1(Gn * Nn + _n, Gn * Rn + nr);
}
function projPtOnLine(_n, nr, Cn) {
  var Bn = new Point$1();
  Point$1.sub(Bn, Cn, nr), Bn.normalize();
  var In = new Point$1();
  Point$1.sub(In, _n, nr);
  var Dn = In.dot(Bn);
  return Dn;
}
function addToPoly(_n, nr) {
  var Cn = _n[_n.length - 1];
  Cn && Cn[0] === nr[0] && Cn[1] === nr[1] || _n.push(nr);
}
function splitPolygonByLine(_n, nr, Cn) {
  for (var Bn = _n.length, In = [], Dn = 0; Dn < Bn; Dn++) {
    var Ln = _n[Dn], $n = _n[(Dn + 1) % Bn], Nn = lineLineIntersect(Ln[0], Ln[1], $n[0], $n[1], nr.x, nr.y, Cn.x, Cn.y);
    Nn && In.push({
      projPt: projPtOnLine(Nn, nr, Cn),
      pt: Nn,
      idx: Dn
    });
  }
  if (In.length < 2)
    return [{ points: _n }, { points: _n }];
  In.sort(function(Yn, Wn) {
    return Yn.projPt - Wn.projPt;
  });
  var Rn = In[0], Fn = In[In.length - 1];
  if (Fn.idx < Rn.idx) {
    var Pn = Rn;
    Rn = Fn, Fn = Pn;
  }
  for (var Un = [Rn.pt.x, Rn.pt.y], Hn = [Fn.pt.x, Fn.pt.y], zn = [Un], Gn = [Hn], Dn = Rn.idx + 1; Dn <= Fn.idx; Dn++)
    addToPoly(zn, _n[Dn].slice());
  addToPoly(zn, Hn), addToPoly(zn, Un);
  for (var Dn = Fn.idx + 1; Dn <= Rn.idx + Bn; Dn++)
    addToPoly(Gn, _n[Dn % Bn].slice());
  return addToPoly(Gn, Un), addToPoly(Gn, Hn), [{
    points: zn
  }, {
    points: Gn
  }];
}
function binaryDividePolygon(_n) {
  var nr = _n.points, Cn = [], Bn = [];
  fromPoints(nr, Cn, Bn);
  var In = new BoundingRect$1(Cn[0], Cn[1], Bn[0] - Cn[0], Bn[1] - Cn[1]), Dn = In.width, Ln = In.height, $n = In.x, Nn = In.y, Rn = new Point$1(), Fn = new Point$1();
  return Dn > Ln ? (Rn.x = Fn.x = $n + Dn / 2, Rn.y = Nn, Fn.y = Nn + Ln) : (Rn.y = Fn.y = Nn + Ln / 2, Rn.x = $n, Fn.x = $n + Dn), splitPolygonByLine(nr, Rn, Fn);
}
function binaryDivideRecursive(_n, nr, Cn, Bn) {
  if (Cn === 1)
    Bn.push(nr);
  else {
    var In = Math.floor(Cn / 2), Dn = _n(nr);
    binaryDivideRecursive(_n, Dn[0], In, Bn), binaryDivideRecursive(_n, Dn[1], Cn - In, Bn);
  }
  return Bn;
}
function clone(_n, nr) {
  for (var Cn = [], Bn = 0; Bn < nr; Bn++)
    Cn.push(clonePath(_n));
  return Cn;
}
function copyPathProps(_n, nr) {
  nr.setStyle(_n.style), nr.z = _n.z, nr.z2 = _n.z2, nr.zlevel = _n.zlevel;
}
function polygonConvert(_n) {
  for (var nr = [], Cn = 0; Cn < _n.length; )
    nr.push([_n[Cn++], _n[Cn++]]);
  return nr;
}
function split(_n, nr) {
  var Cn = [], Bn = _n.shape, In;
  switch (_n.type) {
    case "rect":
      divideRect(Bn, nr, Cn), In = Rect$3;
      break;
    case "sector":
      divideSector(Bn, nr, Cn), In = Sector$1;
      break;
    case "circle":
      divideSector({
        r0: 0,
        r: Bn.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: Bn.cx,
        cy: Bn.cy
      }, nr, Cn), In = Sector$1;
      break;
    default:
      var Dn = _n.getComputedTransform(), Ln = Dn ? Math.sqrt(Math.max(Dn[0] * Dn[0] + Dn[1] * Dn[1], Dn[2] * Dn[2] + Dn[3] * Dn[3])) : 1, $n = map$1(pathToPolygons(_n.getUpdatedPathProxy(), Ln), function(Wn) {
        return polygonConvert(Wn);
      }), Nn = $n.length;
      if (Nn === 0)
        binaryDivideRecursive(binaryDividePolygon, {
          points: $n[0]
        }, nr, Cn);
      else if (Nn === nr)
        for (var Rn = 0; Rn < Nn; Rn++)
          Cn.push({
            points: $n[Rn]
          });
      else {
        var Fn = 0, Pn = map$1($n, function(Wn) {
          var Xn = [], ea = [];
          fromPoints(Wn, Xn, ea);
          var ta = (ea[1] - Xn[1]) * (ea[0] - Xn[0]);
          return Fn += ta, { poly: Wn, area: ta };
        });
        Pn.sort(function(Wn, Xn) {
          return Xn.area - Wn.area;
        });
        for (var Un = nr, Rn = 0; Rn < Nn; Rn++) {
          var Hn = Pn[Rn];
          if (Un <= 0)
            break;
          var zn = Rn === Nn - 1 ? Un : Math.ceil(Hn.area / Fn * nr);
          zn < 0 || (binaryDivideRecursive(binaryDividePolygon, {
            points: Hn.poly
          }, zn, Cn), Un -= zn);
        }
      }
      In = Polygon$1;
      break;
  }
  if (!In)
    return clone(_n, nr);
  for (var Gn = [], Rn = 0; Rn < Cn.length; Rn++) {
    var Yn = new In();
    Yn.setShape(Cn[Rn]), copyPathProps(_n, Yn), Gn.push(Yn);
  }
  return Gn;
}
function alignSubpath(_n, nr) {
  var Cn = _n.length, Bn = nr.length;
  if (Cn === Bn)
    return [_n, nr];
  for (var In = [], Dn = [], Ln = Cn < Bn ? _n : nr, $n = Math.min(Cn, Bn), Nn = Math.abs(Bn - Cn) / 6, Rn = ($n - 2) / 6, Fn = Math.ceil(Nn / Rn) + 1, Pn = [Ln[0], Ln[1]], Un = Nn, Hn = 2; Hn < $n; ) {
    var zn = Ln[Hn - 2], Gn = Ln[Hn - 1], Yn = Ln[Hn++], Wn = Ln[Hn++], Xn = Ln[Hn++], ea = Ln[Hn++], ta = Ln[Hn++], na = Ln[Hn++];
    if (Un <= 0) {
      Pn.push(Yn, Wn, Xn, ea, ta, na);
      continue;
    }
    for (var ra = Math.min(Un, Fn - 1) + 1, aa = 1; aa <= ra; aa++) {
      var ia = aa / ra;
      cubicSubdivide(zn, Yn, Xn, ta, ia, In), cubicSubdivide(Gn, Wn, ea, na, ia, Dn), zn = In[3], Gn = Dn[3], Pn.push(In[1], Dn[1], In[2], Dn[2], zn, Gn), Yn = In[5], Wn = Dn[5], Xn = In[6], ea = Dn[6];
    }
    Un -= ra - 1;
  }
  return Ln === _n ? [Pn, nr] : [_n, Pn];
}
function createSubpath(_n, nr) {
  for (var Cn = _n.length, Bn = _n[Cn - 2], In = _n[Cn - 1], Dn = [], Ln = 0; Ln < nr.length; )
    Dn[Ln++] = Bn, Dn[Ln++] = In;
  return Dn;
}
function alignBezierCurves(_n, nr) {
  for (var Cn, Bn, In, Dn = [], Ln = [], $n = 0; $n < Math.max(_n.length, nr.length); $n++) {
    var Nn = _n[$n], Rn = nr[$n], Fn = void 0, Pn = void 0;
    Nn ? Rn ? (Cn = alignSubpath(Nn, Rn), Fn = Cn[0], Pn = Cn[1], Bn = Fn, In = Pn) : (Pn = createSubpath(In || Nn, Nn), Fn = Nn) : (Fn = createSubpath(Bn || Rn, Rn), Pn = Rn), Dn.push(Fn), Ln.push(Pn);
  }
  return [Dn, Ln];
}
function centroid(_n) {
  for (var nr = 0, Cn = 0, Bn = 0, In = _n.length, Dn = 0, Ln = In - 2; Dn < In; Ln = Dn, Dn += 2) {
    var $n = _n[Ln], Nn = _n[Ln + 1], Rn = _n[Dn], Fn = _n[Dn + 1], Pn = $n * Fn - Rn * Nn;
    nr += Pn, Cn += ($n + Rn) * Pn, Bn += (Nn + Fn) * Pn;
  }
  return nr === 0 ? [_n[0] || 0, _n[1] || 0] : [Cn / nr / 3, Bn / nr / 3, nr];
}
function findBestRingOffset(_n, nr, Cn, Bn) {
  for (var In = (_n.length - 2) / 6, Dn = 1 / 0, Ln = 0, $n = _n.length, Nn = $n - 2, Rn = 0; Rn < In; Rn++) {
    for (var Fn = Rn * 6, Pn = 0, Un = 0; Un < $n; Un += 2) {
      var Hn = Un === 0 ? Fn : (Fn + Un - 2) % Nn + 2, zn = _n[Hn] - Cn[0], Gn = _n[Hn + 1] - Cn[1], Yn = nr[Un] - Bn[0], Wn = nr[Un + 1] - Bn[1], Xn = Yn - zn, ea = Wn - Gn;
      Pn += Xn * Xn + ea * ea;
    }
    Pn < Dn && (Dn = Pn, Ln = Rn);
  }
  return Ln;
}
function reverse(_n) {
  for (var nr = [], Cn = _n.length, Bn = 0; Bn < Cn; Bn += 2)
    nr[Bn] = _n[Cn - Bn - 2], nr[Bn + 1] = _n[Cn - Bn - 1];
  return nr;
}
function findBestMorphingRotation(_n, nr, Cn, Bn) {
  for (var In = [], Dn, Ln = 0; Ln < _n.length; Ln++) {
    var $n = _n[Ln], Nn = nr[Ln], Rn = centroid($n), Fn = centroid(Nn);
    Dn == null && (Dn = Rn[2] < 0 != Fn[2] < 0);
    var Pn = [], Un = [], Hn = 0, zn = 1 / 0, Gn = [], Yn = $n.length;
    Dn && ($n = reverse($n));
    for (var Wn = findBestRingOffset($n, Nn, Rn, Fn) * 6, Xn = Yn - 2, ea = 0; ea < Xn; ea += 2) {
      var ta = (Wn + ea) % Xn + 2;
      Pn[ea + 2] = $n[ta] - Rn[0], Pn[ea + 3] = $n[ta + 1] - Rn[1];
    }
    if (Pn[0] = $n[Wn] - Rn[0], Pn[1] = $n[Wn + 1] - Rn[1], Cn > 0)
      for (var na = Bn / Cn, ra = -Bn / 2; ra <= Bn / 2; ra += na) {
        for (var aa = Math.sin(ra), ia = Math.cos(ra), Aa = 0, ea = 0; ea < $n.length; ea += 2) {
          var sa = Pn[ea], oa = Pn[ea + 1], la = Nn[ea] - Fn[0], ua = Nn[ea + 1] - Fn[1], ca = la * ia - ua * aa, fa = la * aa + ua * ia;
          Gn[ea] = ca, Gn[ea + 1] = fa;
          var ha = ca - sa, pa = fa - oa;
          Aa += ha * ha + pa * pa;
        }
        if (Aa < zn) {
          zn = Aa, Hn = ra;
          for (var ya = 0; ya < Gn.length; ya++)
            Un[ya] = Gn[ya];
        }
      }
    else
      for (var da = 0; da < Yn; da += 2)
        Un[da] = Nn[da] - Fn[0], Un[da + 1] = Nn[da + 1] - Fn[1];
    In.push({
      from: Pn,
      to: Un,
      fromCp: Rn,
      toCp: Fn,
      rotation: -Hn
    });
  }
  return In;
}
function isCombineMorphing(_n) {
  return _n.__isCombineMorphing;
}
var SAVED_METHOD_PREFIX = "__mOriginal_";
function saveAndModifyMethod(_n, nr, Cn) {
  var Bn = SAVED_METHOD_PREFIX + nr, In = _n[Bn] || _n[nr];
  _n[Bn] || (_n[Bn] = _n[nr]);
  var Dn = Cn.replace, Ln = Cn.after, $n = Cn.before;
  _n[nr] = function() {
    var Nn = arguments, Rn;
    return $n && $n.apply(this, Nn), Dn ? Rn = Dn.apply(this, Nn) : Rn = In.apply(this, Nn), Ln && Ln.apply(this, Nn), Rn;
  };
}
function restoreMethod(_n, nr) {
  var Cn = SAVED_METHOD_PREFIX + nr;
  _n[Cn] && (_n[nr] = _n[Cn], _n[Cn] = null);
}
function applyTransformOnBeziers(_n, nr) {
  for (var Cn = 0; Cn < _n.length; Cn++)
    for (var Bn = _n[Cn], In = 0; In < Bn.length; ) {
      var Dn = Bn[In], Ln = Bn[In + 1];
      Bn[In++] = nr[0] * Dn + nr[2] * Ln + nr[4], Bn[In++] = nr[1] * Dn + nr[3] * Ln + nr[5];
    }
}
function prepareMorphPath(_n, nr) {
  var Cn = _n.getUpdatedPathProxy(), Bn = nr.getUpdatedPathProxy(), In = alignBezierCurves(pathToBezierCurves(Cn), pathToBezierCurves(Bn)), Dn = In[0], Ln = In[1], $n = _n.getComputedTransform(), Nn = nr.getComputedTransform();
  function Rn() {
    this.transform = null;
  }
  $n && applyTransformOnBeziers(Dn, $n), Nn && applyTransformOnBeziers(Ln, Nn), saveAndModifyMethod(nr, "updateTransform", { replace: Rn }), nr.transform = null;
  var Fn = findBestMorphingRotation(Dn, Ln, 10, Math.PI), Pn = [];
  saveAndModifyMethod(nr, "buildPath", { replace: function(Un) {
    for (var Hn = nr.__morphT, zn = 1 - Hn, Gn = [], Yn = 0; Yn < Fn.length; Yn++) {
      var Wn = Fn[Yn], Xn = Wn.from, ea = Wn.to, ta = Wn.rotation * Hn, na = Wn.fromCp, ra = Wn.toCp, aa = Math.sin(ta), ia = Math.cos(ta);
      lerp$2(Gn, na, ra, Hn);
      for (var Aa = 0; Aa < Xn.length; Aa += 2) {
        var sa = Xn[Aa], oa = Xn[Aa + 1], la = ea[Aa], ua = ea[Aa + 1], ca = sa * zn + la * Hn, fa = oa * zn + ua * Hn;
        Pn[Aa] = ca * ia - fa * aa + Gn[0], Pn[Aa + 1] = ca * aa + fa * ia + Gn[1];
      }
      var ha = Pn[0], pa = Pn[1];
      Un.moveTo(ha, pa);
      for (var Aa = 2; Aa < Xn.length; ) {
        var la = Pn[Aa++], ua = Pn[Aa++], ya = Pn[Aa++], da = Pn[Aa++], Ca = Pn[Aa++], ma = Pn[Aa++];
        ha === la && pa === ua && ya === Ca && da === ma ? Un.lineTo(Ca, ma) : Un.bezierCurveTo(la, ua, ya, da, Ca, ma), ha = Ca, pa = ma;
      }
    }
  } });
}
function morphPath(_n, nr, Cn) {
  if (!_n || !nr)
    return nr;
  var Bn = Cn.done, In = Cn.during;
  prepareMorphPath(_n, nr), nr.__morphT = 0;
  function Dn() {
    restoreMethod(nr, "buildPath"), restoreMethod(nr, "updateTransform"), nr.__morphT = -1, nr.createPathProxy(), nr.dirtyShape();
  }
  return nr.animateTo({
    __morphT: 1
  }, defaults({
    during: function(Ln) {
      nr.dirtyShape(), In && In(Ln);
    },
    done: function() {
      Dn(), Bn && Bn();
    }
  }, Cn)), nr;
}
function hilbert(_n, nr, Cn, Bn, In, Dn) {
  var Ln = 16;
  _n = In === Cn ? 0 : Math.round(32767 * (_n - Cn) / (In - Cn)), nr = Dn === Bn ? 0 : Math.round(32767 * (nr - Bn) / (Dn - Bn));
  for (var $n = 0, Nn, Rn = (1 << Ln) / 2; Rn > 0; Rn /= 2) {
    var Fn = 0, Pn = 0;
    (_n & Rn) > 0 && (Fn = 1), (nr & Rn) > 0 && (Pn = 1), $n += Rn * Rn * (3 * Fn ^ Pn), Pn === 0 && (Fn === 1 && (_n = Rn - 1 - _n, nr = Rn - 1 - nr), Nn = _n, _n = nr, nr = Nn);
  }
  return $n;
}
function sortPaths(_n) {
  var nr = 1 / 0, Cn = 1 / 0, Bn = -1 / 0, In = -1 / 0, Dn = map$1(_n, function($n) {
    var Nn = $n.getBoundingRect(), Rn = $n.getComputedTransform(), Fn = Nn.x + Nn.width / 2 + (Rn ? Rn[4] : 0), Pn = Nn.y + Nn.height / 2 + (Rn ? Rn[5] : 0);
    return nr = Math.min(Fn, nr), Cn = Math.min(Pn, Cn), Bn = Math.max(Fn, Bn), In = Math.max(Pn, In), [Fn, Pn];
  }), Ln = map$1(Dn, function($n, Nn) {
    return {
      cp: $n,
      z: hilbert($n[0], $n[1], nr, Cn, Bn, In),
      path: _n[Nn]
    };
  });
  return Ln.sort(function($n, Nn) {
    return $n.z - Nn.z;
  }).map(function($n) {
    return $n.path;
  });
}
function defaultDividePath(_n) {
  return split(_n.path, _n.count);
}
function createEmptyReturn() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function combineMorph(_n, nr, Cn) {
  var Bn = [];
  function In(na) {
    for (var ra = 0; ra < na.length; ra++) {
      var aa = na[ra];
      isCombineMorphing(aa) ? In(aa.childrenRef()) : aa instanceof Path$1 && Bn.push(aa);
    }
  }
  In(_n);
  var Dn = Bn.length;
  if (!Dn)
    return createEmptyReturn();
  var Ln = Cn.dividePath || defaultDividePath, $n = Ln({
    path: nr,
    count: Dn
  });
  if ($n.length !== Dn)
    return console.error("Invalid morphing: unmatched splitted path"), createEmptyReturn();
  Bn = sortPaths(Bn), $n = sortPaths($n);
  for (var Nn = Cn.done, Rn = Cn.during, Fn = Cn.individualDelay, Pn = new Transformable$1(), Un = 0; Un < Dn; Un++) {
    var Hn = Bn[Un], zn = $n[Un];
    zn.parent = nr, zn.copyTransform(Pn), Fn || prepareMorphPath(Hn, zn);
  }
  nr.__isCombineMorphing = !0, nr.childrenRef = function() {
    return $n;
  };
  function Gn(na) {
    for (var ra = 0; ra < $n.length; ra++)
      $n[ra].addSelfToZr(na);
  }
  saveAndModifyMethod(nr, "addSelfToZr", {
    after: function(na) {
      Gn(na);
    }
  }), saveAndModifyMethod(nr, "removeSelfFromZr", {
    after: function(na) {
      for (var ra = 0; ra < $n.length; ra++)
        $n[ra].removeSelfFromZr(na);
    }
  });
  function Yn() {
    nr.__isCombineMorphing = !1, nr.__morphT = -1, nr.childrenRef = null, restoreMethod(nr, "addSelfToZr"), restoreMethod(nr, "removeSelfFromZr");
  }
  var Wn = $n.length;
  if (Fn)
    for (var Xn = Wn, ea = function() {
      Xn--, Xn === 0 && (Yn(), Nn && Nn());
    }, Un = 0; Un < Wn; Un++) {
      var ta = Fn ? defaults({
        delay: (Cn.delay || 0) + Fn(Un, Wn, Bn[Un], $n[Un]),
        done: ea
      }, Cn) : Cn;
      morphPath(Bn[Un], $n[Un], ta);
    }
  else
    nr.__morphT = 0, nr.animateTo({
      __morphT: 1
    }, defaults({
      during: function(na) {
        for (var ra = 0; ra < Wn; ra++) {
          var aa = $n[ra];
          aa.__morphT = nr.__morphT, aa.dirtyShape();
        }
        Rn && Rn(na);
      },
      done: function() {
        Yn();
        for (var na = 0; na < _n.length; na++)
          restoreMethod(_n[na], "updateTransform");
        Nn && Nn();
      }
    }, Cn));
  return nr.__zr && Gn(nr.__zr), {
    fromIndividuals: Bn,
    toIndividuals: $n,
    count: Wn
  };
}
function separateMorph(_n, nr, Cn) {
  var Bn = nr.length, In = [], Dn = Cn.dividePath || defaultDividePath;
  function Ln(Hn) {
    for (var zn = 0; zn < Hn.length; zn++) {
      var Gn = Hn[zn];
      isCombineMorphing(Gn) ? Ln(Gn.childrenRef()) : Gn instanceof Path$1 && In.push(Gn);
    }
  }
  if (isCombineMorphing(_n)) {
    Ln(_n.childrenRef());
    var $n = In.length;
    if ($n < Bn)
      for (var Nn = 0, Rn = $n; Rn < Bn; Rn++)
        In.push(clonePath(In[Nn++ % $n]));
    In.length = Bn;
  } else {
    In = Dn({ path: _n, count: Bn });
    for (var Fn = _n.getComputedTransform(), Rn = 0; Rn < In.length; Rn++)
      In[Rn].setLocalTransform(Fn);
    if (In.length !== Bn)
      return console.error("Invalid morphing: unmatched splitted path"), createEmptyReturn();
  }
  In = sortPaths(In), nr = sortPaths(nr);
  for (var Pn = Cn.individualDelay, Rn = 0; Rn < Bn; Rn++) {
    var Un = Pn ? defaults({
      delay: (Cn.delay || 0) + Pn(Rn, Bn, In[Rn], nr[Rn])
    }, Cn) : Cn;
    morphPath(In[Rn], nr[Rn], Un);
  }
  return {
    fromIndividuals: In,
    toIndividuals: nr,
    count: nr.length
  };
}
function isMultiple(_n) {
  return isArray$4(_n[0]);
}
function prepareMorphBatches(_n, nr) {
  for (var Cn = [], Bn = _n.length, In = 0; In < Bn; In++)
    Cn.push({
      one: _n[In],
      many: []
    });
  for (var In = 0; In < nr.length; In++) {
    var Dn = nr[In].length, Ln = void 0;
    for (Ln = 0; Ln < Dn; Ln++)
      Cn[Ln % Bn].many.push(nr[In][Ln]);
  }
  for (var $n = 0, In = Bn - 1; In >= 0; In--)
    if (!Cn[In].many.length) {
      var Nn = Cn[$n].many;
      if (Nn.length <= 1)
        if ($n)
          $n = 0;
        else
          return Cn;
      var Dn = Nn.length, Rn = Math.ceil(Dn / 2);
      Cn[In].many = Nn.slice(Rn, Dn), Cn[$n].many = Nn.slice(0, Rn), $n++;
    }
  return Cn;
}
var pathDividers = {
  clone: function(_n) {
    for (var nr = [], Cn = 1 - Math.pow(1 - _n.path.style.opacity, 1 / _n.count), Bn = 0; Bn < _n.count; Bn++) {
      var In = clonePath(_n.path);
      In.setStyle("opacity", Cn), nr.push(In);
    }
    return nr;
  },
  // Use the default divider
  split: null
};
function applyMorphAnimation(_n, nr, Cn, Bn, In, Dn) {
  if (!_n.length || !nr.length)
    return;
  var Ln = getAnimationConfig("update", Bn, In);
  if (!(Ln && Ln.duration > 0))
    return;
  var $n = Bn.getModel("universalTransition").get("delay"), Nn = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, Ln), Rn, Fn;
  isMultiple(_n) && (Rn = _n, Fn = nr), isMultiple(nr) && (Rn = nr, Fn = _n);
  function Pn(Wn, Xn, ea, ta, na) {
    var ra = Wn.many, aa = Wn.one;
    if (ra.length === 1 && !na) {
      var ia = Xn ? ra[0] : aa, Aa = Xn ? aa : ra[0];
      if (isCombineMorphing(ia))
        Pn({
          many: [ia],
          one: Aa
        }, !0, ea, ta, !0);
      else {
        var sa = $n ? defaults({
          delay: $n(ea, ta)
        }, Nn) : Nn;
        morphPath(ia, Aa, sa), Dn(ia, Aa, ia, Aa, sa);
      }
    } else
      for (var oa = defaults({
        dividePath: pathDividers[Cn],
        individualDelay: $n && function(pa, ya, da, Ca) {
          return $n(pa + ea, ta);
        }
      }, Nn), la = Xn ? combineMorph(ra, aa, oa) : separateMorph(aa, ra, oa), ua = la.fromIndividuals, ca = la.toIndividuals, fa = ua.length, ha = 0; ha < fa; ha++) {
        var sa = $n ? defaults({
          delay: $n(ha, fa)
        }, Nn) : Nn;
        Dn(ua[ha], ca[ha], Xn ? ra[ha] : Wn.one, Xn ? Wn.one : ra[ha], sa);
      }
  }
  for (var Un = Rn ? Rn === _n : _n.length > nr.length, Hn = Rn ? prepareMorphBatches(Fn, Rn) : prepareMorphBatches(Un ? nr : _n, [Un ? _n : nr]), zn = 0, Gn = 0; Gn < Hn.length; Gn++)
    zn += Hn[Gn].many.length;
  for (var Yn = 0, Gn = 0; Gn < Hn.length; Gn++)
    Pn(Hn[Gn], Un, Yn, zn), Yn += Hn[Gn].many.length;
}
function getPathList(_n) {
  if (!_n)
    return [];
  if (isArray$4(_n)) {
    for (var nr = [], Cn = 0; Cn < _n.length; Cn++)
      nr.push(getPathList(_n[Cn]));
    return nr;
  }
  var Bn = [];
  return _n.traverse(function(In) {
    In instanceof Path$1 && !In.disableMorphing && !In.invisible && !In.ignore && Bn.push(In);
  }), Bn;
}
var DATA_COUNT_THRESHOLD = 1e4, TRANSITION_NONE = 0, TRANSITION_P2C = 1, TRANSITION_C2P = 2, getUniversalTransitionGlobalStore = makeInner();
function getDimension(_n, nr) {
  for (var Cn = _n.dimensions, Bn = 0; Bn < Cn.length; Bn++) {
    var In = _n.getDimensionInfo(Cn[Bn]);
    if (In && In.otherDims[nr] === 0)
      return Cn[Bn];
  }
}
function getValueByDimension(_n, nr, Cn) {
  var Bn = _n.getDimensionInfo(Cn), In = Bn && Bn.ordinalMeta;
  if (Bn) {
    var Dn = _n.get(Bn.name, nr);
    return In && In.categories[Dn] || Dn + "";
  }
}
function getGroupId(_n, nr, Cn, Bn) {
  var In = Bn ? "itemChildGroupId" : "itemGroupId", Dn = getDimension(_n, In);
  if (Dn) {
    var Ln = getValueByDimension(_n, nr, Dn);
    return Ln;
  }
  var $n = _n.getRawDataItem(nr), Nn = Bn ? "childGroupId" : "groupId";
  if ($n && $n[Nn])
    return $n[Nn] + "";
  if (!Bn)
    return Cn || _n.getId(nr);
}
function flattenDataDiffItems(_n) {
  var nr = [];
  return each$f(_n, function(Cn) {
    var Bn = Cn.data, In = Cn.dataGroupId;
    if (Bn.count() > DATA_COUNT_THRESHOLD) {
      process.env.NODE_ENV !== "production" && warn("Universal transition is disabled on large data > 10k.");
      return;
    }
    for (var Dn = Bn.getIndices(), Ln = 0; Ln < Dn.length; Ln++)
      nr.push({
        data: Bn,
        groupId: getGroupId(Bn, Ln, In, !1),
        childGroupId: getGroupId(Bn, Ln, In, !0),
        divide: Cn.divide,
        dataIndex: Ln
      });
  }), nr;
}
function fadeInElement(_n, nr, Cn) {
  _n.traverse(function(Bn) {
    Bn instanceof Path$1 && initProps(Bn, {
      style: {
        opacity: 0
      }
    }, nr, {
      dataIndex: Cn,
      isFrom: !0
    });
  });
}
function removeEl(_n) {
  if (_n.parent) {
    var nr = _n.getComputedTransform();
    _n.setLocalTransform(nr), _n.parent.remove(_n);
  }
}
function stopAnimation(_n) {
  _n.stopAnimation(), _n.isGroup && _n.traverse(function(nr) {
    nr.stopAnimation();
  });
}
function animateElementStyles(_n, nr, Cn) {
  var Bn = getAnimationConfig("update", Cn, nr);
  Bn && _n.traverse(function(In) {
    if (In instanceof Displayable$1) {
      var Dn = getOldStyle(In);
      Dn && In.animateFrom({
        style: Dn
      }, Bn);
    }
  });
}
function isAllIdSame(_n, nr) {
  var Cn = _n.length;
  if (Cn !== nr.length)
    return !1;
  for (var Bn = 0; Bn < Cn; Bn++) {
    var In = _n[Bn], Dn = nr[Bn];
    if (In.data.getId(In.dataIndex) !== Dn.data.getId(Dn.dataIndex))
      return !1;
  }
  return !0;
}
function transitionBetween(_n, nr, Cn) {
  var Bn = flattenDataDiffItems(_n), In = flattenDataDiffItems(nr);
  function Dn(ea, ta, na, ra, aa) {
    (na || ea) && ta.animateFrom({
      style: na && na !== ea ? extend(extend({}, na.style), ea.style) : ea.style
    }, aa);
  }
  var Ln = !1, $n = TRANSITION_NONE, Nn = createHashMap(), Rn = createHashMap();
  Bn.forEach(function(ea) {
    ea.groupId && Nn.set(ea.groupId, !0), ea.childGroupId && Rn.set(ea.childGroupId, !0);
  });
  for (var Fn = 0; Fn < In.length; Fn++) {
    var Pn = In[Fn].groupId;
    if (Rn.get(Pn)) {
      $n = TRANSITION_P2C;
      break;
    }
    var Un = In[Fn].childGroupId;
    if (Un && Nn.get(Un)) {
      $n = TRANSITION_C2P;
      break;
    }
  }
  function Hn(ea, ta) {
    return function(na) {
      var ra = na.data, aa = na.dataIndex;
      return ta ? ra.getId(aa) : ea ? $n === TRANSITION_P2C ? na.childGroupId : na.groupId : $n === TRANSITION_C2P ? na.childGroupId : na.groupId;
    };
  }
  var zn = isAllIdSame(Bn, In), Gn = {};
  if (!zn)
    for (var Fn = 0; Fn < In.length; Fn++) {
      var Yn = In[Fn], Wn = Yn.data.getItemGraphicEl(Yn.dataIndex);
      Wn && (Gn[Wn.id] = !0);
    }
  function Xn(ea, ta) {
    var na = Bn[ta], ra = In[ea], aa = ra.data.hostModel, ia = na.data.getItemGraphicEl(na.dataIndex), Aa = ra.data.getItemGraphicEl(ra.dataIndex);
    if (ia === Aa) {
      Aa && animateElementStyles(Aa, ra.dataIndex, aa);
      return;
    }
    // We can't use the elements that already being morphed
    ia && Gn[ia.id] || Aa && (stopAnimation(Aa), ia ? (stopAnimation(ia), removeEl(ia), Ln = !0, applyMorphAnimation(getPathList(ia), getPathList(Aa), ra.divide, aa, ea, Dn)) : fadeInElement(Aa, aa, ea));
  }
  new DataDiffer$1(Bn, In, Hn(!0, zn), Hn(!1, zn), null, "multiple").update(Xn).updateManyToOne(function(ea, ta) {
    var na = In[ea], ra = na.data, aa = ra.hostModel, ia = ra.getItemGraphicEl(na.dataIndex), Aa = filter(map$1(ta, function(sa) {
      return Bn[sa].data.getItemGraphicEl(Bn[sa].dataIndex);
    }), function(sa) {
      return sa && sa !== ia && !Gn[sa.id];
    });
    ia && (stopAnimation(ia), Aa.length ? (each$f(Aa, function(sa) {
      stopAnimation(sa), removeEl(sa);
    }), Ln = !0, applyMorphAnimation(getPathList(Aa), getPathList(ia), na.divide, aa, ea, Dn)) : fadeInElement(ia, aa, na.dataIndex));
  }).updateOneToMany(function(ea, ta) {
    var na = Bn[ta], ra = na.data.getItemGraphicEl(na.dataIndex);
    if (!(ra && Gn[ra.id])) {
      var aa = filter(map$1(ea, function(Aa) {
        return In[Aa].data.getItemGraphicEl(In[Aa].dataIndex);
      }), function(Aa) {
        return Aa && Aa !== ra;
      }), ia = In[ea[0]].data.hostModel;
      aa.length && (each$f(aa, function(Aa) {
        return stopAnimation(Aa);
      }), ra ? (stopAnimation(ra), removeEl(ra), Ln = !0, applyMorphAnimation(
        getPathList(ra),
        getPathList(aa),
        na.divide,
        // Use divide on old.
        ia,
        ea[0],
        Dn
      )) : each$f(aa, function(Aa) {
        return fadeInElement(Aa, ia, ea[0]);
      }));
    }
  }).updateManyToMany(function(ea, ta) {
    new DataDiffer$1(ta, ea, function(na) {
      return Bn[na].data.getId(Bn[na].dataIndex);
    }, function(na) {
      return In[na].data.getId(In[na].dataIndex);
    }).update(function(na, ra) {
      Xn(ea[na], ta[ra]);
    }).execute();
  }).execute(), Ln && each$f(nr, function(ea) {
    var ta = ea.data, na = ta.hostModel, ra = na && Cn.getViewOfSeriesModel(na), aa = getAnimationConfig("update", na, 0);
    ra && na.isAnimationEnabled() && aa && aa.duration > 0 && ra.group.traverse(function(ia) {
      ia instanceof Path$1 && !ia.animators.length && ia.animateFrom({
        style: {
          opacity: 0
        }
      }, aa);
    });
  });
}
function getSeriesTransitionKey(_n) {
  var nr = _n.getModel("universalTransition").get("seriesKey");
  return nr || _n.id;
}
function convertArraySeriesKeyToString(_n) {
  return isArray$4(_n) ? _n.sort().join(",") : _n;
}
function getDivideShapeFromData(_n) {
  if (_n.hostModel)
    return _n.hostModel.getModel("universalTransition").get("divideShape");
}
function findTransitionSeriesBatches(_n, nr) {
  var Cn = createHashMap(), Bn = createHashMap(), In = createHashMap();
  each$f(_n.oldSeries, function(Ln, $n) {
    var Nn = _n.oldDataGroupIds[$n], Rn = _n.oldData[$n], Fn = getSeriesTransitionKey(Ln), Pn = convertArraySeriesKeyToString(Fn);
    Bn.set(Pn, {
      dataGroupId: Nn,
      data: Rn
    }), isArray$4(Fn) && each$f(Fn, function(Un) {
      In.set(Un, {
        key: Pn,
        dataGroupId: Nn,
        data: Rn
      });
    });
  });
  function Dn(Ln) {
    Cn.get(Ln) && warn("Duplicated seriesKey in universalTransition " + Ln);
  }
  return each$f(nr.updatedSeries, function(Ln) {
    if (Ln.isUniversalTransitionEnabled() && Ln.isAnimationEnabled()) {
      var $n = Ln.get("dataGroupId"), Nn = Ln.getData(), Rn = getSeriesTransitionKey(Ln), Fn = convertArraySeriesKeyToString(Rn), Pn = Bn.get(Fn);
      if (Pn)
        process.env.NODE_ENV !== "production" && Dn(Fn), Cn.set(Fn, {
          oldSeries: [{
            dataGroupId: Pn.dataGroupId,
            divide: getDivideShapeFromData(Pn.data),
            data: Pn.data
          }],
          newSeries: [{
            dataGroupId: $n,
            divide: getDivideShapeFromData(Nn),
            data: Nn
          }]
        });
      else if (isArray$4(Rn)) {
        process.env.NODE_ENV !== "production" && Dn(Fn);
        var Un = [];
        each$f(Rn, function(Gn) {
          var Yn = Bn.get(Gn);
          Yn.data && Un.push({
            dataGroupId: Yn.dataGroupId,
            divide: getDivideShapeFromData(Yn.data),
            data: Yn.data
          });
        }), Un.length && Cn.set(Fn, {
          oldSeries: Un,
          newSeries: [{
            dataGroupId: $n,
            data: Nn,
            divide: getDivideShapeFromData(Nn)
          }]
        });
      } else {
        var Hn = In.get(Rn);
        if (Hn) {
          var zn = Cn.get(Hn.key);
          zn || (zn = {
            oldSeries: [{
              dataGroupId: Hn.dataGroupId,
              data: Hn.data,
              divide: getDivideShapeFromData(Hn.data)
            }],
            newSeries: []
          }, Cn.set(Hn.key, zn)), zn.newSeries.push({
            dataGroupId: $n,
            data: Nn,
            divide: getDivideShapeFromData(Nn)
          });
        }
      }
    }
  }), Cn;
}
function querySeries(_n, nr) {
  for (var Cn = 0; Cn < _n.length; Cn++) {
    var Bn = nr.seriesIndex != null && nr.seriesIndex === _n[Cn].seriesIndex || nr.seriesId != null && nr.seriesId === _n[Cn].id;
    if (Bn)
      return Cn;
  }
}
function transitionSeriesFromOpt(_n, nr, Cn, Bn) {
  var In = [], Dn = [];
  each$f(normalizeToArray(_n.from), function(Ln) {
    var $n = querySeries(nr.oldSeries, Ln);
    $n >= 0 && In.push({
      dataGroupId: nr.oldDataGroupIds[$n],
      data: nr.oldData[$n],
      // TODO can specify divideShape in transition.
      divide: getDivideShapeFromData(nr.oldData[$n]),
      groupIdDim: Ln.dimension
    });
  }), each$f(normalizeToArray(_n.to), function(Ln) {
    var $n = querySeries(Cn.updatedSeries, Ln);
    if ($n >= 0) {
      var Nn = Cn.updatedSeries[$n].getData();
      Dn.push({
        dataGroupId: nr.oldDataGroupIds[$n],
        data: Nn,
        divide: getDivideShapeFromData(Nn),
        groupIdDim: Ln.dimension
      });
    }
  }), In.length > 0 && Dn.length > 0 && transitionBetween(In, Dn, Bn);
}
function installUniversalTransition(_n) {
  _n.registerUpdateLifecycle("series:beforeupdate", function(nr, Cn, Bn) {
    each$f(normalizeToArray(Bn.seriesTransition), function(In) {
      each$f(normalizeToArray(In.to), function(Dn) {
        for (var Ln = Bn.updatedSeries, $n = 0; $n < Ln.length; $n++)
          (Dn.seriesIndex != null && Dn.seriesIndex === Ln[$n].seriesIndex || Dn.seriesId != null && Dn.seriesId === Ln[$n].id) && (Ln[$n][SERIES_UNIVERSAL_TRANSITION_PROP] = !0);
      });
    });
  }), _n.registerUpdateLifecycle("series:transition", function(nr, Cn, Bn) {
    var In = getUniversalTransitionGlobalStore(Cn);
    if (In.oldSeries && Bn.updatedSeries && Bn.optionChanged) {
      var Dn = Bn.seriesTransition;
      if (Dn)
        each$f(normalizeToArray(Dn), function(Hn) {
          transitionSeriesFromOpt(Hn, In, Bn, Cn);
        });
      else {
        var Ln = findTransitionSeriesBatches(In, Bn);
        each$f(Ln.keys(), function(Hn) {
          var zn = Ln.get(Hn);
          transitionBetween(zn.oldSeries, zn.newSeries, Cn);
        });
      }
      each$f(Bn.updatedSeries, function(Hn) {
        Hn[SERIES_UNIVERSAL_TRANSITION_PROP] && (Hn[SERIES_UNIVERSAL_TRANSITION_PROP] = !1);
      });
    }
    for (var $n = nr.getSeries(), Nn = In.oldSeries = [], Rn = In.oldDataGroupIds = [], Fn = In.oldData = [], Pn = 0; Pn < $n.length; Pn++) {
      var Un = $n[Pn].getData();
      Un.count() < DATA_COUNT_THRESHOLD && (Nn.push($n[Pn]), Rn.push($n[Pn].get("dataGroupId")), Fn.push(Un));
    }
  });
}
use([install$R]);
use([install$S]);
use([install$Q, install$P, install$O, install$M, install$K, install$I, install$H, install$G, install$F, install$E, install$D, install$B, install$A, install$z, install$y, install$x, install$w, install$v, install$u, install$t, install$s, install$r]);
use(install$p);
use(install$o);
use(install$J);
use(install$n);
use(install$C);
use(install$m);
use(install$l);
use(install$j);
use(install$i);
use(install$q);
use(install$h);
use(install$g);
use(install$f);
use(install$e);
use(install$d);
use(install$c);
use(install$9);
use(install$6);
use(install$8);
use(install$7);
use(install$3);
use(install$5);
use(install$4);
use(install$2);
use(install$1);
use(install);
use(installUniversalTransition);
use(installLabelLayout);
const echarts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axis: Axis$1,
  ChartView: ChartView$1,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  List: SeriesData$1,
  Model: Model$1,
  PRIORITY,
  SeriesModel: SeriesModel$1,
  color: color$e,
  connect,
  dataTool,
  dependencies,
  disConnect,
  disconnect,
  dispose,
  env: env$1,
  extendChartView,
  extendComponentModel,
  extendComponentView,
  extendSeriesModel,
  format,
  getCoordinateSystemDimensions,
  getInstanceByDom,
  getInstanceById,
  getMap,
  graphic,
  helper,
  init: init$1,
  innerDrawElementOnCanvas: brushSingle,
  matrix: matrix$1,
  number,
  parseGeoJSON,
  parseGeoJson: parseGeoJSON,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerLoading,
  registerLocale,
  registerMap: registerMap$1,
  registerPostInit,
  registerPostUpdate,
  registerPreprocessor,
  registerProcessor,
  registerTheme,
  registerTransform,
  registerUpdateLifecycle,
  registerVisual,
  setCanvasCreator,
  setPlatformAPI,
  throttle,
  time: time$1,
  use,
  util,
  vector,
  version: version$2,
  zrUtil: util$1,
  zrender
}, Symbol.toStringTag, { value: "Module" })), components = {};
window.$components = {};
const npmPkgs = { echarts };
let editCanvasConfig = {};
const useLifeHandler$1 = (_n, nr) => {
  if (editCanvasConfig = nr, !_n.events)
    return {};
  let Cn = null;
  const Bn = {};
  if (!_n.isGroup)
    for (const $n in _n.events.baseEvent) {
      const Nn = _n.events.baseEvent[$n].customFunction, Rn = _n.events.baseEvent[$n].arguments, Fn = _n.events.baseEvent[$n].action;
      _n.events.baseEvent[$n].open && (Bn[$n] = (Un) => {
        clearTimeout(Cn);
        let Hn = Un;
        Hn !== void 0 ? (Un && ["mousemove"].includes(Un.type) && (Hn = { ...Un, offsetX: Un.offsetX, offsetY: Un.offsetY, x: Un.x, y: Un.y, movementX: Un.movementX, movementY: Un.movementY, layerX: Un.layerX, layerY: Un.layerY, clientX: Un.clientX, clientY: Un.clientY, target: Un.target }), isObject$8(Un) && isObject$8(Rn) && (Hn = Object.assign(Rn, Hn))) : Hn = Rn, $n === "click" ? Cn = setTimeout(() => {
          Nn && generateBaseFunc(Nn)(Hn, components), Fn && runActionFunc(Fn, Hn, _n);
        }, 300) : (Nn && generateBaseFunc(Nn)(Hn, components), Fn && runActionFunc(Fn, Hn, _n));
      });
    }
  const In = _n.events.advancedEvents || {}, Dn = {
    [EventLife.VNODE_BEFORE_MOUNT]($n) {
      if (components[_n.id] = $n.component, window.$components[_n.id] = $n.component, In[EventLife.VNODE_BEFORE_MOUNT] && In[EventLife.VNODE_BEFORE_MOUNT].open) {
        const Nn = In[EventLife.VNODE_BEFORE_MOUNT].customFunction || "";
        try {
          generateFunc$1(Nn, $n);
        } catch (Rn) {
          console.error(Rn);
        }
      }
    },
    [EventLife.VNODE_MOUNTED]($n) {
      if (In[EventLife.VNODE_MOUNTED] && In[EventLife.VNODE_MOUNTED].open) {
        const Nn = In[EventLife.VNODE_MOUNTED].customFunction || "";
        try {
          generateFunc$1(Nn, $n);
        } catch (Rn) {
          console.error(Rn);
        }
      }
    }
  }, Ln = {};
  if (_n.events.customEvents)
    for (const $n in _n.events.customEvents) {
      const Nn = _n.events.customEvents[$n].customFunction, Rn = _n.events.customEvents[$n].arguments, Fn = _n.events.customEvents[$n].action;
      _n.events.customEvents[$n].open && (Ln[$n] = (Un) => {
        let Hn = Un;
        Un !== void 0 ? isObject$8(Un) && isObject$8(Rn) && (Hn = Object.assign(Rn, Un)) : Hn = Rn, Nn && generateBaseFunc(Nn)(Hn, components), Fn && runActionFunc(Fn, Hn, _n);
      });
    }
  return { ...Bn, ...Dn, ...Ln };
}, getLoginInfo = (_n) => {
  let nr = getLocalStorage("loginInfo" + _n);
  if (nr)
    try {
      nr = JSONParse(nr).data;
    } catch {
      console.log("失败");
    }
  else {
    let Cn = getLocalStorage("userInfo");
    if (Cn)
      try {
        nr = JSONParse(Cn);
      } catch {
        console.log("失败");
      }
  }
  return nr;
}, filterFun = async (_n, nr, Cn, Bn, In) => {
  let Dn = 0;
  if (nr || (nr = []), await nr.map(async (Ln) => {
    let $n = Ln.value;
    if (Ln.valueType === "global") {
      let Fn = getLoginInfo(In);
      Fn && ($n === "token" ? $n = Fn.token : $n === "userId" ? $n = Fn.id : $n === "roles" ? $n = cloneDeep(Fn.roles).map((Pn) => Pn.name).join(",") : $n === "groups" ? $n = cloneDeep(Fn.groups).map((Pn) => Pn.name).join(",") : $n === "projectId" && ($n = editCanvasConfig.groupId));
    } else
      Ln.valueType === "current" ? !$n && Bn.option.dataset && ($n = cloneDeep(Bn.option.dataset)) : Ln.valueType === "link" && Ln.value && Ln.value[0] && components[Ln.value[0]] && components[Ln.value[0]].props.chartConfig.option && (components[Ln.value[0]].props.chartConfig.option.value ? $n = components[Ln.value[0]].props.chartConfig.option.value : components[Ln.value[0]].props.chartConfig.option.text && ($n = cloneDeep(components[Ln.value[0]].props.chartConfig.option.text)));
    let Nn = Cn, Rn = Ln.key || "value";
    Cn && isObject$8(Cn) && Cn[Rn] && (Nn = Cn[Rn]), Ln.type === "default" ? (Ln.tag === "=" && Nn === $n || Ln.tag === "!=" && Nn !== $n || Ln.tag === ">" && Nn > $n || Ln.tag === "<" && Nn < $n || Ln.tag === ">=" && Nn >= $n || Ln.tag === "<=" && Nn <= $n || Ln.tag === "in" && $n.indexOf(Nn) > -1 || Ln.tag === "not" && $n.indexOf(Nn) === -1) && Dn++ : generateFilterFunc(Ln.customFunction)(Bn.option.dataset, Cn) && Dn++;
  }), _n === "and") {
    if (Dn === nr.length)
      return !0;
  } else if (Dn > 0)
    return !0;
  return nr.length === 0;
};
function runActionFunc(_n, nr, Cn) {
  _n.map(async (Bn) => {
    let In = !0;
    if (Bn.filterList && (In = await filterFun(Bn.filterType, Bn.filterList, nr, Cn, Bn.loginPageId)), !In)
      return !1;
    const Dn = Bn.delay || 0;
    setTimeout(() => {
      if (Bn.actionType === "show" || Bn.actionType === "hide" || Bn.actionType === "toggle" || Bn.actionType === "requestData" || Bn.actionType === "translate")
        cloneDeep(Bn.targetList).map(($n) => {
          if (!Bn.condition || Bn.condition && !Bn.condition.value || Bn.condition && (Bn.condition.tag === "=" && nr.value === Bn.condition.value || Bn.condition.tag === "!=" && nr.value !== Bn.condition.value || Bn.condition.tag === "in" && Bn.condition.value.indexOf(nr.value) > -1)) {
            const Nn = $n[$n.length - 1];
            if (Nn && components[Nn])
              if (Bn.actionType === "translate") {
                let Rn = document.getElementById(Nn).parentNode;
                if (Rn) {
                  let Fn = Rn.offsetLeft, Pn = Rn.offsetTop;
                  Rn.style.left = Fn + Bn.translate.x + "px", Rn.style.top = Pn + Bn.translate.y + "px";
                }
              } else
                components[Nn].props.groupData ? Bn.actionType === "show" ? components[Nn].props.groupData.status.hide = !1 : Bn.actionType === "hide" ? components[Nn].props.groupData.status.hide = !0 : Bn.actionType === "toggle" && (components[Nn].props.groupData.status.hide = !components[Nn].props.groupData.status.hide) : components[Nn].props.chartConfig.key === "Page" ? Bn.actionType === "show" ? components[Nn].props.chartConfig.status.hide = !1 : Bn.actionType === "hide" ? $n.length === 1 && (components[Nn].props.chartConfig.status.hide = !0) : Bn.actionType === "toggle" && (components[Nn].props.chartConfig.status.hide = !components[Nn].props.chartConfig.status.hide) : Bn.actionType === "show" ? components[Nn].props.chartConfig.status.hide = !1 : Bn.actionType === "hide" ? components[Nn].props.chartConfig.status.hide = !0 : Bn.actionType === "toggle" ? components[Nn].props.chartConfig.status.hide = !components[Nn].props.chartConfig.status.hide : Bn.actionType === "requestData" && components[Nn].exposed.fetchData && components[Nn].exposed.fetchData();
          }
        });
      else if (Bn.actionType === "toCanvasPage")
        Bn.setting.linkCanvasPage && jumpPublishPage(window.isPublishRouter, Bn.setting.linkCanvasPage);
      else if (Bn.actionType === "toLink")
        Bn.setting.link && (Bn.setting.linkOpenWindow ? window.open(Bn.setting.link) : window.location.href = Bn.setting.link);
      else if (Bn.actionType === "submitForm")
        cloneDeep(Bn.targetList).map(($n) => {
          components[$n] && components[$n].exposed.submitForm();
        });
      else if (Bn.actionType === "executionMethod") {
        const Ln = cloneDeep(Bn.targetList);
        if (Ln[Ln.length - 1] && components[Ln[Ln.length - 1]] && components[Ln[Ln.length - 1]].exposed[Bn.methodName]) {
          let $n = [];
          Bn.methodParams.map(async (Nn) => {
            if (Nn.type === "custom") {
              const Rn = generateFilterFunc(Nn.content)(Cn.option.dataset, nr);
              $n.push(Rn);
            } else if (["text", "number", "boolean"].includes(Nn.valueType))
              $n.push(Nn.value);
            else if (Nn.valueType === "global") {
              let Rn = getLoginInfo(Bn.loginPageId);
              Rn && (Nn.value === "token" ? $n.push(Rn.token) : Nn.value === "userId" ? $n.push(Rn.id) : Nn.value === "roles" ? $n.push(cloneDeep(Rn.roles).map((Fn) => Fn.name).join(",")) : Nn.value === "groups" ? $n.push(cloneDeep(Rn.groups).map((Fn) => Fn.name).join(",")) : Nn.value === "projectId" && $n.push(editCanvasConfig.groupId));
            } else
              Nn.valueType === "current" ? $n.push(nr) : Nn.valueType === "link" && (Nn.value && Nn.value[0] && components[Nn.value[0]] && components[Nn.value[0]].props.chartConfig.option ? components[Nn.value[0]].props.chartConfig.option.value ? $n.push(components[Nn.value[0]].props.chartConfig.option.value) : components[Nn.value[0]].props.chartConfig.option.text ? $n.push(components[Nn.value[0]].props.chartConfig.option.text) : $n.push(Nn.value) : $n.push(Nn.value));
          }), components[Ln[Ln.length - 1]].exposed[Bn.methodName](...$n);
        }
      } else if (Bn.actionType === "logOutWay") {
        const Ln = () => {
          setLocalStorage("loginInfo" + Bn.loginPageId, ""), setSessionStorage("token_" + Bn.loginPageId, ""), setCookie("token_" + Bn.loginPageId, "", -1), Bn.loginPageId && jumpPublishPage(window.isPublishRouter, Bn.loginPageId);
        };
        logout().then(() => {
          Ln();
        }).catch(() => {
          Ln();
        });
      }
    }, Dn * 1e3);
  });
}
function generateFilterFunc(_n) {
  try {
    return new Function(`
      return (
        function(dataset, eventData){
          ${_n}
        }
      )`)();
  } catch (nr) {
    console.error(nr);
  }
}
function generateBaseFunc(_n) {
  try {
    return new Function(`
      return (
        async function(mouseEvent, components){
          ${_n}
        }
      )`)();
  } catch (nr) {
    console.error(nr);
  }
}
function generateFunc$1(_n, nr) {
  try {
    Function(`
      "use strict";
      return (
        async function(e, components, node_modules){
          const {${Object.keys(npmPkgs).join()}} = node_modules;
          ${_n}
        }
      )`)().bind(nr == null ? void 0 : nr.component)(nr, components, npmPkgs);
  } catch (Cn) {
    console.error(Cn);
  }
}
const _hoisted_1$2 = ["data-index"], _hoisted_2$1 = {
  key: 0,
  class: "seat-img"
}, _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    groupData: {
      type: Object,
      required: !0
    },
    themeSetting: {
      type: Object,
      required: !0
    },
    themeColor: {
      type: Object,
      required: !0
    },
    groupIndex: {
      type: Number,
      required: !0
    }
  },
  setup(_n) {
    const nr = useChartEditStore();
    return provide("screenId", nr.editCanvasConfig.id), (Cn, Bn) => (openBlock(!0), createElementBlock(Fragment, null, renderList(_n.groupData.groupList, (In, Dn) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["chart-item", (In.hasGrant !== void 0 && !In.hasGrant ? "no-auth " : "") + unref(animationsClass)(In.styles.animations)]),
      key: In.id,
      "data-index": Dn,
      style: normalizeStyle$1({
        ...unref(getComponentAttrStyle)(In.attr, _n.groupIndex),
        ...unref(getFilterStyle)(In.styles),
        ...unref(getTransformStyle)(In.styles),
        ...unref(getStatusStyle)(In.status),
        ...unref(getPreviewConfigStyle)(In.preview),
        ...unref(getBlendModeStyle)(In.styles)
      })
    }, [
      In.hasGrant !== void 0 && !In.hasGrant ? (openBlock(), createElementBlock("div", _hoisted_2$1, Bn[0] || (Bn[0] = [
        createElementVNode("div", { class: "lock-img" }, null, -1)
      ]))) : (openBlock(), createBlock(resolveDynamicComponent(In.chartConfig.chartKey), mergeProps({
        key: 1,
        id: In.id,
        chartConfig: In,
        themeSetting: _n.themeSetting,
        themeColor: _n.themeColor,
        style: { ...unref(getSizeStyle)(In.attr) }
      }, toHandlers(unref(useLifeHandler$1)(In, unref(nr).editCanvasConfig))), null, 16, ["id", "chartConfig", "themeSetting", "themeColor", "style"]))
    ], 14, _hoisted_1$2))), 128));
  }
}), index_vue_vue_type_style_index_0_scoped_2ebf11bf_lang = "", PreviewRenderGroup = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-2ebf11bf"]]), _hoisted_1$1 = ["id", "is-group", "data-index"], _hoisted_2 = {
  key: 0,
  class: "seat-img"
}, _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "index",
  emits: ["onMounted", "onUnmounted"],
  setup(_n, { emit: nr }) {
    const Cn = useChartEditStore(), Bn = computed(() => Cn.editCanvasConfig.chartThemeSetting), In = computed(() => colorCustomMerge(Cn.editCanvasConfig.chartCustomThemeColorInfo)[Cn.editCanvasConfig.chartThemeColor]);
    provide("screenId", Cn.editCanvasConfig.id);
    const Dn = nr;
    return onMounted((Ln) => {
      Dn("onMounted");
    }), onUnmounted((Ln) => {
      Dn("onUnmounted");
    }), (Ln, $n) => (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(Cn).componentList, (Nn, Rn) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["chart-item", (Nn.hasGrant !== void 0 && !Nn.hasGrant ? "no-auth " : "") + unref(animationsClass)(Nn.styles.animations)]),
      key: Nn.id,
      id: Nn.isGroup ? Nn.id : "",
      "is-group": Nn.isGroup,
      "data-index": Rn,
      style: normalizeStyle$1({
        ...unref(getComponentAttrStyle)(Nn.attr, Rn),
        ...unref(getFilterStyle)(Nn.styles),
        ...unref(getTransformStyle)(Nn.styles),
        ...unref(getStatusStyle)(Nn.status, Nn),
        ...unref(getPreviewConfigStyle)(Nn.preview),
        ...unref(getBlendModeStyle)(Nn.styles)
      })
    }, [
      Nn.hasGrant !== void 0 && !Nn.hasGrant ? (openBlock(), createElementBlock("div", _hoisted_2, $n[0] || ($n[0] = [
        createElementVNode("div", { class: "lock-img" }, null, -1)
      ]))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        Nn.isGroup ? (openBlock(), createBlock(unref(PreviewRenderGroup), mergeProps({
          key: 0,
          groupData: Nn,
          groupIndex: Rn,
          themeSetting: Bn.value,
          themeColor: In.value
        }, toHandlers(unref(useLifeHandler$1)(Nn, unref(Cn).editCanvasConfig))), null, 16, ["groupData", "groupIndex", "themeSetting", "themeColor"])) : (openBlock(), createBlock(resolveDynamicComponent(Nn.chartConfig.chartKey), mergeProps({
          key: 1,
          id: Nn.id,
          chartConfig: Nn,
          themeSetting: Bn.value,
          themeColor: In.value,
          style: { ...unref(getSizeStyle)(Nn.attr) }
        }, toHandlers(unref(useLifeHandler$1)(Nn, unref(Cn).editCanvasConfig))), null, 16, ["id", "chartConfig", "themeSetting", "themeColor", "style"]))
      ], 64))
    ], 14, _hoisted_1$1))), 128));
  }
}), index_vue_vue_type_style_index_0_scoped_a0480e53_lang = "", PreviewRenderList = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-a0480e53"]]), useLifeHandler = (_n) => _n ? {
  onMounted() {
    if (_n.onMounted && _n.onMounted.open) {
      const nr = _n.onMounted.customFunction || "";
      try {
        generateFunc(nr);
      } catch (Cn) {
        console.error(Cn);
      }
    }
  },
  onUnmounted() {
    if (_n.onUnmounted && _n.onUnmounted.open) {
      const nr = _n.onUnMounted.customFunction || "";
      try {
        generateFunc(nr);
      } catch (Cn) {
        console.error(Cn);
      }
    }
  }
} : "";
function generateFunc(_n) {
  try {
    Function(`
      "use strict";
      return (
        async function(components) {
          ${_n}
        }
      )`)()(window.$components);
  } catch (nr) {
    console.error(nr);
  }
}
const useComInstall = (_n, nr) => {
  const Cn = ref(!1);
  let Bn = 0;
  function In(Ln) {
    Ln.forEach(($n) => {
      $n.groupList && In($n.groupList), $n.componentList && In($n.componentList), Bn++;
    });
  }
  In(_n.componentList);
  const Dn = setInterval(async () => {
    if (window.$vue.component) {
      let Ln = 0;
      clearInterval(Dn);
      const $n = async (Rn) => {
        if (window.$vue.component(Rn.chartConfig.chartKey))
          Ln++, Bn === Ln && (Cn.value = !0);
        else {
          const Fn = await fetchChartComponent(Rn.chartConfig);
          Ln++, console.log("loadedNum, loadedNum", Ln, Ln), window.$vue.component(Rn.chartConfig.chartKey, Fn), Bn === Ln && (Cn.value = !0);
        }
      }, Nn = async (Rn) => {
        Rn.forEach((Fn) => {
          Fn.groupList && Nn(Fn.groupList), Fn.componentList && Nn(Fn.componentList), $n(Fn);
        });
      };
      Nn(_n.componentList), nr && nr();
    }
  }, 200);
  return {
    show: Cn
  };
}, usePreviewFitScale = (_n, nr, Cn, Bn) => {
  const In = _n, Dn = nr, Ln = {
    width: 1,
    height: 1
  }, $n = parseFloat((In / Dn).toFixed(5)), Nn = () => {
    const Un = parseFloat(
      (window.innerWidth / window.innerHeight).toFixed(5)
    );
    Cn && (Un > $n ? (Ln.width = parseFloat((window.innerHeight * $n / In).toFixed(5)), Ln.height = parseFloat((window.innerHeight / Dn).toFixed(5)), Cn.style.transform = `scale(${Ln.width}, ${Ln.height})`) : (Ln.height = parseFloat((window.innerWidth / $n / Dn).toFixed(5)), Ln.width = parseFloat((window.innerWidth / In).toFixed(5)), Cn.style.transform = `scale(${Ln.width}, ${Ln.height})`), Bn && Bn(Ln));
  }, Rn = throttle$2(() => {
    Nn();
  }, 200);
  return {
    calcRate: Nn,
    windowResize: () => {
      window.addEventListener("resize", Rn);
    },
    unWindowResize: () => {
      window.removeEventListener("resize", Rn);
    }
  };
};
function getScrollbarWidth() {
  var _n = document.createElement("div");
  _n.style.visibility = "hidden", _n.style.overflow = "scroll", document.body.appendChild(_n);
  var nr = document.createElement("div");
  _n.appendChild(nr);
  var Cn = _n.offsetWidth - nr.offsetWidth;
  return _n.parentNode.removeChild(_n), Cn;
}
const usePreviewScrollYScale = (_n, nr, Cn, Bn) => {
  const In = _n, Dn = nr, Ln = {
    width: 1,
    height: 1
  }, $n = parseFloat((In / Dn).toFixed(5)), Nn = () => {
    if (Cn) {
      const Un = getScrollbarWidth() || 0;
      Ln.height = parseFloat(((window.innerWidth - Un) / $n / Dn).toFixed(5)), Ln.width = parseFloat(((window.innerWidth - Un) / In).toFixed(5)), Cn.style.transform = `scale(${Ln.width}, ${Ln.height})`, Bn && Bn(Ln);
    }
  }, Rn = throttle$2(() => {
    Nn();
  }, 200);
  return {
    calcRate: Nn,
    windowResize: () => {
      window.addEventListener("resize", Rn);
    },
    unWindowResize: () => {
      window.removeEventListener("resize", Rn);
    }
  };
}, usePreviewHideYScale = (_n, nr, Cn, Bn) => {
  const In = _n, Dn = nr, Ln = {
    width: 1,
    height: 1
  }, $n = parseFloat((In / Dn).toFixed(5)), Nn = () => {
    Cn && (Ln.height = parseFloat(((window.innerWidth - 0) / $n / Dn).toFixed(5)), Ln.width = parseFloat(((window.innerWidth - 0) / In).toFixed(5)), Cn.style.transform = `scale(${Ln.width}, ${Ln.height})`, Bn && Bn(Ln));
  }, Rn = throttle$2(() => {
    Nn();
  }, 200);
  return {
    calcRate: Nn,
    windowResize: () => {
      window.addEventListener("resize", Rn);
    },
    unWindowResize: () => {
      window.removeEventListener("resize", Rn);
    }
  };
}, usePreviewScrollXScale = (_n, nr, Cn, Bn) => {
  const In = _n, Dn = nr, Ln = {
    height: 1,
    width: 1
  }, $n = parseFloat((In / Dn).toFixed(5)), Nn = () => {
    if (Cn) {
      const Un = getScrollbarWidth() || 0;
      Ln.width = parseFloat(((window.innerHeight - Un) * $n / In).toFixed(5)), Ln.height = parseFloat(((window.innerHeight - Un) / Dn).toFixed(5)), Cn.style.transform = `scale(${Ln.width}, ${Ln.height})`, Bn && Bn(Ln);
    }
  }, Rn = throttle$2(() => {
    Nn();
  }, 200);
  return {
    calcRate: Nn,
    windowResize: () => {
      window.addEventListener("resize", Rn);
    },
    unWindowResize: () => {
      window.removeEventListener("resize", Rn);
    }
  };
}, usePreviewHideXScale = (_n, nr, Cn, Bn) => {
  const In = _n, Dn = nr, Ln = {
    height: 1,
    width: 1
  }, $n = parseFloat((In / Dn).toFixed(5)), Nn = () => {
    Cn && (Ln.width = parseFloat((window.innerHeight * $n / In).toFixed(5)), Ln.height = parseFloat((window.innerHeight / Dn).toFixed(5)), Cn.style.transform = `scale(${Ln.width}, ${Ln.height})`, Bn && Bn(Ln));
  }, Rn = throttle$2(() => {
    Nn();
  }, 200);
  return {
    calcRate: Nn,
    windowResize: () => {
      window.addEventListener("resize", Rn);
    },
    unWindowResize: () => {
      window.removeEventListener("resize", Rn);
    }
  };
}, usePreviewFullScale = (_n, nr, Cn, Bn) => {
  const In = {
    width: 1,
    height: 1
  }, Dn = () => {
    Cn && (In.width = parseFloat(((window.innerWidth - 0) / _n).toFixed(5)), In.height = parseFloat((window.innerHeight / nr).toFixed(5)), Cn.style.transform = `scale(${In.width}, ${In.height})`, Bn && Bn(In));
  }, Ln = throttle$2(() => {
    Dn();
  }, 200);
  return {
    calcRate: Dn,
    windowResize: () => {
      window.addEventListener("resize", Ln);
    },
    unWindowResize: () => {
      window.removeEventListener("resize", Ln);
    }
  };
}, usePreviewAutoScale = (_n, nr, Cn, Bn) => {
  const In = {
    width: 1,
    height: 1
  }, Dn = () => {
    Cn && (getScrollbarWidth(), In.width = parseFloat((window.innerWidth / _n).toFixed(5)), In.height = parseFloat((window.innerHeight / nr).toFixed(5)), Bn && Bn(In));
  }, Ln = throttle$2(() => {
    Dn();
  }, 200);
  return {
    calcRate: Dn,
    windowResize: () => {
      window.addEventListener("resize", Ln);
    },
    unWindowResize: () => {
      window.removeEventListener("resize", Ln);
    }
  };
}, useScale = (_n) => {
  const nr = ref(), Cn = ref(), Bn = ref(_n.editCanvasConfig.width), In = ref(_n.editCanvasConfig.height), Dn = reactive({ width: 1, height: 1 });
  provide(SCALE_KEY, Dn);
  const Ln = ($n) => {
    Dn.width = $n.width, Dn.height = $n.height;
  };
  return onMounted(() => {
    switch (_n.editCanvasConfig.previewScaleType) {
      case PreviewScaleEnum.FIT:
        (() => {
          const { calcRate: $n, windowResize: Nn, unWindowResize: Rn } = usePreviewFitScale(
            Bn.value,
            In.value,
            Cn.value,
            Ln
          );
          $n(), Nn(), onUnmounted(() => {
            Rn();
          });
        })();
        break;
      case PreviewScaleEnum.HIDE_Y:
        (() => {
          const { calcRate: $n, windowResize: Nn, unWindowResize: Rn } = usePreviewHideYScale(
            Bn.value,
            In.value,
            Cn.value,
            (Fn) => {
              const Pn = nr.value;
              Pn.style.width = `${Bn.value * Fn.width}px`, Pn.style.height = `${In.value * Fn.height}px`, Ln(Fn);
            }
          );
          $n(), Nn(), onUnmounted(() => {
            Rn();
          });
        })();
        break;
      case PreviewScaleEnum.SCROLL_Y:
        (() => {
          const { calcRate: $n, windowResize: Nn, unWindowResize: Rn } = usePreviewScrollYScale(
            Bn.value,
            In.value,
            Cn.value,
            (Fn) => {
              const Pn = nr.value;
              Pn.style.width = `${Bn.value * Fn.width}px`, Pn.style.height = `${In.value * Fn.height}px`, Ln(Fn);
            }
          );
          $n(), Nn(), onUnmounted(() => {
            Rn();
          });
        })();
        break;
      case PreviewScaleEnum.HIDE_X:
        (() => {
          const { calcRate: $n, windowResize: Nn, unWindowResize: Rn } = usePreviewHideXScale(
            Bn.value,
            In.value,
            Cn.value,
            (Fn) => {
              const Pn = nr.value;
              Pn.style.width = `${Bn.value * Fn.width}px`, Pn.style.height = `${In.value * Fn.height}px`, Ln(Fn);
            }
          );
          $n(), Nn(), onUnmounted(() => {
            Rn();
          });
        })();
        break;
      case PreviewScaleEnum.SCROLL_X:
        (() => {
          const { calcRate: $n, windowResize: Nn, unWindowResize: Rn } = usePreviewScrollXScale(
            Bn.value,
            In.value,
            Cn.value,
            (Fn) => {
              const Pn = nr.value;
              Pn.style.width = `${Bn.value * Fn.width}px`, Pn.style.height = `${In.value * Fn.height}px`, Ln(Fn);
            }
          );
          $n(), Nn(), onUnmounted(() => {
            Rn();
          });
        })();
        break;
      case PreviewScaleEnum.FULL:
        (() => {
          const { calcRate: $n, windowResize: Nn, unWindowResize: Rn } = usePreviewFullScale(
            Bn.value,
            In.value,
            Cn.value,
            Ln
          );
          $n(), Nn(), onUnmounted(() => {
            Rn();
          });
        })();
        break;
      case PreviewScaleEnum.AUTO:
        (() => {
          const { calcRate: $n, windowResize: Nn, unWindowResize: Rn } = usePreviewAutoScale(
            Bn.value,
            In.value,
            Cn.value,
            Ln
          );
          $n(), Nn(), onUnmounted(() => {
            Rn();
          });
        })();
        break;
    }
  }), {
    entityRef: nr,
    previewRef: Cn,
    scaleRef: Dn
  };
}, useStore = (_n) => {
  const nr = useChartEditStore();
  nr.requestGlobalConfig = _n[ChartEditStoreEnum.REQUEST_GLOBAL_CONFIG];
}, _hoisted_1 = {
  key: 1,
  class: "no-auth-page"
}, _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "SuspensePage",
  async setup(_n) {
    let nr, Cn;
    const Bn = computed(() => Pn.editCanvasConfig.selectColor ? { background: Pn.editCanvasConfig.background } : {
      background: `url(${Pn.editCanvasConfig.backgroundImage}) center center / ${Pn.editCanvasConfig.backgroundFit} no-repeat`
    }), In = useRouter(), Dn = useRoute();
    window.isPublishRouter = Dn.meta.isPublish, watch(
      () => In.currentRoute.value,
      (Wn, Xn) => {
        Xn && Wn.fullPath !== Xn.fullPath && window.location.reload();
      },
      { immediate: !0 }
    ), computed(() => {
      const Wn = Pn.editCanvasConfig.previewScaleType;
      return Wn === PreviewScaleEnum.SCROLL_Y || Wn === PreviewScaleEnum.SCROLL_X || Wn === PreviewScaleEnum.HIDE_Y || Wn === PreviewScaleEnum.HIDE_X;
    });
    let Ln = -1, $n = null, Nn = null, Rn = null;
    const Fn = () => {
      Un();
    };
    if (Dn.name === "PublishPreview")
      [nr, Cn] = withAsyncContext(() => getPublishScreenInfo()), await nr, Cn();
    else if (Dn.name === "LocalPreview")
      [nr, Cn] = withAsyncContext(() => getSessionStorageInfo()), await nr, Cn();
    else {
      if (Dn.meta.isPublish) {
        let Wn = getQueryString("projectId");
        Wn || (Wn = window.APPID), [nr, Cn] = withAsyncContext(() => getScreenUrlByGroupId(Wn).then((Xn) => {
          const { code: ea, data: ta } = Xn;
          if (ea === 200 && ta) {
            const na = ta.map((ra) => ({
              path: ra.customUrl,
              id: ra.id
            }));
            localStorage.setItem("RouterMatching", JSON.stringify(na));
          }
        }).catch(() => {
        })), await nr, Cn();
      }
      [nr, Cn] = withAsyncContext(() => getScreenDataInfo(Dn.meta.isPublish)), await nr, Cn();
    }
    const Pn = useChartEditStore();
    setTitle(`${Pn.editCanvasConfig.projectName || "--"}`);
    const Un = () => {
      clearTimeout($n), Ln > -1 && Nn && ($n = setTimeout(() => {
        Rn = null, window.$currentUserInfo = null, jumpPublishPage(Dn.meta.isPublish, Nn);
      }, Ln));
    };
    var Hn = {
      versions: function() {
        var Wn = navigator.userAgent;
        return {
          trident: Wn.indexOf("Trident") > -1,
          //IE内核
          presto: Wn.indexOf("Presto") > -1,
          //opera内核
          webKit: Wn.indexOf("AppleWebKit") > -1,
          //苹果、谷歌内核
          gecko: Wn.indexOf("Gecko") > -1 && Wn.indexOf("KHTML") == -1,
          //火狐内核
          mobile: !!Wn.match(/AppleWebKit.*Mobile.*/),
          //是否为移动终端
          ios: !!Wn.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),
          //iOS终端
          android: Wn.indexOf("Android") > -1 || Wn.indexOf("Adr") > -1,
          //Android终端
          iPhone: Wn.indexOf("iPhone") > -1,
          //是否为iPhone或者QQHD浏览器
          iPad: Wn.indexOf("iPad") > -1,
          //是否iPad
          webApp: Wn.indexOf("Safari") == -1,
          //是否web应该程序，没有头部与底部
          weixin: Wn.indexOf("MicroMessenger") > -1,
          //是否微信 （2015-01-22新增）
          qq: Wn.match(/\sQQ/i) == " qq"
          //是否QQ
        };
      }()
    };
    if (Hn.versions.mobile ? Pn.editCanvasConfig.appPageId && jumpPublishPage(Dn.meta.isPublish, Pn.editCanvasConfig.appPageId) : Pn.editCanvasConfig.pcPageId && jumpPublishPage(Dn.meta.isPublish, Pn.editCanvasConfig.pcPageId), Pn.editCanvasConfig.needLogin === 1 && Pn.editCanvasConfig.loginPageId !== void 0) {
      Nn = Pn.editCanvasConfig.loginPageId, Rn = getLocalStorage("loginInfo" + Nn);
      let Wn = "", Xn = getLoginType()[Nn], ea = getSessionStorage("token_" + Nn), ta = getCookie("token_" + Nn);
      if (Xn && (Xn.type === 2 ? ea || (Rn = null) : Xn.type === 3 && (ta || (Rn = null)), Xn.autoLogout ? (Ln = Xn.logoutTime * 60 * 1e3, Un()) : Ln = -1), Rn)
        try {
          Rn = JSONParse(Rn), window.$currentUserInfo = Rn, Wn = Rn.data.token, Pn.editCanvasConfig.checkLogin && getCurrentUserInfo({ Authorization: Wn }).then((na) => {
            const { code: ra, data: aa } = na;
            ra !== 200 && jumpPublishPage(Dn.meta.isPublish, Pn.editCanvasConfig.loginPageId);
          }).catch(() => {
            jumpPublishPage(Dn.meta.isPublish, Pn.editCanvasConfig.loginPageId);
          });
        } catch {
          console.log("失败");
        }
      else
        Rn = null, window.$currentUserInfo = null, jumpPublishPage(Dn.meta.isPublish, Pn.editCanvasConfig.loginPageId);
    }
    useStore(Pn);
    const { entityRef: zn, previewRef: Gn } = useScale(Pn);
    if (Pn.editCanvasConfig.previewScaleType === "auto") {
      const Wn = (ea, ta) => {
        if (ea.originAttr && (ea.attr.w = ea.originAttr.attr.w * ta.width, ea.attr.h = ea.originAttr.attr.h * ta.height, ea.attr.x = ea.originAttr.attr.x * ta.width, ea.attr.y = ea.originAttr.attr.y * ta.height, ea.originAttr.scale = ta, ea.option)) {
          ea.option.collapseStyle && ea.option.collapseStyle.width && (ea.option.collapseStyle.width = ea.originAttr.option.collapseStyle.width * ta.width), ea.option.collapseStyle && ea.option.collapseStyle.height && (ea.option.collapseStyle.height = ea.originAttr.option.collapseStyle.height * ta.width);
          const na = ta.width > 1.25 ? 1.25 : ta.width;
          ea.option.style && ea.option.style.fontSize && (ea.option.style.fontSize = ea.originAttr.option.style.fontSize * na), ea.option.style && ea.option.style.subFontSize && (ea.option.style.subFontSize = ea.originAttr.option.style.subFontSize * na), ea.option.style && ea.option.style.timeSize && (ea.option.style.timeSize = ea.originAttr.option.style.timeSize * na), ea.option.style && ea.option.style.timeLineHeight && (ea.option.style.timeLineHeight = ea.originAttr.option.style.timeLineHeight * ta.height), ea.option.style && ea.option.style.width && (ea.option.style.width = ea.originAttr.option.style.width * ta.width), ["CustomTable"].indexOf(ea.key) === -1 && ea.option.hoverStyle && ea.option.hoverStyle.fontSize && (ea.option.hoverStyle.fontSize = ea.originAttr.option.hoverStyle.fontSize * na), ea.option.hoverStyle && ea.option.hoverStyle.width && (ea.option.hoverStyle.width = ea.originAttr.option.hoverStyle.width * ta.width), ea.option.activeStyle && ea.option.activeStyle.fontSize && ea.originAttr.option.activeStyle && (ea.option.activeStyle.fontSize = ea.originAttr.option.activeStyle.fontSize * na), ea.option.activeStyle && ea.option.activeStyle.width && ea.originAttr.option.activeStyle && (ea.option.activeStyle.width = ea.originAttr.option.activeStyle.width * na), ea.option.fontSize && (ea.option.fontSize = ea.originAttr.option.fontSize * na);
        }
      }, Xn = () => {
        let ea = { width: 1, height: 1 };
        ea.width = window.innerWidth / Pn.editCanvasConfig.width, ea.height = window.innerHeight / Pn.editCanvasConfig.height, Pn.componentList.forEach((ta) => {
          Wn(ta, ea), ta.groupList && ta.groupList.forEach((na) => {
            Wn(na, ea);
          }), ta.componentList && ta.componentList.forEach((na) => {
            Wn(na, ea), na.groupList && na.groupList.forEach((ra) => {
              Wn(ra, ea);
            });
          });
        });
      };
      onMounted(() => {
        window.addEventListener("resize", Xn);
      }), onUnmounted(() => {
        window.removeEventListener("resize", Xn);
      });
    }
    const { show: Yn } = useComInstall(Pn);
    return (Wn, Xn) => {
      const ea = resolveComponent("el-empty");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(`dms-preview ${unref(Pn).editCanvasConfig.previewScaleType}`),
        style: normalizeStyle$1(Bn.value),
        onMousemove: Fn
      }, [
        unref(Pn).editCanvasConfig.hasPerms ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          unref(Pn).editCanvasConfig.previewScaleType === "auto" ? (openBlock(), createElementBlock("div", {
            key: 0,
            style: normalizeStyle$1({ ...unref(getFilterStyle)(unref(Pn).editCanvasConfig), ...unref(getBlendModeStyle)(unref(Pn).editCanvasConfig) })
          }, [
            unref(Yn) ? (openBlock(), createBlock(unref(PreviewRenderList), mergeProps({ key: 0 }, toHandlers(unref(useLifeHandler)(unref(Pn).globalEvent))), null, 16)) : createCommentVNode("", !0)
          ], 4)) : (openBlock(), createElementBlock("div", {
            key: 1,
            ref_key: "entityRef",
            ref: zn,
            class: "dms-preview-entity"
          }, [
            createElementVNode("div", {
              ref_key: "previewRef",
              ref: Gn,
              class: "dms-preview-scale"
            }, [
              createElementVNode("div", {
                style: normalizeStyle$1({ ...unref(getEditCanvasConfigStyle)(unref(Pn).editCanvasConfig), ...Bn.value })
              }, [
                unref(Yn) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  style: normalizeStyle$1({ ...unref(getFilterStyle)(unref(Pn).editCanvasConfig), ...unref(getBlendModeStyle)(unref(Pn).editCanvasConfig) })
                }, [
                  createVNode$1(unref(PreviewRenderList), toHandlers(unref(useLifeHandler)(unref(Pn).globalEvent)), null, 16)
                ], 4)) : createCommentVNode("", !0)
              ], 4)
            ], 512)
          ], 512))
        ], 64)) : (openBlock(), createElementBlock("div", _hoisted_1, [
          createVNode$1(ea, { description: "您没有权限查看该页面" })
        ]))
      ], 38);
    };
  }
}), SuspensePage_vue_vue_type_style_index_0_scoped_8f0ce166_lang = "", SuspensePage = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-8f0ce166"]]), _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "index",
  setup(_n) {
    return (nr, Cn) => (openBlock(), createBlock(Suspense, null, {
      default: withCtx(() => [
        createVNode$1(unref(SuspensePage))
      ]),
      _: 1
    }));
  }
});
export {
  commonjsGlobal as $,
  actionTypeList as A,
  BaseEvent as B,
  ConfigItemBox as C,
  DragKeyEnum as D,
  EditCanvasTypeEnum as E,
  _sfc_main as F,
  GlobalField as G,
  BlendModeEnumList as H,
  objectFitOptions as I,
  JSONStringify as J,
  re as K,
  getLocalStorage as L,
  MenuEnum as M,
  RequestBodyEnum as N,
  RequestBodyEnumList as O,
  PreviewScaleEnum as P,
  RequestParamsTypeEnum as Q,
  RequestDataTypeEnum as R,
  formatParam as S,
  testConnect as T,
  customizeHttp as U,
  ValueTypeEnum as V,
  fileUpload as W,
  SelectValueTypeObj as X,
  newFunctionHandle as Y,
  getDefaultExportFromCjs as Z,
  _imports_0 as _,
  updateGroup as a,
  readFile as a0,
  downloadTextFile as a1,
  RequestHttpEnum as a2,
  SelectHttpTimeNameObj as a3,
  RequestHttpIntervalEnum as a4,
  index as a5,
  PublicConfigClass as a6,
  addGroup as b,
  updateScreen as c,
  addScreen as d,
  deleteScreen as e,
  deleteGroup as f,
  __unplugin_components_0 as g,
  _export_sfc as h,
  useChartEditStore as i,
  useSync as j,
  JSONParse as k,
  useContextMenu as l,
  MouseEventButton as m,
  bgFitOptions as n,
  screenValidate as o,
  html2canvas as p,
  base64Tofile as q,
  EditCanvasConfigEnum as r,
  setScreenHome as s,
  axiosInstance as t,
  useLayoutStore as u,
  getRolesList as v,
  getScreenList as w,
  loadAsyncComponent as x,
  ChartFrameEnum as y,
  EventLife as z
};
